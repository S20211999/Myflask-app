import sys
from PyQt6.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, 
                             QStackedWidget, QPushButton, QLabel, QLineEdit, 
                             QComboBox, QScrollArea, QFrame, QTextEdit, 
                             QMessageBox, QFileDialog, QGridLayout, QSpacerItem, 
                             QSizePolicy, QGroupBox, QTableWidget, QTableWidgetItem, QHeaderView)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QIntValidator, QDoubleValidator, QFont, QPalette, QColor
import sqlite3
import pandas as pd
from datetime import datetime


def safe_int(value):
    try:
        return int(float(str(value).replace(',', '').strip()))
    except (ValueError, TypeError):
        return 0

def safe_float(value):
    try:
        return float(str(value).replace(',', '').replace('x', '').strip())
    except (ValueError, TypeError):
        return 0.0

class PCBFabCostTool(QWidget):
    def __init__(self):
        super().__init__()
        self.init_database()
        self.init_ui()
        self.apply_styles()
        
    def init_database(self):
        """Initialize SQLite database with required tables"""
        self.conn = sqlite3.connect('pcb_data.db')
        self.cursor = self.conn.cursor()
        
        # Create PCB data table for data entry
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS pcb_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                Units TEXT NOT NULL,            
                FabricatorName TEXT NOT NULL,
                PCBPartNumber TEXT NOT NULL,
                Quantity INTEGER NOT NULL,
                Layers INTEGER NOT NULL,
                PCBspec TEXT,
                material TEXT,
                Length REAL NOT NULL,
                Width REAL NOT NULL,
                ArraySize TEXT,
                BoardThickness INTEGER NOT NULL,                
                CuInner TEXT,
                CuOuter TEXT,
                SurfaceFinish TEXT,
                SelectivePlating TEXT,
                Drills TEXT,
                Impedance TEXT,                            
                Soldermask TEXT,
                Silkscreen TEXT,
                back_drill TEXT,
                blind_via TEXT,
                berried_via TEXT,
                ViaType TEXT,
                ViaFill TEXT,
                Beveling TEXT,
                EdgePlating TEXT,
                PricePerUnit TEXT,
                Quantity TEXT,
                EnggCost TEXT,
                TotalCostINR REAL NOT NULL,
                LeadTime TEXT
                created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create calculation results table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS calculation_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                customer_name TEXT,
                job_number TEXT,
                qty INTEGER,
                Units TEXT,
                PCB_Part_Number TEXT,
                Layers INTEGER,
                PCBspec TEXT,
                material TEXT,
                Length REAL,
                Width REAL,
                Soldermask TEXT,
                Silkscreen TEXT,
                BoardThickness INTEGER,
                CuInner TEXT,
                CuOuter TEXT,
                SurfaceFinish TEXT,
                back_drill TEXT,
                blind_via TEXT,
                berried_via TEXT,
                per_sq_mm_price REAL,
                per_Units_price REAL,
                TotalCostINR REAL,
                calculation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        self.conn.commit()
        
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("PCB Fabrication Cost Tool")
        self.setGeometry(100, 100, 1600, 900)
        
        # Main layout
        main_layout = QVBoxLayout()
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)
        
        # Header section
        header_layout = QVBoxLayout()
        
        
        # Navigation buttons
        nav_layout = QHBoxLayout()
        nav_layout.setSpacing(5)
        
        self.calc_btn = QPushButton("Calculation")
        self.data_entry_btn = QPushButton("Data Entry")
        
        # Make buttons larger and more attractive
        for btn in [self.calc_btn, self.data_entry_btn]:
            btn.setMinimumHeight(50)
            btn.setFont(QFont("Arial", 14, QFont.Weight.Bold))
            btn.setCheckable(True)
        
        nav_layout.addWidget(self.calc_btn)
        nav_layout.addWidget(self.data_entry_btn)
        nav_layout.addStretch()
        
        header_layout.addLayout(nav_layout)
        main_layout.addLayout(header_layout)
        
        # Connect navigation buttons
        self.calc_btn.clicked.connect(self.show_calculation_page)
        self.data_entry_btn.clicked.connect(self.show_data_entry_page)
        
        # Stacked widget for pages
        self.stacked_widget = QStackedWidget()
        
        # Create pages
        self.calculation_page = CalculationPage(self)
        self.data_entry_page = DataEntryPage(self)
        
        self.stacked_widget.addWidget(self.calculation_page)
        self.stacked_widget.addWidget(self.data_entry_page)
        
        main_layout.addWidget(self.stacked_widget)
        self.setLayout(main_layout)
        
        # Show calculation page by default
        self.show_calculation_page()
        
    def apply_styles(self):
        """Apply custom styles to the application"""
        style = """
            QWidget {
                background-color: #f5f5f5;
                font-family: "Segoe UI", Arial, sans-serif;
            }
            
            QPushButton {
                background-color: #ffffff;
                border: 2px solid #e1e1e1;
                border-radius: 8px;
                padding: 12px 24px;
                font-size: 14px;
                font-weight: bold;
                color: #333333;
            }
            
            QPushButton:hover {
                background-color: #e8f4fd;
                border-color: #0078d4;
            }
            
            QPushButton:checked {
                background-color: #0078d4;
                color: white;
                border-color: #106ebe;
            }
            
            QPushButton:pressed {
                background-color: #106ebe;
            }
            
            QFrame {
                background-color: white;
                border: 1px solid #e1e1e1;
                border-radius: 10px;
                padding: 15px;
            }
            
            QLineEdit {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 13px;
                background-color: white;
            }
            
            QLineEdit:focus {
                border-color: #0078d4;
            }
            
            QComboBox {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 13px;
                background-color: white;
            }
            
            QComboBox:focus {
                border-color: #0078d4;
            }
            
            QTextEdit {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 10px;
                font-size: 12px;
                background-color: white;
            }
            
            QLabel {
                color: #333333;
                font-size: 13px;
                font-weight: 500;
            }
            
            QScrollArea {
                border: 1px solid #e1e1e1;
                border-radius: 6px;
                background-color: white;
            }
            
            QGroupBox {
                font-weight: bold;
                border: 2px solid #e1e1e1;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
                background-color: white;
            }
            
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 10px 0 10px;
                color: #0078d4;
                font-size: 14px;
            }
        """
        self.setStyleSheet(style)
        
    def show_calculation_page(self):
        """Switch to calculation page"""
        self.stacked_widget.setCurrentWidget(self.calculation_page)
        self.calc_btn.setChecked(True)
        self.data_entry_btn.setChecked(False)
        #self.calculation_page.refresh_data()
        
    def show_data_entry_page(self):
        """Switch to data entry page"""
        self.stacked_widget.setCurrentWidget(self.data_entry_page)
        self.data_entry_btn.setChecked(True)
        self.calc_btn.setChecked(False)
        self.data_entry_page.refresh_saved_data()

class EditableDataCard(QFrame):
    """Custom data card that emits signal when double-clicked"""
    double_clicked = pyqtSignal(object)
    
    def __init__(self, data):
        super().__init__()
        self.data = data
        self.init_ui()



        
    def init_ui(self):
        """Initialize card UI"""
        self.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        self.setMinimumHeight(250)
        
        # Card styling
        self.setStyleSheet("""
            EditableDataCard {
                background-color: white;
                border: 2px solid #e1e1e1;
                border-radius: 10px;
                margin: 5px;
            }
            EditableDataCard:hover {
                border-color: #0078d4;
                background-color: #f8f9fa;
            }
        """)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 12, 0, 0)
        layout.setSpacing(6)
        
        # Header with fabrcator name
        header = QLabel(f"{self.data[1]}")
        header.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        header.setStyleSheet("color: #0078d4; margin-bottom: 5px;")
        layout.addWidget(header)
        
        details = [
            f"Material: {self.data[2]} | Layers: {self.data[3]} | Qty: {int(safe_float(self.data[4])):,}",
            f"PCB Size: L {safe_float(self.data[6]):.2f} W {safe_float(self.data[7]):.2f} | Price: â‚¹{safe_float(self.data[5]):,.2f}",
        ]


        
        for detail in details:
            label = QLabel(detail)
            label.setFont(QFont("Arial", 10))
            label.setStyleSheet("color: #666666; margin: 2px 0;")
            layout.addWidget(label)
            
        
    def mouseDoubleClickEvent(self, event):
        """Handle double-click event"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.double_clicked.emit(self.data)

class DataEntryPage(QWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.current_edit_id = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize data entry page UI"""
        layout = QHBoxLayout()
        layout.setSpacing(20)
        
        # Left side - Scrollable Input form (keeping existing code)
        left_frame = QGroupBox("PCB Specification Entry")
        left_frame_layout = QVBoxLayout(left_frame)
        
        # Create scroll area for the input form
        self.input_scroll_area = QScrollArea()
        self.input_scroll_area.setWidgetResizable(True)
        self.input_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.input_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
    
        
        # Create container widget for the form
        input_container = QWidget()
        input_layout = QVBoxLayout(input_container)
        
        # Form layout
        form_layout = QGridLayout()
        form_layout.setSpacing(12)
        
        row = 0
        
        # Basic Information Group
        basic_label = QLabel("Basic Information")
        basic_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        basic_label.setStyleSheet("color: #0078d4; margin: 10px 0 5px 0;")
        form_layout.addWidget(basic_label, row, 0, 1, 2)
        row += 1
        
        # Units selection
        form_layout.addWidget(QLabel("Units:"), row, 0)
        self.Units_combo = QComboBox()
        self.Units_combo.addItems(["mm", "inch"])
        form_layout.addWidget(self.Units_combo, row, 1)
        row += 1
        
        # Fabricator name
        form_layout.addWidget(QLabel("Fabricator Name:"), row, 0)
        self.fabricator_input = QLineEdit()
        self.fabricator_input.setPlaceholderText("Enter fabricator name...")
        form_layout.addWidget(self.fabricator_input, row, 1)
        row += 1
        
        # PCB quantity
        form_layout.addWidget(QLabel("PCB Quantity:"), row, 0)
        self.qty_input = QLineEdit()
        self.qty_input.setValidator(QIntValidator(1, 999999))
        self.qty_input.setPlaceholderText("Enter quantity...")
        form_layout.addWidget(self.qty_input, row, 1)
        row += 1
        
        # PCB layer
        form_layout.addWidget(QLabel("PCB Layers:"), row, 0)
        self.layer_combo = QComboBox()
        self.layer_combo.addItems(["1", "2", "4", "6", "8", "10", "12", "14", "16", "18", "20", "22", "24", "26", "28", "30", "32", "34", "36", "38", "40"])
        form_layout.addWidget(self.layer_combo, row, 1)
        row += 1

        form_layout.addWidget(QLabel("PCB Size:"), row, 0)
        size_widget = QWidget()
        size_layout = QHBoxLayout(size_widget)
        size_layout.setContentsMargins(0, 0, 0, 0)
        
        self.length_input = QLineEdit()
        self.length_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.length_input.setPlaceholderText("Length")
        
        self.width_input = QLineEdit()
        self.width_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.width_input.setPlaceholderText("Width")
        
        size_layout.addWidget(QLabel("L:"))
        size_layout.addWidget(self.length_input)
        size_layout.addWidget(QLabel("W:"))
        size_layout.addWidget(self.width_input)
        
        form_layout.addWidget(size_widget, row, 1)
        row += 1

        # PCB Part Number
        form_layout.addWidget(QLabel("PCB Part Number:"), row, 0)
        self.part_number_input = QLineEdit()
        self.part_number_input.setPlaceholderText("Enter PCB Part Number...")
        form_layout.addWidget(self.part_number_input, row, 1)
        row += 1

        # PCB Specification
        form_layout.addWidget(QLabel("PCBspec :"), row, 0)
        self.PCBspec = QComboBox()
        self.PCBspec.addItems(["Class 2", "Class 3", "MIL Grade"])
        form_layout.addWidget(self.PCBspec, row, 1)
        row += 1

        # Array Size
        form_layout.addWidget(QLabel("Array Size:"), row, 0)
        self.array_size_input = QLineEdit()
        self.array_size_input.setPlaceholderText("e.g. 2x3")
        form_layout.addWidget(self.array_size_input, row, 1)
        row += 1

        # Board Thickness
        form_layout.addWidget(QLabel("Board Thickness (mil):"), row, 0)
        self.BoardThickness_input = QLineEdit()
        self.BoardThickness_input.setValidator(QIntValidator(1, 5000))
        self.BoardThickness_input.setPlaceholderText("Enter board thickness...")
        form_layout.addWidget(self.BoardThickness_input, row, 1)
        row += 1

        
        materials = [
            ("Material:", "material_input"),
            ("Solder mask:", "Soldermask_input"),
            ("Silkscreen:", "Silkscreen_input"),
            ("Copper Inner:", "CuInner_input"),
            ("Copper Outer:", "CuOuter_input")
        ]
        
        for label_text, attr_name in materials:
            form_layout.addWidget(QLabel(label_text), row, 0)
            line_edit = QLineEdit()
            line_edit.setPlaceholderText(f"Enter {label_text.lower().rstrip(':')}...")
            setattr(self, attr_name, line_edit)
            form_layout.addWidget(line_edit, row, 1)
            row += 1
        
        # Surface Finish
        form_layout.addWidget(QLabel("Surface Finish:"), row, 0)
        self.SurfaceFinish_input = QLineEdit()
        self.SurfaceFinish_input.setPlaceholderText("e.g. ENIG, HASL...")
        form_layout.addWidget(self.SurfaceFinish_input, row, 1)
        row += 1

        

        form_layout.addWidget(QLabel("Back Drill:"), row, 0)
        self.back_drill_combo = QComboBox()
        self.back_drill_combo.addItems(["YES", "NO"])
        form_layout.addWidget(self.back_drill_combo, row, 1)
        row += 1

        form_layout.addWidget(QLabel("Blind Via:"), row, 0)
        self.blind_via_combo = QComboBox()
        self.blind_via_combo.addItems(["YES", "NO"])
        form_layout.addWidget(self.blind_via_combo, row, 1)
        row += 1

        form_layout.addWidget(QLabel("Buried Via:"), row, 0)
        self.berried_via_combo = QComboBox()
        self.berried_via_combo.addItems(["YES", "NO"])
        form_layout.addWidget(self.berried_via_combo, row, 1)
        row += 1


        # Selective Plating
        form_layout.addWidget(QLabel("Selective Plating:"), row, 0)
        self.selective_plating_input = QComboBox()
        self.selective_plating_input.addItems(["YES", "NO"])
        form_layout.addWidget(self.selective_plating_input, row, 1)
        row += 1

        # Drills
        form_layout.addWidget(QLabel("Drills:"), row, 0)
        self.drills_input = QLineEdit()
        self.drills_input.setPlaceholderText("Drill type/details...")
        form_layout.addWidget(self.drills_input, row, 1)
        row += 1

        # Impedance
        form_layout.addWidget(QLabel("Impedance:"), row, 0)
        self.impedance_input =  QComboBox()
        self.impedance_input.addItems(["YES", "NO"])
        form_layout.addWidget(self.impedance_input, row, 1)
        row += 1

        # Via Type
        form_layout.addWidget(QLabel("Via Type:"), row, 0)
        self.via_type_input = QLineEdit()
        self.via_type_input.setPlaceholderText("Through, Blind, Buried, etc.")
        form_layout.addWidget(self.via_type_input, row, 1)
        row += 1

        # Via Fill
        form_layout.addWidget(QLabel("Via Fill:"), row, 0)
        self.via_fill_input = QLineEdit()
        self.via_fill_input.setPlaceholderText("Conductive/Non-conductive...")
        form_layout.addWidget(self.via_fill_input, row, 1)
        row += 1

        # Beveling
        form_layout.addWidget(QLabel("Beveling:"), row, 0)
        self.beveling_input = QLineEdit()
        self.beveling_input.setPlaceholderText("Yes/No or details...")
        form_layout.addWidget(self.beveling_input, row, 1)
        row += 1

        # Edge Plating
        form_layout.addWidget(QLabel("Edge Plating:"), row, 0)
        self.edge_plating_input = QLineEdit()
        self.edge_plating_input.setPlaceholderText("Yes/No or details...")
        form_layout.addWidget(self.edge_plating_input, row, 1)
        row += 1

        # Price Per Units
        form_layout.addWidget(QLabel("Price Per Units ($):"), row, 0)
        self.PricePerUnits_input = QLineEdit()
        self.PricePerUnits_input.setValidator(QDoubleValidator(0.01, 999999.99, 2))
        self.PricePerUnits_input.setPlaceholderText("e.g. 5.25")
        form_layout.addWidget(self.PricePerUnits_input, row, 1)
        row += 1

        # Engineering Cost
        form_layout.addWidget(QLabel("Engineering Cost ($):"), row, 0)
        self.engg_cost_input = QLineEdit()
        self.engg_cost_input.setValidator(QDoubleValidator(0.00, 999999.99, 2))
        self.engg_cost_input.setPlaceholderText("Enter engineering cost...")
        form_layout.addWidget(self.engg_cost_input, row, 1)
        row += 1

        # Lead Time
        form_layout.addWidget(QLabel("Lead Time:"), row, 0)
        self.lead_time_input = QLineEdit()
        self.lead_time_input.setPlaceholderText("Enter lead time...")
        form_layout.addWidget(self.lead_time_input, row, 1)
        row += 1


        
        form_layout.addWidget(QLabel("Total Price (â‚¹):"), row, 0)
        self.price_input = QLineEdit()
        self.price_input.setValidator(QDoubleValidator(0.01, 999999.99, 2))
        self.price_input.setPlaceholderText("Enter total price...")
        form_layout.addWidget(self.price_input, row, 1)
        
        input_layout.addLayout(form_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        
        self.save_btn = QPushButton("Save Data")
        self.update_btn = QPushButton("Update Data")
        self.clear_btn = QPushButton("Clear Form")
        self.delete_btn = QPushButton("Delete Record")
        
        # Initially hide update and delete buttons
        self.update_btn.hide()
        self.delete_btn.hide()
        
        for btn in [self.save_btn, self.update_btn, self.clear_btn, self.delete_btn]:
            btn.setMinimumHeight(40)
            
        self.save_btn.clicked.connect(self.save_data)
        self.update_btn.clicked.connect(self.update_data)
        self.clear_btn.clicked.connect(self.clear_form)
        self.delete_btn.clicked.connect(self.delete_data)
        
        button_layout.addWidget(self.save_btn)
        button_layout.addWidget(self.update_btn)
        button_layout.addWidget(self.clear_btn)
        button_layout.addWidget(self.delete_btn)
        
        input_layout.addLayout(button_layout)
        
        # Set the container widget to the scroll area
        self.input_scroll_area.setWidget(input_container)
        
        # Add scroll area to the frame layout
        left_frame_layout.addWidget(self.input_scroll_area)
        
            # Right side - Saved data cards
        right_frame = QGroupBox("Saved PCB Data Records")
        right_layout = QVBoxLayout(right_frame)
        
        # Search/Filter section (stays at top, not scrollable)
        search_layout = QHBoxLayout()
        search_label = QLabel("ðŸ”ŽSearch:")
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search by fabricator or material...")
        self.search_input.textChanged.connect(self.filter_cards)
        
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.search_input)
        right_layout.addLayout(search_layout)
        
        # ENHANCED Scroll area for cards
        self.cards_scroll_area = QScrollArea()
        self.cards_scroll_area.setWidgetResizable(True)
        self.cards_scroll_area.setMinimumWidth(400)
        self.cards_scroll_area.setMinimumHeight(300)  # Ensure minimum height
        
        # Enhanced scroll bar policies
        self.cards_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.cards_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)
        
        # Enhanced scroll area styling
        self.cards_scroll_area.setStyleSheet("""
            QScrollArea {
                border: 2px solid #e1e1e1;
                border-radius: 8px;
                background-color: #f8f9fa;
            }
            QScrollArea > QWidget > QWidget {
                background-color: #f8f9fa;
            QComboBox{
                                             
                                             }
            }
            QScrollBar:vertical {
                border: none;
                background-color: #f0f0f0;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #c0c0c0;
                min-height: 20px;
                border-radius: 6px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #0078d4;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        
        # Cards container widget
        self.cards_widget = QWidget()
        self.cards_widget.setStyleSheet("background-color: transparent;")
        
        # Cards layout with improved spacing
        self.cards_layout = QVBoxLayout(self.cards_widget)
        self.cards_layout.setSpacing(10)
        self.cards_layout.setContentsMargins(10, 10, 10, 10)
        
        # Set the cards widget to the scroll area
        self.cards_scroll_area.setWidget(self.cards_widget)
        
        # Add scroll area to right layout
        right_layout.addWidget(self.cards_scroll_area)
        
        # Add record count label at bottom
        self.record_count_label = QLabel("No records")
        self.record_count_label.setStyleSheet("color: #666666; font-size: 11px; padding: 5px;")
        self.record_count_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        right_layout.addWidget(self.record_count_label)
        
        # Add frames to main layout
        layout.addWidget(left_frame, 1)
        layout.addWidget(right_frame, 1)
        self.setLayout(layout)
        
        self.refresh_saved_data()

    def save_data(self):
        """Save PCB data to database"""
        try:
            # Validate required fields
            if not all([
                self.fabricator_input.text().strip(),
                self.qty_input.text(),
                self.length_input.text(),
                self.width_input.text(),
                self.price_input.text()
            ]):
                QMessageBox.warning(self, "Validation Error", 
                                "Please fill all required fields!")
                return
            
            data = self.get_form_data()
            
            # Insert into database
            self.parent.cursor.execute('''
                INSERT INTO pcb_data (
                    FabricatorName, Units, PCBPartNumber, Quantity, Layers, PCBspec, material,
                    Soldermask, Silkscreen, CuInner, CuOuter, SurfaceFinish, SelectivePlating,
                    Drills, Impedance, ViaType, ViaFill, Beveling, EdgePlating, PricePerUnit,
                    Quantity, EnggCost, TotalCostINR, LeadTime
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', tuple(data.values()))
            
            self.parent.conn.commit()
            QMessageBox.information(self, "Success", "Data saved successfully!")
            self.clear_form()
            self.refresh_saved_data()
            
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save data: {str(e)}")

    
    def update_data(self):
        """Update existing PCB data"""
        try:
            if self.current_edit_id is None:
                return
            
            data = self.get_form_data()
            
            # Update existing record
            self.parent.cursor.execute('''
                UPDATE pcb_data SET
                    FabricatorName = ?, Units = ?, PCBPartNumber = ?, Quantity = ?, Layers = ?, 
                    PCBspec = ?, material = ?, Soldermask = ?, Silkscreen = ?, CuInner = ?, CuOuter = ?,
                    SurfaceFinish = ?, SelectivePlating = ?, Drills = ?, Impedance = ?, ViaType = ?, 
                    ViaFill = ?, Beveling = ?, EdgePlating = ?, PricePerUnit = ?, Quantity = ?, EnggCost = ?,
                    TotalCostINR = ?, LeadTime = ?
                WHERE id = ?
            ''', tuple(data.values()) + (self.current_edit_id,))

            self.parent.conn.commit()
            QMessageBox.information(self, "Success", "Data updated successfully!")
            self.clear_form()
            self.refresh_saved_data()
            
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to update data: {str(e)}")
 

    def get_form_data(self):
        """Get data from form inputs"""
        return {
            'FabricatorName': self.fabricator_input.text().strip(),
            'Units': self.Units_combo.currentText(),
            'PCBPartNumber': self.part_number_input.text().strip(),
            'Quantity': int(self.qty_input.text()),
            'Layers': int(self.layer_combo.currentText()),
            'PCBspec': self.PCBspec.currentText(),
            'material': self.material_input.text().strip(),
            'Length': float(self.length_input.text()),
            'Width': float(self.width_input.text()),
            'ArraySize': self.array_size_input.text().strip(),
            'BoardThickness': int(self.BoardThickness_input.text() or 0),
            'CuInner': self.CuInner_input.text().strip(),
            'CuOuter': self.CuOuter_input.text().strip(),
            'SurfaceFinish': self.SurfaceFinish_input.text().strip(),
            'SelectivePlating': self.selective_plating_input.currentText(),
            'Drills': self.drills_input.text().strip(),
            'Impedance': self.impedance_input.currentText().strip(),
            'Soldermask': self.Soldermask_input.text().strip(),
            'Silkscreen': self.Silkscreen_input.text().strip(),
            'back_drill': self.back_drill_combo.currentText(),
            'blind_via': self.blind_via_combo.currentText(),
            'berried_via': self.berried_via_combo.currentText(),
            'ViaType': self.via_type_input.text().strip(),
            'ViaFill': self.via_fill_input.text().strip(),
            'Beveling': self.beveling_input.text().strip(),
            'EdgePlating': self.edge_plating_input.text().strip(),
            'PricePerUnit': self.PricePerUnits_input.text().strip(),
            'Quantity': self.qty_input.text(),
            'EnggCost': self.engg_cost_input.text().strip(),
            'TotalCostINR': float(self.price_input.text()),
            'LeadTime': self.lead_time_input.text().strip()  # New field
        }
                
    def clear_form(self):
        """Clear all form inputs and reset editing state"""
        # Clear all QLineEdit inputs
        for widget in [self.fabricator_input, self.qty_input, self.length_input, 
                    self.width_input, self.material_input, self.Soldermask_input,
                    self.Silkscreen_input, self.CuInner_input, self.CuOuter_input,
                    self.price_input, self.array_size_input, self.engg_cost_input,
                    self.PricePerUnits_input, self.via_type_input, self.via_fill_input,
                    self.beveling_input, self.edge_plating_input, self.impedance_input,
                    self.selective_plating_input, self.drills_input]:
            widget.clear()

        # Reset combo boxes to default
        for combo in [self.Units_combo, self.layer_combo, self.PCBspec, self.back_drill_combo,
                    self.blind_via_combo, self.berried_via_combo]:
            combo.setCurrentIndex(0)

        # Reset editing state
        self.current_edit_id = None
        self.save_btn.show()
        self.update_btn.hide()
        self.delete_btn.hide()

    def refresh_saved_data(self):
        """Refresh the saved data cards"""
        # Clear existing cards
        for i in reversed(range(self.cards_layout.count())):
            child = self.cards_layout.itemAt(i).widget()
            if child:
                child.setParent(None)
                
        # Fetch data from database
        self.parent.cursor.execute('''
            SELECT id, FabricatorName, material, Layers, Quantity, TotalCostINR, 
                   Length, Width, Units
            FROM pcb_data ORDER BY created_date DESC
        ''')
        
        self.all_data = self.parent.cursor.fetchall()
        self.display_cards(self.all_data)
        
    def display_cards(self, data):
        """Display data cards"""
        # Clear existing cards
        for i in reversed(range(self.cards_layout.count())):
            child = self.cards_layout.itemAt(i).widget()
            if child:
                child.setParent(None)
        
        if not data:
            no_data_label = QLabel("No PCB data records found.")
            no_data_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            no_data_label.setStyleSheet("""
                color: #666666; 
                font-style: italic; 
                font-size: 14px;
                padding: 40px;
                background-color: white;
                border: 2px dashed #e1e1e1;
                border-radius: 10px;
                margin: 20px;
            """)
            self.cards_layout.addWidget(no_data_label)
            self.record_count_label.setText("No records")
        else:
            # Debug: Print the data structure
            print(f"Data count: {len(data)}")
            if data:
                print(f"First record structure: {data[0]}")
                print(f"Record length: {len(data[0])}")
            
            for row in data:
                card = EditableDataCard(row)
                card.double_clicked.connect(self.load_data_in_form)
                self.cards_layout.addWidget(card)
            
            self.record_count_label.setText(f"Ã°Å¸â€œÅ  {len(data)} record{'s' if len(data) != 1 else ''}")
        
        self.cards_layout.addStretch()


    def scroll_to_top(self):
        """Scroll the cards area to top"""
        self.cards_scroll_area.verticalScrollBar().setValue(0)

    def scroll_to_card(self, card_id):
        """Scroll to a specific card by ID"""
        for i in range(self.cards_layout.count()):
            widget = self.cards_layout.itemAt(i).widget()
            if isinstance(widget, EditableDataCard) and widget.data[0] == card_id:
                # Calculate position and scroll to it
                card_pos = widget.pos().y()
                self.cards_scroll_area.verticalScrollBar().setValue(card_pos)
                break


    def filter_cards(self):
        """Filter cards based on search input"""
        search_text = self.search_input.text().lower()
        
        if not search_text:
            filtered_data = self.all_data
        else:
            filtered_data = [
                row for row in self.all_data
                if search_text in row[1].lower() or search_text in row[2].lower()
            ]
        
        self.display_cards(filtered_data)

    def load_data_in_form(self, data):
        """Load card data into input fields for editing"""
        self.current_edit_id = data[0]
        
        # Query full record from database
        self.parent.cursor.execute("SELECT * FROM pcb_data WHERE id=?", (self.current_edit_id,))
        record = self.parent.cursor.fetchone()
        
        if not record:
            QMessageBox.warning(self, "Load Error", "Failed to load the selected record.")
            return

        # Unpack record data
        FabricatorName = record[2]
        PCBPartNumber = record[3]
        Units = record[1]
        Quantity = record[27]
        Layers = record[4]
        PCBspec = record[5]
        Length = record[7]
        Width = record[8]
        ArraySize = record[9]
        BoardThickness = record[10]
        material = record[6]
        Soldermask = record[8]
        Silkscreen = record[9]
        CuInner = record[11]
        CuOuter = record[12]
        SurfaceFinish = record[13]
        SelectivePlating = record[14]
        Drills = record[15]
        back_drill = record[19]
        blind_via = record[20]
        berried_via = record[21]
        ViaType = record[22]
        TotalCostINR = record[29]


        # Populate form fields
        self.fabricator_input.setText(FabricatorName or "")
        self.part_number_input.setText(PCBPartNumber or "")
        self.Units_combo.setCurrentText(Units)
        self.qty_input.setText(str(Quantity))
        self.layer_combo.setCurrentText(str(Layers))
        self.PCBspec.setCurrentText(str(PCBspec))
        self.length_input.setText(str(Length))
        self.width_input.setText(str(Width))
        self.array_size_input.setText(ArraySize or "")
        self.BoardThickness_input.setText(str(BoardThickness))
        self.material_input.setText(material or "")
        self.Soldermask_input.setText(Soldermask or "")
        self.Silkscreen_input.setText(Silkscreen or "")
        self.CuInner_input.setText(CuInner or "")
        self.CuOuter_input.setText(CuOuter or "")
        self.SurfaceFinish_input.setText(SurfaceFinish or "")
        self.selective_plating_input.setCurrentText(SelectivePlating)
        self.drills_input.setText(Drills)
        self.back_drill_combo.setCurrentText(back_drill)
        self.blind_via_combo.setCurrentText(blind_via)
        self.berried_via_combo.setCurrentText(berried_via)
        self.via_type_input.setText(ViaType)
        self.price_input.setText(str(TotalCostINR))

        # Switch to edit mode
        self.save_btn.hide()
        self.update_btn.show()
        self.delete_btn.show()

    def delete_data(self):
        """Delete selected record from database"""
        if self.current_edit_id is None:
            return

        reply = QMessageBox.question(
            self, "Confirm Delete",
            "Are you sure you want to delete this PCB record?\n\nThis action cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            try:
                self.parent.cursor.execute("DELETE FROM pcb_data WHERE id=?", (self.current_edit_id,))
                self.parent.conn.commit()
                QMessageBox.information(self, "Deleted", "Record deleted successfully!")
                self.clear_form()
                self.refresh_saved_data()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to delete record: {str(e)}")

class CalculationPage(QWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.init_ui()
        
    def init_ui(self):
        """Initialize calculation page UI with updated fields"""
        layout = QHBoxLayout()
        layout.setSpacing(20)
        
        # Left side - Scrollable Input form
        left_frame = QGroupBox("Price Calculation Input")
        left_frame_layout = QVBoxLayout(left_frame)
        
        # Create scroll area for the input form
        self.input_scroll_area = QScrollArea()
        self.input_scroll_area.setWidgetResizable(True)
        self.input_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.input_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # Create container widget for the form
        input_container = QWidget()
        input_layout = QVBoxLayout(input_container)
        
        form_layout = QGridLayout()
        form_layout.setSpacing(12)
        row = 0

        # Customer Information
        customer_label = QLabel("Customer Information")
        customer_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        customer_label.setStyleSheet("color: #0078d4; margin: 10px 0 5px 0;")
        form_layout.addWidget(customer_label, row, 0, 1, 2)
        row += 1

        form_layout.addWidget(QLabel("Customer Name:"), row, 0)
        self.customer_input = QLineEdit()
        self.customer_input.setPlaceholderText("Enter customer name...")
        form_layout.addWidget(self.customer_input, row, 1)
        row += 1

        form_layout.addWidget(QLabel("Job Number:"), row, 0)
        self.job_input = QLineEdit()
        self.job_input.setPlaceholderText("Enter job number...")
        form_layout.addWidget(self.job_input, row, 1)
        row += 1
        
        form_layout.addWidget(QLabel("PCB Part Number:"), row, 0)
        self.pcb_part_input = QLineEdit()
        self.pcb_part_input.setPlaceholderText("Enter PCB part number...")
        form_layout.addWidget(self.pcb_part_input, row, 1)
        row += 1

        # PCB Specifications
        pcb_label = QLabel("PCB Specifications")
        pcb_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        pcb_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(pcb_label, row, 0, 1, 2)
        row += 1

        form_layout.addWidget(QLabel("Unit:"), row, 0)
        self.unit_combo = QComboBox()
        self.unit_combo.addItems(["mm", "inch"])
        form_layout.addWidget(self.unit_combo, row, 1)
        row += 1

        # PCB Size
        form_layout.addWidget(QLabel("PCB Size (L Ã— W):"), row, 0)
        size_widget = QWidget()
        size_layout = QHBoxLayout(size_widget)
        size_layout.setContentsMargins(0, 0, 0, 0)
        
        self.length_input = QLineEdit()
        self.length_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.length_input.setPlaceholderText("Length")
        
        self.width_input = QLineEdit()
        self.width_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.width_input.setPlaceholderText("Width")  # Fixed typo here
        
        size_layout.addWidget(QLabel("L:"))
        size_layout.addWidget(self.length_input)
        size_layout.addWidget(QLabel("Ã—"))
        size_layout.addWidget(QLabel("W:"))
        size_layout.addWidget(self.width_input)
        
        form_layout.addWidget(size_widget, row, 1)
        row += 1


        # Initialize filter_combos dictionary BEFORE using it
        self.filter_combos = {}
        
        # Create all filter fields
        filter_fields = [
            "Layers", "material", "BoardThickness", "CuInner", "CuOuter",
            "SurfaceFinish", "impedance", "soldermask", "silkscreen", 
            "back_drill", "blind_via", "berried_via"
        ]
        
        for field in filter_fields:
            label_text = field.replace('_', ' ').title() + ":"
            form_layout.addWidget(QLabel(label_text), row, 0)
            combo = QComboBox()
            combo.setMinimumWidth(200)
            self.filter_combos[field] = combo
            form_layout.addWidget(combo, row, 1)
            row += 1

        input_layout.addLayout(form_layout)
        
        # Calculate button
        self.calculate_btn = QPushButton("ðŸ§® Calculate Price")
        self.calculate_btn.setMinimumHeight(50)
        self.calculate_btn.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        self.calculate_btn.clicked.connect(self.calculate_price)
        input_layout.addWidget(self.calculate_btn)
        
        # Set the container widget to the scroll area
        self.input_scroll_area.setWidget(input_container)
        left_frame_layout.addWidget(self.input_scroll_area)
        
        # Right side - Results
        right_frame = QGroupBox("Calculation Results")
        right_layout = QVBoxLayout(right_frame)

        # Create table widget for results
        self.results_table = QTableWidget()
        self.results_table.setColumnCount(2)
        self.results_table.setHorizontalHeaderLabels(['Parameter', 'Value'])
        self.results_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.results_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.results_table.verticalHeader().setVisible(False)
        self.results_table.setAlternatingRowColors(True)
        self.results_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.results_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        right_layout.addWidget(self.results_table)

        
        # Export button
        self.export_btn = QPushButton("ðŸ“Š Export to Excel")
        self.export_btn.setMinimumHeight(45)
        self.export_btn.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        self.export_btn.clicked.connect(self.export_to_excel)
        right_layout.addWidget(self.export_btn)
        
        # Add frames to main layout
        layout.addWidget(left_frame, 1)
        layout.addWidget(right_frame, 1)
        self.setLayout(layout)
            
    def refresh_data(self):
        try:
            filter_fields = [...]  # your fields
            for field in filter_fields:
                print(f"Fetching values for: {field}")
                self.parent.cursor.execute(f"""
                    SELECT DISTINCT {field}
                    FROM pcb_data
                    WHERE {field} IS NOT NULL AND {field} != ''
                    ORDER BY {field}
                """)
                values = [str(row[0]) for row in self.parent.cursor.fetchall()]
                print(f"Found {len(values)} values for {field}: {values}")

                if field in self.filter_combos:
                    self.filter_combos[field].clear()
                    if values:
                        self.filter_combos[field].addItems(values)
        except Exception as e:
            print(f"Error during refresh_data: {e}")





    def calculate_price(self):
        """Calculate PCB price based on updated database data"""
        try:
            # Validate inputs
            if not all([
                self.customer_input.text().strip(),
                self.job_input.text().strip(),
                self.pcb_part_input.text().strip(),
                self.length_input.text(),
                self.width_input.text()
            ]):
                QMessageBox.warning(self, "Input Error", "Please fill all required fields!")
                return

            # Get input values
            customer_name = self.customer_input.text().strip()
            job_number = self.job_input.text().strip()
            pcb_part_number = self.pcb_part_input.text().strip()
            unit = self.unit_combo.currentText()
            length_text = self.length_input.text().strip()
            width_text = self.width_input.text().strip()

            if not length_text or not width_text:
                QMessageBox.warning(self, "Input Error", "Please enter both Length and Width.")
                return

            try:
                length = float(length_text)
                width = float(width_text)
            except ValueError:
                QMessageBox.warning(self, "Input Error", "Length and Width must be numeric.")
                return


            # Build dynamic query based on selected filters
            query_conditions = []
            params = []
            for field, combo in self.filter_combos.items():
                if combo.currentText():
                    query_conditions.append(f"{field} = ?")
                    params.append(combo.currentText())

            base_query = '''
            SELECT quantity, length, width, PricePerUnit, TotalCostINR
            FROM pcb_data
            '''
            
            if query_conditions:
                query = base_query + "WHERE " + " AND ".join(query_conditions) + " ORDER BY PricePerUnit DESC"
            else:
                query = base_query + "ORDER BY PricePerUnit DESC"

            self.parent.cursor.execute(query, params)
            matches = self.parent.cursor.fetchall()

            if not matches:
                QMessageBox.information(self, "No Match", "No matching records found for the specified criteria.")
                return

            # Use the record with maximum price per unit
            best_match = matches[0]
            ref_qty, ref_length, ref_width, ref_PricePerUnit, ref_total_cost = best_match

            # Calculate price per square unit
            ref_area = ref_length * ref_width
            price_per_sq_unit = ref_PricePerUnit / ref_area if ref_area > 0 else 0

            # Calculate prices for input PCB
            input_area = length * width
            per_unit_price = price_per_sq_unit * input_area

            # Populate results table
            self.populate_results_table(customer_name, job_number, pcb_part_number, unit, 
                                    length, width, input_area, ref_length, ref_width, 
                                    ref_PricePerUnit, price_per_sq_unit, per_unit_price)

            # Save calculation to database (existing logic)
            self.parent.cursor.execute('''
            INSERT INTO calculation_results (
                customer_name, job_number, pcb_part_number, unit, Length, Width,
                Layers, PCBspec, material, BoardThickness, CuInner, CuOuter, SurfaceFinish,
                impedance, Soldermask, Silkscreen, back_drill, blind_via, berried_via,
                per_sq_unit_price, per_unit_price, total_price
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                customer_name, job_number, pcb_part_number, unit, length, width,
                self.filter_combos.get("Layers", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("material", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("BoardThickness", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("CuInner", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("CuOuter", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("SurfaceFinish", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("impedance", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("soldermask", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("silkscreen", type('obj', (object,), {'currentText': lambda: ''})).currentText(),

                self.filter_combos.get("back_drill", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("blind_via", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("berried_via", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                price_per_sq_unit, per_unit_price, per_unit_price
            ))

            self.parent.conn.commit()

        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Calculation failed: {str(e)}")

    def populate_results_table(self, customer_name, job_number, pcb_part_number, unit,
                            length, width, input_area, ref_length, ref_width,
                            ref_PricePerUnit, price_per_sq_unit, per_unit_price):
        """Populate the results table with calculation data in Excel-like format"""
        
        # Define all rows with their data
        rows = [
            ("PCB Fabrication Cost Tool", "", "header"),
            ("", "", "spacer"),
            ("Customer Information", "", "section"),
            ("Customer Name", customer_name, "data"),
            ("Job Number", job_number, "data"),
            ("PCB Part Number", pcb_part_number, "data"),
            ("Calculation Date", datetime.now().strftime('%Y-%m-%d %H:%M:%S'), "data"),
            ("", "", "spacer"),
            ("PCB Specifications", "", "section"),
            ("Unit", unit, "data"),
            ("PCB Length", f"{length} {unit}", "data"),
            ("PCB Width", f"{width} {unit}", "data"),
            ("PCB Area", f"{input_area:.2f} {unit}Â²", "data"),
        ]
        
        # Add selected configuration if filters are applied - FIXED LINE
        if any(combo.currentText() for combo in self.filter_combos.values()):
            rows.extend([
                ("", "", "spacer"),
                ("Selected Configuration", "", "section")
            ])
            
            for field, combo in self.filter_combos.items():
                if combo.currentText():
                    field_display = field.replace('_', ' ').title()
                    rows.append((field_display, combo.currentText(), "data"))
        
        # Add reference data and calculations
        rows.extend([
            ("", "", "spacer"),
            ("Reference Data", "", "section"),
            ("Reference PCB Size", f"{ref_length} Ã— {ref_width} {unit}", "data"),
            ("Reference Price/Unit", f"â‚¹{ref_PricePerUnit:.2f}", "data"),
            ("", "", "spacer"),
            ("Price Calculation", "", "section"),
            ("Price per Square Unit", f"â‚¹{price_per_sq_unit:.4f}", "calculation"),
            ("Estimated Price per PCB", f"â‚¹{per_unit_price:.2f}", "calculation"),
            ("Unit Cost", f"â‚¹{per_unit_price:.2f} per piece", "calculation")
        ])

        # Set up the table
        self.results_table.setRowCount(len(rows))
        
        # Populate table items
        for row_idx, (param, value, row_type) in enumerate(rows):
            param_item = QTableWidgetItem(param)
            value_item = QTableWidgetItem(value)
            
            # Apply formatting based on row type
            if row_type == "header":
                # Blue header like Excel
                param_item.setBackground(QColor(68, 114, 196))  # Excel blue
                param_item.setForeground(QColor(255, 255, 255))  # White text
                value_item.setBackground(QColor(68, 114, 196))
                value_item.setForeground(QColor(255, 255, 255))
                font = QFont()
                font.setBold(True)
                font.setPointSize(14)
                param_item.setFont(font)
                param_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                
            elif row_type == "section":
                # Light blue section headers
                param_item.setBackground(QColor(213, 228, 247))  # Light blue
                value_item.setBackground(QColor(213, 228, 247))
                font = QFont()
                font.setBold(True)
                param_item.setFont(font)
                value_item.setFont(font)
                
            elif row_type == "calculation":
                # Light green for calculations
                param_item.setBackground(QColor(226, 239, 218))  # Light green
                value_item.setBackground(QColor(226, 239, 218))
                font = QFont()
                font.setBold(True)
                param_item.setFont(font)
                value_item.setFont(font)
                value_item.setTextAlignment(Qt.AlignmentFlag.AlignRight)
                
            elif row_type == "data":
                # Regular data rows
                param_item.setBackground(QColor(242, 242, 242))  # Light gray
                value_item.setBackground(QColor(255, 255, 255))  # White
                value_item.setTextAlignment(Qt.AlignmentFlag.AlignRight)
                
            elif row_type == "spacer":
                # Empty spacer rows
                param_item.setBackground(QColor(255, 255, 255))
                value_item.setBackground(QColor(255, 255, 255))

            self.results_table.setItem(row_idx, 0, param_item)
            self.results_table.setItem(row_idx, 1, value_item)

        # Resize columns and rows
        self.results_table.resizeColumnsToContents()
        self.results_table.resizeRowsToContents()

                
    def export_to_excel(self):
        """Export calculation results to Excel with two-column format"""
        try:
            self.parent.cursor.execute('''
            SELECT customer_name, job_number, pcb_part_number, unit, pcb_length, pcb_width,
            Layers, material, BoardThickness, CuInner, CuOuter, SurfaceFinish,
            impedance, soldermask, silkscreen, back_drill, blind_via, berried_via,
            per_sq_unit_price, per_unit_price, total_price, calculation_date
            FROM calculation_results ORDER BY calculation_date DESC
            ''')
            
            data = self.parent.cursor.fetchall()
            
            if not data:
                QMessageBox.information(self, "Export", "No calculation data to export.")
                return

            file_path, _ = QFileDialog.getSaveFileName(
                self, "Export to Excel", 
                f"PCB_Calculations_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                "Excel Files (*.xlsx)"
            )
            
            if file_path:
                # Import openpyxl for advanced Excel formatting
                try:
                    import openpyxl
                    from openpyxl.styles import Alignment, Font
                except ImportError:
                    QMessageBox.critical(self, "Export Error", 
                                    "openpyxl library not found. Please install it using: pip install openpyxl")
                    return

                # Create workbook and worksheet
                wb = openpyxl.Workbook()
                ws = wb.active
                ws.title = "PCB Calculations"
                
                # Tool name merged across two columns in first row
                tool_name = "PCB Fabrication Cost Tool"
                ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=2)
                ws.cell(row=1, column=1).value = tool_name
                ws.cell(row=1, column=1).alignment = Alignment(horizontal='center', vertical='center')
                ws.cell(row=1, column=1).font = Font(size=16, bold=True)
                
                # Column headers in row 2
                ws.cell(row=2, column=1).value = "Parameter"
                ws.cell(row=2, column=2).value = "Value"
                ws.cell(row=2, column=1).font = Font(bold=True)
                ws.cell(row=2, column=2).font = Font(bold=True)
                
                # Parameter names corresponding to the data columns
                parameter_names = [
                    'Customer Name', 'Job Number', 'PCB Part Number', 'Unit', 
                    'PCB Length', 'PCB Width', 'Layers', 'Material', 'Board Thickness', 
                    'Cu Inner', 'Cu Outer', 'Surface Finish', 'Impedance', 
                    'Soldermask', 'Silkscreen', 'Back Drill', 'Blind Via', 'Buried Via',
                    'Price per Sq Unit', 'Per Unit Price', 'Total Price', 'Calculation Date'
                ]
                
                # Use the most recent calculation (first record)
                latest_record = data[0]
                
                # Write parameter-value pairs starting from row 3
                for i, (param_name, value) in enumerate(zip(parameter_names, latest_record), 3):
                    ws.cell(row=i, column=1).value = param_name
                    ws.cell(row=i, column=2).value = value
                
                # Adjust column widths
                ws.column_dimensions['A'].width = 25
                ws.column_dimensions['B'].width = 30
                
                # Save the workbook
                wb.save(file_path)
                
                QMessageBox.information(self, "Export Success", 
                                    f"Data exported successfully!\n\nFile saved as:\n{file_path}")
                                    
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export data: {str(e)}")

def main():
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    
    # Set application icon and properties
    app.setApplicationName("PCB Fabrication Cost Tool")
    app.setApplicationVersion("2.0")
    app.setOrganizationName("PCB Tools")
    
    # Create and show main window
    window = PCBFabCostTool()
    window.show()
    
    sys.exit(app.exec())

if __name__ == '__main__':
    main()
