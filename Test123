import sys
from PyQt6.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, 
                             QStackedWidget, QPushButton, QLabel, QLineEdit, 
                             QComboBox, QScrollArea, QFrame, QTextEdit, 
                             QMessageBox, QFileDialog, QGridLayout, QSpacerItem, 
                             QSizePolicy, QGroupBox)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QIntValidator, QDoubleValidator, QFont, QPalette, QColor
import sqlite3
import pandas as pd
from datetime import datetime

class PCBFabCostTool(QWidget):
    def __init__(self):
        super().__init__()
        self.init_database()
        self.init_ui()
        self.apply_styles()
        
    def init_database(self):
        """Initialize SQLite database with required tables"""
        self.conn = sqlite3.connect('pcb_fab_cost.db')
        self.cursor = self.conn.cursor()
        
        # Create PCB data table for data entry
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS pcb_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                fabricator_name TEXT NOT NULL,
                unit TEXT NOT NULL,
                pcb_qty INTEGER NOT NULL,
                pcb_layer INTEGER NOT NULL,
                pcb_length REAL NOT NULL,
                pcb_width REAL NOT NULL,
                material TEXT,
                mask_color TEXT,
                silk_color TEXT,
                copper_inner TEXT,
                copper_outer TEXT,
                back_drill TEXT,
                blind_via TEXT,
                berried_via TEXT,
                total_price REAL NOT NULL,
                created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create calculation results table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS calculation_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                customer_name TEXT,
                job_number TEXT,
                unit TEXT,
                qty INTEGER,
                pcb_length REAL,
                pcb_width REAL,
                fabricator_name TEXT,
                pcb_layer INTEGER,
                material TEXT,
                mask_color TEXT,
                silk_color TEXT,
                copper_inner TEXT,
                copper_outer TEXT,
                back_drill TEXT,
                blind_via TEXT,
                berried_via TEXT,
                per_sq_mm_price REAL,
                per_unit_price REAL,
                total_price REAL,
                calculation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        self.conn.commit()
        
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("PCB Fabrication Cost Tool")
        self.setGeometry(100, 100, 1600, 900)
        
        # Main layout
        main_layout = QVBoxLayout()
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)
        
        # Header section
        header_layout = QVBoxLayout()
        
        
        # Navigation buttons
        nav_layout = QHBoxLayout()
        nav_layout.setSpacing(5)
        
        self.calc_btn = QPushButton("ğŸ“Š Calculation")
        self.data_entry_btn = QPushButton("ğŸ“ Data Entry")
        
        # Make buttons larger and more attractive
        for btn in [self.calc_btn, self.data_entry_btn]:
            btn.setMinimumHeight(50)
            btn.setFont(QFont("Arial", 14, QFont.Weight.Bold))
            btn.setCheckable(True)
        
        nav_layout.addStretch()
        nav_layout.addWidget(self.calc_btn)
        nav_layout.addWidget(self.data_entry_btn)
        nav_layout.addStretch()
        
        header_layout.addLayout(nav_layout)
        main_layout.addLayout(header_layout)
        
        # Connect navigation buttons
        self.calc_btn.clicked.connect(self.show_calculation_page)
        self.data_entry_btn.clicked.connect(self.show_data_entry_page)
        
        # Stacked widget for pages
        self.stacked_widget = QStackedWidget()
        
        # Create pages
        self.calculation_page = CalculationPage(self)
        self.data_entry_page = DataEntryPage(self)
        
        self.stacked_widget.addWidget(self.calculation_page)
        self.stacked_widget.addWidget(self.data_entry_page)
        
        main_layout.addWidget(self.stacked_widget)
        self.setLayout(main_layout)
        
        # Show calculation page by default
        self.show_calculation_page()
        
    def apply_styles(self):
        """Apply custom styles to the application"""
        style = """
            QWidget {
                background-color: #f5f5f5;
                font-family: "Segoe UI", Arial, sans-serif;
            }
            
            QPushButton {
                background-color: #ffffff;
                border: 2px solid #e1e1e1;
                border-radius: 8px;
                padding: 12px 24px;
                font-size: 14px;
                font-weight: bold;
                color: #333333;
            }
            
            QPushButton:hover {
                background-color: #e8f4fd;
                border-color: #0078d4;
            }
            
            QPushButton:checked {
                background-color: #0078d4;
                color: white;
                border-color: #106ebe;
            }
            
            QPushButton:pressed {
                background-color: #106ebe;
            }
            
            QFrame {
                background-color: white;
                border: 1px solid #e1e1e1;
                border-radius: 10px;
                padding: 15px;
            }
            
            QLineEdit {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 13px;
                background-color: white;
            }
            
            QLineEdit:focus {
                border-color: #0078d4;
            }
            
            QComboBox {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 13px;
                background-color: white;
            }
            
            QComboBox:focus {
                border-color: #0078d4;
            }
            
            QTextEdit {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 10px;
                font-size: 12px;
                background-color: white;
            }
            
            QLabel {
                color: #333333;
                font-size: 13px;
                font-weight: 500;
            }
            
            QScrollArea {
                border: 1px solid #e1e1e1;
                border-radius: 6px;
                background-color: white;
            }
            
            QGroupBox {
                font-weight: bold;
                border: 2px solid #e1e1e1;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
                background-color: white;
            }
            
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 10px 0 10px;
                color: #0078d4;
                font-size: 14px;
            }
        """
        self.setStyleSheet(style)
        
    def show_calculation_page(self):
        """Switch to calculation page"""
        self.stacked_widget.setCurrentWidget(self.calculation_page)
        self.calc_btn.setChecked(True)
        self.data_entry_btn.setChecked(False)
        self.calculation_page.refresh_data()
        
    def show_data_entry_page(self):
        """Switch to data entry page"""
        self.stacked_widget.setCurrentWidget(self.data_entry_page)
        self.data_entry_btn.setChecked(True)
        self.calc_btn.setChecked(False)
        self.data_entry_page.refresh_saved_data()

class EditableDataCard(QFrame):
    """Custom data card that emits signal when double-clicked"""
    double_clicked = pyqtSignal(object)
    
    def __init__(self, data):
        super().__init__()
        self.data = data
        self.init_ui()
        
    def init_ui(self):
        """Initialize card UI"""
        self.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        self.setMinimumHeight(140)
        
        # Card styling
        self.setStyleSheet("""
            EditableDataCard {
                background-color: white;
                border: 2px solid #e1e1e1;
                border-radius: 10px;
                margin: 5px;
            }
            EditableDataCard:hover {
                border-color: #0078d4;
                background-color: #f8f9fa;
            }
        """)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 12, 0, 0)
        layout.setSpacing(6)
        
        # Header with fabricator name
        header = QLabel(f"ğŸ­ {self.data[1]}")
        header.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        header.setStyleSheet("color: #0078d4; margin-bottom: 5px;")
        layout.addWidget(header)
        
        # Details
        details = [
            f"ğŸ“‹ Material: {self.data[2]}",
            f"ğŸ”¢ Layers: {self.data[3]} | Qty: {self.data[4]:,}",
            f"ğŸ“ Size: {self.data[6]} Ã— {self.data[7]}",
            f"ğŸ’° Price: ${self.data[5]:,.2f}"
        ]
        
        for detail in details:
            label = QLabel(detail)
            label.setFont(QFont("Arial", 10))
            label.setStyleSheet("color: #666666; margin: 2px 0;")
            layout.addWidget(label)
            
        # Double-click hint
        hint = QLabel("ğŸ’¡ Double-click to edit")
        hint.setFont(QFont("Arial", 8))
        hint.setStyleSheet("color: #999999; font-style: italic;")
        hint.setAlignment(Qt.AlignmentFlag.AlignRight)
        layout.addWidget(hint)
        
    def mouseDoubleClickEvent(self, event):
        """Handle double-click event"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.double_clicked.emit(self.data)

class DataEntryPage(QWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.current_edit_id = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize data entry page UI"""
        layout = QHBoxLayout()
        layout.setSpacing(20)
        
        # Left side - Scrollable Input form (keeping existing code)
        left_frame = QGroupBox("PCB Specification Entry")
        left_frame_layout = QVBoxLayout(left_frame)
        
        # Create scroll area for the input form
        self.input_scroll_area = QScrollArea()
        self.input_scroll_area.setWidgetResizable(True)
        self.input_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.input_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
    
        
        # Create container widget for the form
        input_container = QWidget()
        input_layout = QVBoxLayout(input_container)
        
        # Form layout
        form_layout = QGridLayout()
        form_layout.setSpacing(12)
        
        row = 0
        
        # Basic Information Group
        basic_label = QLabel("Basic Information")
        basic_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        basic_label.setStyleSheet("color: #0078d4; margin: 10px 0 5px 0;")
        form_layout.addWidget(basic_label, row, 0, 1, 2)
        row += 1
        
        # Unit selection
        form_layout.addWidget(QLabel("Unit:"), row, 0)
        self.unit_combo = QComboBox()
        self.unit_combo.addItems(["mm", "inch"])
        form_layout.addWidget(self.unit_combo, row, 1)
        row += 1
        
        # Fabricator name
        form_layout.addWidget(QLabel("Fabricator Name:"), row, 0)
        self.fabricator_input = QLineEdit()
        self.fabricator_input.setPlaceholderText("Enter fabricator name...")
        form_layout.addWidget(self.fabricator_input, row, 1)
        row += 1
        
        # PCB quantity
        form_layout.addWidget(QLabel("PCB Quantity:"), row, 0)
        self.qty_input = QLineEdit()
        self.qty_input.setValidator(QIntValidator(1, 999999))
        self.qty_input.setPlaceholderText("Enter quantity...")
        form_layout.addWidget(self.qty_input, row, 1)
        row += 1
        
        # PCB layer
        form_layout.addWidget(QLabel("PCB Layers:"), row, 0)
        self.layer_combo = QComboBox()
        layers = [str(i) for i in range(1, 41)]
        self.layer_combo.addItems(layers)
        form_layout.addWidget(self.layer_combo, row, 1)
        row += 1

        # PCB Dimensions section
        dimensions_label = QLabel("PCB Dimensions")
        dimensions_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        dimensions_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(dimensions_label, row, 0, 1, 2)
        row += 1

        form_layout.addWidget(QLabel("PCB Size (L Ã— W):"), row, 0)
        size_widget = QWidget()
        size_layout = QHBoxLayout(size_widget)
        size_layout.setContentsMargins(0, 0, 0, 0)
        
        self.length_input = QLineEdit()
        self.length_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.length_input.setPlaceholderText("Length")
        
        self.width_input = QLineEdit()
        self.width_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.width_input.setPlaceholderText("Width")
        
        size_layout.addWidget(QLabel("L:"))
        size_layout.addWidget(self.length_input)
        size_layout.addWidget(QLabel("Ã—"))
        size_layout.addWidget(QLabel("W:"))
        size_layout.addWidget(self.width_input)
        
        form_layout.addWidget(size_widget, row, 1)
        row += 1

        # Material Specifications
        material_label = QLabel("Material Specifications")
        material_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        material_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(material_label, row, 0, 1, 2)
        row += 1
        
        materials = [
            ("Material:", "material_input"),
            ("Mask Color:", "mask_color_input"),
            ("Silk Color:", "silk_color_input"),
            ("Copper Inner:", "copper_inner_input"),
            ("Copper Outer:", "copper_outer_input")
        ]
        
        for label_text, attr_name in materials:
            form_layout.addWidget(QLabel(label_text), row, 0)
            line_edit = QLineEdit()
            line_edit.setPlaceholderText(f"Enter {label_text.lower().rstrip(':')}...")
            setattr(self, attr_name, line_edit)
            form_layout.addWidget(line_edit, row, 1)
            row += 1

        # Special Features
        features_label = QLabel("Special Features")
        features_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        features_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(features_label, row, 0, 1, 2)
        row += 1
        
        features = [
            ("Back Drill:", "back_drill_combo"),
            ("Blind Via:", "blind_via_combo"),
            ("Buried Via:", "berried_via_combo")
        ]
        
        for label_text, attr_name in features:
            form_layout.addWidget(QLabel(label_text), row, 0)
            combo = QComboBox()
            combo.addItems(["No", "Yes"])
            setattr(self, attr_name, combo)
            form_layout.addWidget(combo, row, 1)
            row += 1
        
        # Pricing
        pricing_label = QLabel("Pricing")
        pricing_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        pricing_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(pricing_label, row, 0, 1, 2)
        row += 1
        
        form_layout.addWidget(QLabel("Total Price ($):"), row, 0)
        self.price_input = QLineEdit()
        self.price_input.setValidator(QDoubleValidator(0.01, 999999.99, 2))
        self.price_input.setPlaceholderText("Enter total price...")
        form_layout.addWidget(self.price_input, row, 1)
        
        input_layout.addLayout(form_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        
        self.save_btn = QPushButton("ğŸ’¾ Save Data")
        self.update_btn = QPushButton("ğŸ“ Update Data")
        self.clear_btn = QPushButton("ğŸ—‘ï¸ Clear Form")
        self.delete_btn = QPushButton("âŒ Delete Record")
        
        # Initially hide update and delete buttons
        self.update_btn.hide()
        self.delete_btn.hide()
        
        for btn in [self.save_btn, self.update_btn, self.clear_btn, self.delete_btn]:
            btn.setMinimumHeight(40)
            
        self.save_btn.clicked.connect(self.save_data)
        self.update_btn.clicked.connect(self.update_data)
        self.clear_btn.clicked.connect(self.clear_form)
        self.delete_btn.clicked.connect(self.delete_data)
        
        button_layout.addWidget(self.save_btn)
        button_layout.addWidget(self.update_btn)
        button_layout.addWidget(self.clear_btn)
        button_layout.addWidget(self.delete_btn)
        
        input_layout.addLayout(button_layout)
        
        # Set the container widget to the scroll area
        self.input_scroll_area.setWidget(input_container)
        
        # Add scroll area to the frame layout
        left_frame_layout.addWidget(self.input_scroll_area)
        
            # Right side - Saved data cards
        right_frame = QGroupBox("Saved PCB Data Records")
        right_layout = QVBoxLayout(right_frame)
        
        # Search/Filter section (stays at top, not scrollable)
        search_layout = QHBoxLayout()
        search_label = QLabel("ğŸ” Search:")
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search by fabricator or material...")
        self.search_input.textChanged.connect(self.filter_cards)
        
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.search_input)
        right_layout.addLayout(search_layout)
        
        # ENHANCED Scroll area for cards
        self.cards_scroll_area = QScrollArea()
        self.cards_scroll_area.setWidgetResizable(True)
        self.cards_scroll_area.setMinimumWidth(400)
        self.cards_scroll_area.setMinimumHeight(300)  # Ensure minimum height
        
        # Enhanced scroll bar policies
        self.cards_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.cards_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)
        
        # Enhanced scroll area styling
        self.cards_scroll_area.setStyleSheet("""
            QScrollArea {
                border: 2px solid #e1e1e1;
                border-radius: 8px;
                background-color: #f8f9fa;
            }
            QScrollArea > QWidget > QWidget {
                background-color: #f8f9fa;
            }
            QScrollBar:vertical {
                border: none;
                background-color: #f0f0f0;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #c0c0c0;
                min-height: 20px;
                border-radius: 6px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #0078d4;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        
        # Cards container widget
        self.cards_widget = QWidget()
        self.cards_widget.setStyleSheet("background-color: transparent;")
        
        # Cards layout with improved spacing
        self.cards_layout = QVBoxLayout(self.cards_widget)
        self.cards_layout.setSpacing(10)
        self.cards_layout.setContentsMargins(10, 10, 10, 10)
        
        # Set the cards widget to the scroll area
        self.cards_scroll_area.setWidget(self.cards_widget)
        
        # Add scroll area to right layout
        right_layout.addWidget(self.cards_scroll_area)
        
        # Add record count label at bottom
        self.record_count_label = QLabel("No records")
        self.record_count_label.setStyleSheet("color: #666666; font-size: 11px; padding: 5px;")
        self.record_count_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        right_layout.addWidget(self.record_count_label)
        
        # Add frames to main layout
        layout.addWidget(left_frame, 1)
        layout.addWidget(right_frame, 1)
        self.setLayout(layout)
        
        self.refresh_saved_data()

    def save_data(self):
        """Save PCB data to database"""
        try:
            # Validate required fields
            if not all([
                self.fabricator_input.text().strip(),
                self.qty_input.text(),
                self.length_input.text(),
                self.width_input.text(),
                self.price_input.text()
            ]):
                QMessageBox.warning(self, "Validation Error", 
                                  "Please fill all required fields!")
                return
            
            data = self.get_form_data()
            
            # Insert into database
            self.parent.cursor.execute('''
                INSERT INTO pcb_data (
                    fabricator_name, unit, pcb_qty, pcb_layer, pcb_length, pcb_width,
                    material, mask_color, silk_color, copper_inner, copper_outer,
                    back_drill, blind_via, berried_via, total_price
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', tuple(data.values()))
            
            self.parent.conn.commit()
            QMessageBox.information(self, "Success", "Data saved successfully!")
            self.clear_form()
            self.refresh_saved_data()
            
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save data: {str(e)}")
    
    def update_data(self):
        """Update existing PCB data"""
        try:
            if self.current_edit_id is None:
                return
                
            data = self.get_form_data()
            
            # Update existing record
            self.parent.cursor.execute('''
                UPDATE pcb_data SET
                    fabricator_name = ?, unit = ?, pcb_qty = ?, pcb_layer = ?, 
                    pcb_length = ?, pcb_width = ?, material = ?, mask_color = ?, 
                    silk_color = ?, copper_inner = ?, copper_outer = ?,
                    back_drill = ?, blind_via = ?, berried_via = ?, total_price = ?
                WHERE id = ?
            ''', tuple(data.values()) + (self.current_edit_id,))

            self.parent.conn.commit()
            QMessageBox.information(self, "Success", "Data updated successfully!")
            self.clear_form()
            self.refresh_saved_data()
            
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to update data: {str(e)}")
    
    def get_form_data(self):
        """Get data from form inputs"""
        return {
            'fabricator_name': self.fabricator_input.text().strip(),
            'unit': self.unit_combo.currentText(),
            'pcb_qty': int(self.qty_input.text()),
            'pcb_layer': int(self.layer_combo.currentText()),
            'pcb_length': float(self.length_input.text()),
            'pcb_width': float(self.width_input.text()),
            'material': self.material_input.text().strip(),
            'mask_color': self.mask_color_input.text().strip(),
            'silk_color': self.silk_color_input.text().strip(),
            'copper_inner': self.copper_inner_input.text().strip(),
            'copper_outer': self.copper_outer_input.text().strip(),
            'back_drill': self.back_drill_combo.currentText(),
            'blind_via': self.blind_via_combo.currentText(),
            'berried_via': self.berried_via_combo.currentText(),
            'total_price': float(self.price_input.text())
        }
        
    def clear_form(self):
        """Clear all form inputs and reset editing state"""
        # Clear all inputs
        for widget in [self.fabricator_input, self.qty_input, self.length_input, 
                      self.width_input, self.material_input, self.mask_color_input,
                      self.silk_color_input, self.copper_inner_input, 
                      self.copper_outer_input, self.price_input]:
            widget.clear()
        
        # Reset combos to default
        for combo in [self.unit_combo, self.layer_combo, self.back_drill_combo,
                     self.blind_via_combo, self.berried_via_combo]:
            combo.setCurrentIndex(0)
        
        # Reset editing state
        self.current_edit_id = None
        self.save_btn.show()
        self.update_btn.hide()
        self.delete_btn.hide()

    def refresh_saved_data(self):
        """Refresh the saved data cards"""
        # Clear existing cards
        for i in reversed(range(self.cards_layout.count())):
            child = self.cards_layout.itemAt(i).widget()
            if child:
                child.setParent(None)
                
        # Fetch data from database
        self.parent.cursor.execute('''
            SELECT id, fabricator_name, material, pcb_layer, pcb_qty, total_price, 
                   pcb_length, pcb_width, unit
            FROM pcb_data ORDER BY created_date DESC
        ''')
        
        self.all_data = self.parent.cursor.fetchall()
        self.display_cards(self.all_data)
        
    def display_cards(self, data):
        """Display data cards"""
        # Clear existing cards
        for i in reversed(range(self.cards_layout.count())):
            child = self.cards_layout.itemAt(i).widget()
            if child:
                child.setParent(None)
        
        if not data:
            no_data_label = QLabel("ğŸ“‹ No PCB data records found.")
            no_data_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            no_data_label.setStyleSheet("""
                color: #666666; 
                font-style: italic; 
                font-size: 14px;
                padding: 40px;
                background-color: white;
                border: 2px dashed #e1e1e1;
                border-radius: 10px;
                margin: 20px;
            """)
            self.cards_layout.addWidget(no_data_label)
            self.record_count_label.setText("No records")
        else:
            # Debug: Print the data structure
            print(f"Data count: {len(data)}")
            if data:
                print(f"First record structure: {data[0]}")
                print(f"Record length: {len(data[0])}")
            
            for row in data:
                card = EditableDataCard(row)
                card.double_clicked.connect(self.load_data_in_form)
                self.cards_layout.addWidget(card)
            
            self.record_count_label.setText(f"ğŸ“Š {len(data)} record{'s' if len(data) != 1 else ''}")
        
        self.cards_layout.addStretch()


    def scroll_to_top(self):
        """Scroll the cards area to top"""
        self.cards_scroll_area.verticalScrollBar().setValue(0)

    def scroll_to_card(self, card_id):
        """Scroll to a specific card by ID"""
        for i in range(self.cards_layout.count()):
            widget = self.cards_layout.itemAt(i).widget()
            if isinstance(widget, EditableDataCard) and widget.data[0] == card_id:
                # Calculate position and scroll to it
                card_pos = widget.pos().y()
                self.cards_scroll_area.verticalScrollBar().setValue(card_pos)
                break


    def filter_cards(self):
        """Filter cards based on search input"""
        search_text = self.search_input.text().lower()
        
        if not search_text:
            filtered_data = self.all_data
        else:
            filtered_data = [
                row for row in self.all_data
                if search_text in row[1].lower() or search_text in row[2].lower()
            ]
        
        self.display_cards(filtered_data)

    def load_data_in_form(self, data):
        """Load card data into input fields for editing"""
        self.current_edit_id = data[0]
        
        # Query full record from database
        self.parent.cursor.execute("SELECT * FROM pcb_data WHERE id=?", (self.current_edit_id,))
        record = self.parent.cursor.fetchone()
        
        if not record:
            QMessageBox.warning(self, "Load Error", "Failed to load the selected record.")
            return

        # Unpack record data
        (_, fabricator_name, unit, pcb_qty, pcb_layer, pcb_length, pcb_width, 
         material, mask_color, silk_color, copper_inner, copper_outer, 
         back_drill, blind_via, berried_via, total_price, _) = record

        # Populate form fields
        self.fabricator_input.setText(fabricator_name or "")
        self.unit_combo.setCurrentText(unit)
        self.qty_input.setText(str(pcb_qty))
        self.layer_combo.setCurrentText(str(pcb_layer))
        self.length_input.setText(str(pcb_length))
        self.width_input.setText(str(pcb_width))
        self.material_input.setText(material or "")
        self.mask_color_input.setText(mask_color or "")
        self.silk_color_input.setText(silk_color or "")
        self.copper_inner_input.setText(copper_inner or "")
        self.copper_outer_input.setText(copper_outer or "")
        self.back_drill_combo.setCurrentText(back_drill)
        self.blind_via_combo.setCurrentText(blind_via)
        self.berried_via_combo.setCurrentText(berried_via)  # Correct variable name
        self.price_input.setText(str(total_price))

        # Switch to edit mode
        self.save_btn.hide()
        self.update_btn.show()
        self.delete_btn.show()

    def delete_data(self):
        """Delete selected record from database"""
        if self.current_edit_id is None:
            return

        reply = QMessageBox.question(
            self, "Confirm Delete",
            "Are you sure you want to delete this PCB record?\n\nThis action cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            try:
                self.parent.cursor.execute("DELETE FROM pcb_data WHERE id=?", (self.current_edit_id,))
                self.parent.conn.commit()
                QMessageBox.information(self, "Deleted", "Record deleted successfully!")
                self.clear_form()
                self.refresh_saved_data()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to delete record: {str(e)}")

class CalculationPage(QWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.init_ui()
        
    def init_ui(self):
        """Initialize calculation page UI"""
        layout = QHBoxLayout()
        layout.setSpacing(20)
        
        # Left side - Scrollable Input form
        left_frame = QGroupBox("Price Calculation Input")
        left_frame_layout = QVBoxLayout(left_frame)
        
        # Create scroll area for the input form
        self.input_scroll_area = QScrollArea()
        self.input_scroll_area.setWidgetResizable(True)
        self.input_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.input_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # Create container widget for the form
        input_container = QWidget()
        input_layout = QVBoxLayout(input_container)
        
        form_layout = QGridLayout()
        form_layout.setSpacing(12)
        row = 0

        # Customer Information
        customer_label = QLabel("Customer Information")
        customer_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        customer_label.setStyleSheet("color: #0078d4; margin: 10px 0 5px 0;")
        form_layout.addWidget(customer_label, row, 0, 1, 2)
        row += 1

        form_layout.addWidget(QLabel("Customer Name:"), row, 0)
        self.customer_input = QLineEdit()
        self.customer_input.setPlaceholderText("Enter customer name...")
        form_layout.addWidget(self.customer_input, row, 1)
        row += 1

        form_layout.addWidget(QLabel("Job Number:"), row, 0)
        self.job_input = QLineEdit()
        self.job_input.setPlaceholderText("Enter job number...")
        form_layout.addWidget(self.job_input, row, 1)
        row += 1

        # PCB Specifications
        pcb_label = QLabel("PCB Specifications")
        pcb_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        pcb_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(pcb_label, row, 0, 1, 2)
        row += 1

        form_layout.addWidget(QLabel("Unit:"), row, 0)
        self.unit_combo = QComboBox()
        self.unit_combo.addItems(["mm", "inch"])
        form_layout.addWidget(self.unit_combo, row, 1)
        row += 1

        form_layout.addWidget(QLabel("Quantity:"), row, 0)
        self.qty_input = QLineEdit()
        self.qty_input.setValidator(QIntValidator(1, 999999))
        self.qty_input.setPlaceholderText("Enter quantity...")
        form_layout.addWidget(self.qty_input, row, 1)
        row += 1

        # PCB Size with improved layout
        form_layout.addWidget(QLabel("PCB Size (L Ã— W):"), row, 0)
        size_widget = QWidget()
        size_layout = QHBoxLayout(size_widget)
        size_layout.setContentsMargins(0, 0, 0, 0)
        
        self.length_input = QLineEdit()
        self.length_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.length_input.setPlaceholderText("Length")
        
        self.width_input = QLineEdit()
        self.width_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.width_input.setPlaceholderText("Width")
        
        size_layout.addWidget(QLabel("L:"))
        size_layout.addWidget(self.length_input)
        size_layout.addWidget(QLabel("Ã—"))
        size_layout.addWidget(QLabel("W:"))
        size_layout.addWidget(self.width_input)
        
        form_layout.addWidget(size_widget, row, 1)
        row += 1

        # Database Filters
        filter_label = QLabel("Database Filters")
        filter_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        filter_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(filter_label, row, 0, 1, 2)
        row += 1

        # Create filter combos
        filters = [
            ("Fabricator:", "fabricator"),
            ("PCB Layer:", "pcb_layer"), 
            ("Material:", "material"),
            ("Mask Color:", "mask_color"),
            ("Silk Color:", "silk_color"),
            ("Copper Inner:", "copper_inner"),
            ("Copper Outer:", "copper_outer"),
            ("Back Drill:", "back_drill"),
            ("Blind Via:", "blind_via"),
            ("Buried Via:", "berried_via")
        ]
        
        self.filter_combos = {}
        for label_text, key in filters:
            form_layout.addWidget(QLabel(label_text), row, 0)
            combo = QComboBox()
            combo.setMinimumWidth(200)
            self.filter_combos[key] = combo
            form_layout.addWidget(combo, row, 1)
            row += 1

        self.filter_combos["fabricator"].currentTextChanged.connect(self.update_filters)
        
        input_layout.addLayout(form_layout)
        
        # Calculate button
        self.calculate_btn = QPushButton("ğŸ§® Calculate Price")
        self.calculate_btn.setMinimumHeight(50)
        self.calculate_btn.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        self.calculate_btn.clicked.connect(self.calculate_price)
        input_layout.addWidget(self.calculate_btn)
        
        # Set the container widget to the scroll area
        self.input_scroll_area.setWidget(input_container)
        
        # Add scroll area to the frame layout
        left_frame_layout.addWidget(self.input_scroll_area)
        
        # Right side - Results
        right_frame = QGroupBox("Calculation Results")
        right_layout = QVBoxLayout(right_frame)
        
        self.results_text = QTextEdit()
        self.results_text.setReadOnly(True)
        self.results_text.setFont(QFont("Consolas", 11))
        right_layout.addWidget(self.results_text)
        
        # Export button
        self.export_btn = QPushButton("ğŸ“Š Export to Excel")
        self.export_btn.setMinimumHeight(45)
        self.export_btn.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        self.export_btn.clicked.connect(self.export_to_excel)
        right_layout.addWidget(self.export_btn)
        
        # Add frames to main layout
        layout.addWidget(left_frame, 1)
        layout.addWidget(right_frame, 1)
        self.setLayout(layout)
        
    def refresh_data(self):
        """Refresh dropdown data from database"""
        # Get unique fabricators
        self.parent.cursor.execute("SELECT DISTINCT fabricator_name FROM pcb_data ORDER BY fabricator_name")
        fabricators = [row[0] for row in self.parent.cursor.fetchall()]
        
        self.filter_combos["fabricator"].clear()
        if fabricators:
            self.filter_combos["fabricator"].addItems(fabricators)
            self.update_filters()

    def update_filters(self):
        """Update filter dropdowns based on selected fabricator"""
        fabricator = self.filter_combos["fabricator"].currentText()
        if not fabricator:
            return
            
        # Get data for selected fabricator
        self.parent.cursor.execute('''
            SELECT DISTINCT pcb_layer, material, mask_color, silk_color, 
                   copper_inner, copper_outer, back_drill, blind_via, berried_via
            FROM pcb_data WHERE fabricator_name = ?
            ORDER BY pcb_layer
        ''', (fabricator,))
        
        data = self.parent.cursor.fetchall()
        
        if not data:
            return
            
        # Update each dropdown
        fields = ["pcb_layer", "material", "mask_color", "silk_color", 
                 "copper_inner", "copper_outer", "back_drill", "blind_via", "berried_via"]
        
        for i, field in enumerate(fields):
            combo = self.filter_combos[field]
            combo.blockSignals(True)
            combo.clear()
            unique_values = sorted(set(str(row[i]) for row in data if row[i]))
            combo.addItems(unique_values)
            combo.blockSignals(False)

    def calculate_price(self):
        """Calculate PCB price based on database data"""
        try:
            # Validate inputs
            if not all([
                self.customer_input.text().strip(),
                self.job_input.text().strip(),
                self.qty_input.text(),
                self.length_input.text(),
                self.width_input.text(),
                self.filter_combos["fabricator"].currentText()
            ]):
                QMessageBox.warning(self, "Input Error", 
                                  "Please fill all required fields!")
                return
                
            # Get input values
            customer_name = self.customer_input.text().strip()
            job_number = self.job_input.text().strip()
            unit = self.unit_combo.currentText()
            qty = int(self.qty_input.text())
            length = float(self.length_input.text())
            width = float(self.width_input.text())
            
            # Search for matching records
            query = '''
                SELECT pcb_qty, pcb_length, pcb_width, total_price
                FROM pcb_data 
                WHERE fabricator_name = ? AND pcb_layer = ? AND material = ? 
                  AND mask_color = ? AND silk_color = ? AND copper_inner = ? 
                  AND copper_outer = ? AND back_drill = ? AND blind_via = ? 
                  AND berried_via = ? AND pcb_qty >= ?
                ORDER BY total_price DESC
            '''
            
            params = (
                self.filter_combos["fabricator"].currentText(),
                int(self.filter_combos["pcb_layer"].currentText()) if self.filter_combos["pcb_layer"].currentText() else 0,
                self.filter_combos["material"].currentText(),
                self.filter_combos["mask_color"].currentText(),
                self.filter_combos["silk_color"].currentText(),
                self.filter_combos["copper_inner"].currentText(),
                self.filter_combos["copper_outer"].currentText(),
                self.filter_combos["back_drill"].currentText(),
                self.filter_combos["blind_via"].currentText(),
                self.filter_combos["berried_via"].currentText(),
                qty
            )
            
            self.parent.cursor.execute(query, params)
            matches = self.parent.cursor.fetchall()
            
            if not matches:
                QMessageBox.information(self, "No Match", 
                                      "No matching records found for the specified criteria and quantity.")
                return
                
            # Use the record with maximum price
            best_match = matches[0]
            ref_qty, ref_length, ref_width, ref_price = best_match
            
            # Calculate price per square unit
            ref_area = ref_length * ref_width
            price_per_sq_unit = ref_price / ref_area if ref_area > 0 else 0
            
            # Calculate prices for input PCB
            input_area = length * width
            per_unit_price = price_per_sq_unit * input_area
            total_price = per_unit_price * qty
            
            # Display enhanced results
            results = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    CALCULATION RESULTS                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ CUSTOMER INFORMATION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Customer Name: {customer_name}
â€¢ Job Number: {job_number}
â€¢ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

ğŸ”§ PCB SPECIFICATIONS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Unit: {unit}
â€¢ Quantity: {qty:,} pieces
â€¢ Dimensions: {length} Ã— {width} {unit}
â€¢ Area per PCB: {input_area:.2f} {unit}Â²
â€¢ Total Area: {input_area * qty:.2f} {unit}Â²

âš™ï¸ SELECTED CONFIGURATION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Fabricator: {self.filter_combos["fabricator"].currentText()}
â€¢ Layers: {self.filter_combos["pcb_layer"].currentText()}
â€¢ Material: {self.filter_combos["material"].currentText()}
â€¢ Mask Color: {self.filter_combos["mask_color"].currentText()}
â€¢ Silk Color: {self.filter_combos["silk_color"].currentText()}
â€¢ Copper Inner: {self.filter_combos["copper_inner"].currentText()}
â€¢ Copper Outer: {self.filter_combos["copper_outer"].currentText()}
â€¢ Back Drill: {self.filter_combos["back_drill"].currentText()}
â€¢ Blind Via: {self.filter_combos["blind_via"].currentText()}
â€¢ Buried Via: {self.filter_combos["berried_via"].currentText()}

ğŸ’° PRICE CALCULATION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Reference PCB: {ref_length} Ã— {ref_width} {unit} @ ${ref_price:.2f} for {ref_qty:,} pcs
â€¢ Price per {unit}Â²: ${price_per_sq_unit:.4f}
â€¢ Price per PCB: ${per_unit_price:.2f}
â€¢ Total Price for {qty:,} pieces: ${total_price:.2f}

ğŸ“Š COST BREAKDOWN
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Unit Cost: ${per_unit_price:.2f} per piece
â€¢ Total Cost: ${total_price:.2f}
â€¢ Cost per {unit}Â²: ${price_per_sq_unit:.4f}
            """
            
            self.results_text.setPlainText(results.strip())
            
            # Save calculation to database
            self.parent.cursor.execute('''
                INSERT INTO calculation_results (
                    customer_name, job_number, unit, qty, pcb_length, pcb_width,
                    fabricator_name, pcb_layer, material, mask_color, silk_color,
                    copper_inner, copper_outer, back_drill, blind_via, berried_via,
                    per_sq_mm_price, per_unit_price, total_price
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                customer_name, job_number, unit, qty, length, width,
                self.filter_combos["fabricator"].currentText(),
                int(self.filter_combos["pcb_layer"].currentText()) if self.filter_combos["pcb_layer"].currentText() else 0,
                self.filter_combos["material"].currentText(), self.filter_combos["mask_color"].currentText(),
                self.filter_combos["silk_color"].currentText(), self.filter_combos["copper_inner"].currentText(),
                self.filter_combos["copper_outer"].currentText(), self.filter_combos["back_drill"].currentText(),
                self.filter_combos["blind_via"].currentText(), self.filter_combos["berried_via"].currentText(),
                price_per_sq_unit, per_unit_price, total_price
            ))
            
            self.parent.conn.commit()
            
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Calculation failed: {str(e)}")

    def export_to_excel(self):
        """Export calculation results to Excel"""
        try:
            # Get all calculation results
            self.parent.cursor.execute('''
                SELECT customer_name, job_number, unit, qty, pcb_length, pcb_width,
                       fabricator_name, pcb_layer, material, mask_color, silk_color,
                       copper_inner, copper_outer, back_drill, blind_via, berried_via,
                       per_sq_mm_price, per_unit_price, total_price, calculation_date
                FROM calculation_results ORDER BY calculation_date DESC
            ''')
            
            data = self.parent.cursor.fetchall()
            
            if not data:
                QMessageBox.information(self, "Export", "No calculation data to export.")
                return
                
            # Create DataFrame
            columns = [
                'Customer Name', 'Job Number', 'Unit', 'Qty', 'PCB Length', 'PCB Width',
                'Fabricator', 'PCB Layer', 'Material', 'Mask Color', 'Silk Color',
                'Copper Inner', 'Copper Outer', 'Back Drill', 'Blind Via', 'Buried Via',
                'Price per Sq Unit', 'Per Unit Price', 'Total Price', 'Calculation Date'
            ]
            
            df = pd.DataFrame(data, columns=columns)
            
            # Get save location
            file_path, _ = QFileDialog.getSaveFileName(
                self, "Export to Excel", 
                f"PCB_Calculations_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                "Excel Files (*.xlsx)"
            )
            
            if file_path:
                df.to_excel(file_path, index=False, engine='openpyxl')
                QMessageBox.information(self, "Export Success", 
                                      f"Data exported successfully!\n\nFile saved as:\n{file_path}")
                
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export data: {str(e)}")


def main():
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    
    # Set application icon and properties
    app.setApplicationName("PCB Fabrication Cost Tool")
    app.setApplicationVersion("2.0")
    app.setOrganizationName("PCB Tools")
    
    # Create and show main window
    window = PCBFabCostTool()
    window.show()
    
    sys.exit(app.exec())

if __name__ == '__main__':
    main()
