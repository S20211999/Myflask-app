
import sys
import json
from html import unescape
import pandas as pd
from collections import defaultdict
from selenium import webdriver
from selenium.webdriver.common.by import By
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QPushButton, QVBoxLayout,
    QWidget, QFileDialog, QTableWidget, QTableWidgetItem, QLabel
)

# Constants
INR_TO_USD = 85.85
VALID_DISTRIBUTORS = [
    "DigiKey", "Mouser Electronics", "Arrow Electronics",
    "element14 Asia-Pacific"
]


class BOMPriceChecker(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BOM Price Checker - Specific Distributors")
        self.setGeometry(100, 100, 1200, 600)

        self.layout = QVBoxLayout()
        self.load_button = QPushButton("Load BOM Excel")
        self.load_button.clicked.connect(self.load_bom)
        self.layout.addWidget(self.load_button)

        self.status_label = QLabel("")
        self.layout.addWidget(self.status_label)

        self.table = QTableWidget()
        self.layout.addWidget(self.table)

        container = QWidget()
        container.setLayout(self.layout)
        self.setCentralWidget(container)

    def load_bom(self):
        file_name, _ = QFileDialog.getOpenFileName(self, "Open BOM Excel", "", "Excel Files (*.xlsx *.xls)")
        if file_name:
            df = pd.read_excel(file_name)
            if 'Part Number' not in df.columns:
                self.status_label.setText("‚ùå 'Part Number' column not found.")
                return

            part_numbers = df['Part Number'].dropna().unique()
            self.status_label.setText(f"üîç Processing {len(part_numbers)} parts...")
            QApplication.processEvents()
            raw_data = self.scrape_findchips_prices(part_numbers)
            self.populate_table(raw_data)

    def scrape_findchips_prices(self, part_numbers):
        options = webdriver.ChromeOptions()
        options.add_argument("--headless")
        options.add_argument("--disable-gpu")
        options.add_argument("--no-sandbox")
        options.add_argument("--log-level=3")
        driver = webdriver.Chrome(options=options)

        all_distributors = VALID_DISTRIBUTORS + ["Manufacturer"]
        result_dict = {}

        for part in part_numbers:
            driver.get(f"https://www.findchips.com/search/{part}")
            driver.implicitly_wait(3)
            rows = driver.find_elements(By.CSS_SELECTOR, "tr.row")
            dist_prices = {}

            manufacturer_name = None
            manu_price = None

            for row in rows:
                pn = row.get_attribute("data-mfrpartnumber")
                if pn != part:
                    continue

                distributor = row.get_attribute("data-distributor_name") or "N/A"
                manufacturer_name = row.get_attribute("data-mfr") or "N/A"

                raw_price = row.get_attribute("data-price")
                if not raw_price:
                    continue

                try:
                    raw_price = unescape(raw_price)
                    price_list = json.loads(raw_price)
                    numeric_prices = []
                    for _, currency, price in price_list:
                        price = float(price.replace(",", ""))
                        if currency == "INR":
                            price /= INR_TO_USD
                        numeric_prices.append(price)

                    if numeric_prices:
                        min_price = round(min(numeric_prices), 4)
                        max_price = round(max(numeric_prices), 4)

                        # Store by exact distributor match
                        if distributor in VALID_DISTRIBUTORS:
                            dist_prices[distributor] = (min_price, max_price)

                        # Manufacturer price match logic
                        if distributor.lower() == (manufacturer_name or "").lower():
                            manu_price = (min_price, max_price)
                except:
                    continue

            if manu_price:
                dist_prices["Manufacturer"] = manu_price

            result_dict[part] = dist_prices

        driver.quit()
        return {
            "data": result_dict,
            "distributors": all_distributors
        }

    def populate_table(self, result):
        data = result["data"]
        distributors = result["distributors"]

        headers = ["Part Number"]
        for dist in distributors:
            headers.append(f"{dist} Min")
            headers.append(f"{dist} Max")

        self.table.setRowCount(len(data))
        self.table.setColumnCount(len(headers))
        self.table.setHorizontalHeaderLabels(headers)

        for row_idx, (part, dist_data) in enumerate(data.items()):
            self.table.setItem(row_idx, 0, QTableWidgetItem(part))
            col_idx = 1
            for dist in distributors:
                if dist in dist_data:
                    min_p, max_p = dist_data[dist]
                    self.table.setItem(row_idx, col_idx, QTableWidgetItem(f"{min_p:.4f}"))
                    self.table.setItem(row_idx, col_idx + 1, QTableWidgetItem(f"{max_p:.4f}"))
                else:
                    self.table.setItem(row_idx, col_idx, QTableWidgetItem("‚Äî"))
                    self.table.setItem(row_idx, col_idx + 1, QTableWidgetItem("‚Äî"))
                col_idx += 2

        self.status_label.setText(f"‚úÖ Loaded {len(data)} parts across {len(distributors)} sources.")


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = BOMPriceChecker()
    window.show()
    sys.exit(app.exec())
