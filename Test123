import sys
from PyQt6.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, 
                             QStackedWidget, QPushButton, QLabel, QLineEdit, 
                             QComboBox, QScrollArea, QFrame, QTextEdit, 
                             QMessageBox, QFileDialog, QGridLayout, QSpacerItem, 
                             QSizePolicy, QGroupBox, QTableWidget, QTableWidgetItem, QHeaderView)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QIntValidator, QDoubleValidator, QFont, QPalette, QColor
import sqlite3
import pandas as pd
from datetime import datetime

class PCBFabCostTool(QWidget):
    def __init__(self):
        super().__init__()
        self.init_database()
        self.init_ui()
        self.apply_styles()
            
    def init_database(self):
        """Initialize SQLite database with updated tables"""
        self.conn = sqlite3.connect('pcb_fab_cost.db')
        self.cursor = self.conn.cursor()
        
        # Create updated PCB data table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS pcb_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                fabricator_name TEXT NOT NULL,  -- Add this if missing
                pcb_part_number TEXT NOT NULL,
                quantity INTEGER NOT NULL,
                layers INTEGER NOT NULL,
                pcb_spec TEXT,
                material TEXT,
                length REAL NOT NULL,
                width REAL NOT NULL,
                array_size TEXT,
                board_thickness REAL,
                cu_inner TEXT,
                cu_outer TEXT,
                surface_finish TEXT,
                selective_plating TEXT,
                drills TEXT,
                impedance TEXT,
                soldermask TEXT,
                silkscreen TEXT,
                back_drill TEXT,
                blind_via TEXT,
                berried_via TEXT,
                via_type TEXT,
                via_fill TEXT,
                beveling TEXT,
                edge_plating TEXT,
                price_per_unit REAL NOT NULL,
                engg_cost REAL,
                total_cost_inr REAL NOT NULL,
                lead_time TEXT,
                created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        

        
        # Create updated calculation results table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS calculation_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                customer_name TEXT,
                job_number TEXT,
                pcb_part_number TEXT,
                unit TEXT,
                pcb_length REAL,
                pcb_width REAL,
                layers INTEGER,
                material TEXT,
                board_thickness REAL,
                cu_inner TEXT,
                cu_outer TEXT,
                surface_finish TEXT,
                impedance TEXT,
                soldermask TEXT,
                silkscreen TEXT,
                back_drill TEXT,
                blind_via TEXT,
                berried_via TEXT,
                per_sq_unit_price REAL,
                per_unit_price REAL,
                total_price REAL,
                calculation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        self.conn.commit()
        
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("PCB Fabrication Cost Tool")
        self.setGeometry(100, 100, 1600, 900)
        
        # Main layout
        main_layout = QVBoxLayout()
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)
        
        # Header section
        header_layout = QVBoxLayout()
        
        
        # Navigation buttons
        nav_layout = QHBoxLayout()
        nav_layout.setSpacing(5)
        
        self.calc_btn = QPushButton("üìä Calculation")
        self.data_entry_btn = QPushButton("üìù Data Entry")
        
        # Make buttons larger and more attractive
        for btn in [self.calc_btn, self.data_entry_btn]:
            btn.setMinimumHeight(50)
            btn.setFont(QFont("Arial", 14, QFont.Weight.Bold))
            btn.setCheckable(True)
        
        nav_layout.addStretch()
        nav_layout.addWidget(self.calc_btn)
        nav_layout.addWidget(self.data_entry_btn)
        nav_layout.addStretch()
        
        header_layout.addLayout(nav_layout)
        main_layout.addLayout(header_layout)
        
        # Connect navigation buttons
        self.calc_btn.clicked.connect(self.show_calculation_page)
        self.data_entry_btn.clicked.connect(self.show_data_entry_page)
        
        # Stacked widget for pages
        self.stacked_widget = QStackedWidget()
        
        # Create pages
        self.calculation_page = CalculationPage(self)
        self.data_entry_page = DataEntryPage(self)
        
        self.stacked_widget.addWidget(self.calculation_page)
        self.stacked_widget.addWidget(self.data_entry_page)
        
        main_layout.addWidget(self.stacked_widget)
        self.setLayout(main_layout)
        
        # Show calculation page by default
        self.show_calculation_page()
        
    def apply_styles(self):
        """Apply custom styles to the application"""
        style = """
            QWidget {
                background-color: #f5f5f5;
                font-family: "Segoe UI", Arial, sans-serif;
            }
            
            QPushButton {
                background-color: #ffffff;
                border: 2px solid #e1e1e1;
                border-radius: 8px;
                padding: 12px 24px;
                font-size: 14px;
                font-weight: bold;
                color: #333333;
            }
            
            QPushButton:hover {
                background-color: #e8f4fd;
                border-color: #0078d4;
            }
            
            QPushButton:checked {
                background-color: #0078d4;
                color: white;
                border-color: #106ebe;
            }
            
            QPushButton:pressed {
                background-color: #106ebe;
            }
            
            QFrame {
                background-color: white;
                border: 1px solid #e1e1e1;
                border-radius: 10px;
                padding: 15px;
            }
            
            QLineEdit {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 13px;
                background-color: white;
            }
            
            QLineEdit:focus {
                border-color: #0078d4;
            }
            
            QComboBox {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 13px;
                color: black;
                background-color: white;
            }
            
            QComboBox:focus {
                border-color: #0078d4;
                color: black;
            }
            
            QTextEdit {
                border: 2px solid #e1e1e1;
                border-radius: 6px;
                padding: 10px;
                font-size: 12px;
                background-color: white;
            }
            
            QLabel {
                color: #333333;
                font-size: 13px;
                font-weight: 500;
            }
            
            QScrollArea {
                border: 1px solid #e1e1e1;
                border-radius: 6px;
                background-color: white;
            }
            
            QGroupBox {
                font-weight: bold;
                border: 2px solid #e1e1e1;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
                background-color: white;
            }
            
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 10px 0 10px;
                color: #0078d4;
                font-size: 14px;
            }
        """
        self.setStyleSheet(style)
        
    def show_calculation_page(self):
        """Switch to calculation page"""
        self.stacked_widget.setCurrentWidget(self.calculation_page)
        self.calc_btn.setChecked(True)
        self.data_entry_btn.setChecked(False)
        self.calculation_page.refresh_data()
        
    def show_data_entry_page(self):
        """Switch to data entry page"""
        self.stacked_widget.setCurrentWidget(self.data_entry_page)
        self.data_entry_btn.setChecked(True)
        self.calc_btn.setChecked(False)
        self.data_entry_page.refresh_saved_data()

class EditableDataCard(QFrame):
    """Updated data card for new PCB data structure"""
    double_clicked = pyqtSignal(object)
    
    def __init__(self, data):
        super().__init__()
        self.data = data
        self.init_ui()
        
    def init_ui(self):
        """Initialize card UI with new data structure"""
        self.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        self.setMaximumHeight(160)
        self.setMinimumHeight(160)
        
        # Card styling
        self.setStyleSheet("""
            UpdatedEditableDataCard {
                background-color: white;
                border: 2px solid #e1e1e1;
                border-radius: 10px;
                margin: 5px;
            }
            UpdatedEditableDataCard:hover {
                border-color: #0078d4;
                background-color: #f8f9fa;
            }
            QLabel {
                color: #333333;
                background-color: transparent;
            }
        """)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(4)
        
        if len(self.data) < 6:
            error_label = QLabel("‚ùå Invalid data format")
            layout.addWidget(error_label)
            return
        
        # Header with PCB part number
        header = QLabel(f"üîß {self.data[1]}")  # pcb_part_number
        header.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        header.setStyleSheet("color: #0078d4; margin-bottom: 3px;")
        layout.addWidget(header)
        
        # Details
        try:
            details = [
                f"üìã Material: {self.data[2] if self.data[2] else 'N/A'}",  # material
                f"üî¢ Layers: {self.data[3]} | Qty: {self.data[4]:,}",  # layers, quantity
                f"üìè Size: {self.data[6]} √ó {self.data[7]}",  # length, width
                f"üí∞ Cost: ‚Çπ{self.data[5]:,.2f}",  # total_cost_inr
                f"‚è±Ô∏è Lead Time: {self.data[8] if self.data[8] else 'N/A'}"  # lead_time
            ]
            
            for detail in details:
                label = QLabel(detail)
                label.setFont(QFont("Arial", 9))
                label.setStyleSheet("color: #666666; margin: 1px 0;")
                layout.addWidget(label)
                
        except Exception as e:
            error_label = QLabel(f"‚ùå Error: {str(e)}")
            layout.addWidget(error_label)
            
        # Double-click hint
        hint = QLabel("üí° Double-click to edit")
        hint.setFont(QFont("Arial", 8))
        hint.setStyleSheet("color: #999999; font-style: italic;")
        hint.setAlignment(Qt.AlignmentFlag.AlignRight)
        layout.addWidget(hint)
        
    def mouseDoubleClickEvent(self, event):
        """Handle double-click event"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.double_clicked.emit(self.data)

class DataEntryPage(QWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.current_edit_id = None
        self.init_ui()
        
    def init_ui(self):
        """Initialize data entry page UI with new fields"""
        layout = QHBoxLayout()
        layout.setSpacing(20)
        
        # Left side - Scrollable Input form
        left_frame = QGroupBox("PCB Specification Entry")
        left_frame_layout = QVBoxLayout(left_frame)
        
        # Create scroll area for the input form
        self.input_scroll_area = QScrollArea()
        self.input_scroll_area.setWidgetResizable(True)
        self.input_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.input_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # Create container widget for the form
        input_container = QWidget()
        input_layout = QVBoxLayout(input_container)
        
        # Form layout
        form_layout = QGridLayout()
        form_layout.setSpacing(12)
        
        row = 0
        
        # Basic Information Group
        basic_label = QLabel("Basic Information")
        basic_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        basic_label.setStyleSheet("color: #0078d4; margin: 10px 0 5px 0;")
        form_layout.addWidget(basic_label, row, 0, 1, 2)
        row += 1
        
        
        # PCB Part Number
        form_layout.addWidget(QLabel("PCB Part Number:"), row, 0)
        self.pcb_part_number_input = QLineEdit()
        self.pcb_part_number_input.setPlaceholderText("Enter PCB part number...")
        form_layout.addWidget(self.pcb_part_number_input, row, 1)
        row += 1
        
        # Quantity
        form_layout.addWidget(QLabel("Quantity:"), row, 0)
        self.quantity_input = QLineEdit()
        self.quantity_input.setValidator(QIntValidator(1, 999999))
        self.quantity_input.setPlaceholderText("Enter quantity...")
        form_layout.addWidget(self.quantity_input, row, 1)
        row += 1
        
        # Layers
        form_layout.addWidget(QLabel("Layers:"), row, 0)
        self.layers_combo = QComboBox()
        layers = [str(i) for i in range(1, 41)]
        self.layers_combo.addItems(layers)
        form_layout.addWidget(self.layers_combo, row, 1)
        row += 1
        
        # PCB Spec
        form_layout.addWidget(QLabel("PCB Spec:"), row, 0)
        self.pcb_spec_combo = QComboBox()
        self.pcb_spec_combo.addItems(["Class 2", "Class 3", "Mil Grade"])
        form_layout.addWidget(self.pcb_spec_combo, row, 1)
        row += 1
        
        # Materialupdate_data
        form_layout.addWidget(QLabel("Material:"), row, 0)
        self.material_input = QLineEdit()
        self.material_input.setPlaceholderText("Enter material...")
        form_layout.addWidget(self.material_input, row, 1)
        row += 1

        # PCB Dimensions section
        dimensions_label = QLabel("PCB Dimensions")
        dimensions_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        dimensions_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(dimensions_label, row, 0, 1, 2)
        row += 1

        # Length
        form_layout.addWidget(QLabel("Length:"), row, 0)
        self.length_input = QLineEdit()
        self.length_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.length_input.setPlaceholderText("Enter length...")
        form_layout.addWidget(self.length_input, row, 1)
        row += 1
        
        # Width
        form_layout.addWidget(QLabel("Width:"), row, 0)
        self.width_input = QLineEdit()
        self.width_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.width_input.setPlaceholderText("Enter width...")
        form_layout.addWidget(self.width_input, row, 1)
        row += 1
        
        # Array Size
        form_layout.addWidget(QLabel("Array Size:"), row, 0)
        self.array_size_input = QLineEdit()
        self.array_size_input.setPlaceholderText("Enter array size...")
        form_layout.addWidget(self.array_size_input, row, 1)
        row += 1
        
        # Board Thickness
        form_layout.addWidget(QLabel("Board Thickness:"), row, 0)
        self.board_thickness_input = QLineEdit()
        self.board_thickness_input.setValidator(QDoubleValidator(0.1, 10.0, 2))
        self.board_thickness_input.setPlaceholderText("Enter board thickness...")
        form_layout.addWidget(self.board_thickness_input, row, 1)
        row += 1

        # Material Specifications
        material_label = QLabel("Material Specifications")
        material_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        material_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(material_label, row, 0, 1, 2)
        row += 1
        
        # Cu Inner
        form_layout.addWidget(QLabel("Cu Inner:"), row, 0)
        self.cu_inner_input = QLineEdit()
        self.cu_inner_input.setPlaceholderText("Enter Cu inner...")
        form_layout.addWidget(self.cu_inner_input, row, 1)
        row += 1
        
        # Cu Outer
        form_layout.addWidget(QLabel("Cu Outer:"), row, 0)
        self.cu_outer_input = QLineEdit()
        self.cu_outer_input.setPlaceholderText("Enter Cu outer...")
        form_layout.addWidget(self.cu_outer_input, row, 1)
        row += 1
        
        # Surface Finish
        form_layout.addWidget(QLabel("Surface Finish:"), row, 0)
        self.surface_finish_input = QLineEdit()
        self.surface_finish_input.setPlaceholderText("Enter surface finish...")
        form_layout.addWidget(self.surface_finish_input, row, 1)
        row += 1
        
        # Selective Plating
        form_layout.addWidget(QLabel("Selective Plating:"), row, 0)
        self.selective_plating_combo = QComboBox()
        self.selective_plating_combo.addItems(["No", "Yes"])
        form_layout.addWidget(self.selective_plating_combo, row, 1)
        row += 1
        
        # Drills
        form_layout.addWidget(QLabel("Drills:"), row, 0)
        self.drills_input = QLineEdit()
        self.drills_input.setPlaceholderText("Enter drill specifications...")
        form_layout.addWidget(self.drills_input, row, 1)
        row += 1
        
        # Impedance
        form_layout.addWidget(QLabel("Impedance:"), row, 0)
        self.impedance_combo = QComboBox()
        self.impedance_combo.addItems(["No", "Yes"])
        form_layout.addWidget(self.impedance_combo, row, 1)
        row += 1
        
        # Soldermask
        form_layout.addWidget(QLabel("Soldermask:"), row, 0)
        self.soldermask_input = QLineEdit()
        self.soldermask_input.setPlaceholderText("Enter soldermask color...")
        form_layout.addWidget(self.soldermask_input, row, 1)
        row += 1
        
        # Silkscreen
        form_layout.addWidget(QLabel("Silkscreen:"), row, 0)
        self.silkscreen_input = QLineEdit()
        self.silkscreen_input.setPlaceholderText("Enter silkscreen color...")
        form_layout.addWidget(self.silkscreen_input, row, 1)
        row += 1

        # Special Features
        features_label = QLabel("Special Features")
        features_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        features_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(features_label, row, 0, 1, 2)
        row += 1
        
        # Back Drill
        form_layout.addWidget(QLabel("Back Drill:"), row, 0)
        self.back_drill_combo = QComboBox()
        self.back_drill_combo.addItems(["No", "Yes"])
        form_layout.addWidget(self.back_drill_combo, row, 1)
        row += 1
        
        # Blind Via
        form_layout.addWidget(QLabel("Blind Via:"), row, 0)
        self.blind_via_combo = QComboBox()
        self.blind_via_combo.addItems(["No", "Yes"])
        form_layout.addWidget(self.blind_via_combo, row, 1)
        row += 1
        
        # Berried Via
        form_layout.addWidget(QLabel("Buried Via:"), row, 0)
        self.berried_via_combo = QComboBox()
        self.berried_via_combo.addItems(["No", "Yes"])
        form_layout.addWidget(self.berried_via_combo, row, 1)
        row += 1
        
        # Via Type
        form_layout.addWidget(QLabel("Via Type:"), row, 0)
        self.via_type_input = QLineEdit()
        self.via_type_input.setPlaceholderText("Enter via type...")
        form_layout.addWidget(self.via_type_input, row, 1)
        row += 1
        
        # Via Fill
        form_layout.addWidget(QLabel("Via Fill:"), row, 0)
        self.via_fill_input = QLineEdit()
        self.via_fill_input.setPlaceholderText("Enter via fill...")
        form_layout.addWidget(self.via_fill_input, row, 1)
        row += 1
        
        # Beveling
        form_layout.addWidget(QLabel("Beveling:"), row, 0)
        self.beveling_input = QLineEdit()
        self.beveling_input.setPlaceholderText("Enter beveling...")
        form_layout.addWidget(self.beveling_input, row, 1)
        row += 1
        
        # Edge Plating
        form_layout.addWidget(QLabel("Edge Plating:"), row, 0)
        self.edge_plating_combo = QComboBox()
        self.edge_plating_combo.addItems(["No", "Yes"])
        form_layout.addWidget(self.edge_plating_combo, row, 1)
        row += 1
        
        # Pricing
        pricing_label = QLabel("Pricing & Timeline")
        pricing_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        pricing_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(pricing_label, row, 0, 1, 2)
        row += 1
        
        # Price Per Unit
        form_layout.addWidget(QLabel("Price Per Unit (‚Çπ):"), row, 0)
        self.price_per_unit_input = QLineEdit()
        self.price_per_unit_input.setValidator(QDoubleValidator(0.01, 999999.99, 2))
        self.price_per_unit_input.setPlaceholderText("Enter price per unit...")
        form_layout.addWidget(self.price_per_unit_input, row, 1)
        row += 1
        
        # Engineering Cost
        form_layout.addWidget(QLabel("Engineering Cost (‚Çπ):"), row, 0)
        self.engg_cost_input = QLineEdit()
        self.engg_cost_input.setValidator(QDoubleValidator(0.0, 999999.99, 2))
        self.engg_cost_input.setPlaceholderText("Enter engineering cost...")
        form_layout.addWidget(self.engg_cost_input, row, 1)
        row += 1
        
        # Total Cost INR
        form_layout.addWidget(QLabel("Total Cost INR (‚Çπ):"), row, 0)
        self.total_cost_inr_input = QLineEdit()
        self.total_cost_inr_input.setValidator(QDoubleValidator(0.01, 999999.99, 2))
        self.total_cost_inr_input.setPlaceholderText("Enter total cost...")
        form_layout.addWidget(self.total_cost_inr_input, row, 1)
        row += 1
        
        # Lead Time
        form_layout.addWidget(QLabel("Lead Time:"), row, 0)
        self.lead_time_input = QLineEdit()
        self.lead_time_input.setPlaceholderText("Enter lead time...")
        form_layout.addWidget(self.lead_time_input, row, 1)
        row += 1
        
        input_layout.addLayout(form_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        
        self.save_btn = QPushButton("üíæ Save Data")
        self.update_btn = QPushButton("üìù Update Data")
        self.clear_btn = QPushButton("üóëÔ∏è Clear Form")
        self.delete_btn = QPushButton("‚ùå Delete Record")
        
        # Initially hide update and delete buttons
        self.update_btn.hide()
        self.delete_btn.hide()
        
        for btn in [self.save_btn, self.update_btn, self.clear_btn, self.delete_btn]:
            btn.setMinimumHeight(40)
            
        self.save_btn.clicked.connect(self.save_data)
        self.update_btn.clicked.connect(self.update_data)
        self.clear_btn.clicked.connect(self.clear_form)
        self.delete_btn.clicked.connect(self.delete_data)
        
        button_layout.addWidget(self.save_btn)
        button_layout.addWidget(self.update_btn)
        button_layout.addWidget(self.clear_btn)
        button_layout.addWidget(self.delete_btn)
        
        input_layout.addLayout(button_layout)
        
        # Set the container widget to the scroll area
        self.input_scroll_area.setWidget(input_container)
        
        # Add scroll area to the frame layout
        left_frame_layout.addWidget(self.input_scroll_area)
        
        # Right side - Saved data cards (keeping existing structure)
        right_frame = QGroupBox("Saved PCB Data Records")
        right_layout = QVBoxLayout(right_frame)
        
        # Search/Filter section
        search_layout = QHBoxLayout()
        search_label = QLabel("üîç Search:")
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search by part number or material...")
        self.search_input.textChanged.connect(self.filter_cards)
        
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.search_input)
        right_layout.addLayout(search_layout)
        
        # Scroll area for cards
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setMinimumWidth(400)
        
        self.cards_widget = QWidget()
        self.cards_layout = QVBoxLayout(self.cards_widget)
        self.cards_layout.setSpacing(8)
        
        self.scroll_area.setWidget(self.cards_widget)
        right_layout.addWidget(self.scroll_area)
        
        # Add frames to main layout
        layout.addWidget(left_frame, 1)
        layout.addWidget(right_frame, 1)
        self.setLayout(layout)
        
        self.refresh_saved_data()
        
    def get_form_data(self):
        """Get data from form inputs"""
        return {
            'pcb_part_number': self.pcb_part_number_input.text().strip(),
            'quantity': int(self.quantity_input.text()) if self.quantity_input.text() else 0,
            'layers': int(self.layers_combo.currentText()),
            'pcb_spec': self.pcb_spec_combo.currentText(),
            'material': self.material_input.text().strip(),
            'length': float(self.length_input.text()) if self.length_input.text() else 0.0,
            'width': float(self.width_input.text()) if self.width_input.text() else 0.0,
            'array_size': self.array_size_input.text().strip(),
            'board_thickness': float(self.board_thickness_input.text()) if self.board_thickness_input.text() else 0.0,
            'cu_inner': self.cu_inner_input.text().strip(),
            'cu_outer': self.cu_outer_input.text().strip(),
            'surface_finish': self.surface_finish_input.text().strip(),
            'selective_plating': self.selective_plating_combo.currentText(),
            'drills': self.drills_input.text().strip(),
            'impedance': self.impedance_combo.currentText(),
            'soldermask': self.soldermask_input.text().strip(),
            'silkscreen': self.silkscreen_input.text().strip(),
            'back_drill': self.back_drill_combo.currentText(),
            'blind_via': self.blind_via_combo.currentText(),
            'berried_via': self.berried_via_combo.currentText(),
            'via_type': self.via_type_input.text().strip(),
            'via_fill': self.via_fill_input.text().strip(),
            'beveling': self.beveling_input.text().strip(),
            'edge_plating': self.edge_plating_combo.currentText(),
            'price_per_unit': float(self.price_per_unit_input.text()) if self.price_per_unit_input.text() else 0.0,
            'engg_cost': float(self.engg_cost_input.text()) if self.engg_cost_input.text() else 0.0,
            'total_cost_inr': float(self.total_cost_inr_input.text()) if self.total_cost_inr_input.text() else 0.0,
            'lead_time': self.lead_time_input.text().strip()
        }
        
    def save_data(self):
        """Save PCB data to database"""
        try:
            # Validate required fields
            if not all([
                self.pcb_part_number_input.text().strip(),
                self.quantity_input.text(),
                self.length_input.text(),
                self.width_input.text(),
                self.price_per_unit_input.text(),
                self.total_cost_inr_input.text()
            ]):
                QMessageBox.warning(self, "Validation Error", 
                                  "Please fill all required fields!")
                return
            
            data = self.get_form_data()
            
            # Insert into database
            self.parent.cursor.execute('''
                INSERT INTO pcb_data (
                    pcb_part_number, quantity, layers, pcb_spec, material, length, width,
                    array_size, board_thickness, cu_inner, cu_outer, surface_finish,
                    selective_plating, drills, impedance, soldermask, silkscreen,
                    back_drill, blind_via, berried_via, via_type, via_fill, beveling,
                    edge_plating, price_per_unit, engg_cost, total_cost_inr, lead_time
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', tuple(data.values()))
            
            self.parent.conn.commit()
            QMessageBox.information(self, "Success", "Data saved successfully!")
            self.clear_form()
            self.refresh_saved_data()
            
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save data: {str(e)}")
    
    def clear_form(self):
        """Clear all form inputs"""
        # Clear text inputs
        for widget in [self.pcb_part_number_input, self.quantity_input, self.material_input, 
                      self.length_input, self.width_input, self.array_size_input,
                      self.board_thickness_input, self.cu_inner_input, self.cu_outer_input,
                      self.surface_finish_input, self.drills_input, self.soldermask_input,
                      self.silkscreen_input, self.via_type_input, self.via_fill_input,
                      self.beveling_input, self.price_per_unit_input, self.engg_cost_input,
                      self.total_cost_inr_input, self.lead_time_input]:
            widget.clear()
        
        # Reset combos to default
        for combo in [self.layers_combo, self.pcb_spec_combo, self.selective_plating_combo,
                     self.impedance_combo, self.back_drill_combo, self.blind_via_combo,
                     self.berried_via_combo, self.edge_plating_combo]:
            combo.setCurrentIndex(0)
        
        # Reset editing state
        self.current_edit_id = None
        self.save_btn.show()
        self.update_btn.hide()
        self.delete_btn.hide()

    def refresh_saved_data(self):
        """Refresh the saved data cards"""
        for i in reversed(range(self.cards_layout.count())):
            child = self.cards_layout.itemAt(i).widget()
            if child:
                child.setParent(None)
                
        self.parent.cursor.execute('''
            SELECT id, pcb_part_number, material, layers, quantity, total_cost_inr, 
                   length, width, lead_time
            FROM pcb_data ORDER BY created_date DESC
        ''')
        
        self.all_data = self.parent.cursor.fetchall()
        self.display_cards(self.all_data)
        
    def display_cards(self, data):
        """Display data cards"""
        for i in reversed(range(self.cards_layout.count())):
            child = self.cards_layout.itemAt(i).widget()
            if child:
                child.setParent(None)
        
        if not data:
            no_data_label = QLabel("üìã No PCB data records found.")
            no_data_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            no_data_label.setStyleSheet("color: #666666; font-style: italic; padding: 20px;")
            self.cards_layout.addWidget(no_data_label)
        else:
            for row in data:
                card = EditableDataCard(row)
                card.double_clicked.connect(self.load_data_in_form)
                self.cards_layout.addWidget(card)
        
        self.cards_layout.addStretch()



    def scroll_to_top(self):
        """Scroll the cards area to top"""
        self.cards_scroll_area.verticalScrollBar().setValue(0)

    def scroll_to_card(self, card_id):
        """Scroll to a specific card by ID"""
        for i in range(self.cards_layout.count()):
            widget = self.cards_layout.itemAt(i).widget()
            if isinstance(widget, EditableDataCard) and widget.data[0] == card_id:
                # Calculate position and scroll to it
                card_pos = widget.pos().y()
                self.cards_scroll_area.verticalScrollBar().setValue(card_pos)
                break


    def load_data_in_form(self, data):
        """Load card data into input fields for editing"""
        self.current_edit_id = data[0]
        
        # Query full record from database
        self.parent.cursor.execute("SELECT * FROM pcb_data WHERE id=?", (self.current_edit_id,))
        record = self.parent.cursor.fetchone()
        
        if not record:
            QMessageBox.warning(self, "Load Error", "Failed to load the selected record.")
            return

        # Unpack record data
        (_, fabricator_name, unit, pcb_qty, pcb_layer, pcb_length, pcb_width, 
         material, mask_color, silk_color, copper_inner, copper_outer, 
         back_drill, blind_via, berried_via, total_price, _) = record

        # Populate form fields
        self.fabricator_input.setText(fabricator_name or "")
        self.unit_combo.setCurrentText(unit)
        self.qty_input.setText(str(pcb_qty))
        self.layer_combo.setCurrentText(str(pcb_layer))
        self.length_input.setText(str(pcb_length))
        self.width_input.setText(str(pcb_width))
        self.material_input.setText(material or "")
        self.mask_color_input.setText(mask_color or "")
        self.silk_color_input.setText(silk_color or "")
        self.copper_inner_input.setText(copper_inner or "")
        self.copper_outer_input.setText(copper_outer or "")
        self.back_drill_combo.setCurrentText(back_drill)
        self.blind_via_combo.setCurrentText(blind_via)
        self.berried_via_combo.setCurrentText(berried_via)  # Correct variable name
        self.price_input.setText(str(total_price))

        # Switch to edit mode
        self.save_btn.hide()
        self.update_btn.show()
        self.delete_btn.show()

    def delete_data(self):
        """Delete selected record from database"""
        if self.current_edit_id is None:
            return

        reply = QMessageBox.question(
            self, "Confirm Delete",
            "Are you sure you want to delete this PCB record?\n\nThis action cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            try:
                self.parent.cursor.execute("DELETE FROM pcb_data WHERE id=?", (self.current_edit_id,))
                self.parent.conn.commit()
                QMessageBox.information(self, "Deleted", "Record deleted successfully!")
                self.clear_form()
                self.refresh_saved_data()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to delete record: {str(e)}")

    def filter_cards(self):
        """Filter cards based on search input"""
        search_text = self.search_input.text().lower()
        
        if not search_text:
            filtered_data = self.all_data
        else:
            filtered_data = [
                row for row in self.all_data
                if search_text in str(row[1]).lower() or search_text in str(row[2]).lower()
            ]
        
        self.display_cards(filtered_data)

    def update_data(self):
        """Update existing PCB data"""
        try:
            if self.current_edit_id is None:
                return
                
            # Validate required fields
            if not all([
                self.pcb_part_number_input.text().strip(),
                self.quantity_input.text(),
                self.length_input.text(),
                self.width_input.text(),
                self.price_per_unit_input.text(),
                self.total_cost_inr_input.text()
            ]):
                QMessageBox.warning(self, "Validation Error", 
                                "Please fill all required fields!")
                return
                
            data = self.get_form_data()
            
            # Update existing record
            self.parent.cursor.execute('''
                UPDATE pcb_data SET
                    pcb_part_number = ?, quantity = ?, layers = ?, pcb_spec = ?, material = ?, 
                    length = ?, width = ?, array_size = ?, board_thickness = ?, cu_inner = ?, 
                    cu_outer = ?, surface_finish = ?, selective_plating = ?, drills = ?, 
                    impedance = ?, soldermask = ?, silkscreen = ?, back_drill = ?, blind_via = ?, 
                    berried_via = ?, via_type = ?, via_fill = ?, beveling = ?, edge_plating = ?, 
                    price_per_unit = ?, engg_cost = ?, total_cost_inr = ?, lead_time = ?
                WHERE id = ?
            ''', tuple(data.values()) + (self.current_edit_id,))

            self.parent.conn.commit()
            QMessageBox.information(self, "Success", "Data updated successfully!")
            self.clear_form()
            self.refresh_saved_data()
            
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to update data: {str(e)}")

    def load_data_in_form(self, data):
        """Load card data into input fields for editing"""
        self.current_edit_id = data[0]
        
        # Query full record from database with correct field names
        self.parent.cursor.execute("SELECT * FROM pcb_data WHERE id=?", (self.current_edit_id,))
        record = self.parent.cursor.fetchone()
        
        if not record:
            QMessageBox.warning(self, "Load Error", "Failed to load the selected record.")
            return

        # Unpack record data according to new database schema
        (_, pcb_part_number, quantity, layers, pcb_spec, material, length, width,
        array_size, board_thickness, cu_inner, cu_outer, surface_finish,
        selective_plating, drills, impedance, soldermask, silkscreen,
        back_drill, blind_via, berried_via, via_type, via_fill, beveling,
        edge_plating, price_per_unit, engg_cost, total_cost_inr, lead_time, _) = record

        # Populate form fields with correct field names
        self.pcb_part_number_input.setText(pcb_part_number or "")
        self.quantity_input.setText(str(quantity))
        self.layers_combo.setCurrentText(str(layers))
        self.pcb_spec_combo.setCurrentText(pcb_spec or "Class 2")
        self.material_input.setText(material or "")
        self.length_input.setText(str(length))
        self.width_input.setText(str(width))
        self.array_size_input.setText(array_size or "")
        self.board_thickness_input.setText(str(board_thickness) if board_thickness else "")
        self.cu_inner_input.setText(cu_inner or "")
        self.cu_outer_input.setText(cu_outer or "")
        self.surface_finish_input.setText(surface_finish or "")
        self.selective_plating_combo.setCurrentText(selective_plating or "No")
        self.drills_input.setText(drills or "")
        self.impedance_combo.setCurrentText(impedance or "No")
        self.soldermask_input.setText(soldermask or "")
        self.silkscreen_input.setText(silkscreen or "")
        self.back_drill_combo.setCurrentText(back_drill or "No")
        self.blind_via_combo.setCurrentText(blind_via or "No")
        self.berried_via_combo.setCurrentText(berried_via or "No")
        self.via_type_input.setText(via_type or "")
        self.via_fill_input.setText(via_fill or "")
        self.beveling_input.setText(beveling or "")
        self.edge_plating_combo.setCurrentText(edge_plating or "No")
        self.price_per_unit_input.setText(str(price_per_unit))
        self.engg_cost_input.setText(str(engg_cost) if engg_cost else "")
        self.total_cost_inr_input.setText(str(total_cost_inr))
        self.lead_time_input.setText(lead_time or "")

        # Switch to edit mode
        self.save_btn.hide()
        self.update_btn.show()
        self.delete_btn.show()



class CalculationPage(QWidget):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.init_ui()
        
    def init_ui(self):
        """Initialize calculation page UI with updated fields"""
        layout = QHBoxLayout()
        layout.setSpacing(20)
        
        # Left side - Scrollable Input form
        left_frame = QGroupBox("Price Calculation Input")
        left_frame_layout = QVBoxLayout(left_frame)
        
        # Create scroll area for the input form
        self.input_scroll_area = QScrollArea()
        self.input_scroll_area.setWidgetResizable(True)
        self.input_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.input_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # Create container widget for the form
        input_container = QWidget()
        input_layout = QVBoxLayout(input_container)
        
        form_layout = QGridLayout()
        form_layout.setSpacing(12)
        row = 0

        # Customer Information
        customer_label = QLabel("Customer Information")
        customer_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        customer_label.setStyleSheet("color: #0078d4; margin: 10px 0 5px 0;")
        form_layout.addWidget(customer_label, row, 0, 1, 2)
        row += 1

        form_layout.addWidget(QLabel("Customer Name:"), row, 0)
        self.customer_input = QLineEdit()
        self.customer_input.setPlaceholderText("Enter customer name...")
        form_layout.addWidget(self.customer_input, row, 1)
        row += 1

        form_layout.addWidget(QLabel("Job Number:"), row, 0)
        self.job_input = QLineEdit()
        self.job_input.setPlaceholderText("Enter job number...")
        form_layout.addWidget(self.job_input, row, 1)
        row += 1
        
        form_layout.addWidget(QLabel("PCB Part Number:"), row, 0)
        self.pcb_part_input = QLineEdit()
        self.pcb_part_input.setPlaceholderText("Enter PCB part number...")
        form_layout.addWidget(self.pcb_part_input, row, 1)
        row += 1

        # PCB Specifications
        pcb_label = QLabel("PCB Specifications")
        pcb_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        pcb_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(pcb_label, row, 0, 1, 2)
        row += 1

        form_layout.addWidget(QLabel("Unit:"), row, 0)
        self.unit_combo = QComboBox()
        self.unit_combo.addItems(["mm", "inch"])
        form_layout.addWidget(self.unit_combo, row, 1)
        row += 1

        # PCB Size
        form_layout.addWidget(QLabel("PCB Size (L √ó W):"), row, 0)
        size_widget = QWidget()
        size_layout = QHBoxLayout(size_widget)
        size_layout.setContentsMargins(0, 0, 0, 0)
        
        self.length_input = QLineEdit()
        self.length_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.length_input.setPlaceholderText("Length")
        
        self.width_input = QLineEdit()
        self.width_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
        self.width_input.setPlaceholderText("Width")  # Fixed typo here
        
        size_layout.addWidget(QLabel("L:"))
        size_layout.addWidget(self.length_input)
        size_layout.addWidget(QLabel("√ó"))
        size_layout.addWidget(QLabel("W:"))
        size_layout.addWidget(self.width_input)
        
        form_layout.addWidget(size_widget, row, 1)
        row += 1

        # Database Filters section
        filter_label = QLabel("Database Filters")
        filter_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        filter_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
        form_layout.addWidget(filter_label, row, 0, 1, 2)
        row += 1

        # Initialize filter_combos dictionary BEFORE using it
        self.filter_combos = {}
        
        # Create all filter fields
        filter_fields = [
            "layers", "material", "board_thickness", "cu_inner", "cu_outer",
            "surface_finish", "impedance", "soldermask", "silkscreen", 
            "back_drill", "blind_via", "berried_via"
        ]
        
        for field in filter_fields:
            label_text = field.replace('_', ' ').title() + ":"
            form_layout.addWidget(QLabel(label_text), row, 0)
            combo = QComboBox()
            combo.setMinimumWidth(200)
            self.filter_combos[field] = combo
            form_layout.addWidget(combo, row, 1)
            row += 1

        input_layout.addLayout(form_layout)
        
        # Calculate button
        self.calculate_btn = QPushButton("üßÆ Calculate Price")
        self.calculate_btn.setMinimumHeight(50)
        self.calculate_btn.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        self.calculate_btn.clicked.connect(self.calculate_price)
        input_layout.addWidget(self.calculate_btn)
        
        # Set the container widget to the scroll area
        self.input_scroll_area.setWidget(input_container)
        left_frame_layout.addWidget(self.input_scroll_area)
        
        # Right side - Results
        right_frame = QGroupBox("Calculation Results")
        right_layout = QVBoxLayout(right_frame)

        # Create table widget for results
        self.results_table = QTableWidget()
        self.results_table.setColumnCount(2)
        self.results_table.setHorizontalHeaderLabels(['Parameter', 'Value'])
        self.results_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.results_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.results_table.verticalHeader().setVisible(False)
        self.results_table.setAlternatingRowColors(True)
        self.results_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.results_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        right_layout.addWidget(self.results_table)

        
        # Export button
        self.export_btn = QPushButton("üìä Export to Excel")
        self.export_btn.setMinimumHeight(45)
        self.export_btn.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        self.export_btn.clicked.connect(self.export_to_excel)
        right_layout.addWidget(self.export_btn)
        
        # Add frames to main layout
        layout.addWidget(left_frame, 1)
        layout.addWidget(right_frame, 1)
        self.setLayout(layout)
            
    def refresh_data(self):
        """Refresh dropdown data from database"""
        try:
            # Get unique values for each filter
            filter_fields = ["layers", "material", "board_thickness", "cu_inner", "cu_outer",
                            "surface_finish", "impedance", "soldermask", "silkscreen",
                            "back_drill", "blind_via", "berried_via"]
            
            for field in filter_fields:
                self.parent.cursor.execute(f"SELECT DISTINCT {field} FROM pcb_data WHERE {field} IS NOT NULL AND {field} != '' ORDER BY {field}")
                values = [str(row[0]) for row in self.parent.cursor.fetchall()]
                if field in self.filter_combos:
                    self.filter_combos[field].clear()
                    if values:
                        self.filter_combos[field].addItems(values)
        except Exception as e:
            print(f"Error refreshing data: {e}")


    def calculate_price(self):
        """Calculate PCB price based on updated database data"""
        try:
            # Validate inputs
            if not all([
                self.customer_input.text().strip(),
                self.job_input.text().strip(),
                self.pcb_part_input.text().strip(),
                self.length_input.text(),
                self.width_input.text()
            ]):
                QMessageBox.warning(self, "Input Error", "Please fill all required fields!")
                return

            # Get input values
            customer_name = self.customer_input.text().strip()
            job_number = self.job_input.text().strip()
            pcb_part_number = self.pcb_part_input.text().strip()
            unit = self.unit_combo.currentText()
            length = float(self.length_input.text())
            width = float(self.width_input.text())

            # Build dynamic query based on selected filters
            query_conditions = []
            params = []
            for field, combo in self.filter_combos.items():
                if combo.currentText():
                    query_conditions.append(f"{field} = ?")
                    params.append(combo.currentText())

            base_query = '''
            SELECT quantity, length, width, price_per_unit, total_cost_inr
            FROM pcb_data
            '''
            
            if query_conditions:
                query = base_query + "WHERE " + " AND ".join(query_conditions) + " ORDER BY price_per_unit DESC"
            else:
                query = base_query + "ORDER BY price_per_unit DESC"

            self.parent.cursor.execute(query, params)
            matches = self.parent.cursor.fetchall()

            if not matches:
                QMessageBox.information(self, "No Match", "No matching records found for the specified criteria.")
                return

            # Use the record with maximum price per unit
            best_match = matches[0]
            ref_qty, ref_length, ref_width, ref_price_per_unit, ref_total_cost = best_match

            # Calculate price per square unit
            ref_area = ref_length * ref_width
            price_per_sq_unit = ref_price_per_unit / ref_area if ref_area > 0 else 0

            # Calculate prices for input PCB
            input_area = length * width
            per_unit_price = price_per_sq_unit * input_area

            # Populate results table
            self.populate_results_table(customer_name, job_number, pcb_part_number, unit, 
                                    length, width, input_area, ref_length, ref_width, 
                                    ref_price_per_unit, price_per_sq_unit, per_unit_price)

            # Save calculation to database (existing logic)
            self.parent.cursor.execute('''
            INSERT INTO calculation_results (
                customer_name, job_number, pcb_part_number, unit, pcb_length, pcb_width,
                layers, material, board_thickness, cu_inner, cu_outer, surface_finish,
                impedance, soldermask, silkscreen, back_drill, blind_via, berried_via,
                per_sq_unit_price, per_unit_price, total_price
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                customer_name, job_number, pcb_part_number, unit, length, width,
                self.filter_combos.get("layers", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("material", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("board_thickness", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("cu_inner", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("cu_outer", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("surface_finish", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("impedance", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                "",  # soldermask - not in filter
                "",  # silkscreen - not in filter
                self.filter_combos.get("back_drill", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("blind_via", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                self.filter_combos.get("berried_via", type('obj', (object,), {'currentText': lambda: ''})).currentText(),
                price_per_sq_unit, per_unit_price, per_unit_price
            ))

            self.parent.conn.commit()

        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numeric values!")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Calculation failed: {str(e)}")

    def populate_results_table(self, customer_name, job_number, pcb_part_number, unit,
                            length, width, input_area, ref_length, ref_width,
                            ref_price_per_unit, price_per_sq_unit, per_unit_price):
        """Populate the results table with calculation data in Excel-like format"""
        
        # Define all rows with their data
        rows = [
            ("PCB Fabrication Cost Tool", "", "header"),
            ("", "", "spacer"),
            ("Customer Information", "", "section"),
            ("Customer Name", customer_name, "data"),
            ("Job Number", job_number, "data"),
            ("PCB Part Number", pcb_part_number, "data"),
            ("Calculation Date", datetime.now().strftime('%Y-%m-%d %H:%M:%S'), "data"),
            ("", "", "spacer"),
            ("PCB Specifications", "", "section"),
            ("Unit", unit, "data"),
            ("PCB Length", f"{length} {unit}", "data"),
            ("PCB Width", f"{width} {unit}", "data"),
            ("PCB Area", f"{input_area:.2f} {unit}¬≤", "data"),
        ]
        
        # Add selected configuration if filters are applied - FIXED LINE
        if any(combo.currentText() for combo in self.filter_combos.values()):
            rows.extend([
                ("", "", "spacer"),
                ("Selected Configuration", "", "section")
            ])
            
            for field, combo in self.filter_combos.items():
                if combo.currentText():
                    field_display = field.replace('_', ' ').title()
                    rows.append((field_display, combo.currentText(), "data"))
        
        # Add reference data and calculations
        rows.extend([
            ("", "", "spacer"),
            ("Reference Data", "", "section"),
            ("Reference PCB Size", f"{ref_length} √ó {ref_width} {unit}", "data"),
            ("Reference Price/Unit", f"‚Çπ{ref_price_per_unit:.2f}", "data"),
            ("", "", "spacer"),
            ("Price Calculation", "", "section"),
            ("Price per Square Unit", f"‚Çπ{price_per_sq_unit:.4f}", "calculation"),
            ("Estimated Price per PCB", f"‚Çπ{per_unit_price:.2f}", "calculation"),
            ("Unit Cost", f"‚Çπ{per_unit_price:.2f} per piece", "calculation")
        ])

        # Set up the table
        self.results_table.setRowCount(len(rows))
        
        # Populate table items
        for row_idx, (param, value, row_type) in enumerate(rows):
            param_item = QTableWidgetItem(param)
            value_item = QTableWidgetItem(value)
            
            # Apply formatting based on row type
            if row_type == "header":
                # Blue header like Excel
                param_item.setBackground(QColor(68, 114, 196))  # Excel blue
                param_item.setForeground(QColor(255, 255, 255))  # White text
                value_item.setBackground(QColor(68, 114, 196))
                value_item.setForeground(QColor(255, 255, 255))
                font = QFont()
                font.setBold(True)
                font.setPointSize(14)
                param_item.setFont(font)
                param_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                
            elif row_type == "section":
                # Light blue section headers
                param_item.setBackground(QColor(213, 228, 247))  # Light blue
                value_item.setBackground(QColor(213, 228, 247))
                font = QFont()
                font.setBold(True)
                param_item.setFont(font)
                value_item.setFont(font)
                
            elif row_type == "calculation":
                # Light green for calculations
                param_item.setBackground(QColor(226, 239, 218))  # Light green
                value_item.setBackground(QColor(226, 239, 218))
                font = QFont()
                font.setBold(True)
                param_item.setFont(font)
                value_item.setFont(font)
                value_item.setTextAlignment(Qt.AlignmentFlag.AlignRight)
                
            elif row_type == "data":
                # Regular data rows
                param_item.setBackground(QColor(242, 242, 242))  # Light gray
                value_item.setBackground(QColor(255, 255, 255))  # White
                value_item.setTextAlignment(Qt.AlignmentFlag.AlignRight)
                
            elif row_type == "spacer":
                # Empty spacer rows
                param_item.setBackground(QColor(255, 255, 255))
                value_item.setBackground(QColor(255, 255, 255))

            self.results_table.setItem(row_idx, 0, param_item)
            self.results_table.setItem(row_idx, 1, value_item)

        # Resize columns and rows
        self.results_table.resizeColumnsToContents()
        self.results_table.resizeRowsToContents()

                
    def export_to_excel(self):
        """Export calculation results to Excel with two-column format"""
        try:
            self.parent.cursor.execute('''
            SELECT customer_name, job_number, pcb_part_number, unit, pcb_length, pcb_width,
            layers, material, board_thickness, cu_inner, cu_outer, surface_finish,
            impedance, soldermask, silkscreen, back_drill, blind_via, berried_via,
            per_sq_unit_price, per_unit_price, total_price, calculation_date
            FROM calculation_results ORDER BY calculation_date DESC
            ''')
            
            data = self.parent.cursor.fetchall()
            
            if not data:
                QMessageBox.information(self, "Export", "No calculation data to export.")
                return

            file_path, _ = QFileDialog.getSaveFileName(
                self, "Export to Excel", 
                f"PCB_Calculations_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                "Excel Files (*.xlsx)"
            )
            
            if file_path:
                # Import openpyxl for advanced Excel formatting
                try:
                    import openpyxl
                    from openpyxl.styles import Alignment, Font
                except ImportError:
                    QMessageBox.critical(self, "Export Error", 
                                    "openpyxl library not found. Please install it using: pip install openpyxl")
                    return

                # Create workbook and worksheet
                wb = openpyxl.Workbook()
                ws = wb.active
                ws.title = "PCB Calculations"
                
                # Tool name merged across two columns in first row
                tool_name = "PCB Fabrication Cost Tool"
                ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=2)
                ws.cell(row=1, column=1).value = tool_name
                ws.cell(row=1, column=1).alignment = Alignment(horizontal='center', vertical='center')
                ws.cell(row=1, column=1).font = Font(size=16, bold=True)
                
                # Column headers in row 2
                ws.cell(row=2, column=1).value = "Parameter"
                ws.cell(row=2, column=2).value = "Value"
                ws.cell(row=2, column=1).font = Font(bold=True)
                ws.cell(row=2, column=2).font = Font(bold=True)
                
                # Parameter names corresponding to the data columns
                parameter_names = [
                    'Customer Name', 'Job Number', 'PCB Part Number', 'Unit', 
                    'PCB Length', 'PCB Width', 'Layers', 'Material', 'Board Thickness', 
                    'Cu Inner', 'Cu Outer', 'Surface Finish', 'Impedance', 
                    'Soldermask', 'Silkscreen', 'Back Drill', 'Blind Via', 'Buried Via',
                    'Price per Sq Unit', 'Per Unit Price', 'Total Price', 'Calculation Date'
                ]
                
                # Use the most recent calculation (first record)
                latest_record = data[0]
                
                # Write parameter-value pairs starting from row 3
                for i, (param_name, value) in enumerate(zip(parameter_names, latest_record), 3):
                    ws.cell(row=i, column=1).value = param_name
                    ws.cell(row=i, column=2).value = value
                
                # Adjust column widths
                ws.column_dimensions['A'].width = 25
                ws.column_dimensions['B'].width = 30
                
                # Save the workbook
                wb.save(file_path)
                
                QMessageBox.information(self, "Export Success", 
                                    f"Data exported successfully!\n\nFile saved as:\n{file_path}")
                                    
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export data: {str(e)}")

def main():
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    
    # Set application icon and properties
    app.setApplicationName("PCB Fabrication Cost Tool")
    app.setApplicationVersion("2.0")
    app.setOrganizationName("PCB Tools")
    
    # Create and show main window
    window = PCBFabCostTool()
    window.show()
    
    sys.exit(app.exec())

if __name__ == '__main__':
    main()
