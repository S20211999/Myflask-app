def generate_pads_script(self):
    """Generate comprehensive PADS Layout script with proper chamfer, courtyard, and silkscreen"""
    data = self.get_footprint_data()
    settings = self.settings_panel.get_settings()
    account_settings = AccountManager.load_account_settings()
    
    lines = []
    footprint_name = data.get('footprint_name', 'Unnamed')

    # PADS script header
    lines.append("! PADS Layout Script - Enhanced Version")
    lines.append(f"! Footprint: {footprint_name}")
    lines.append(f"! Generated by LibSienna Footprint Designer")
    lines.append("")

    # Get pads and resolver
    pads = data.get('padstacks', [])
    resolver = PadPositionResolver(pads)

    # Step 1: Create unique padstack definitions
    lines.append("! ===== PADSTACK DEFINITIONS =====")
    lines.append("*DEFINE_PADSTACK*")

    unique_padstacks = {}
    padstack_counter = 1

    for pad in pads:
        padstack_name = self.generate_pad_name_for_script(pad)
        if padstack_name not in unique_padstacks:
            unique_padstacks[padstack_name] = f"PAD{padstack_counter:03d}"
            pad_type = pad.get('type', 'square')

            lines.append(f"! Padstack: {padstack_name}")
            lines.append(f"{unique_padstacks[padstack_name]} {padstack_name}")

            # Get mask/paste settings
            mask_enabled = pad.get('mask_enabled', True)
            paste_enabled = pad.get('paste_enabled', True)
            mask_exp = to_decimal(pad.get('mask_expansion', 0)) if mask_enabled else 0
            paste_exp = to_decimal(pad.get('paste_expansion', 0)) if paste_enabled else 0

            if pad_type == 'square':
                size = to_decimal(pad.get('size', 1)) * 1000  # Convert to mils
                lines.append(f" TOP S{size:.0f}")
                lines.append(f" BOTTOM S{size:.0f}")
                
                if mask_exp > 0:
                    mask_size = (size/1000 + 2 * mask_exp) * 1000
                    lines.append(f" SOLDERMASK S{mask_size:.0f}")
                if paste_exp > 0:
                    paste_size = (size/1000 + 2 * paste_exp) * 1000
                    lines.append(f" PASTE S{paste_size:.0f}")

            elif pad_type in ['rectangle', 'SMD-oblong', 'rounded_rectangle']:
                length = to_decimal(pad.get('length', 1)) * 1000
                width = to_decimal(pad.get('width', 1)) * 1000
                shape = "R" if pad_type == 'rectangle' else "O"  # O for oblong/rounded

                lines.append(f" TOP {shape}{length:.0f}X{width:.0f}")
                lines.append(f" BOTTOM {shape}{length:.0f}X{width:.0f}")
                
                if mask_exp > 0:
                    mask_l = (length/1000 + 2 * mask_exp) * 1000
                    mask_w = (width/1000 + 2 * mask_exp) * 1000
                    lines.append(f" SOLDERMASK {shape}{mask_l:.0f}X{mask_w:.0f}")
                if paste_exp > 0:
                    paste_l = (length/1000 + 2 * paste_exp) * 1000
                    paste_w = (width/1000 + 2 * paste_exp) * 1000
                    lines.append(f" PASTE {shape}{paste_l:.0f}X{paste_w:.0f}")

            elif pad_type == 'round':
                diameter = to_decimal(pad.get('diameter', 1)) * 1000
                lines.append(f" TOP C{diameter:.0f}")
                lines.append(f" BOTTOM C{diameter:.0f}")
                
                if mask_exp > 0:
                    mask_dia = (diameter/1000 + 2 * mask_exp) * 1000
                    lines.append(f" SOLDERMASK C{mask_dia:.0f}")
                if paste_exp > 0:
                    paste_dia = (diameter/1000 + 2 * paste_exp) * 1000
                    lines.append(f" PASTE C{paste_dia:.0f}")

            elif pad_type in ['PTH', 'NPTH']:
                hole_dia = to_decimal(pad.get('hole_diameter', 0.8)) * 1000
                lines.append(f" DRILL {hole_dia:.0f}")
                
                if pad_type == 'PTH':
                    pad_dia = to_decimal(pad.get('pad_diameter', 1.2)) * 1000
                    lines.append(f" TOP C{pad_dia:.0f}")
                    lines.append(f" BOTTOM C{pad_dia:.0f}")

            elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
                hole_length = to_decimal(pad.get('hole_length', 1.5)) * 1000
                hole_width = to_decimal(pad.get('hole_width', 0.8)) * 1000
                lines.append(f" DRILL O{hole_length:.0f}X{hole_width:.0f}")
                
                if pad_type == 'PTH_oblong':
                    pad_length = to_decimal(pad.get('pad_length', 2.0)) * 1000
                    pad_width = to_decimal(pad.get('pad_width', 1.2)) * 1000
                    lines.append(f" TOP O{pad_length:.0f}X{pad_width:.0f}")
                    lines.append(f" BOTTOM O{pad_length:.0f}X{pad_width:.0f}")

            elif pad_type == 'PTH_rectangle':
                hole_length = to_decimal(pad.get('hole_length', 1.5)) * 1000
                hole_width = to_decimal(pad.get('hole_width', 0.8)) * 1000
                lines.append(f" DRILL R{hole_length:.0f}X{hole_width:.0f}")
                
                pad_length = to_decimal(pad.get('pad_length', 2.0)) * 1000
                pad_width = to_decimal(pad.get('pad_width', 1.2)) * 1000
                lines.append(f" TOP R{pad_length:.0f}X{pad_width:.0f}")
                lines.append(f" BOTTOM R{pad_length:.0f}X{pad_width:.0f}")

            lines.append("")
            padstack_counter += 1

    lines.append("*END_DEFINE_PADSTACK*")
    lines.append("")

    # Step 2: Create part definition with pad placements
    lines.append("! ===== PART DEFINITION =====")
    lines.append("*PART*")
    lines.append(f"{footprint_name}")
    lines.append("")

    lines.append("! Pad placements:")
    for pad in pads:
        padstack_name = self.generate_pad_name_for_script(pad)
        pin_number = pad.get('pin_number', '1')
        abs_x, abs_y = resolver.get_absolute_position(pad)
        
        # Convert to mils and reference the padstack
        x_mils = abs_x * 1000
        y_mils = abs_y * 1000
        lines.append(f"{pin_number} {x_mils:.0f} {y_mils:.0f} {unique_padstacks[padstack_name]}")

    lines.append("")

    # Get dimensions and settings for geometry generation
    origin_offset_x = to_decimal(data.get('origin_offset_x', '0'))
    origin_offset_y = to_decimal(data.get('origin_offset_y', '0'))
    body_length = to_decimal(data.get('body_length', '0'))
    body_width = to_decimal(data.get('body_width', '0'))
    body_shape = data.get('body_shape', 'rectangle')
    body_chamfer = to_decimal(data.get('body_chamfer', '0'))
    chamfer_corners = data.get('chamfer_corners', {})

    # Calculate body corners with origin offset (in mm)
    tl = (origin_offset_x, origin_offset_y)  # Top-left
    tr = (origin_offset_x + body_length, origin_offset_y)  # Top-right
    bl = (origin_offset_x, origin_offset_y - body_width)  # Bottom-left
    br = (origin_offset_x + body_length, origin_offset_y - body_width)  # Bottom-right

    # Calculate pad bounds for silkscreen gap calculation
    pad_bounds_list = []
    for pad in pads:
        abs_x, abs_y = resolver.get_absolute_position(pad)
        pad_bounds = self.calculate_pad_bounds_for_script(pad, abs_x, abs_y)
        if pad_bounds:
            pad_bounds_list.append(pad_bounds)

    # Step 3: Generate Assembly Layer with Chamfer Support
    if body_length > 0 and body_width > 0:
        lines.append("! ===== ASSEMBLY LAYER =====")
        assembly_width = to_decimal(data.get('body_line_width', '0.05')) * 1000

        if body_shape == 'round':
            # Round assembly
            radius = max(body_length, body_width) / Decimal('2')
            center_x = (origin_offset_x + body_length / Decimal('2')) * 1000
            center_y = (origin_offset_y - body_width / Decimal('2')) * 1000
            radius_mils = radius * 1000
            lines.append(f"CIRCLE {center_x:.0f} {center_y:.0f} {radius_mils:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
        else:
            # Rectangular assembly with chamfer support
            if body_chamfer > 0 and any(chamfer_corners.values()):
                # Generate chamfered body outline
                lines.append("! Body outline assembly (chamfered)")
                assembly_segments = self.generate_chamfered_body_segments_pads(
                    tl, tr, bl, br, body_chamfer, chamfer_corners
                )
                for (x1, y1), (x2, y2) in assembly_segments:
                    lines.append(f"LINE {x1*1000:.0f} {y1*1000:.0f} {x2*1000:.0f} {y2*1000:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
            else:
                # Standard rectangular body
                lines.append("! Body outline assembly")
                lines.append(f"LINE {tl[0]*1000:.0f} {tl[1]*1000:.0f} {tr[0]*1000:.0f} {tr[1]*1000:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
                lines.append(f"LINE {tr[0]*1000:.0f} {tr[1]*1000:.0f} {br[0]*1000:.0f} {br[1]*1000:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
                lines.append(f"LINE {br[0]*1000:.0f} {br[1]*1000:.0f} {bl[0]*1000:.0f} {bl[1]*1000:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
                lines.append(f"LINE {bl[0]*1000:.0f} {bl[1]*1000:.0f} {tl[0]*1000:.0f} {tl[1]*1000:.0f} {assembly_width:.0f} ASSEMBLY_TOP")

        lines.append("")

    # Step 4: Generate Silkscreen with Gap Logic and Chamfer Support
    if data.get('silkscreen_enabled', True) and body_length > 0 and body_width > 0:
        lines.append("! ===== SILKSCREEN WITH PAD GAPS =====")
        silkscreen_width = to_decimal(data.get('silkscreen_line_width', '0.15')) * 1000
        silkscreen_gap = to_decimal(data.get('silkscreen_airgap', '0.15'))
        follow_chamfer = data.get('silkscreen_follow_chamfer', False)

        if body_shape == 'round':
            # Round silkscreen - simplified approach
            radius = max(body_length, body_width) / Decimal('2')
            center_x = (origin_offset_x + body_length / Decimal('2')) * 1000
            center_y = (origin_offset_y - body_width / Decimal('2')) * 1000
            radius_mils = radius * 1000
            lines.append(f"! NOTE: Round silkscreen with pad gaps requires manual editing")
            lines.append(f"CIRCLE {center_x:.0f} {center_y:.0f} {radius_mils:.0f} {silkscreen_width:.0f} SILK_TOP")
        else:
            # Rectangular silkscreen with proper gap logic
            if follow_chamfer and body_chamfer > 0 and any(chamfer_corners.values()):
                # Generate chamfered silkscreen with gaps
                lines.append("! Chamfered silkscreen with pad gaps")
                silk_segments = self.generate_chamfered_silkscreen_segments_pads(
                    tl, tr, bl, br, body_chamfer, chamfer_corners, pad_bounds_list, silkscreen_gap
                )
            else:
                # Standard rectangular silkscreen with gaps
                lines.append("! Rectangular silkscreen with pad gaps")
                silk_segments = self.generate_standard_silkscreen_segments_pads(
                    tl, tr, bl, br, pad_bounds_list, silkscreen_gap
                )

            # Generate the silkscreen line commands
            for (x1, y1), (x2, y2) in silk_segments:
                lines.append(f"LINE {x1*1000:.0f} {y1*1000:.0f} {x2*1000:.0f} {y2*1000:.0f} {silkscreen_width:.0f} SILK_TOP")

        lines.append("")

    # Step 5: Generate Proper Courtyard with Individual Side Calculations
    lines.append("! ===== COURTYARD WITH PROPER CALCULATIONS =====")
    base_expansion = to_decimal(data.get('courtyard_expansion', '0.25'))
    courtyard_line_width = to_decimal(data.get('courtyard_line_width', '0.1'))
    body_line_width = to_decimal(data.get('body_line_width', '0.05'))
    courtyard_width = courtyard_line_width * 1000

    if body_length > 0 and body_width > 0:
        if body_shape == 'round':
            # Round courtyard logic
            radius = max(body_length, body_width) / Decimal('2')
            center_x = (origin_offset_x + body_length / Decimal('2'))
            center_y = (origin_offset_y - body_width / Decimal('2'))
            
            # Check if pads extend beyond body circle
            max_pad_distance = Decimal('0')
            if pad_bounds_list:
                for pad_bounds in pad_bounds_list:
                    px_min, py_min, px_max, py_max = [to_decimal(str(coord)) for coord in pad_bounds]
                    # Check all corners of pad bounds
                    pad_corners = [(px_min, py_min), (px_max, py_min), (px_max, py_max), (px_min, py_max)]
                    for corner_x, corner_y in pad_corners:
                        distance = ((corner_x - center_x)**2 + (corner_y - center_y)**2).sqrt()
                        max_pad_distance = max(max_pad_distance, distance)

            # Determine courtyard radius
            if max_pad_distance > radius:
                courtyard_radius = max_pad_distance + base_expansion + (courtyard_line_width / Decimal('2'))
            else:
                courtyard_radius = radius + base_expansion + (courtyard_line_width / Decimal('2')) + (body_line_width / Decimal('2'))

            lines.append(f"CIRCLE {center_x*1000:.0f} {center_y*1000:.0f} {courtyard_radius*1000:.0f} {courtyard_width:.0f} BOARD_GEOMETRY")
        else:
            # Rectangular courtyard with proper individual side calculations
            lines.append("! Rectangular courtyard with individual side calculations")
            
            # Body bounds adjusted for origin offset
            body_bounds_adjusted = [tl[0], bl[1], tr[0], tl[1]]  # [min_x, min_y, max_x, max_y]
            
            # Calculate overall pad bounds
            pad_bounds_for_courtyard = None
            if pad_bounds_list:
                min_x = min(pb[0] for pb in pad_bounds_list)
                min_y = min(pb[1] for pb in pad_bounds_list)
                max_x = max(pb[2] for pb in pad_bounds_list)
                max_y = max(pb[3] for pb in pad_bounds_list)
                pad_bounds_for_courtyard = [min_x, min_y, max_x, max_y]

            # Determine outermost bounds for each side
            courtyard_line_w = courtyard_line_width / 2
            body_line_w = body_line_width / 2
            body_linecourtyard = courtyard_line_w + body_line_w

            if body_bounds_adjusted and pad_bounds_for_courtyard:
                # Calculate individual side expansions
                expansions = {}
                
                # Left side
                if body_bounds_adjusted[0] <= pad_bounds_for_courtyard[0]:
                    outermost_left = body_bounds_adjusted[0]
                    expansions['left'] = base_expansion + body_linecourtyard
                else:
                    outermost_left = pad_bounds_for_courtyard[0]
                    expansions['left'] = base_expansion + courtyard_line_w

                # Right side  
                if body_bounds_adjusted[2] >= pad_bounds_for_courtyard[2]:
                    outermost_right = body_bounds_adjusted[2]
                    expansions['right'] = base_expansion + body_linecourtyard
                else:
                    outermost_right = pad_bounds_for_courtyard[2]
                    expansions['right'] = base_expansion + courtyard_line_w

                # Bottom side
                if body_bounds_adjusted[1] <= pad_bounds_for_courtyard[1]:
                    outermost_bottom = body_bounds_adjusted[1]
                    expansions['bottom'] = base_expansion + body_linecourtyard
                else:
                    outermost_bottom = pad_bounds_for_courtyard[1]
                    expansions['bottom'] = base_expansion + courtyard_line_w

                # Top side
                if body_bounds_adjusted[3] >= pad_bounds_for_courtyard[3]:
                    outermost_top = body_bounds_adjusted[3]
                    expansions['top'] = base_expansion + body_linecourtyard
                else:
                    outermost_top = pad_bounds_for_courtyard[3]
                    expansions['top'] = base_expansion + courtyard_line_w

            elif body_bounds_adjusted:
                outermost_left = body_bounds_adjusted[0]
                outermost_right = body_bounds_adjusted[2]
                outermost_bottom = body_bounds_adjusted[1]
                outermost_top = body_bounds_adjusted[3]
                expansion_val = base_expansion + body_linecourtyard
                expansions = {'left': expansion_val, 'right': expansion_val, 'bottom': expansion_val, 'top': expansion_val}
            elif pad_bounds_for_courtyard:
                outermost_left = pad_bounds_for_courtyard[0]
                outermost_right = pad_bounds_for_courtyard[2]
                outermost_bottom = pad_bounds_for_courtyard[1]
                outermost_top = pad_bounds_for_courtyard[3]
                expansion_val = base_expansion + courtyard_line_w
                expansions = {'left': expansion_val, 'right': expansion_val, 'bottom': expansion_val, 'top': expansion_val}
            else:
                lines.append("! No geometry found for courtyard")

            if 'expansions' in locals():
                # Calculate courtyard bounds with individual expansions
                cy_left = (outermost_left - expansions['left']) * 1000
                cy_right = (outermost_right + expansions['right']) * 1000
                cy_bottom = (outermost_bottom - expansions['bottom']) * 1000
                cy_top = (outermost_top + expansions['top']) * 1000

                # Generate courtyard rectangle
                lines.append(f"LINE {cy_left:.0f} {cy_top:.0f} {cy_right:.0f} {cy_top:.0f} {courtyard_width:.0f} BOARD_GEOMETRY")
                lines.append(f"LINE {cy_right:.0f} {cy_top:.0f} {cy_right:.0f} {cy_bottom:.0f} {courtyard_width:.0f} BOARD_GEOMETRY")
                lines.append(f"LINE {cy_right:.0f} {cy_bottom:.0f} {cy_left:.0f} {cy_bottom:.0f} {courtyard_width:.0f} BOARD_GEOMETRY")
                lines.append(f"LINE {cy_left:.0f} {cy_bottom:.0f} {cy_left:.0f} {cy_top:.0f} {courtyard_width:.0f} BOARD_GEOMETRY")

    lines.append("")
    lines.append("*END*")

    # Save script
    script = '\n'.join(lines)
    output_path = account_settings.get('pads_output_path', os.path.expanduser("~/Documents/PADS"))
    os.makedirs(output_path, exist_ok=True)
    file_name = os.path.join(output_path, f"{footprint_name}_pads_enhanced.pt")

    try:
        with open(file_name, "w") as f:
            f.write(script)
        self.show_script_dialog("Enhanced PADS Script Generated", file_name, script)
    except Exception as e:
        QMessageBox.critical(self, "Error", f"Failed to save PADS script: {str(e)}")

# Helper methods for PADS script generation
def generate_chamfered_body_segments_pads(self, tl, tr, bl, br, chamfer_size, chamfer_corners):
    """Generate chamfered body line segments for PADS"""
    segments = []
    chamfer_size = to_decimal(str(chamfer_size))
    
    # Define corner points with chamfers
    points = []
    
    # Start from top-left, moving clockwise
    if chamfer_corners.get('tl', False):
        points.append((tl[0], tl[1] - chamfer_size))
        points.append((tl[0] + chamfer_size, tl[1]))
    else:
        points.append((tl[0], tl[1]))
    
    # Top edge to top-right
    if chamfer_corners.get('tr', False):
        points.append((tr[0] - chamfer_size, tr[1]))
        points.append((tr[0], tr[1] - chamfer_size))
    else:
        points.append((tr[0], tr[1]))
    
    # Right edge to bottom-right
    if chamfer_corners.get('br', False):
        points.append((br[0], br[1] + chamfer_size))
        points.append((br[0] - chamfer_size, br[1]))
    else:
        points.append((br[0], br[1]))
    
    # Bottom edge to bottom-left
    if chamfer_corners.get('bl', False):
        points.append((bl[0] + chamfer_size, bl[1]))
        points.append((bl[0], bl[1] + chamfer_size))
    else:
        points.append((bl[0], bl[1]))
    
    # Generate line segments
    for i in range(len(points)):
        p1 = points[i]
        p2 = points[(i + 1) % len(points)]
        segments.append((p1, p2))
    
    return segments

def generate_standard_silkscreen_segments_pads(self, tl, tr, bl, br, pad_bounds_list, gap):
    """Generate standard rectangular silkscreen segments with pad gaps for PADS"""
    segments = []
    
    # Top line
    segments.extend(self.generate_silkscreen_segments_with_gaps_pads(
        tl[0], tl[1], tr[0], tr[1], pad_bounds_list, gap, 'horizontal'))
    
    # Right line
    segments.extend(self.generate_silkscreen_segments_with_gaps_pads(
        tr[0], tr[1], br[0], br[1], pad_bounds_list, gap, 'vertical'))
    
    # Bottom line
    segments.extend(self.generate_silkscreen_segments_with_gaps_pads(
        br[0], br[1], bl[0], bl[1], pad_bounds_list, gap, 'horizontal'))
    
    # Left line
    segments.extend(self.generate_silkscreen_segments_with_gaps_pads(
        bl[0], bl[1], tl[0], tl[1], pad_bounds_list, gap, 'vertical'))
    
    return segments

def generate_chamfered_silkscreen_segments_pads(self, tl, tr, bl, br, chamfer_size, chamfer_corners, pad_bounds_list, gap):
    """Generate chamfered silkscreen segments with pad gaps for PADS"""
    segments = []
    
    # Get chamfered body segments first
    body_segments = self.generate_chamfered_body_segments_pads(tl, tr, bl, br, chamfer_size, chamfer_corners)
    
    # For each body segment, check for pad gaps
    for (x1, y1), (x2, y2) in body_segments:
        # Determine if this is horizontal or vertical segment
        if abs(x2 - x1) > abs(y2 - y1):
            orientation = 'horizontal'
        else:
            orientation = 'vertical'
        
        # Generate segments with gaps
        gap_segments = self.generate_silkscreen_segments_with_gaps_pads(
            x1, y1, x2, y2, pad_bounds_list, gap, orientation)
        segments.extend(gap_segments)
    
    return segments

def generate_silkscreen_segments_with_gaps_pads(self, x1, y1, x2, y2, pad_bounds_list, gap, orientation):
    """Generate line segments with gaps where pads would interfere - PADS version"""
    segments = []
    gap_decimal = to_decimal(str(gap))

    if orientation == 'horizontal':
        start_pos = min(x1, x2)
        end_pos = max(x1, x2)
        line_y = y1

        # Find intersections with pads
        intersections = []
        for pad_bounds in pad_bounds_list:
            if not pad_bounds:
                continue
            
            px_min, py_min, px_max, py_max = [to_decimal(str(coord)) for coord in pad_bounds]
            pad_min_x = px_min - gap_decimal
            pad_max_x = px_max + gap_decimal
            pad_min_y = py_min - gap_decimal
            pad_max_y = py_max + gap_decimal

            # Check if horizontal line intersects with expanded pad
            if (line_y >= pad_min_y and line_y <= pad_max_y and
                pad_max_x >= start_pos and pad_min_x <= end_pos):
                
                inter_start = max(start_pos, pad_min_x)
                inter_end = min(end_pos, pad_max_x)
                intersections.append((inter_start, inter_end))

        # Merge overlapping intersections
        merged = self.merge_intervals(intersections)

        # Generate segments between gaps
        current_pos = start_pos
        for gap_start, gap_end in merged:
            if current_pos < gap_start:
                segments.append(((current_pos, line_y), (gap_start, line_y)))
            current_pos = gap_end

        if current_pos < end_pos:
            segments.append(((current_pos, line_y), (end_pos, line_y)))

    else:  # vertical
        start_pos = min(y1, y2)
        end_pos = max(y1, y2)
        line_x = x1

        intersections = []
        for pad_bounds in pad_bounds_list:
            if not pad_bounds:
                continue
            
            px_min, py_min, px_max, py_max = [to_decimal(str(coord)) for coord in pad_bounds]
            pad_min_x = px_min - gap_decimal
            pad_max_x = px_max + gap_decimal
            pad_min_y = py_min - gap_decimal
            pad_max_y = py_max + gap_decimal

            if (line_x >= pad_min_x and line_x <= pad_max_x and
                pad_max_y >= start_pos and pad_min_y <= end_pos):
                
                inter_start = max(start_pos, pad_min_y)
                inter_end = min(end_pos, pad_max_y)
                intersections.append((inter_start, inter_end))

        merged = self.merge_intervals(intersections)

        current_pos = start_pos
        for gap_start, gap_end in merged:
            if current_pos < gap_start:
                segments.append(((line_x, current_pos), (line_x, gap_start)))
            current_pos = gap_end

        if current_pos < end_pos:
            segments.append(((line_x, current_pos), (line_x, end_pos)))

    return segments
