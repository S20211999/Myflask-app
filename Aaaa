
import sys
import os
import json
import math
import os
from pathlib import Path

from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,QDialog,
                            QHBoxLayout, QGridLayout, QLabel, QLineEdit, QSizePolicy,
                            QComboBox, QPushButton, QScrollArea, QFrame,
                            QSpinBox, QDoubleSpinBox, QFileDialog, QMessageBox, QCheckBox,
                            QSplitter, QGroupBox, QToolBar)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer, QRectF, QPointF
from PyQt6.QtGui import QPainter, QPen, QBrush, QColor, QFont, QPalette, QPolygonF, QAction, QPainterPath
import struct
import decimal
from decimal import Decimal, getcontext, ROUND_HALF_UP

# Set decimal precision (adjust as needed for your application)
getcontext().prec = 5
getcontext().rounding = ROUND_HALF_UP

def to_decimal(value, default=0):
    """Convert various input types to Decimal safely"""
    if value is None or value == "":
        return Decimal(str(default))
    try:
        if isinstance(value, str):
            if value.strip() == "":
                return Decimal(str(default))
            return Decimal(value)
        elif isinstance(value, (int, float)):
            return Decimal(str(value))
        elif isinstance(value, Decimal):
            return value
        else:
            return Decimal(str(default))
    except (ValueError, TypeError, decimal.InvalidOperation):
        return Decimal(str(default))

def convert_floats_to_decimals(data):
    """Recursively convert all float values in nested data structures to Decimal"""
    if isinstance(data, dict):
        return {k: convert_floats_to_decimals(v) for k, v in data.items()}
    elif isinstance(data, list):
        return [convert_floats_to_decimals(x) for x in data]
    elif isinstance(data, float):
        return Decimal(str(data))
    else:
        return data



class AccountManager:
    """Manages account settings separate from footprint data"""
    
    SETTINGS_FILE = "account_settings.json"
    
    @staticmethod
    def get_settings_path():
        """Get the path for account settings file"""
        # Store in user's home directory
        home_dir = os.path.expanduser("~")
        settings_dir = os.path.join(home_dir, ".libsienna")
        os.makedirs(settings_dir, exist_ok=True)
        return os.path.join(settings_dir, AccountManager.SETTINGS_FILE)
    
    @staticmethod
    def load_account_settings():
        """Load account settings from JSON file"""
        settings_path = AccountManager.get_settings_path()
        
        # Default settings
        default_settings = {
            'current_user': None,
            'altium_output_path': os.path.expanduser("~/Documents/Altium"),
            'allegro_output_path': os.path.expanduser("~/Documents/Allegro"),
            'pads_output_path': os.path.expanduser("~/Documents/PADS"),
            'xpedition_output_path': os.path.expanduser("~/Documents/Xpedition")
        }
        
        try:
            if os.path.exists(settings_path):
                with open(settings_path, 'r') as f:
                    settings = json.load(f)
                    # Merge with defaults to ensure all keys exist
                    for key, value in default_settings.items():
                        if key not in settings:
                            settings[key] = value
                    return settings
            else:
                return default_settings
        except Exception as e:
            print(f"Error loading account settings: {e}")
            return default_settings
    
    @staticmethod
    def save_account_settings(settings):
        """Save account settings to JSON file"""
        settings_path = AccountManager.get_settings_path()
        
        try:
            with open(settings_path, 'w') as f:
                json.dump(settings, f, indent=4)
            return True
        except Exception as e:
            print(f"Error saving account settings: {e}")
            return False

class AccountDialog(QDialog):
    """Account management dialog"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Account Settings")
        self.setMinimumSize(500, 400)
        self.current_user = None
        self.setup_ui()
        self.load_settings()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(15)
        
        # Title
        title = QLabel("Account Settings")
        title.setStyleSheet("font-size: 16px; font-weight: bold; color: #ffffff; margin-bottom: 10px;")
        layout.addWidget(title)
        
        # User Account Section
        self.setup_user_section(layout)
        
        # Separator
        self.add_separator(layout)
        
        # Output Paths Section
        self.setup_output_paths_section(layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.save_settings)
        button_layout.addWidget(self.save_btn)
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(self.cancel_btn)
        
        layout.addLayout(button_layout)
        
        # Apply dark theme
        self.setup_styling()
    
    def add_separator(self, layout):
        """Add a separator line"""
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setStyleSheet("color: #555;")
        layout.addWidget(separator)
    
    def setup_user_section(self, layout):
        user_group = QGroupBox("User Account")
        user_layout = QVBoxLayout(user_group)
        
        # User display/login
        self.user_display = QLabel("Not logged in")
        self.user_display.setStyleSheet("color: #ffffff; margin: 5px;")
        user_layout.addWidget(self.user_display)
        
        # Login form (initially visible)
        self.login_frame = QFrame()
        login_layout = QGridLayout(self.login_frame)
        
        login_layout.addWidget(QLabel("Username:"), 0, 0)
        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter username")
        login_layout.addWidget(self.username_input, 0, 1)
        
        login_layout.addWidget(QLabel("Password:"), 1, 0)
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText("Enter password")
        login_layout.addWidget(self.password_input, 1, 1)
        
        self.login_btn = QPushButton("Login")
        self.login_btn.clicked.connect(self.handle_login)
        login_layout.addWidget(self.login_btn, 2, 0, 1, 2)
        
        user_layout.addWidget(self.login_frame)
        
        # Logout button (initially hidden)
        self.logout_btn = QPushButton("Logout")
        self.logout_btn.clicked.connect(self.handle_logout)
        self.logout_btn.setVisible(False)
        user_layout.addWidget(self.logout_btn)
        
        layout.addWidget(user_group)
    
    def setup_output_paths_section(self, layout):
        paths_group = QGroupBox("Script Output Paths")
        paths_layout = QGridLayout(paths_group)
        
        # Altium output path
        paths_layout.addWidget(QLabel("Altium Script Output:"), 0, 0)
        path_layout1 = QHBoxLayout()
        self.altium_output_path = QLineEdit()
        self.altium_output_path.setPlaceholderText("Select Altium output directory...")
        path_layout1.addWidget(self.altium_output_path)
        browse_btn1 = QPushButton("Browse...")
        browse_btn1.clicked.connect(lambda: self.browse_output_path(self.altium_output_path, "Altium"))
        browse_btn1.setMaximumWidth(80)
        path_layout1.addWidget(browse_btn1)
        paths_layout.addLayout(path_layout1, 0, 1)
        
        # Allegro output path
        paths_layout.addWidget(QLabel("Allegro Script Output:"), 1, 0)
        path_layout2 = QHBoxLayout()
        self.allegro_output_path = QLineEdit()
        self.allegro_output_path.setPlaceholderText("Select Allegro output directory...")
        path_layout2.addWidget(self.allegro_output_path)
        browse_btn2 = QPushButton("Browse...")
        browse_btn2.clicked.connect(lambda: self.browse_output_path(self.allegro_output_path, "Allegro"))
        browse_btn2.setMaximumWidth(80)
        path_layout2.addWidget(browse_btn2)
        paths_layout.addLayout(path_layout2, 1, 1)
        
        # PADS output path
        paths_layout.addWidget(QLabel("PADS Script Output:"), 2, 0)
        path_layout3 = QHBoxLayout()
        self.pads_output_path = QLineEdit()
        self.pads_output_path.setPlaceholderText("Select PADS output directory...")
        path_layout3.addWidget(self.pads_output_path)
        browse_btn3 = QPushButton("Browse...")
        browse_btn3.clicked.connect(lambda: self.browse_output_path(self.pads_output_path, "PADS"))
        browse_btn3.setMaximumWidth(80)
        path_layout3.addWidget(browse_btn3)
        paths_layout.addLayout(path_layout3, 2, 1)
        
        # Xpedition output path
        paths_layout.addWidget(QLabel("Xpedition Script Output:"), 3, 0)
        path_layout4 = QHBoxLayout()
        self.xpedition_output_path = QLineEdit()
        self.xpedition_output_path.setPlaceholderText("Select Xpedition output directory...")
        path_layout4.addWidget(self.xpedition_output_path)
        browse_btn4 = QPushButton("Browse...")
        browse_btn4.clicked.connect(lambda: self.browse_output_path(self.xpedition_output_path, "Xpedition"))
        browse_btn4.setMaximumWidth(80)
        path_layout4.addWidget(browse_btn4)
        paths_layout.addLayout(path_layout4, 3, 1)
        
        layout.addWidget(paths_group)
    
    def browse_output_path(self, line_edit, tool_name):
        """Browse for output path"""
        path = QFileDialog.getExistingDirectory(
            self,
            f"Select {tool_name} Script Output Directory",
            line_edit.text()
        )
        
        if path:
            line_edit.setText(path)
    
    def handle_login(self):
        username = self.username_input.text().strip()
        password = self.password_input.text().strip()
        
        if not username or not password:
            QMessageBox.warning(self, "Login", "Please enter both username and password")
            return
        
        # Simple mock authentication - replace with real authentication
        if username and password:  # Accept any non-empty credentials for demo
            self.current_user = username
            self.user_display.setText(f"Welcome, {username}")
            self.login_frame.setVisible(False)
            self.logout_btn.setVisible(True)
            
            # Clear password for security
            self.password_input.clear()
            
            QMessageBox.information(self, "Login", f"Successfully logged in as {username}")
        else:
            QMessageBox.warning(self, "Login", "Invalid credentials")
    
    def handle_logout(self):
        self.current_user = None
        self.user_display.setText("Not logged in")
        self.login_frame.setVisible(True)
        self.logout_btn.setVisible(False)
        self.username_input.clear()
        self.password_input.clear()
    
    def load_settings(self):
        """Load account settings"""
        settings = AccountManager.load_account_settings()
        
        self.altium_output_path.setText(settings.get('altium_output_path', os.path.expanduser("~/Documents/Altium")))
        self.allegro_output_path.setText(settings.get('allegro_output_path', os.path.expanduser("~/Documents/Allegro")))
        self.pads_output_path.setText(settings.get('pads_output_path', os.path.expanduser("~/Documents/PADS")))
        self.xpedition_output_path.setText(settings.get('xpedition_output_path', os.path.expanduser("~/Documents/Xpedition")))
        
        # Set user if logged in
        user = settings.get('current_user')
        if user:
            self.current_user = user
            self.user_display.setText(f"Welcome, {user}")
            self.login_frame.setVisible(False)
            self.logout_btn.setVisible(True)
    
    def save_settings(self):
        """Save account settings"""
        settings = {
            'current_user': self.current_user,
            'altium_output_path': self.altium_output_path.text(),
            'allegro_output_path': self.allegro_output_path.text(),
            'pads_output_path': self.pads_output_path.text(),
            'xpedition_output_path': self.xpedition_output_path.text()
        }
        
        if AccountManager.save_account_settings(settings):
            QMessageBox.information(self, "Success", "Account settings saved successfully!")
            self.accept()
        else:
            QMessageBox.critical(self, "Error", "Failed to save account settings!")
    
    def get_account_settings(self):
        """Get current account settings"""
        return {
            'current_user': self.current_user,
            'altium_output_path': self.altium_output_path.text(),
            'allegro_output_path': self.allegro_output_path.text(),
            'pads_output_path': self.pads_output_path.text(),
            'xpedition_output_path': self.xpedition_output_path.text()
        }
    
    def setup_styling(self):
        self.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLabel {
                color: #ffffff;
            }
            QLineEdit {
                background-color: #3c3c3c;
                border: 1px solid #555;
                padding: 5px;
                border-radius: 3px;
                color: #ffffff;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
                color: #ffffff;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
        """)




class LibSiennaFileFormat:
    """Custom file format handler for LibSienna footprint files"""
    MAGIC_HEADER = b'LSFP'
    VERSION = 1

    @staticmethod
    def save_footprint(data, filename):
        """Save footprint data in custom LibSienna format (excluding settings)"""
        try:
            # Create a copy of data without settings that should be stored separately
            footprint_data = data.copy()
            # Remove settings that should be stored separately
            footprint_data.pop('script_output_path', None)
            footprint_data.pop('current_user', None)
            
            with open(filename, 'wb') as f:
                # Write magic header and version
                f.write(LibSiennaFileFormat.MAGIC_HEADER)
                f.write(struct.pack('<I', LibSiennaFileFormat.VERSION))
                
                # Convert data to JSON and compress
                json_data = json.dumps(footprint_data, indent=2)
                compressed_data = json_data.encode('utf-8')
                
                # Write compressed data size and data
                f.write(struct.pack('<I', len(compressed_data)))
                f.write(compressed_data)
                
            print(f"Successfully saved file: {filename}")  # Debug info
            return True
        except Exception as e:
            print(f"Save error: {e}")
            return False

    @staticmethod
    def load_footprint(filename):
        """Load footprint data from custom LibSienna format"""
        try:
            print(f"Attempting to load file: {filename}")  # Debug info
            
            # Check if file exists
            if not os.path.exists(filename):
                print(f"File does not exist: {filename}")
                return None
                
            with open(filename, 'rb') as f:
                # Read and verify magic header
                magic = f.read(4)
                if magic != LibSiennaFileFormat.MAGIC_HEADER:
                    print(f"Invalid file format. Expected {LibSiennaFileFormat.MAGIC_HEADER}, got {magic}")
                    return None
                
                # Read version
                version_data = f.read(4)
                if len(version_data) != 4:
                    print("Could not read version")
                    return None
                    
                version = struct.unpack('<I', version_data)[0]
                print(f"File version: {version}")
                if version != LibSiennaFileFormat.VERSION:
                    print(f"Unsupported version {version}")
                    return None
                
                # Read data size
                size_data = f.read(4)
                if len(size_data) != 4:
                    print("Could not read data size")
                    return None
                    
                data_size = struct.unpack('<I', size_data)[0]
                print(f"Data size: {data_size}")
                
                # Read compressed data
                compressed_data = f.read(data_size)
                if len(compressed_data) != data_size:
                    print(f"Could not read all data. Expected {data_size}, got {len(compressed_data)}")
                    return None
                
                # Decompress and parse JSON
                json_data = compressed_data.decode('utf-8')
                data = json.loads(json_data)
                
                print("Successfully loaded and parsed data")
                return data
                
        except Exception as e:
            print(f"Load error: {e}")
            import traceback
            traceback.print_exc()  # Print full error traceback
            return None


class SettingsManager:
    """Manage application settings separately from footprint data"""
    
    @staticmethod
    def get_settings_file():
        """Get the path to the settings file"""
        home_dir = os.path.expanduser("~")
        settings_dir = os.path.join(home_dir, ".libsienna")
        os.makedirs(settings_dir, exist_ok=True)
        return os.path.join(settings_dir, "settings.json")
    
    @staticmethod
    def save_settings(settings):
        """Save settings to JSON file"""
        try:
            settings_file = SettingsManager.get_settings_file()
            with open(settings_file, 'w') as f:
                json.dump(settings, f, indent=2)
            return True
        except Exception as e:
            print(f"Error saving settings: {e}")
            return False
    
    @staticmethod
    def load_settings():
        """Load settings from JSON file"""
        try:
            settings_file = SettingsManager.get_settings_file()
            if os.path.exists(settings_file):
                with open(settings_file, 'r') as f:
                    return json.load(f)
            return {}
        except Exception as e:
            print(f"Error loading settings: {e}")
            return {}


class PolygonLineRow(QWidget):
    data_changed = pyqtSignal()
    delete_requested = pyqtSignal(object)

    def __init__(self, line_number=1):
        super().__init__()
        self.line_number = line_number
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(5, 2, 5, 2)
        layout.setSpacing(5)

        # Line number label
        self.line_label = QLabel(f"Line {self.line_number}:")
        self.line_label.setMinimumWidth(60)
        layout.addWidget(self.line_label)

        # Line size
        layout.addWidget(QLabel("Size:"))
        self.line_size = QLineEdit()
        self.line_size.setText("1.0")
        self.line_size.setMaximumWidth(80)
        layout.addWidget(self.line_size)

        # Direction
        layout.addWidget(QLabel("Direction:"))
        self.direction = QComboBox()
        self.direction.addItems(['right', 'down', 'left', 'up'])
        self.direction.setMaximumWidth(80)
        layout.addWidget(self.direction)

        # Corner type
        layout.addWidget(QLabel("Corner:"))
        self.corner_type = QComboBox()
        self.corner_type.addItems(['90-degree', 'chamfer', 'fillet'])
        self.corner_type.setMaximumWidth(100)
        layout.addWidget(self.corner_type)

        # Corner size
        layout.addWidget(QLabel("Corner Size:"))
        self.corner_size = QLineEdit()
        self.corner_size.setText("0")
        self.corner_size.setMaximumWidth(80)
        layout.addWidget(self.corner_size)

        # Delete button
        self.delete_btn = QPushButton("Delete")
        self.delete_btn.setMaximumWidth(60)
        layout.addWidget(self.delete_btn)

        layout.addStretch()

    def connect_signals(self):
        self.line_size.textChanged.connect(self.data_changed.emit)
        self.direction.currentTextChanged.connect(self.data_changed.emit)
        self.corner_type.currentTextChanged.connect(self.data_changed.emit)
        self.corner_size.textChanged.connect(self.data_changed.emit)
        self.delete_btn.clicked.connect(lambda: self.delete_requested.emit(self))

    def get_data(self):
        return {
            'line_size': to_decimal(self.line_size.text()) if self.line_size.text() else 1.0,
            'direction': self.direction.currentText(),
            'corner_type': self.corner_type.currentText(),
            'corner_size': to_decimal(self.corner_size.text()) if self.corner_size.text() else 0.0
        }

    def set_data(self, data):
        self.line_size.setText(str(data.get('line_size', 1.0)))
        self.direction.setCurrentText(data.get('direction', 'right'))
        self.corner_type.setCurrentText(data.get('corner_type', '90-degree'))
        self.corner_size.setText(str(data.get('corner_size', 0)))

class CustomPolygonWidget(QWidget):
    data_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.polygon_lines = []
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(5)

        # Header
        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel("Custom Polygon Definition:"))
        
        add_line_btn = QPushButton("+ Add Line")
        add_line_btn.clicked.connect(self.add_polygon_line)
        add_line_btn.setMaximumWidth(100)
        header_layout.addWidget(add_line_btn)
        header_layout.addStretch()
        
        layout.addLayout(header_layout)

        # Lines container
        self.lines_widget = QWidget()
        self.lines_layout = QVBoxLayout(self.lines_widget)
        self.lines_layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.lines_widget)

        # Add initial line
        self.add_polygon_line()

    def add_polygon_line(self):
        line_row = PolygonLineRow(len(self.polygon_lines) + 1)
        line_row.data_changed.connect(self.data_changed.emit)
        line_row.delete_requested.connect(self.delete_polygon_line)
        
        self.polygon_lines.append(line_row)
        self.lines_layout.addWidget(line_row)

    def delete_polygon_line(self, line_row):
        if len(self.polygon_lines) > 1: # Keep at least one line
            self.polygon_lines.remove(line_row)
            line_row.setParent(None)
            self.update_line_numbers()

    def update_line_numbers(self):
        """Update line numbers after add/delete operations"""
        for i, line_row in enumerate(self.polygon_lines):
            line_row.line_number = i + 1
            # Update the label text
            line_row.layout().itemAt(0).widget().setText(f"Line {i + 1}:")

    def get_data(self):
        """Get polygon data"""
        return {
            'lines': [line.get_data() for line in self.polygon_lines]
        }

    def set_data(self, data):
        """Set polygon data"""
        # Clear existing lines
        for line in self.polygon_lines[:]:
            self.delete_polygon_line(line)
        
        # Add lines from data
        lines_data = data.get('lines', [{'line_size': 1.0, 'direction': 'right', 'corner_type': '90-degree', 'corner_size': 0}])
        for line_data in lines_data:
            self.add_polygon_line()
            self.polygon_lines[-1].set_data(line_data)

class FootprintRenderer(QWidget):
    def __init__(self):
        super().__init__()
        self.setMinimumSize(400, 400)
        self.footprint_data = {}
        self.auto_fit = True

        self.zoom_factor = Decimal('1.0')
        self.offset_x = Decimal('0.0')
        self.offset_y = Decimal('0.0')
        self.origin_offset_x = Decimal('0.0')
        self.origin_offset_y = Decimal('0.0')
        
        self.setStyleSheet("background-color: #2b2b2b; border: 1px solid #555;")
        self.selected_pads = set()
        self.setup_dimension_controls()


    def setup_dimension_controls(self):
        """Create overlay dimension control widgets"""
        # Air Gap Dimensions toggle
        self.show_airgap_checkbox = QCheckBox("Air Gap Dimensions ", self)
        self.show_airgap_checkbox.setChecked(True)
        self.show_airgap_checkbox.move(10, 10)
        self.show_airgap_checkbox.setStyleSheet("""
            QCheckBox {
                color: #00FFFF;
                background-color: rgba(0,0,0,180);
                padding: 4px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
            }
            QCheckBox::indicator {
                width: 14px;
                height: 14px;
            }
            QCheckBox::indicator:checked {
                background-color: #00FFFF;
            }
        """)

        # Pitch Dimensions toggle
        self.show_pitch_checkbox = QCheckBox(" Pitch Dimensions", self)
        self.show_pitch_checkbox.setChecked(False)
        self.show_pitch_checkbox.move(10, 40)
        self.show_pitch_checkbox.setStyleSheet("""
            QCheckBox {
                color: #FFA500;
                background-color: rgba(0,0,0,180);
                padding: 4px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
            }
            QCheckBox::indicator {
                width: 14px;
                height: 14px;
            }
            QCheckBox::indicator:checked {
                background-color: #FFA500;
            }
        """)

        # Clear All Dimensions button
        self.clear_dims_btn = QPushButton("Clear All Dimensions", self)
        self.clear_dims_btn.move(10, 70)
        self.clear_dims_btn.setMaximumWidth(160)
        self.clear_dims_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(68,68,68,200);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
                border: 1px solid #666;
            }
            QPushButton:hover {
                background-color: rgba(88,88,88,220);
            }
            QPushButton:pressed {
                background-color: rgba(48,48,48,200);
            }
        """)



        # Connect signals
        self.show_airgap_checkbox.stateChanged.connect(self.on_dimension_toggle)
        self.show_pitch_checkbox.stateChanged.connect(self.on_dimension_toggle)
        self.clear_dims_btn.clicked.connect(self.on_clear_dimensions)





    def mousePressEvent(self, event):
        """Handle mouse clicks for pad selection"""
        pos = event.position()
        
        # Convert all coordinates to Decimal before arithmetic
        center_x = to_decimal(str(self.width() / 2))
        center_y = to_decimal(str(self.height() / 2))
        
        # Convert PyQt position coordinates to Decimal
        pos_x = to_decimal(str(pos.x()))
        pos_y = to_decimal(str(pos.y()))
        
        # Account for zoom and offset - ALL DECIMAL ARITHMETIC
        world_x = (pos_x - center_x - self.offset_x) / self.zoom_factor
        world_y = -(pos_y - center_y - self.offset_y) / self.zoom_factor  # Y-axis flipped

        # Check if click is on any pad
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        clicked_pad = None
        
        # Convert world coordinates to float for comparison with pad bounds
        world_x_float = float(world_x)
        world_y_float = float(world_y)
        
        for i, bounds in enumerate(pad_bounds_list):
            if bounds:
                min_x, min_y, max_x, max_y = bounds
                if min_x <= world_x_float <= max_x and min_y <= world_y_float <= max_y:
                    clicked_pad = i
                    break

        if clicked_pad is not None:
            # Toggle pad selection
            if clicked_pad in self.selected_pads:
                self.selected_pads.remove(clicked_pad)
            else:
                # Limit to 2 pads maximum
                if len(self.selected_pads) >= 2:
                    # Remove oldest selection (FIFO)
                    oldest_pad = next(iter(self.selected_pads))
                    self.selected_pads.remove(oldest_pad)
                self.selected_pads.add(clicked_pad)
        else:
            # Click outside pads - clear selection
            self.selected_pads.clear()

        self.update()  # Repaint to show selection changes
    # Repaint to show selection changes


    def resizeEvent(self, event):
        """Handle resize events to position settings button"""
        super().resizeEvent(event)
        # Position settings button in top right corner
        if hasattr(self, 'settings_btn'):
            self.settings_btn.move(self.width() - 90, 10)


    def on_dimension_toggle(self):
        """Handle dimension toggle changes"""
        self.update()  # Trigger repaint

    def on_clear_dimensions(self):
        """Clear all dimension displays and selections"""
        self.show_airgap_checkbox.setChecked(False)
        self.show_pitch_checkbox.setChecked(False)
        self.selected_pads.clear()  # Clear pad selections
        self.update()

    def update_footprint(self, data):
        self.footprint_data = data
        # Clear cached absolute positions when data changes
        self._absolute_positions = None
        if self.auto_fit:
            self.fit_to_view()
        self.update()

    def on_fit_to_view(self):
        """Handle fit to view button click"""
        self.auto_fit = True
        self.fit_to_view()
        self.update()        

    def fit_to_view(self):
        if not self.footprint_data.get('padstacks') and not all(k in self.footprint_data for k in ['body_length', 'body_width']):
            return

        # Reset offsets for auto-fit
        self.offset_x = Decimal('0.0')
        self.offset_y = Decimal('0.0')

        # Calculate body bounds
        body_bounds = None
        if all(k in self.footprint_data for k in ['body_length', 'body_width']):
            length = to_decimal(self.footprint_data['body_length'])
            width = to_decimal(self.footprint_data['body_width'])
            half_length = length / Decimal('2')
            half_width = width / Decimal('2')
            body_bounds = [-half_length, -half_width, half_length, half_width]

        # Calculate pad bounds
        pad_bounds = self.calculate_all_pads_bounds()

        # Determine outermost bounds
        if body_bounds and pad_bounds:
            min_x = min(body_bounds[0], pad_bounds[0])
            min_y = min(body_bounds[1], pad_bounds[1])
            max_x = max(body_bounds[2], pad_bounds[2])
            max_y = max(body_bounds[3], pad_bounds[3])
        elif body_bounds:
            min_x, min_y, max_x, max_y = body_bounds
        elif pad_bounds:
            min_x, min_y, max_x, max_y = pad_bounds
        else:
            return

        # Add courtyard expansion
        courtyard = to_decimal(self.footprint_data.get('courtyard_expansion', '0.25'))
        min_x -= courtyard
        max_x += courtyard
        min_y -= courtyard
        max_y += courtyard

        # Calculate zoom to fit
        if max_x > min_x and max_y > min_y:
            margin = Decimal('20')
            width_available = Decimal(str(self.width())) - Decimal('2') * margin
            height_available = Decimal(str(self.height())) - Decimal('2') * margin
            
            zoom_x = width_available / (max_x - min_x)
            zoom_y = height_available / (max_y - min_y)
            self.zoom_factor = min(zoom_x, zoom_y, Decimal('110'))  # Max zoom limit

        self.update()

    def calculate_pad_bounds(self, pad):
        """Calculate bounding box for a pad"""
        try:
            x = to_decimal(pad.get('x_offset', 0))
            y = to_decimal(pad.get('y_offset', 0))
        except (ValueError, TypeError):
            x, y = 0, 0
            
        pad_type = pad['type']

        if pad_type == 'square':
            try:
                size = to_decimal(pad.get('size', 1))
                return [x - size/2, y - size/2, x + size/2, y + size/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong']:
            try:
                length = to_decimal(pad.get('length', 1))
                width = to_decimal(pad.get('width', 1))
                return [x - length/2, y - width/2, x + length/2, y + width/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

        elif pad_type in ['round']:
            try:
                diameter = to_decimal(pad.get('diameter', 1))
                return [x - diameter/2, y - diameter/2, x + diameter/2, y + diameter/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]
            
        elif pad_type == 'D-shape':
            try:
                length = to_decimal(pad.get('length', 1))
                width = to_decimal(pad.get('width', 1))
                # D-shape can also be rotated, so handle rotation here too
                rotation = pad.get('rotation', 0)
                try:
                    rotation_rad = math.radians(float(to_decimal(str(rotation))))
                except (ValueError, TypeError):
                    rotation_rad = 0
                    
                if rotation_rad != 0:
                    return self._calculate_rotated_bounds(x, y, length, width, rotation_rad)
                else:
                    return [x - length/2, y - width/2, x + length/2, y + width/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]
            
        elif pad_type == 'PTH_rectangle':
            try:
                pad_length = to_decimal(pad.get('pad_length', 2.0))
                pad_width = to_decimal(pad.get('pad_width', 1.2))
                
                # Handle rotation
                rotation = pad.get('rotation', 0)
                try:
                    rotation_rad = math.radians(float(to_decimal(str(rotation))))
                except (ValueError, TypeError):
                    rotation_rad = 0
                    
                if rotation_rad != 0:
                    return self._calculate_rotated_bounds(x, y, pad_length, pad_width, rotation_rad)
                else:
                    return [x - pad_length/2, y - pad_width/2, x + pad_length/2, y + pad_width/2]
            except (ValueError, TypeError):
                return [x - 1.0, y - 0.6, x + 1.0, y + 0.6]
            
        elif pad_type == 'NPTH_rectangle':
            try:
                hole_length = to_decimal(pad.get('hole_length', 1.5))
                hole_width = to_decimal(pad.get('hole_width', 0.8))
                
                # Handle rotation
                rotation = pad.get('rotation', 0)
                try:
                    rotation_rad = math.radians(float(to_decimal(str(rotation))))
                except (ValueError, TypeError):
                    rotation_rad = 0

                if rotation_rad != 0:
                    return self._calculate_rotated_bounds(x, y, hole_length, hole_width, rotation_rad)
                else:
                    return [x - hole_length/2, y - hole_width/2, x + hole_length/2, y + hole_width/2]
            except (ValueError, TypeError):
                return [x - 0.75, y - 0.4, x + 0.75, y + 0.4]

        elif pad_type in ['PTH', 'NPTH']:
            try:
                if pad_type == 'PTH':
                    diameter = to_decimal(pad.get('pad_diameter', 1.2))
                else:
                    diameter = to_decimal(pad.get('hole_diameter', 0.8))
                return [x - diameter/2, y - diameter/2, x + diameter/2, y + diameter/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            try:
                if pad_type == 'PTH_oblong':
                    length = to_decimal(pad.get('pad_length', 2.0))
                    width = to_decimal(pad.get('pad_width', 1.2))
                else:
                    length = to_decimal(pad.get('hole_length', 1.5))
                    width = to_decimal(pad.get('hole_width', 0.8))
                
                # Handle rotation
                rotation = pad.get('rotation', 0)
                try:
                    rotation_rad = math.radians(float(to_decimal(str(rotation))))
                except (ValueError, TypeError):
                    rotation_rad = 0
                    
                if rotation_rad != 0:
                    return self._calculate_rotated_bounds(x, y, length, width, rotation_rad)
                else:
                    return [x - length/2, y - width/2, x + length/2, y + width/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

        elif pad_type == 'custom':
            # Calculate bounds for custom polygon
            polygon_points = self.calculate_polygon_points(pad)
            if polygon_points:
                xs = [p.x() for p in polygon_points]
                ys = [p.y() for p in polygon_points]
                return [min(xs), min(ys), max(xs), max(ys)]

        return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

    def _calculate_rotated_bounds(self, center_x, center_y, length, width, rotation_rad):
        """Helper method to calculate bounds for a rotated rectangle"""
        try:
            # Calculate half dimensions
            half_length = length / 2
            half_width = width / 2
            
            # Define the four corners of the rectangle relative to center
            corners = [
                (-half_length, -half_width),  # bottom-left
                (half_length, -half_width),   # bottom-right
                (half_length, half_width),    # top-right
                (-half_length, half_width)    # top-left
            ]
            
            # Rotate each corner
            cos_r = math.cos(rotation_rad)
            sin_r = math.sin(rotation_rad)
            
            rotated_corners = []
            for cx, cy in corners:
                # Apply rotation matrix
                rx = float(cx) * cos_r - float(cy) * sin_r
                ry = float(cx) * sin_r + float(cy) * cos_r
                rotated_corners.append((rx, ry))
            
            # Find bounding box of rotated corners
            xs = [corner[0] for corner in rotated_corners]
            ys = [corner[1] for corner in rotated_corners]
            
            min_x = center_x + to_decimal(str(min(xs)))
            max_x = center_x + to_decimal(str(max(xs)))
            min_y = center_y + to_decimal(str(min(ys)))
            max_y = center_y + to_decimal(str(max(ys)))
            
            return [min_x, min_y, max_x, max_y]
            
        except Exception as e:
            print(f"Error calculating rotated bounds: {e}")
            # Fallback to original rectangle bounds
            half_length = length / 2
            half_width = width / 2
            return [center_x - half_length, center_y - half_width, center_x + half_length, center_y + half_width]


    def calculate_polygon_points(self, pad):
        """Calculate polygon points from line definitions with proper corner handling"""
        lines_data = pad.get('polygon_data', {}).get('lines', [])
        if not lines_data:
            return []

        raw_points = []
        try:
            current_x = to_decimal(pad.get('x_offset', 0))
            current_y = to_decimal(pad.get('y_offset', 0))
        except (ValueError, TypeError):
            current_x, current_y = 0, 0
            
        raw_points.append((current_x, current_y))

        for line_data in lines_data:
            try:
                line_size = to_decimal(line_data.get('line_size', 1.0))
            except (ValueError, TypeError):
                line_size = 1.0
                
            direction = line_data.get('direction', 'right')

            if direction == 'right':
                current_x += line_size
            elif direction == 'down':
                current_y -= line_size
            elif direction == 'left':
                current_x -= line_size
            elif direction == 'up':
                current_y += line_size

            raw_points.append((current_x, current_y))

        final_points = []
        # Fix these lines:
        final_points.append(QPointF(raw_points[0][0], raw_points[0][1]))  # was missing 


        for i in range(1, len(raw_points) - 1):
            prev_point = raw_points[i-1]
            curr_point = raw_points[i]
            next_point = raw_points[i+1]

            line_data = lines_data[i-1]
            corner_type = line_data.get('corner_type', '90-degree')
            try:
                corner_size = to_decimal(line_data.get('corner_size', 0))
            except (ValueError, TypeError):
                corner_size = 0

            if corner_type == '90-degree' or corner_size == 0:
                final_points.append(QPointF(curr_point[0], curr_point[1]))
            elif corner_type == 'chamfer':
                chamfer_points = self.calculate_chamfer_points(
                    QPointF(prev_point[0], prev_point[1]),  # FIXED
                    QPointF(curr_point[0], curr_point[1]),  # FIXED
                    QPointF(next_point[0], next_point[1]),  # FIXED,
                    corner_size
                )
                final_points.extend(chamfer_points)
            elif corner_type == 'fillet':
                fillet_points = self.calculate_fillet_points(
                    QPointF(prev_point[0], prev_point[1]),   # FIXED
                    QPointF(curr_point[0], curr_point[1]),   # FIXED
                    QPointF(next_point[0], next_point[1]),   #
                    corner_size
                )
                final_points.extend(fillet_points)

        final_points.append(QPointF(raw_points[-1][0], raw_points[-1][1]))
        return final_points

    def calculate_all_pads_bounds(self):
        """Calculate bounding box for all copper pads"""
        if not self.footprint_data.get('padstacks'):
            return None

        min_x = min_y = to_decimal('inf')
        max_x = max_y = to_decimal('-inf')

        for pad in self.footprint_data['padstacks']:
            pad_bounds = self.calculate_pad_bounds(pad)
            if pad_bounds:
                min_x = min(min_x, pad_bounds[0])
                min_y = min(min_y, pad_bounds[1])
                max_x = max(max_x, pad_bounds[2])
                max_y = max(max_y, pad_bounds[3])
        if min_x == to_decimal('inf'):
            return None

        return [min_x, min_y, max_x, max_y]

    def get_individual_pad_bounds(self):
        """Get bounding box for each individual pad using relative positions"""
        if not self.footprint_data.get('padstacks'):
            return []

        pad_bounds_list = []
        for pad in self.footprint_data['padstacks']:
            pad_bounds = self.calculate_pad_bounds(pad)
            if pad_bounds:
                pad_bounds_list.append(pad_bounds)
        return pad_bounds_list



    def get_individual_pad_bounds_absolute(self):
        """Get bounding box for each individual pad using absolute positions"""
        if not self.footprint_data.get('padstacks'):
            return []

        pad_bounds_list = []
        for i, pad in enumerate(self.footprint_data['padstacks']):
            pad_bounds = self.calculate_pad_bounds_absolute(pad, i)
            if pad_bounds:
                pad_bounds_list.append(pad_bounds)
        
        return pad_bounds_list

    def calculate_pad_bounds_absolute(self, pad, pad_index):
        """Calculate bounding box for a pad using absolute position"""
        absolute_positions = getattr(self, '_absolute_positions', None)
        if absolute_positions is None:
            absolute_positions = self.calculate_pad_absolute_positions()
            self._absolute_positions = absolute_positions

        if pad_index in absolute_positions:
            x, y = absolute_positions[pad_index]
        else:
            try:
                x = to_decimal(pad.get('x_offset', 0))
                y = to_decimal(pad.get('y_offset', 0))
            except (ValueError, TypeError):
                x, y = 0, 0

        pad_type = pad['type']

        if pad_type == 'square':
            try:
                size = to_decimal(pad.get('size', 1))
                return [x - size/2, y - size/2, x + size/2, y + size/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong']:
            try:
                length = to_decimal(pad.get('length', 1))
                width = to_decimal(pad.get('width', 1))
                return [x - length/2, y - width/2, x + length/2, y + width/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

        elif pad_type in ['round']:
            try:
                diameter = to_decimal(pad.get('diameter', 1))
                return [x - diameter/2, y - diameter/2, x + diameter/2, y + diameter/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

        elif pad_type == 'D-shape':
            try:
                length = to_decimal(pad.get('length', 1))
                width = to_decimal(pad.get('width', 1))
                # ADD ROTATION HANDLING FOR D-SHAPE
                rotation = pad.get('rotation', 0)
                try:
                    rotation_rad = math.radians(float(to_decimal(str(rotation))))
                except (ValueError, TypeError):
                    rotation_rad = 0
                    
                if rotation_rad != 0:
                    return self._calculate_rotated_bounds(x, y, length, width, rotation_rad)
                else:
                    return [x - length/2, y - width/2, x + length/2, y + width/2]
            except (ValueError, TypeError):
                return [x - 0.5, y - 0.5, x + 0.5, y + 0.5]

        elif pad_type in ['PTH', 'NPTH']:
            try:
                if pad_type == 'PTH':
                    diameter = to_decimal(pad.get('pad_diameter', 1.2))
                else:
                    diameter = to_decimal(pad.get('hole_diameter', 0.8))
                return [x - diameter/2, y - diameter/2, x + diameter/2, y + diameter/2]
            except (ValueError, TypeError):
                return [x - 0.6, y - 0.6, x + 0.6, y + 0.6]

        elif pad_type == 'PTH_rectangle':  # ADD ROTATION HANDLING
            try:
                pad_length = to_decimal(pad.get('pad_length', 2.0))
                pad_width = to_decimal(pad.get('pad_width', 1.2))
                
                # Handle rotation
                rotation = pad.get('rotation', 0)
                try:
                    rotation_rad = math.radians(float(to_decimal(str(rotation))))
                except (ValueError, TypeError):
                    rotation_rad = 0
                    
                if rotation_rad != 0:
                    return self._calculate_rotated_bounds(x, y, pad_length, pad_width, rotation_rad)
                else:
                    return [x - pad_length/2, y - pad_width/2, x + pad_length/2, y + pad_width/2]
            except (ValueError, TypeError):
                return [x - 1.0, y - 0.6, x + 1.0, y + 0.6]

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:  # ADD ROTATION HANDLING
            try:
                if pad_type == 'PTH_oblong':
                    length = to_decimal(pad.get('pad_length', 2.0))
                    width = to_decimal(pad.get('pad_width', 1.2))
                else:
                    length = to_decimal(pad.get('hole_length', 1.5))
                    width = to_decimal(pad.get('hole_width', 0.8))
                
                # Handle rotation
                rotation = pad.get('rotation', 0)
                try:
                    rotation_rad = math.radians(float(to_decimal(str(rotation))))
                except (ValueError, TypeError):
                    rotation_rad = 0
                    
                if rotation_rad != 0:
                    return self._calculate_rotated_bounds(x, y, length, width, rotation_rad)
                else:
                    return [x - length/2, y - width/2, x + length/2, y + width/2]
            except (ValueError, TypeError):
                return [x - 1.0, y - 0.6, x + 1.0, y + 0.6]
            
        elif pad_type == 'NPTH_rectangle':
            try:
                hole_length = to_decimal(pad.get('hole_length', 1.5))
                hole_width = to_decimal(pad.get('hole_width', 0.8))
                rotation = pad.get('rotation', 0)
                                
                try:
                    rotation_rad = math.radians(float(to_decimal(str(rotation))))
                except (ValueError, TypeError):
                    rotation_rad = 0

                if rotation_rad != 0:
                    bounds = self._calculate_rotated_bounds(x, y, hole_length, hole_width, rotation_rad)
                    return bounds
                else:
                    bounds = [x - hole_length/2, y - hole_width/2, x + hole_length/2, y + hole_width/2]
                    return bounds
            except (ValueError, TypeError):
                half_l = Decimal('0.75')
                half_w = Decimal('0.4')
                return [x - half_l, y - half_w, x + half_l, y + half_w]
        
        elif pad_type == 'custom':
            # Handle custom polygon pads with absolute positioning
            polygon_points = self.calculate_polygon_points_absolute(pad, x, y)
            if polygon_points:
                xs = [p.x() for p in polygon_points]
                ys = [p.y() for p in polygon_points]
                return [min(xs), min(ys), max(xs), max(ys)]

        half = Decimal('0.5')
        return [x - half, y - half, x + half, y + half]

    def calculate_polygon_points_absolute(self, pad, abs_x, abs_y):
        """Calculate polygon points using absolute position"""
        lines_data = pad.get('polygon_data', {}).get('lines', [])
        if not lines_data:
            return []

        raw_points = []
        current_x = abs_x
        current_y = abs_y
        raw_points.append((current_x, current_y))

        for line_data in lines_data:
            try:
                line_size = to_decimal(line_data.get('line_size', 1.0))
            except (ValueError, TypeError):
                line_size = 1.0
                
            direction = line_data.get('direction', 'right')

            if direction == 'right':
                current_x += line_size
            elif direction == 'down':
                current_y -= line_size
            elif direction == 'left':
                current_x -= line_size
            elif direction == 'up':
                current_y += line_size

            raw_points.append((current_x, current_y))

        final_points = []
        final_points.append(QPointF(raw_points[0][0], raw_points[0][1]))

        for i in range(1, len(raw_points) - 1):
            prev_point = raw_points[i-1]
            curr_point = raw_points[i]
            next_point = raw_points[i+1]

            line_data = lines_data[i-1]
            corner_type = line_data.get('corner_type', '90-degree')
            try:
                corner_size = to_decimal(line_data.get('corner_size', 0))
            except (ValueError, TypeError):
                corner_size = 0

            if corner_type == '90-degree' or corner_size == 0:
                final_points.append(QPointF(curr_point[0], curr_point[1]))
            elif corner_type == 'chamfer':
                chamfer_points = self.calculate_chamfer_points(
                    QPointF(prev_point[0], prev_point[1]),
                    QPointF(curr_point[0], curr_point[1]),
                    QPointF(next_point[0], next_point[1]),
                    corner_size
                )
                final_points.extend(chamfer_points)
            elif corner_type == 'fillet':
                fillet_points = self.calculate_fillet_points(
                    QPointF(prev_point[0], prev_point[1]),
                    QPointF(curr_point[0], curr_point[1]),
                    QPointF(next_point[0], next_point[1]),
                    corner_size
                )
                final_points.extend(fillet_points)

        final_points.append(QPointF(raw_points[-1][0], raw_points[-1][1]))
        return final_points

    def calculate_pad_absolute_positions(self):
        """Calculate absolute positions for all pads considering offset_from"""
        if not self.footprint_data.get('padstacks'):
            return {}

        pads = self.footprint_data['padstacks']
        resolver = PadPositionResolver(pads)
        positions = {}

        for i, pad in enumerate(pads):
            try:
                abs_x, abs_y = resolver.get_absolute_position(pad)  # This will now work safely
                positions[i] = (abs_x, abs_y)
            except Exception as e:
                print(f"Error calculating position for pad {i}: {e}")
                # Fallback to direct offset
                try:
                    x = to_decimal(pad.get('x_offset', 0))
                    y = to_decimal(pad.get('y_offset', 0))
                    positions[i] = (x, y)
                except (ValueError, TypeError):
                    positions[i] = (0, 0)

        return positions

    def calculate_chamfer_points(self, p1, p2, p3, chamfer_size):
        """Calculate chamfer points for corner at p2"""
        def point_along_line(p_start, p_end, dist):
            vx = p_end.x() - p_start.x()
            vy = p_end.y() - p_start.y()
            length = math.sqrt(vx*vx + vy*vy)
            if length == 0:
                return p_start
            scale = to_decimal(str(dist)) / to_decimal(str(length))
            return QPointF(
            float(to_decimal(str(p_start.x())) + to_decimal(str(vx)) * scale), 
            float(to_decimal(str(p_start.y())) + to_decimal(str(vy)) * scale)
        )

        cp1 = point_along_line(p2, p1, chamfer_size)
        cp2 = point_along_line(p2, p3, chamfer_size)
        return [cp1, cp2]

    def calculate_fillet_points(self, p1, p2, p3, radius, segments=8):
        """Calculate arc points for fillet at corner p2"""
        def normalize(v):
            length = math.sqrt(v[0]**2 + v[1]**2)
            if length == 0:
                return (0.0, 0.0)
            return (v[0] / length, v[1] / length)

        v1 = (p1.x() - p2.x(), p1.y() - p2.y())
        v2 = (p3.x() - p2.x(), p3.y() - p2.y())

        n1 = normalize(v1)
        n2 = normalize(v2)

        # Dot product
        dot = max(min(n1[0] * n2[0] + n1[1] * n2[1], 1), -1)
        angle = math.acos(dot)

        if angle < 0.01:
            return [p2]

        # FIX: Convert all math results to Decimal before arithmetic
        radius_decimal = to_decimal(str(radius))
        angle_half = angle / 2
        tan_half_angle = math.tan(angle_half)
        
        # Convert tan result to Decimal before division
        tangent_length = radius_decimal / to_decimal(str(tan_half_angle))

        tp1 = QPointF(
            float(to_decimal(str(p2.x())) + to_decimal(str(n1[0])) * tangent_length), 
            float(to_decimal(str(p2.y())) + to_decimal(str(n1[1])) * tangent_length)
        )
        tp2 = QPointF(
            float(to_decimal(str(p2.x())) + to_decimal(str(n2[0])) * tangent_length),
            float(to_decimal(str(p2.y())) + to_decimal(str(n2[1])) * tangent_length)
        )

        # Bisector
        bisector = normalize(((n1[0] + n2[0]) / 2, (n1[1] + n2[1]) / 2))
        
        # FIX: Convert sin result to Decimal before division
        sin_half_angle = math.sin(angle_half)
        dist_to_center = radius_decimal / to_decimal(str(sin_half_angle))

        center = QPointF(
            float(to_decimal(str(p2.x())) + to_decimal(str(bisector[0])) * dist_to_center),
            float(to_decimal(str(p2.y())) + to_decimal(str(bisector[1])) * dist_to_center)
        )

        start_angle = math.atan2(tp1.y() - center.y(), tp1.x() - center.x())
        end_angle = math.atan2(tp2.y() - center.y(), tp2.x() - center.x())

        cross = (tp1.x() - center.x()) * (tp2.y() - center.y()) - (tp1.y() - center.y()) * (tp2.x() - center.x())

        points = []
        for i in range(segments + 1):
            t = i / segments
            if cross > 0:
                angle_t = start_angle + t * (end_angle - start_angle)
            else:
                if end_angle > start_angle:
                    end_angle -= 2 * math.pi
                angle_t = start_angle + t * (end_angle - start_angle)

            # FIX: Convert trigonometric results to Decimal before arithmetic
            cos_result = math.cos(angle_t)
            sin_result = math.sin(angle_t)
            
            x = float(to_decimal(str(center.x())) + radius_decimal * to_decimal(str(cos_result)))
            y = float(to_decimal(str(center.y())) + radius_decimal * to_decimal(str(sin_result)))
            
            points.append(QPointF(x, y))

        return points

    def draw_selected_pads_highlight(self, painter):
        """Draw selection highlights on selected pads"""
        if not self.selected_pads:
            return

        # Draw selection highlights
        painter.setPen(QPen(QColor("#FF00FF"), 3/self.zoom_factor)) # Magenta highlight
        painter.setBrush(QBrush()) # No fill

        pad_bounds_list = self.get_individual_pad_bounds_absolute()

        for pad_index in self.selected_pads:
            if pad_index < len(pad_bounds_list):
                bounds = pad_bounds_list[pad_index]
                if bounds:
                    # Convert bounds to Decimal for consistent arithmetic
                    min_x = to_decimal(str(bounds[0]))
                    min_y = to_decimal(str(bounds[1]))
                    max_x = to_decimal(str(bounds[2]))
                    max_y = to_decimal(str(bounds[3]))
                    
                    # Draw highlight rectangle slightly larger than pad
                    margin = to_decimal('0.1')
                    painter.drawRect(QRectF(
                        float(min_x - margin),
                        float(min_y - margin),
                        float(max_x - min_x + 2*margin),
                        float(max_y - min_y + 2*margin)
                    ))

    def draw_fiducials(self, painter):
        """Draw fiducial markers with keepout - only 2 at top-right and bottom-left corners"""
        if not self.footprint_data.get('fiducials_enabled', False):
            return

        # Get settings from the settings panel directly
        try:
            diameter = to_decimal(self.footprint_data.get('settings', {}).get('fiducial_diameter', 1.0))
            mask_opening = to_decimal(self.footprint_data.get('settings', {}).get('fiducial_mask_opening', 2.0))
            keepout_diameter = to_decimal(self.footprint_data.get('settings', {}).get('fiducial_keepout_diameter', 3.0))
            x_offset = to_decimal(self.footprint_data.get('settings', {}).get('fiducial_x_offset', 2.0))
            y_offset = to_decimal(self.footprint_data.get('settings', {}).get('fiducial_y_offset', 2.0))
            body_length = to_decimal(self.footprint_data.get('body_length', 5.0))
            body_width = to_decimal(self.footprint_data.get('body_width', 3.0))
        except (ValueError, TypeError):
            # Use default values if settings are invalid
            diameter = 1.0
            mask_opening = 2.0
            keepout_diameter = 3.0
            x_offset = 2.0
            y_offset = 2.0
            body_length = 5.0
            body_width = 3.0

        # Calculate body corners considering origin offset
        body_left = self.origin_offset_x
        body_right = self.origin_offset_x + body_length
        body_bottom = self.origin_offset_y - body_width  # Y-axis is flipped
        body_top = self.origin_offset_y

        # Calculate fiducial positions - top-right and bottom-left corners with offset
        positions = [
            (body_right + x_offset, body_top + y_offset),    # Top-right corner + offset
            (body_left - x_offset, body_bottom - y_offset),  # Bottom-left corner - offset
        ]

        for x, y in positions:
            # Draw keepout area first (largest circle)
            painter.setPen(QPen(QColor("#FF4500"), 2/self.zoom_factor))  # Orange Red for keepout
            painter.setBrush(QBrush())  # No fill
            painter.drawEllipse(QRectF(x - keepout_diameter/2, y - keepout_diameter/2, 
                                    keepout_diameter, keepout_diameter))

            # Draw mask opening (medium circle)
            painter.setPen(QPen(QColor("#8A2BE2"), 1/self.zoom_factor))  # Purple for mask
            painter.setBrush(QBrush())
            painter.drawEllipse(QRectF(x - mask_opening/2, y - mask_opening/2, 
                                    mask_opening, mask_opening))

            # Draw copper pad (smallest circle)
            painter.setPen(QPen(QColor("#FFD700"), 2/self.zoom_factor))  # Gold for fiducial
            # Create semi-transparent gold color correctly
            fiducial_color = QColor("#FFD700")
            fiducial_color.setAlpha(100)  # Semi-transparent
            painter.setBrush(QBrush(fiducial_color))
            painter.drawEllipse(QRectF(x - diameter/2, y - diameter/2, diameter, diameter))

            # Draw center cross
            cross_size = diameter / 4
            painter.setPen(QPen(QColor("#000000"), 1/self.zoom_factor))
            painter.drawLine(QPointF(x - cross_size, y), QPointF(x + cross_size, y))
            painter.drawLine(QPointF(x, y - cross_size), QPointF(x, y + cross_size))

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        # Get center point and apply offset
        center_x = self.width() // 2
        center_y = self.height() // 2

        # Apply translation with offset for cursor-centered zoom
        painter.translate(center_x + self.offset_x, center_y + self.offset_y)
        painter.scale(self.zoom_factor, -self.zoom_factor)  # Flip Y axis

        # ADD THIS NEW LINE TO APPLY ORIGIN OFFSET:
        
        # Clear cached positions when data changes
        self._absolute_positions = None

        # Rest of the paintEvent method remains the same...


        # Draw origin first
        self.draw_origin(painter)
        self.draw_fiducials(painter)

        # Draw body outline with shape support
        # Draw body outline with shape support
        body_bounds = None
        if all(k in self.footprint_data for k in ['body_length', 'body_width']):
            try:
                length = to_decimal(self.footprint_data['body_length'])
                width = to_decimal(self.footprint_data['body_width'])
                body_shape = self.footprint_data.get('body_shape', 'rectangle')
                
                painter.setPen(QPen(QColor("#FF69B4"), 2/self.zoom_factor)) # Pink
                painter.setBrush(QBrush()) # No fill
                
                # APPLY ORIGIN OFFSET ONLY TO BODY DRAWING
                painter.save()  # Save current state
                painter.translate(self.origin_offset_x, self.origin_offset_y)
                
                if body_shape == 'rectangle':
                    # Draw body with top-left corner at origin (0,0) - account for Y-flip
                    painter.drawRect(QRectF(0, -width, length, width))
                elif body_shape == 'round':
                    diameter = max(length, width)
                    # Draw body with top-left corner at origin (0,0) - account for Y-flip
                    painter.drawEllipse(QRectF(0, -diameter, diameter, diameter))

                    
                painter.restore()  # Restore original state
                
                # Calculate body_bounds WITHOUT offset (for other calculations)

                # Calculate body_bounds with top-left at origin (0,0)
                if body_shape == 'rectangle':
                    body_bounds = [0, -width, length, 0]  # [min_x, min_y, max_x, max_y]
                elif body_shape == 'round':
                    diameter = max(length, width)
                    body_bounds = [0, -diameter, diameter, 0]


                    
            except (ValueError, TypeError):
                pass


        # Get individual pad bounds for silkscreen calculation
        individual_pad_bounds = self.get_individual_pad_bounds_absolute()

        # Calculate overall pad bounds for courtyard
        pad_bounds = self.calculate_all_pads_bounds_absolute()

        # Draw silkscreen layer with gaps where pads overlap
        if body_bounds and self.footprint_data.get('silkscreen_enabled', True):
            try:
                airgap = to_decimal(self.footprint_data.get('silkscreen_airgap', 0.15))
            except (ValueError, TypeError):
                airgap = 0.15
            self.draw_silkscreen(painter, body_bounds, individual_pad_bounds, airgap)

        # Draw courtyard based on outermost bounds
        self.draw_courtyard(painter, body_bounds, pad_bounds)

        # Draw pads with absolute positioning
        for i, pad in enumerate(self.footprint_data.get('padstacks', [])):
            self.draw_pad(painter, pad, i)

        self.draw_custom_layers(painter)
        
        # Draw thermal vias  
        self.draw_thermal_vias(painter)

            # NEW: Draw unique padstack names below footprint
        self.draw_unique_padstack_names(painter)

        # Draw selection highlights
        # NEW: Draw selection highlights
        self.draw_selected_pads_highlight(painter)

        # Draw dimensions based on overlay control states and selections
        if self.show_airgap_checkbox.isChecked():
            self.draw_all_airgap_dimensions(painter)
        
        if self.show_pitch_checkbox.isChecked():
            self.draw_all_pitch_dimensions(painter)

        # NEW: Draw instruction text
        self.draw_selection_instructions(painter)



    def draw_selection_instructions(self, painter):
        """Draw instruction text for pad selection"""
        painter.save()
        painter.resetTransform()  # Switch to screen coordinates

        instructions = []
        if self.show_airgap_checkbox.isChecked() or self.show_pitch_checkbox.isChecked():
            if len(self.selected_pads) == 0:
                instructions.append("Click on 2 pads to measure dimensions")
            elif len(self.selected_pads) == 1:
                instructions.append("Click on 1 more pad to measure")
            elif len(self.selected_pads) == 2:
                instructions.append("Dimensions shown between selected pads")
                instructions.append("Click elsewhere to clear selection")

        if instructions:
            # Position at bottom-left
            y_start = self.height() - 60
            painter.setPen(QPen(QColor("#FFFFFF"), 1))
            font = QFont("Arial", 10)
            painter.setFont(font)

            for i, instruction in enumerate(instructions):
                # Draw background for better visibility
                text_rect = painter.fontMetrics().boundingRect(instruction)
                text_rect.moveTo(10, y_start + i * 20)
                text_rect.adjust(-3, -1, 3, 1)

                painter.setBrush(QBrush(QColor(0, 0, 0, 150)))
                painter.drawRect(text_rect)
                painter.setBrush(QBrush())
                painter.drawText(10, y_start + i * 20 + 15, instruction)

        painter.restore()

    def calculate_all_pads_bounds_absolute(self):
        """Calculate the outer bounding box of all pads using absolute pad bounds"""
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if not pad_bounds_list:
            return None

        min_x = min(pb[0] for pb in pad_bounds_list)
        min_y = min(pb[1] for pb in pad_bounds_list)
        max_x = max(pb[2] for pb in pad_bounds_list)
        max_y = max(pb[3] for pb in pad_bounds_list)

        return [min_x, min_y, max_x, max_y]

    def draw_courtyard(self, painter, body_bounds, pad_bounds):
        """Draw courtyard based on outermost bounds of body or pads with line width adjustments"""
        try:
            base_expansion = to_decimal(self.footprint_data.get('courtyard_expansion', '0.25'))
            courtyard_line_width = to_decimal(self.footprint_data.get('courtyard_line_width', '0.1'))
            body_line_width = to_decimal(self.footprint_data.get('body_line_width', '0.05'))
        except (ValueError, TypeError):
            base_expansion = Decimal('0.25')
            courtyard_line_width = Decimal('0.1')
            body_line_width = Decimal('0.05')

        # Helper function to convert bounds to Decimal tuples
        def safe_decimal_bounds(bounds):
            """Convert bounds tuple to Decimal tuple"""
            if bounds is None:
                return None
            return tuple(to_decimal(str(coord)) for coord in bounds)

        # Convert all bounds to Decimal
        body_bounds_decimal = safe_decimal_bounds(body_bounds)
        pad_bounds_decimal = safe_decimal_bounds(pad_bounds)

        # Adjust body_bounds for origin offset if present
        if body_bounds_decimal:
            body_bounds_adjusted = (
                body_bounds_decimal[0] + self.origin_offset_x,
                body_bounds_decimal[1] + self.origin_offset_y,
                body_bounds_decimal[2] + self.origin_offset_x,
                body_bounds_decimal[3] + self.origin_offset_y
            )
        else:
            body_bounds_adjusted = None

        # Determine outermost bounds using Decimal arithmetic
        outermost_bounds = None
        outermost_bounds_type = None
        
        if body_bounds_adjusted and pad_bounds_decimal:
            # Use whichever is outermost - all Decimal operations
            outermost_bounds = [
                min(body_bounds_adjusted[0], pad_bounds_decimal[0]),  # min_x
                min(body_bounds_adjusted[1], pad_bounds_decimal[1]),  # min_y
                max(body_bounds_adjusted[2], pad_bounds_decimal[2]),  # max_x
                max(body_bounds_adjusted[3], pad_bounds_decimal[3])   # max_y
            ]
            # Determine which bounds are actually outermost
            if (body_bounds_adjusted[0] <= pad_bounds_decimal[0] and 
                body_bounds_adjusted[1] <= pad_bounds_decimal[1] and
                body_bounds_adjusted[2] >= pad_bounds_decimal[2] and
                body_bounds_adjusted[3] >= pad_bounds_decimal[3]):
                outermost_bounds_type = 'body'
            else:
                outermost_bounds_type = 'pad'
        elif body_bounds_adjusted:
            outermost_bounds = list(body_bounds_adjusted)
            outermost_bounds_type = 'body'
        elif pad_bounds_decimal:
            outermost_bounds = list(pad_bounds_decimal)
            outermost_bounds_type = 'pad'

        if outermost_bounds:
            # Calculate adjusted expansion based on outermost bounds type
            expansion = base_expansion
            if outermost_bounds_type == 'pad':
                expansion += courtyard_line_width / 2
            elif outermost_bounds_type == 'body':
                expansion += (courtyard_line_width / 2) + (body_line_width / 2)

            # Apply courtyard expansion - all Decimal arithmetic
            courtyard_bounds = [
                outermost_bounds[0] - expansion,  # min_x
                outermost_bounds[1] - expansion,  # min_y
                outermost_bounds[2] + expansion,  # max_x
                outermost_bounds[3] + expansion   # max_y
            ]

            # Draw courtyard rectangle - convert to float only for PyQt
            painter.setPen(QPen(QColor("#00FF00"), 1/self.zoom_factor))  # Green
            painter.setBrush(QBrush())  # No fill

            courtyard_width = courtyard_bounds[2] - courtyard_bounds[0]
            courtyard_height = courtyard_bounds[3] - courtyard_bounds[1]

            painter.drawRect(QRectF(
                float(courtyard_bounds[0]),
                float(courtyard_bounds[1]),
                float(courtyard_width),
                float(courtyard_height)
            ))

    def draw_silkscreen(self, painter, body_bounds, individual_pad_bounds, airgap=0.15):
        """Draw silkscreen exactly along body outline with gaps only where pads overlap with airgap"""
        if not body_bounds:
            return

        min_x, min_y, max_x, max_y = body_bounds
        body_shape = self.footprint_data.get('body_shape', 'rectangle')

        # Set silkscreen line properties
        line_width = 4/self.zoom_factor
        painter.setPen(QPen(QColor("#FFF305"), line_width))

        if body_shape == 'rectangle':
            self.draw_rectangle_silkscreen(painter, body_bounds, individual_pad_bounds, airgap)
        elif body_shape == 'round':
            self.draw_round_silkscreen(painter, body_bounds, individual_pad_bounds, airgap)

    def draw_rectangle_silkscreen(self, painter, body_bounds, individual_pad_bounds, airgap):
        """Draw rectangular silkscreen with gaps where pads overlap"""
        if not body_bounds:
            return

        # APPLY ORIGIN OFFSET TO BODY BOUNDS FOR SILKSCREEN
        min_x = body_bounds[0] + self.origin_offset_x
        min_y = body_bounds[1] + self.origin_offset_y
        max_x = body_bounds[2] + self.origin_offset_x
        max_y = body_bounds[3] + self.origin_offset_y

        # Helper function to merge overlapping intervals
        def merge_intervals(intervals):
            """Merge overlapping intervals in the form [(start, end), ...]"""
            if not intervals:
                return []
            intervals = sorted(intervals, key=lambda x: x[0])
            merged = [intervals[0]]
            for current in intervals[1:]:
                last = merged[-1]
                if current[0] <= last[1]:
                    merged[-1] = (last[0], max(last[1], current[1]))
                else:
                    merged.append(current)
            return merged

        # Helper function to convert pad bounds to Decimal
        def safe_decimal_bounds(bounds):
            """Convert pad bounds tuple to Decimal tuple"""
            if bounds is None:
                return None
            return tuple(to_decimal(str(coord)) for coord in bounds)

        # Helper function to draw line segments with gaps where pads interfere
        def draw_line_with_pad_gaps(x1, y1, x2, y2, pad_bounds_list, gap, orientation):
            """Draw line segment with gaps where pads (+ airgap) would overlap"""
            # Convert gap to Decimal if not already
            gap_decimal = to_decimal(str(gap))
            
            if orientation == 'horizontal':
                start_pos = min(x1, x2)
                end_pos = max(x1, x2)
                line_y = y1
                intersections = []
                
                for pad_bounds in pad_bounds_list:
                    if not pad_bounds:
                        continue
                    
                    # Convert pad bounds to Decimal for arithmetic
                    bounds_decimal = safe_decimal_bounds(pad_bounds)
                    if not bounds_decimal:
                        continue
                        
                    px_min, py_min, px_max, py_max = bounds_decimal
                    
                    # Expand pad bounds by airgap - now all Decimal arithmetic
                    pad_min_x = px_min - gap_decimal
                    pad_max_x = px_max + gap_decimal
                    pad_min_y = py_min - gap_decimal
                    pad_max_y = py_max + gap_decimal
                    
                    # Check if this horizontal line intersects with expanded pad
                    if (line_y >= pad_min_y and line_y <= pad_max_y and
                        pad_max_x >= start_pos and pad_min_x <= end_pos):
                        # Calculate intersection range
                        inter_start = max(start_pos, pad_min_x)
                        inter_end = min(end_pos, pad_max_x)
                        intersections.append((float(inter_start), float(inter_end)))
                
                # Sort and merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Draw line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        painter.drawLine(QPointF(float(current_pos), float(line_y)), QPointF(float(gap_start), float(line_y)))
                    current_pos = gap_end
                
                # Draw final segment if needed
                if current_pos < end_pos:
                    painter.drawLine(QPointF(float(current_pos), float(line_y)), QPointF(float(end_pos), float(line_y)))
                    
            else:  # vertical
                start_pos = min(y1, y2)
                end_pos = max(y1, y2)
                line_x = x1
                intersections = []
                
                for pad_bounds in pad_bounds_list:
                    if not pad_bounds:
                        continue
                    
                    # Convert pad bounds to Decimal for arithmetic
                    bounds_decimal = safe_decimal_bounds(pad_bounds)
                    if not bounds_decimal:
                        continue
                        
                    px_min, py_min, px_max, py_max = bounds_decimal
                    
                    # Expand pad bounds by airgap - now all Decimal arithmetic
                    pad_min_x = px_min - gap_decimal
                    pad_max_x = px_max + gap_decimal
                    pad_min_y = py_min - gap_decimal
                    pad_max_y = py_max + gap_decimal
                    
                    # Check if this vertical line intersects with expanded pad
                    if (line_x >= pad_min_x and line_x <= pad_max_x and
                        pad_max_y >= start_pos and pad_min_y <= end_pos):
                        # Calculate intersection range
                        inter_start = max(start_pos, pad_min_y)
                        inter_end = min(end_pos, pad_max_y)
                        intersections.append((float(inter_start), float(inter_end)))
                
                # Sort and merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Draw line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        painter.drawLine(QPointF(float(line_x), float(current_pos)), QPointF(float(line_x), float(gap_start)))
                    current_pos = gap_end
                
                # Draw final segment if needed
                if current_pos < end_pos:
                    painter.drawLine(QPointF(float(line_x), float(current_pos)), QPointF(float(line_x), float(end_pos)))

        # Draw all four sides of rectangular body outline with gaps where pads interfere
        # Top line
        draw_line_with_pad_gaps(min_x, max_y, max_x, max_y, individual_pad_bounds, airgap, 'horizontal')
        # Bottom line
        draw_line_with_pad_gaps(min_x, min_y, max_x, min_y, individual_pad_bounds, airgap, 'horizontal')
        # Left line
        draw_line_with_pad_gaps(min_x, min_y, min_x, max_y, individual_pad_bounds, airgap, 'vertical')
        # Right line
        draw_line_with_pad_gaps(max_x, min_y, max_x, max_y, individual_pad_bounds, airgap, 'vertical')


    def draw_round_silkscreen(self, painter, body_bounds, individual_pad_bounds, airgap):
        """Draw round silkscreen with gaps where pads overlap"""
        if not body_bounds:
            return

        # APPLY ORIGIN OFFSET TO BODY BOUNDS FOR SILKSCREEN
        min_x = body_bounds[0] + self.origin_offset_x
        min_y = body_bounds[1] + self.origin_offset_y
        max_x = body_bounds[2] + self.origin_offset_x
        max_y = body_bounds[3] + self.origin_offset_y

        # Calculate circle parameters
        center_x = (min_x + max_x) / Decimal('2')
        center_y = (min_y + max_y) / Decimal('2')
        radius = (max_x - min_x) / Decimal('2')

        # Convert airgap to Decimal
        airgap_decimal = to_decimal(str(airgap))

        # Check if any pads overlap with the circle outline
        has_pad_overlaps = False
        for pad_bounds in individual_pad_bounds:
            if not pad_bounds:
                continue
            
            # Convert pad bounds to Decimal
            px_min, py_min, px_max, py_max = [to_decimal(str(coord)) for coord in pad_bounds]
            
            # Expand pad bounds by airgap
            pad_min_x = px_min - airgap_decimal
            pad_max_x = px_max + airgap_decimal
            pad_min_y = py_min - airgap_decimal
            pad_max_y = py_max + airgap_decimal

            # Simple check: if pad rectangle intersects with circle bounds
            circle_left = center_x - radius
            circle_right = center_x + radius
            circle_top = center_y + radius
            circle_bottom = center_y - radius

            if (pad_max_x >= circle_left and pad_min_x <= circle_right and
                pad_max_y >= circle_bottom and pad_min_y <= circle_top):
                has_pad_overlaps = True
                break

        if not has_pad_overlaps:
            # No pad overlaps, draw complete circle
            painter.drawEllipse(QRectF(float(min_x), float(min_y), float(max_x - min_x), float(max_y - min_y)))
        else:
            # Draw circle with gaps - simplified approach using small arc segments
            num_segments = 72  # 5-degree segments
            angle_step = 360.0 / num_segments

            for i in range(num_segments):
                start_angle = i * angle_step
                end_angle = (i + 1) * angle_step

                # Calculate midpoint of this arc segment
                mid_angle = math.radians((start_angle + end_angle) / 2)
                mid_x = center_x + radius * Decimal(str(math.cos(mid_angle)))
                mid_y = center_y + radius * Decimal(str(math.sin(mid_angle)))

                # Check if this segment overlaps with any expanded pad
                segment_overlaps = False
                for pad_bounds in individual_pad_bounds:
                    if not pad_bounds:
                        continue
                    
                    # Convert pad bounds to Decimal
                    px_min, py_min, px_max, py_max = [to_decimal(str(coord)) for coord in pad_bounds]
                    
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - airgap_decimal
                    pad_max_x = px_max + airgap_decimal
                    pad_min_y = py_min - airgap_decimal
                    pad_max_y = py_max + airgap_decimal

                    # Check if segment midpoint is inside expanded pad rectangle
                    if (mid_x >= pad_min_x and mid_x <= pad_max_x and
                        mid_y >= pad_min_y and mid_y <= pad_max_y):
                        segment_overlaps = True
                        break

                # Draw this segment if it doesn't overlap with pads
                if not segment_overlaps:
                    # Use drawArc for precise arc drawing
                    arc_rect = QRectF(float(min_x), float(min_y), float(max_x - min_x), float(max_y - min_y))
                    start_angle_16 = int(start_angle * 16)
                    span_angle_16 = int(angle_step * 16)
                    painter.drawArc(arc_rect, start_angle_16, span_angle_16)

    def draw_pad(self, painter, pad, pad_index=None):
        """Draw pad using absolute position with proper layer handling for TH pads"""
        # Get absolute positions
        absolute_positions = getattr(self, '_absolute_positions', None)
        if absolute_positions is None:
            absolute_positions = self.calculate_pad_absolute_positions()
            self._absolute_positions = absolute_positions

        # Use absolute position if available, otherwise fall back to direct offsets
        if pad_index is not None and pad_index in absolute_positions:
            x, y = absolute_positions[pad_index]
        else:
            try:
                x = to_decimal(pad.get('x_offset', 0))
                y = to_decimal(pad.get('y_offset', 0))
            except (ValueError, TypeError):
                x, y = 0, 0

        pin_num = pad.get('pin_number', '1')

        # Define through hole pad types (no paste layer)
        through_hole_types = ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong', 'PTH_rectangle']
        smd_types = ['square', 'rectangle', 'rounded_rectangle', 'round', 'SMD-oblong', 'D-shape', 'custom']

        # Draw paste layer (silver) - SKIP FOR THROUGH HOLE PADS
        if pad['type'] not in through_hole_types:
            # Check if paste is enabled for SMD pads
            paste_enabled = pad.get('paste_enabled', True)
            if paste_enabled:
                try:
                    paste_exp = to_decimal(pad.get('paste_expansion', 0))
                except (ValueError, TypeError):
                    paste_exp = 0
                    
                if paste_exp != 0:
                    painter.setPen(QPen(QColor("#C0C0C0"), 1/self.zoom_factor))
                    painter.setBrush(QBrush()) # No fill - outline only
                    self.draw_pad_shape(painter, pad, x, y, paste_exp)

        # Draw mask layer (purple #8A2BE2) - outline only
        mask_enabled = pad.get('mask_enabled', True)
        if mask_enabled:
            try:
                mask_exp = to_decimal(pad.get('mask_expansion', 0))
            except (ValueError, TypeError):
                mask_exp = 0
                
            if mask_exp != 0:
                painter.setPen(QPen(QColor("#8A2BE2"), 1/self.zoom_factor))
                painter.setBrush(QBrush()) # No fill - outline only
                self.draw_pad_shape(painter, pad, x, y, mask_exp)

        # Draw copper pad (red) - outline only
        pen_width = Decimal('2') / self.zoom_factor
        painter.setPen(QPen(QColor("#FF0000"), float(pen_width)))
        painter.setBrush(QBrush()) # No fill - outline only
        self.draw_pad_shape(painter, pad, x, y, 0)

        # Draw pin number with correct orientation
        self.draw_pin_number(painter, pad, x, y, pin_num)


    def draw_unique_padstack_names(self, painter):
        """Draw unique padstack names below the footprint (after courtyard)"""
        if not self.footprint_data.get('padstacks') and not self.footprint_data.get('fiducials_enabled', False):
            return

        # Collect unique pad names
        unique_names = []
        seen_names = set()
        
        # Regular pads
        for pad in self.footprint_data.get('padstacks', []):
            pad_name = self.generate_pad_name(pad)
            if pad_name not in seen_names:
                unique_names.append(pad_name)
                seen_names.add(pad_name)
        
        # Add fiducial padstack name if fiducials are enabled
        if self.footprint_data.get('fiducials_enabled', False):
            fiducial_settings = self.footprint_data.get('settings', {})
            fiducial_name = self.generate_fiducial_padstack_name(fiducial_settings)
            if fiducial_name not in seen_names:
                unique_names.append(fiducial_name)
                seen_names.add(fiducial_name)

        if not unique_names:
            return

        # Get text settings
        settings = self.footprint_data.get('text_settings', {})
        text_height = to_decimal(settings.get('text_height', '0.5'))

        # Calculate courtyard expansion
        expansion = to_decimal(self.footprint_data.get('courtyard_expansion', '0.25'))

        # SIMPLIFIED APPROACH: Find the lowest point of all elements
        lowest_y = Decimal('inf')

        # Check body bounds
        if all(k in self.footprint_data for k in ['body_length', 'body_width']):
            width = to_decimal(self.footprint_data['body_width'])
            body_bottom = self.origin_offset_y - width
            lowest_y = min(lowest_y, body_bottom)

        # Check pad bounds
        pad_bounds = self.calculate_all_pads_bounds_absolute()
        if pad_bounds:
            pad_bottom = to_decimal(str(pad_bounds[1]))  # pad_bounds[1] is min_y
            lowest_y = min(lowest_y, pad_bottom)

        # If no bounds found, use default
        if lowest_y == Decimal('inf'):
            lowest_y = Decimal('-1.0')  # Default 1mm below origin

        # Position text below courtyard
        text_start_y = lowest_y - expansion - Decimal('0.5')  # 0.5mm below courtyard

        # Draw each unique name in world coordinates
        painter.save()

        # Set text properties for world space drawing with zoom scaling
        painter.setPen(QPen(QColor("#FFAA00"), self.zoom_factor))  # Orange, scale with zoom

        for i, pad_name in enumerate(unique_names):
            # Simple linear text spacing
            text_y = text_start_y - (Decimal(str(i)) * (text_height + Decimal('0.2')))  # Stack vertically

            # Draw text in world coordinates at origin X (0)
            # Convert to screen coordinates for font sizing
            transform = painter.worldTransform()
            screen_pos = transform.map(QPointF(float(Decimal('0')), float(text_y)))

            # Switch to screen coordinates for text rendering
            painter.save()
            painter.resetTransform()

            # SIMPLIFIED: Linear zoom factor application
            font_size = float(text_height * to_decimal(str(self.zoom_factor)))
            font = QFont("Arial", int(font_size))
            font.setBold(True)
            painter.setFont(font)

            # Get text metrics
            fm = painter.fontMetrics()
            text_rect = fm.boundingRect(pad_name)
            text_rect.moveCenter(screen_pos.toPoint())

            # Draw text with zoom-aware pen width
            painter.setPen(QPen(QColor("#FFAA00"), max(1, int(Decimal('2')/to_decimal(str(self.zoom_factor))))))
            painter.setBrush(QBrush())
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignCenter, pad_name)

            painter.restore()

        painter.restore()

    def generate_fiducial_padstack_name(self, fiducial_settings):
        """Generate fiducial padstack name based on settings"""
        try:
            diameter = to_decimal(fiducial_settings.get('fiducial_diameter', '1.0'))
            mask_opening = to_decimal(fiducial_settings.get('fiducial_mask_opening', '2.0'))
            keepout_diameter = to_decimal(fiducial_settings.get('fiducial_keepout_diameter', '3.0'))
            
            # Create name based on dimensions (in 0.1mm units)
            name = f"FID_C{int(diameter * 100)}"
            
            if mask_opening > diameter:
                mask_size = int(mask_opening * 100)
                name += f"_M{mask_size}"
                
            if keepout_diameter > mask_opening:
                keepout_size = int(keepout_diameter * 100)
                name += f"_K{keepout_size}"
                
            return name
        except (ValueError, TypeError):
            return "FID_C100_M200_K300"  # Default fiducial name


    def draw_pin_number(self, painter, pad, x, y, pin_num):
        """Draw pin number in screen space with correct orientation and ultra-small size"""
        # Save current state
        painter.save()

        # Get current transform matrix
        transform = painter.worldTransform()

        # Map pad center to screen coordinates
        screen_pos = transform.map(QPointF(x, y))

        # Reset transform to draw in screen space (ensures upright text)
        painter.resetTransform()

        # Calculate font size based on pad size and zoom for ultra-small text
        pad_type = pad['type']
        try:
            if pad_type == 'square':
                pad_size = to_decimal(pad.get('size', 1))
                base_font_size = max(6, min(pad_size * self.zoom_factor * 0.12, 12))
            elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong', 'PTH_rectangle']:
                min_dim = min(to_decimal(pad.get('length', 1)), to_decimal(pad.get('width', 1)))
                base_font_size = max(6, min(min_dim * self.zoom_factor * 0.1, 12))
            elif pad_type in ['round', 'D-shape']:
                diameter = to_decimal(pad.get('diameter', 1))
                base_font_size = max(6, min(diameter * self.zoom_factor * 0.12, 12))
            else:
                base_font_size = max(6, min(8, 12))
        except (ValueError, TypeError):
            base_font_size = 8

        # Set text properties for screen space
        painter.setPen(QPen(QColor("#FFFFFF"), 1))
        font = QFont("Arial", int(base_font_size))
        font.setBold(True) # Make bold for better visibility at small sizes
        painter.setFont(font)

        # Calculate text area based on font size
        text_width = base_font_size * 1.5
        text_height = base_font_size * 1.2

        # Draw text in screen coordinates (always upright)
        text_rect = QRectF(screen_pos.x() - text_width/2, screen_pos.y() - text_height/2,
                          text_width, text_height)
        painter.drawText(text_rect, Qt.AlignmentFlag.AlignCenter, pin_num)

        # Restore transform
        painter.restore()

    def draw_pad_shape(self, painter, pad, x, y, expansion):
        """Draw pad shape as outline only (no fill) - PRESERVES CALLER'S PEN COLOR"""
        pad_type = pad['type']

        # Ensure no fill - outline only
        painter.setBrush(QBrush())

        if pad_type == 'square':
            try:
                size = to_decimal(pad.get('size', 1)) + 2*expansion
                painter.drawRect(QRectF(x-size/2, y-size/2, size, size))
            except (ValueError, TypeError):
                painter.drawRect(QRectF(x-0.5, y-0.5, 1, 1))

        elif pad_type == 'rectangle':
            try:
                length = to_decimal(pad.get('length', 1)) + 2*expansion
                width = to_decimal(pad.get('width', 1)) + 2*expansion
                painter.drawRect(QRectF(x-length/2, y-width/2, length, width))
            except (ValueError, TypeError):
                painter.drawRect(QRectF(x-0.5, y-0.5, 1, 1))

        elif pad_type == 'SMD-oblong':
            # SMD-oblong is a racetrack/pill shape (rectangle with semicircle ends)
            try:
                length = to_decimal(pad.get('length', 1)) + 2*expansion
                width = to_decimal(pad.get('width', 1)) + 2*expansion
                
                # Draw as rounded rectangle with radius = width/2 to create pill shape
                radius = width / 2
                painter.drawRoundedRect(QRectF(x-length/2, y-width/2, length, width), radius, radius)
            except (ValueError, TypeError):
                painter.drawRoundedRect(QRectF(x-0.5, y-0.5, 1, 1), 0.5, 0.5)

        elif pad_type == 'rounded_rectangle':
            try:
                length = to_decimal(pad.get('length', 1)) + 2*expansion
                width = to_decimal(pad.get('width', 1)) + 2*expansion
                radius = to_decimal(pad.get('corner_radius', 0.2))
                painter.drawRoundedRect(QRectF(x-length/2, y-width/2, length, width), radius, radius)
            except (ValueError, TypeError):
                painter.drawRoundedRect(QRectF(x-0.5, y-0.5, 1, 1), 0.2, 0.2)

        elif pad_type == 'round':
            try:
                diameter = to_decimal(pad.get('diameter', 1)) + 2*expansion
                painter.drawEllipse(QRectF(x-diameter/2, y-diameter/2, diameter, diameter))
            except (ValueError, TypeError):
                painter.drawEllipse(QRectF(x-0.5, y-0.5, 1, 1))

        elif pad_type == 'D-shape':
            # D-shape is rounded rectangle with one side corner radius
            try:
                length = to_decimal(pad.get('length', 1)) + 2*expansion
                width = to_decimal(pad.get('width', 1)) + 2*expansion
                corner_radius = to_decimal(pad.get('corner_radius', 0.2))
                rotation = to_decimal(pad.get('rotation', 0)) if pad.get('rotation') else 0
            except (ValueError, TypeError):
                length, width, corner_radius, rotation = 1, 1, 0.2, 0

            painter.save()
            if rotation != 0:
                painter.translate(x, y)
                painter.rotate(rotation)
                painter.translate(-x, -y)

            # Create D-shape path (rounded rectangle with rounded corners on one side)
            path = QPainterPath()
            half_length = length / 2
            half_width = width / 2
            r = corner_radius

            # Start from left-top corner
            path.moveTo(x - half_length, y - half_width)
            # Top line to rounded corner
            path.lineTo(x + half_length - r, y - half_width)
            # Top-right rounded corner
            path.quadTo(x + half_length, y - half_width, x + half_length, y - half_width + r)
            # Right side line
            path.lineTo(x + half_length, y + half_width - r)
            # Bottom-right rounded corner
            path.quadTo(x + half_length, y + half_width, x + half_length - r, y + half_width)
            # Bottom line
            path.lineTo(x - half_length, y + half_width)
            # Close path (left side straight)
            path.closeSubpath()

            painter.drawPath(path)
            painter.restore()

        elif pad_type in ['PTH', 'NPTH']:
            if expansion == 0: # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                try:
                    hole_diameter = to_decimal(pad.get('hole_diameter', 0.8))
                except (ValueError, TypeError):
                    hole_diameter = 0.8
                    
                # Draw hole (black circle)
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                painter.drawEllipse(QRectF(x-hole_diameter/2, y-hole_diameter/2, hole_diameter, hole_diameter))

                # Draw pad for PTH only
                if pad_type == 'PTH':
                    pen_width = Decimal('2') / self.zoom_factor
                    painter.setPen(QPen(QColor("#FF0000"), float(pen_width))) # Red for copper
                    painter.setBrush(QBrush()) # No fill for pad outline
                    try:
                        pad_diameter = to_decimal(pad.get('pad_diameter', 1.2))
                    except (ValueError, TypeError):
                        pad_diameter = 1.2
                    painter.drawEllipse(QRectF(x-pad_diameter/2, y-pad_diameter/2, pad_diameter, pad_diameter))

                # Restore original pen
                painter.setPen(saved_pen)
            else: # Drawing mask/paste expansion - PRESERVE CALLER'S PEN COLOR
                if pad_type == 'PTH':
                    try:
                        pad_diameter = to_decimal(pad.get('pad_diameter', 1.2)) + 2*expansion
                        painter.drawEllipse(QRectF(x-pad_diameter/2, y-pad_diameter/2, pad_diameter, pad_diameter))
                    except (ValueError, TypeError):
                        painter.drawEllipse(QRectF(x-0.6, y-0.6, 1.2, 1.2))
                else: # NPTH
                    try:
                        hole_diameter = to_decimal(pad.get('hole_diameter', 0.8)) + 2*expansion
                        painter.drawEllipse(QRectF(x-hole_diameter/2, y-hole_diameter/2, hole_diameter, hole_diameter))
                    except (ValueError, TypeError):
                        painter.drawEllipse(QRectF(x-0.4, y-0.4, 0.8, 0.8))

        elif pad_type == 'PTH_rectangle':
            # PTH_rectangle is like PTH_oblong but with sharp rectangular corners
            # Apply rotation if specified
            rotation = pad.get('rotation', 0)
            painter.save()
            
            # Convert rotation to to_decimal if it's a string
            try:
                rotation_value = to_decimal(rotation) if rotation else 0
            except (ValueError, TypeError):
                rotation_value = 0
            
            if rotation_value != 0:
                painter.translate(x, y)
                painter.rotate(rotation_value)
                painter.translate(-x, -y)
            
            if expansion == 0: # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                try:
                    hole_length = to_decimal(pad.get('hole_length', 1.5))
                    hole_width = to_decimal(pad.get('hole_width', 0.8))
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8
                    
                # Draw rectangular hole (black) - NO ROUNDING
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                # Draw rectangle (not rounded rectangle)
                painter.drawRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width))

                # Draw rectangular pad (sharp corners)
                pen_width = Decimal('2') / self.zoom_factor
                painter.setPen(QPen(QColor("#FF0000"), float(pen_width))) # Red for copper
                painter.setBrush(QBrush()) # No fill for pad outline
                try:
                    pad_length = to_decimal(pad.get('pad_length', 2.0))
                    pad_width = to_decimal(pad.get('pad_width', 1.2))
                except (ValueError, TypeError):
                    pad_length, pad_width = 2.0, 1.2
                # Draw rectangle (not rounded rectangle)
                painter.drawRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width))

                # Restore original pen
                painter.setPen(saved_pen)
            else: # Drawing mask/paste expansion - PRESERVE CALLER'S PEN COLOR
                try:
                    pad_length = to_decimal(pad.get('pad_length', 2.0)) + 2*expansion
                    pad_width = to_decimal(pad.get('pad_width', 1.2)) + 2*expansion
                except (ValueError, TypeError):
                    pad_length, pad_width = 2.0, 1.2
                # Draw rectangle (not rounded rectangle)
                painter.drawRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width))
            
            painter.restore()

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            # Apply rotation if specified
            rotation = pad.get('rotation', 0)
            painter.save()
            
            # Convert rotation to to_decimal if it's a string
            try:
                rotation_value = to_decimal(rotation) if rotation else 0
            except (ValueError, TypeError):
                rotation_value = 0
            
            if rotation_value != 0:
                painter.translate(x, y)
                painter.rotate(rotation_value)
                painter.translate(-x, -y)
            
            if expansion == 0: # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                try:
                    hole_length = to_decimal(pad.get('hole_length', 1.5))
                    hole_width = to_decimal(pad.get('hole_width', 0.8))
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8
                    
                # Draw oblong hole (black)
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                # Draw oblong as rounded rectangle
                radius = hole_width / 2
                painter.drawRoundedRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width), radius, radius)

                # Draw pad for PTH oblong only
                if pad_type == 'PTH_oblong':
                    pen_width = Decimal('2') / self.zoom_factor
                    painter.setPen(QPen(QColor("#FF0000"), float(pen_width))) # Red for copper
                    painter.setBrush(QBrush()) # No fill for pad outline
                    try:
                        pad_length = to_decimal(pad.get('pad_length', 2.0))
                        pad_width = to_decimal(pad.get('pad_width', 1.2))
                    except (ValueError, TypeError):
                        pad_length, pad_width = 2.0, 1.2
                    pad_radius = pad_width / 2
                    painter.drawRoundedRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width), pad_radius, pad_radius)

                # Restore original pen
                painter.setPen(saved_pen)
            else: # Drawing mask/paste expansion - PRESERVE CALLER'S PEN COLOR
                if pad_type == 'PTH_oblong':
                    try:
                        pad_length = to_decimal(pad.get('pad_length', 2.0)) + 2*expansion
                        pad_width = to_decimal(pad.get('pad_width', 1.2)) + 2*expansion
                    except (ValueError, TypeError):
                        pad_length, pad_width = 2.0, 1.2
                    pad_radius = pad_width / 2
                    painter.drawRoundedRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width), pad_radius, pad_radius)
                else: # NPTH_oblong
                    try:
                        hole_length = to_decimal(pad.get('hole_length', 1.5)) + 2*expansion
                        hole_width = to_decimal(pad.get('hole_width', 0.8)) + 2*expansion
                    except (ValueError, TypeError):
                        hole_length, hole_width = 1.5, 0.8
                    radius = hole_width / 2
                    painter.drawRoundedRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width), radius, radius)
            
            painter.restore()

        elif pad_type == 'PTH_rectangle':
            # PTH_rectangle is rectangular through-hole with rotation
            try:
                rotation = to_decimal(pad.get('rotation', 0)) if pad.get('rotation') else 0
            except (ValueError, TypeError):
                rotation = 0

            painter.save()
            if rotation != 0:
                painter.translate(x, y)
                painter.rotate(rotation)
                painter.translate(-x, -y)

            if expansion == 0: # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                try:
                    hole_length = to_decimal(pad.get('hole_length', 1.5))
                    hole_width = to_decimal(pad.get('hole_width', 0.8))
                    pad_length = to_decimal(pad.get('pad_length', 2.0))
                    pad_width = to_decimal(pad.get('pad_width', 1.2))
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8
                    pad_length, pad_width = 2.0, 1.2
                    
                # Draw rectangular hole (black)
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                painter.drawRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width))

                # Draw rectangular pad (red outline)
                pen_width = Decimal('2') / self.zoom_factor
                painter.setPen(QPen(QColor("#FF0000"), float(pen_width)))
                painter.setBrush(QBrush()) # No fill for pad outline
                painter.drawRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width))

                # Restore original pen
                painter.setPen(saved_pen)
            else: # Drawing mask/paste expansion
                try:
                    pad_length = to_decimal(pad.get('pad_length', 2.0)) + 2*expansion
                    pad_width = to_decimal(pad.get('pad_width', 1.2)) + 2*expansion
                except (ValueError, TypeError):
                    pad_length, pad_width = 2.0, 1.2
                painter.drawRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width))
            
            painter.restore()


        elif pad_type == 'NPTH_rectangle':
            # NPTH_rectangle is rectangular non-plated through-hole with rotation
            try:
                rotation = to_decimal(pad.get('rotation', 0)) if pad.get('rotation') else 0
            except (ValueError, TypeError):
                rotation = 0

            painter.save()
            if rotation != 0:
                painter.translate(x, y)
                painter.rotate(rotation)
                painter.translate(-x, -y)

            if expansion == 0:  # Drawing the actual hole
                # Save current pen color
                saved_pen = painter.pen()

                try:
                    hole_length = to_decimal(pad.get('hole_length', 1.5))
                    hole_width = to_decimal(pad.get('hole_width', 0.8))
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8

                # Draw rectangular hole (black) - NO ROUNDING
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                # Draw rectangle (not rounded rectangle)
                painter.drawRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width))

                # Restore original pen
                painter.setPen(saved_pen)

            else:  # Drawing mask/paste expansion
                try:
                    hole_length = to_decimal(pad.get('hole_length', 1.5)) + 2*expansion
                    hole_width = to_decimal(pad.get('hole_width', 0.8)) + 2*expansion
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8

                # Draw rectangle (not rounded rectangle)
                painter.drawRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width))

            painter.restore()

        elif pad_type == 'custom':
            # Draw custom polygon using absolute position
            polygon_points = self.calculate_polygon_points_absolute(pad, x, y)
            if polygon_points:
                # Apply expansion to polygon - FIXED VERSION
                if expansion != 0:
                    # Calculate proper uniform expansion using offset algorithm
                    expanded_points = self.expand_polygon_uniformly(polygon_points, expansion)
                    polygon_points = expanded_points if expanded_points else polygon_points

                polygon = QPolygonF(polygon_points)
                painter.drawPolygon(polygon)
        # Draw custom polygon using absolute position   

    def expand_polygon_uniformly(self, points, expansion):
        """Expand polygon by moving each edge outward by the expansion amount"""
        if not points or len(points) < 3 or expansion == 0:
            return points

        try:
            # Convert expansion to float for all mathematical operations
            expansion_float = float(expansion)
            
            expanded_points = []
            n = len(points)
            
            for i in range(n):
                # Get current vertex and adjacent vertices
                prev_i = (i - 1) % n
                next_i = (i + 1) % n
                
                curr = points[i]
                prev = points[prev_i]
                next = points[next_i]

                # Calculate edge vectors (using float operations)
                edge1 = QPointF(curr.x() - prev.x(), curr.y() - prev.y())  # incoming edge
                edge2 = QPointF(next.x() - curr.x(), next.y() - curr.y())  # outgoing edge

                # Calculate outward normals for each edge (rotate 90 clockwise)
                normal1 = QPointF(edge1.y(), -edge1.x())
                normal2 = QPointF(edge2.y(), -edge2.x())

                # Normalize the normals
                len1 = math.sqrt(normal1.x()**2 + normal1.y()**2)
                len2 = math.sqrt(normal2.x()**2 + normal2.y()**2)
                
                if len1 > 0:
                    normal1 = QPointF(normal1.x() / len1, normal1.y() / len1)
                if len2 > 0:
                    normal2 = QPointF(normal2.x() / len2, normal2.y() / len2)

                # Average the normals to get the direction to move this vertex
                avg_normal = QPointF(
                    (normal1.x() + normal2.x()) / 2,
                    (normal1.y() + normal2.y()) / 2
                )

                # Normalize the average normal
                avg_len = math.sqrt(avg_normal.x()**2 + avg_normal.y()**2)
                if avg_len > 0:
                    avg_normal = QPointF(avg_normal.x() / avg_len, avg_normal.y() / avg_len)

                # Calculate the actual expansion distance
                # For sharp corners, we need to expand more to maintain edge offset
                dot_product = normal1.x() * normal2.x() + normal1.y() * normal2.y()
                
                # Clamp dot product to avoid floating point errors
                dot_product = max(min(dot_product, 1.0), -1.0)
                
                # Calculate the angle between normals
                try:
                    angle = math.acos(abs(dot_product))  # Use abs to avoid negative values
                    sin_half_angle = math.sin(angle / 2)
                except (ValueError, ZeroDivisionError):
                    sin_half_angle = 0.5  # Fallback value
                
                # Avoid division by zero for straight lines
                expansion_factor = 1.0 / sin_half_angle if sin_half_angle > 0.01 else 1.0
                
                # Limit extreme expansions for very sharp angles
                expansion_factor = min(expansion_factor, 10.0)

                # Move the vertex outward - ALL FLOAT OPERATIONS NOW
                offset_distance = -expansion_float * expansion_factor  # Negative for outward expansion

                new_point = QPointF(
                    curr.x() + avg_normal.x() * offset_distance,
                    curr.y() + avg_normal.y() * offset_distance
                )

                expanded_points.append(new_point)

            return expanded_points

        except Exception as e:
            print(f"Polygon expansion error: {e}")
            return points  # Return original points on error


    def draw_custom_layers(self, painter):
        """Draw custom layers (mask, paste, keepout)"""
        custom_layers = self.footprint_data.get('custom_layers', [])
        
        for layer in custom_layers:
            layer_type = layer.get('layer', 'mask')
            shape = layer.get('shape', 'rectangle')
            
            # Get position
            try:
                x_offset = to_decimal(layer.get('x_offset', 0))
                y_offset = to_decimal(layer.get('y_offset', 0))
            except (ValueError, TypeError):
                x_offset, y_offset = 0, 0
                
            # Handle offset_from
            offset_from = layer.get('offset_from', 'origin')
            if offset_from != 'origin':
                # Get reference pad position
                absolute_positions = self.calculate_pad_absolute_positions()
                pads = self.footprint_data.get('padstacks', [])
                ref_pad = None
                for i, pad in enumerate(pads):
                    if pad.get('pin_number') == offset_from:
                        if i in absolute_positions:
                            ref_x, ref_y = absolute_positions[i]
                            x_offset += ref_x
                            y_offset += ref_y
                        break
            
            # Set color based on layer type
            if layer_type == 'mask':
                painter.setPen(QPen(QColor("#8A2BE2"), 2/self.zoom_factor))  # Purple
            elif layer_type == 'paste':
                painter.setPen(QPen(QColor("#C0C0C0"), 2/self.zoom_factor))  # Silver
            elif layer_type == 'keepout':
                painter.setPen(QPen(QColor("#FF4500"), 2/self.zoom_factor))  # Orange Red
            
            painter.setBrush(QBrush())  # No fill
            
            # Draw shape
            if shape == 'rectangle':
                try:
                    length = to_decimal(layer.get('length', 1))
                    width = to_decimal(layer.get('width', 1))
                    painter.drawRect(QRectF(x_offset - length/2, y_offset - width/2, length, width))
                except (ValueError, TypeError):
                    painter.drawRect(QRectF(x_offset - 0.5, y_offset - 0.5, 1, 1))
                    
            elif shape == 'rounded_rectangle':
                try:
                    length = to_decimal(layer.get('length', 1))
                    width = to_decimal(layer.get('width', 1))
                    radius = to_decimal(layer.get('corner_radius', 0.2))
                    painter.drawRoundedRect(QRectF(x_offset - length/2, y_offset - width/2, length, width), radius, radius)
                except (ValueError, TypeError):
                    painter.drawRoundedRect(QRectF(x_offset - 0.5, y_offset - 0.5, 1, 1), 0.2, 0.2)
                    
            elif shape == 'oblong':
                try:
                    length = to_decimal(layer.get('length', 2))
                    width = to_decimal(layer.get('width', 1))
                    rotation = to_decimal(layer.get('rotation', 0))
                    
                    # APPLY ROTATION FOR OBLONG
                    painter.save()
                    if rotation != 0:
                        painter.translate(x_offset, y_offset)
                        painter.rotate(rotation)
                        painter.translate(-x_offset, -y_offset)
                    
                    radius = width / 2
                    painter.drawRoundedRect(QRectF(x_offset - length/2, y_offset - width/2, length, width), radius, radius)
                    painter.restore()
                    
                except (ValueError, TypeError):
                    painter.drawRoundedRect(QRectF(x_offset - 1, y_offset - 0.5, 2, 1), 0.5, 0.5)
                    
            elif shape == 'custom_polygon':
                # Handle custom polygon similar to pad custom polygons
                polygon_points = self.calculate_custom_layer_polygon_points(layer, x_offset, y_offset)
                if polygon_points:
                    polygon = QPolygonF(polygon_points)
                    painter.drawPolygon(polygon)

    def draw_thermal_vias(self, painter):
        """Draw thermal vias"""
        thermal_vias = self.footprint_data.get('thermal_vias', [])
        
        for via in thermal_vias:
            via_type = via.get('type', 'single')
            
            # Get position
            try:
                x_offset = to_decimal(via.get('x_offset', 0))
                y_offset = to_decimal(via.get('y_offset', 0))
            except (ValueError, TypeError):
                x_offset, y_offset = 0, 0
                
            # Handle offset_from - UPDATED TO INCLUDE THERMAL VIA PINS
            offset_from = via.get('offset_from', 'origin')
            if offset_from != 'origin':
                # First check pad positions
                absolute_positions = self.calculate_pad_absolute_positions()
                pads = self.footprint_data.get('padstacks', [])
                found_reference = False
                
                # Check pad pins first
                for i, pad in enumerate(pads):
                    if pad.get('pin_number') == offset_from:
                        if i in absolute_positions:
                            ref_x, ref_y = absolute_positions[i]
                            x_offset += ref_x
                            y_offset += ref_y
                            found_reference = True
                            break
                
                # If not found in pads, check thermal via pins
                if not found_reference:
                    thermal_vias_list = self.footprint_data.get('thermal_vias', [])
                    for other_via in thermal_vias_list:
                        if other_via.get('pin_number') == offset_from and other_via != via:
                            # Calculate position of the reference thermal via
                            try:
                                ref_x_offset = to_decimal(other_via.get('x_offset', 0))
                                ref_y_offset = to_decimal(other_via.get('y_offset', 0))
                            except (ValueError, TypeError):
                                ref_x_offset, ref_y_offset = 0, 0
                            
                            # Handle recursive offset_from for the reference via
                            ref_offset_from = other_via.get('offset_from', 'origin')
                            if ref_offset_from != 'origin':
                                # Recursively resolve reference via position
                                # Check pads for the reference via's offset
                                for j, ref_pad in enumerate(pads):
                                    if ref_pad.get('pin_number') == ref_offset_from:
                                        if j in absolute_positions:
                                            ref_pad_x, ref_pad_y = absolute_positions[j]
                                            ref_x_offset += ref_pad_x
                                            ref_y_offset += ref_pad_y
                                            break
                            
                            x_offset += ref_x_offset
                            y_offset += ref_y_offset
                            found_reference = True
                            break
            
            # Set via appearance
            painter.setPen(QPen(QColor("#00CED1"), 2/self.zoom_factor)) # Dark Turquoise for via
            painter.setBrush(QBrush(QColor("#008B8B"))) # Dark Cyan fill
            
            # Rest of the drawing code remains the same...
            if via_type == 'single':
                try:
                    via_diameter = to_decimal(via.get('via_diameter', 0.2))
                    drill_diameter = to_decimal(via.get('drill_diameter', 0.1))
                except (ValueError, TypeError):
                    via_diameter, drill_diameter = 0.2, 0.1
                    
                # Draw via pad
                painter.drawEllipse(QRectF(x_offset - via_diameter/2, y_offset - via_diameter/2,
                                        via_diameter, via_diameter))
                
                # Draw drill hole (black)
                painter.setPen(QPen(QColor("#000000"), 1/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                painter.drawEllipse(QRectF(x_offset - drill_diameter/2, y_offset - drill_diameter/2,
                                        drill_diameter, drill_diameter))
                                        
            elif via_type == 'grid_array':
                try:
                    rows = int(via.get('rows', 2))
                    columns = int(via.get('columns', 2))
                    row_spacing = to_decimal(via.get('row_spacing', 1.0))
                    col_spacing = to_decimal(via.get('col_spacing', 1.0))
                    via_diameter = to_decimal(via.get('via_diameter', 0.2))
                    drill_diameter = to_decimal(via.get('drill_diameter', 0.1))
                except (ValueError, TypeError):
                    rows, columns = 2, 2
                    row_spacing, col_spacing = 1.0, 1.0
                    via_diameter, drill_diameter = 0.2, 0.1
                
                # Calculate grid starting position (centered)
                start_x = x_offset - (columns - 1) * col_spacing / 2
                start_y = y_offset - (rows - 1) * row_spacing / 2
                
                for row in range(rows):
                    for col in range(columns):
                        via_x = start_x + col * col_spacing
                        via_y = start_y + row * row_spacing
                        
                        # Draw via pad
                        painter.setPen(QPen(QColor("#00CED1"), 2/self.zoom_factor))
                        painter.setBrush(QBrush(QColor("#008B8B")))
                        painter.drawEllipse(QRectF(via_x - via_diameter/2, via_y - via_diameter/2,
                                                via_diameter, via_diameter))
                        
                        # Draw drill hole
                        painter.setPen(QPen(QColor("#000000"), 1/self.zoom_factor))
                        painter.setBrush(QBrush(QColor("#000000")))
                        painter.drawEllipse(QRectF(via_x - drill_diameter/2, via_y - drill_diameter/2,
                                                drill_diameter, drill_diameter))

    def calculate_custom_layer_polygon_points(self, layer, abs_x, abs_y):
        """Calculate polygon points for custom layer shapes"""
        polygon_data = layer.get('polygon_data', {})
        lines_data = polygon_data.get('lines', [])
        
        if not lines_data:
            return []

        # Similar to pad polygon calculation
        raw_points = []
        current_x = abs_x
        current_y = abs_y
        raw_points.append((current_x, current_y))

        for line_data in lines_data:
            try:
                line_size = to_decimal(line_data.get('line_size', 1.0))
            except (ValueError, TypeError):
                line_size = 1.0

            direction = line_data.get('direction', 'right')

            if direction == 'right':
                current_x += line_size
            elif direction == 'down':
                current_y -= line_size
            elif direction == 'left':
                current_x -= line_size
            elif direction == 'up':
                current_y += line_size

            raw_points.append((current_x, current_y))

        # Convert to QPointF and handle corners (similar to pad polygons)
        final_points = []
        final_points.append(QPointF(raw_points[0][0], raw_points[0][1]))
        
        for i in range(1, len(raw_points) - 1):
            prev_point = raw_points[i-1]
            curr_point = raw_points[i]
            next_point = raw_points[i+1]
            
            if i-1 < len(lines_data):
                line_data = lines_data[i-1]
                corner_type = line_data.get('corner_type', '90-degree')
                try:
                    corner_size = to_decimal(line_data.get('corner_size', 0))
                except (ValueError, TypeError):
                    corner_size = 0

                if corner_type == '90-degree' or corner_size == 0:
                    final_points.append(QPointF(curr_point[0], curr_point[1]))
                elif corner_type == 'chamfer':
                    chamfer_points = self.calculate_chamfer_points(
                        QPointF(prev_point[0], prev_point[1]),
                        QPointF(curr_point[0], curr_point[1]),
                        QPointF(next_point[0], next_point[1]),
                        corner_size
                    )
                    final_points.extend(chamfer_points)
                elif corner_type == 'fillet':
                    fillet_points = self.calculate_fillet_points(
                        QPointF(prev_point[0], prev_point[1]),
                        QPointF(curr_point[0], curr_point[1]),
                        QPointF(next_point[0], next_point[1]),
                        corner_size
                    )
                    final_points.extend(fillet_points)
            else:
                final_points.append(QPointF(curr_point[0], curr_point[1]))
        
        if len(raw_points) > 1:
            final_points.append(QPointF(raw_points[-1][0], raw_points[-1][1]))

        return final_points


    def draw_origin(self, painter):
        """Draw origin crosshair"""
        # Draw origin crosshair
        painter.setPen(QPen(QColor("#FFFF00"), 2/float(self.zoom_factor))) # Yellow crosshair

        # Crosshair size
        cross_size = Decimal('10') / self.zoom_factor

        # Horizontal line
        painter.drawLine(QPointF(-cross_size, 0), QPointF(cross_size, 0))

        # Vertical line
        painter.drawLine(QPointF(0, -cross_size), QPointF(0, cross_size))

        # Origin circle
        painter.setPen(QPen(QColor("#FFFF00"), 1/self.zoom_factor))
        painter.setBrush(QBrush()) # No fill
        painter.drawEllipse(QPointF(0, 0), 3/self.zoom_factor, 3/self.zoom_factor)

    def wheelEvent(self, event):
        """Handle mouse wheel events with cursor-centered zoom - FIXED VERSION"""
        zoom_in_factor = Decimal('1.2')
        zoom_out_factor = Decimal('1') / zoom_in_factor

        # Get mouse position - convert to Decimal
        mouse_pos = event.position()
        mouse_x = to_decimal(str(mouse_pos.x()))
        mouse_y = to_decimal(str(mouse_pos.y()))

        # Store old zoom factor
        old_zoom = self.zoom_factor

        # Determine zoom direction
        if event.angleDelta().y() > 0:
            zoom_factor = zoom_in_factor
        else:
            zoom_factor = zoom_out_factor

        # Update zoom factor with limits
        new_zoom = self.zoom_factor * zoom_factor
        new_zoom = max(Decimal('0.1'), min(new_zoom, Decimal('1000')))  # Clamp zoom
        self.zoom_factor = new_zoom

        # Calculate widget center - convert to Decimal
        center_x = to_decimal(str(self.width())) / Decimal('2')
        center_y = to_decimal(str(self.height())) / Decimal('2')

        # Mouse position relative to center (in widget coordinates)
        mouse_rel_x = mouse_x - center_x
        mouse_rel_y = mouse_y - center_y

        # Calculate scene coordinates more accurately
        # Convert mouse position to scene coordinates BEFORE zoom change
        scene_x = (mouse_rel_x - self.offset_x) / old_zoom
        scene_y = (mouse_rel_y - self.offset_y) / (-old_zoom)  # Note: negative for Y-flip

        # Calculate new offsets to keep the scene point under the mouse
        self.offset_x = mouse_rel_x - scene_x * self.zoom_factor
        self.offset_y = mouse_rel_y - scene_y * (-self.zoom_factor)  # Note: negative for Y-flip

        # Disable auto fit when manually zooming
        self.auto_fit = False
        self.update()

    def to_decimal_coordinate(self, value):
        """Convert coordinate value to Decimal safely"""
        try:
            return to_decimal(str(value))
        except (ValueError, TypeError):
            return Decimal('0')



    def calculate_all_pad_pitches(self):
        """Calculate center-to-center pitch distances between all pad pairs"""
        pads = self.footprint_data.get('padstacks', [])
        if len(pads) < 2:
            return []
        
        pitches = []
        positions = self.calculate_pad_absolute_positions()
        
        # Calculate pitches between all pad pairs
        for i in range(len(pads)):
            for j in range(i + 1, len(pads)):
                if i not in positions or j not in positions:
                    continue
                    
                x1, y1 = positions[i]
                x2, y2 = positions[j]
                
                dx = abs(x2 - x1)
                dy = abs(y2 - y1)
                
                # Add horizontal pitch if significant
                if dx > 0.01:  # Minimum threshold to avoid noise
                    pitches.append({
                        'pad_pair': (i, j),
                        'direction': 'horizontal',
                        'pitch': dx,
                        'start_pos': QPointF(min(x1, x2), (y1 + y2) / 2),
                        'end_pos': QPointF(max(x1, x2), (y1 + y2) / 2)
                    })
                
                # Add vertical pitch if significant  
                if dy > 0.01:
                    pitches.append({
                        'pad_pair': (i, j),
                        'direction': 'vertical', 
                        'pitch': dy,
                        'start_pos': QPointF((x1 + x2) / 2, min(y1, y2)),
                        'end_pos': QPointF((x1 + x2) / 2, max(y1, y2))
                    })
        
        return pitches


    def calculate_min_pad_to_pad_airgap(self):
        """Calculate minimum edge-to-edge distance between all pads"""
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if len(pad_bounds_list) < 2:
            return None, None

        min_gap = to_decimal('inf')
        closest_pads = None

        for i in range(len(pad_bounds_list)):
            for j in range(i + 1, len(pad_bounds_list)):
                # Unpack bounds
                x1_min, y1_min, x1_max, y1_max = pad_bounds_list[i]
                x2_min, y2_min, x2_max, y2_max = pad_bounds_list[j]

                # Horizontal gap
                if x1_max < x2_min:  # b1 right edge < b2 left edge
                    x_gap = x2_min - x1_max
                elif x2_max < x1_min:  # b2 right edge < b1 left edge
                    x_gap = x1_min - x2_max
                else:
                    x_gap = 0  # Overlapping in X

                # Vertical gap
                if y1_max < y2_min:  # b1 top edge < b2 bottom edge
                    y_gap = y2_min - y1_max
                elif y2_max < y1_min:  # b2 top edge < b1 bottom edge
                    y_gap = y1_min - y2_max
                else:
                    y_gap = 0  # Overlapping in Y

                # Actual distance
                if x_gap == 0 and y_gap == 0:
                    dist = 0  # Overlapping pads
                elif x_gap == 0:
                    dist = y_gap  # Vertically separated
                elif y_gap == 0:
                    dist = x_gap  # Horizontally separated
                else:
                    dist = math.sqrt(x_gap**2 + y_gap**2)  # Corner-to-corner

                if dist < min_gap:
                    min_gap = dist
                    closest_pads = (i, j, x_gap, y_gap)

        return (min_gap if min_gap != to_decimal('inf') else None), closest_pads

    def calculate_all_pad_airgaps(self):
        """Calculate only X and Y edge-to-edge pad clearances."""
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if len(pad_bounds_list) < 2:
            return []
        
        airgaps = []
        
        for i in range(len(pad_bounds_list)):
            for j in range(i + 1, len(pad_bounds_list)):
                b1 = pad_bounds_list[i]  # [min_x, min_y, max_x, max_y]
                b2 = pad_bounds_list[j]

                h_start = h_end = v_start = v_end = None
                x_gap = y_gap = 0

                # --- Horizontal gap (edge-to-edge) ---
                if b1[2] < b2[0]:  # pad1 right to pad2 left
                    x_gap = b2[0] - b1[2]
                    h_start = QPointF(b1[2], (b1[1] + b1[3]) / 2)
                    h_end   = QPointF(b2[0], (b2[1] + b2[3]) / 2)
                elif b2[2] < b1[0]:  # pad2 right to pad1 left
                    x_gap = b1[0] - b2[2]
                    h_start = QPointF(b2[2], (b2[1] + b2[3]) / 2)
                    h_end   = QPointF(b1[0], (b1[1] + b1[3]) / 2)

                # --- Vertical gap (edge-to-edge) ---
                if b1[3] < b2[1]:  # pad1 top to pad2 bottom
                    y_gap = b2[1] - b1[3]
                    v_start = QPointF((b1[0] + b1[2]) / 2, b1[3])
                    v_end   = QPointF((b2[0] + b2[2]) / 2, b2[1])
                elif b2[3] < b1[1]:  # pad2 top to pad1 bottom
                    y_gap = b1[1] - b2[3]
                    v_start = QPointF((b2[0] + b2[2]) / 2, b2[3])
                    v_end   = QPointF((b1[0] + b1[2]) / 2, b1[1])

                airgaps.append({
                    'pads': (i, j),
                    'x_gap': x_gap,
                    'y_gap': y_gap,
                    'h_line': (h_start, h_end) if h_start and h_end else None,
                    'v_line': (v_start, v_end) if v_start and v_end else None,
                })
        
        return airgaps


    def draw_dimension_line_with_label(self, painter, start_point, end_point, value_mm, label_prefix, color, label_offset=QPointF(0,0)):
        """Draw a dimension line with colored 'pill' label in mm with optional offset."""
        if not start_point or not end_point or value_mm <= 0:
            return

        # 1) Dimension line - FIX: Convert zoom_factor to float for division
        painter.setPen(QPen(color, 1.5/float(self.zoom_factor)))
        painter.drawLine(start_point, end_point)

        # 2) End ticks - FIX: Convert zoom_factor to float for division
        ext = 3/float(self.zoom_factor)
        v = QPointF(end_point.x() - start_point.x(), end_point.y() - start_point.y())
        L = math.hypot(v.x(), v.y())
        if L > 0:
            n = QPointF(v.x()/L, v.y()/L)
            p = QPointF(-n.y(), n.x())
            painter.drawLine(QPointF(start_point.x()+p.x()*ext, start_point.y()+p.y()*ext),
                            QPointF(start_point.x()-p.x()*ext, start_point.y()-p.y()*ext))
            painter.drawLine(QPointF(end_point.x()+p.x()*ext, end_point.y()+p.y()*ext),
                            QPointF(end_point.x()-p.x()*ext, end_point.y()-p.y()*ext))

        # 3) Label (world midpoint -> screen) with offset
        mid = QPointF((start_point.x()+end_point.x())/2, (start_point.y()+end_point.y())/2)
        screen_mid = painter.worldTransform().map(mid)

        # Apply offset to prevent label overlap
        screen_mid += label_offset

        label_text = f"{label_prefix}:{value_mm}mm"

        painter.save()
        painter.resetTransform()

        font = QFont("Arial", 9)
        font.setBold(True)
        painter.setFont(font)

        fm = painter.fontMetrics()
        rect = fm.boundingRect(label_text)
        rect.moveCenter(screen_mid.toPoint())
        rect.adjust(-4, -2, 4, 2)

        bg = QColor(color)
        bg.setAlpha(200)
        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush(bg))
        painter.drawRoundedRect(rect, 4, 4)

        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush())
        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, label_text)

        painter.restore()

    def draw_all_airgap_dimensions(self, painter):
        """Draw air gap dimensions only between selected pads (if exactly 2 selected)"""
        if len(self.selected_pads) != 2:
            return

        pad_indices = list(self.selected_pads)
        i, j = pad_indices[0], pad_indices[1]

        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if i >= len(pad_bounds_list) or j >= len(pad_bounds_list):
            return

        b1 = pad_bounds_list[i]  # (x_min, y_min, x_max, y_max)
        b2 = pad_bounds_list[j]

        # Calculate horizontal gap (X)
        h_start = h_end = None
        x_gap = 0

        if b1[2] < b2[0]:  # pad1 right edge < pad2 left edge
            x_gap = b2[0] - b1[2]
            h_start = QPointF(b1[2], (b1[1] + b1[3]) / 2)
            h_end   = QPointF(b2[0], (b2[1] + b2[3]) / 2)

        elif b2[2] < b1[0]:  # pad2 right edge < pad1 left edge
            x_gap = b1[0] - b2[2]
            h_start = QPointF(b2[2], (b2[1] + b2[3]) / 2)
            h_end   = QPointF(b1[0], (b1[1] + b1[3]) / 2)

        # Calculate vertical gap (Y)
        v_start = v_end = None
        y_gap = 0

        if b1[3] < b2[1]:  # pad1 top < pad2 bottom
            y_gap = b2[1] - b1[3]
            v_start = QPointF((b1[0] + b1[2]) / 2, b1[3])
            v_end   = QPointF((b2[0] + b2[2]) / 2, b2[1])

        elif b2[3] < b1[1]:  # pad2 top < pad1 bottom
            y_gap = b1[1] - b2[3]
            v_start = QPointF((b2[0] + b2[2]) / 2, b2[3])
            v_end   = QPointF((b1[0] + b1[2]) / 2, b1[1])

        # Draw dimension lines
        if h_start and h_end and x_gap > 0:
            label_offset = QPointF(0, -15)
            self.draw_dimension_line_with_label(
                painter, h_start, h_end, x_gap, "X Gap", QColor("#00FFFF"), label_offset
            )

        if v_start and v_end and y_gap > 0:
            label_offset = QPointF(15, 0)
            self.draw_dimension_line_with_label(
                painter, v_start, v_end, y_gap, "Y Gap", QColor("#FFFF00"), label_offset
            )

    def draw_all_pitch_dimensions(self, painter):
        """Draw pitch dimensions only between selected pads (if exactly 2 selected)"""
        if len(self.selected_pads) != 2:
            return
        
        pad_indices = list(self.selected_pads)
        i, j = pad_indices[0], pad_indices[1]
        
        positions = self.calculate_pad_absolute_positions()
        if i not in positions or j not in positions:
            return
        
        x1, y1 = positions[i]
        x2, y2 = positions[j]
        
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        
        # Draw horizontal pitch if significant
        if dx > 0.01:
            start = QPointF(min(x1, x2), (y1 + y2) / 2)
            end = QPointF(max(x1, x2), (y1 + y2) / 2)
            label_offset = QPointF(0, -25)  # Offset to avoid overlap
            self.draw_dimension_line_with_label(
                painter, start, end, dx, "Pitch X", QColor("#FFA500"), label_offset
            )
        
        # Draw vertical pitch if significant
        if dy > 0.01:
            start = QPointF((x1 + x2) / 2, min(y1, y2))
            end = QPointF((x1 + x2) / 2, max(y1, y2))
            label_offset = QPointF(25, 0)  # Offset to avoid overlap
            self.draw_dimension_line_with_label(
                painter, start, end, dy, "Pitch Y", QColor("#FFA500"), label_offset
            )


    def draw_minimum_airgap_summary(self, painter):
        """Draw minimum airgap summary in top-left corner"""
        airgaps = self.calculate_all_pad_airgaps()
        if not airgaps:
            return
        
        # Find minimum values
        min_x = min((a['x_gap'] for a in airgaps if a['x_gap'] > 0), default=None)
        min_y = min((a['y_gap'] for a in airgaps if a['y_gap'] > 0), default=None)
        min_overall = min((min(a['x_gap'], a['y_gap']) for a in airgaps 
                        if a['x_gap'] > 0 or a['y_gap'] > 0), default=None)
        
        if min_overall is None:
            return
        
        painter.save()
        painter.resetTransform()
        
        # Create summary text
        summary_lines = []
        if min_overall is not None:
            summary_lines.append(f"Min Airgap: {min_overall:.3f}mm")
        if min_x is not None:
            summary_lines.append(f"Min X Gap: {min_x:.3f}mm")
        if min_y is not None:
            summary_lines.append(f"Min Y Gap: {min_y:.3f}mm")
        
        # Set font
        font = QFont("Arial", 10)
        font.setBold(True)
        painter.setFont(font)
        
        # Calculate text area
        fm = painter.fontMetrics()
        max_width = max(fm.horizontalAdvance(line) for line in summary_lines)
        line_height = fm.height()
        total_height = len(summary_lines) * line_height + 10
        
        # Draw background
        bg_rect = QRectF(10, 10, max_width + 20, total_height)
        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush(QColor("#000000", 180)))
        painter.drawRect(bg_rect)
        
        # Draw text lines
        y_offset = 10
        painter.setPen(QPen(QColor("#00FF00"), 1))
        for line in summary_lines:
            painter.drawText(20, y_offset + line_height, line)
            y_offset += line_height
        
        painter.restore()

    def draw_selection_instructions(self, painter):
        """Draw instruction text for pad selection"""
        painter.save()
        painter.resetTransform()  # Switch to screen coordinates
        
        instructions = []
        
        if self.show_airgap_checkbox.isChecked() or self.show_pitch_checkbox.isChecked():
            if len(self.selected_pads) == 0:
                instructions.append("Click on 2 pads to measure dimensions")
            elif len(self.selected_pads) == 1:
                instructions.append("Click on 1 more pad to measure")
            elif len(self.selected_pads) == 2:
                instructions.append("Dimensions shown between selected pads")
                instructions.append("Click elsewhere to clear selection")
        
        if instructions:
            # Position at bottom-left
            y_start = self.height() - 60
            
            painter.setPen(QPen(QColor("#FFFFFF"), 1))
            font = QFont("Arial", 10)
            painter.setFont(font)
            
            for i, instruction in enumerate(instructions):
                # Draw background for better visibility
                text_rect = painter.fontMetrics().boundingRect(instruction)
                text_rect.moveTo(10, y_start + i * 20)
                text_rect.adjust(-3, -1, 3, 1)
                
                painter.setBrush(QBrush(QColor(0, 0, 0, 150)))
                painter.drawRect(text_rect)
                
                painter.setBrush(QBrush())
                painter.drawText(10, y_start + i * 20 + 15, instruction)
        
        painter.restore()



    def draw_pad_airgap_dimension(self, painter):
        """Draw pad-to-pad airgap dimension in screen space"""
        min_airgap, closest_pads = self.calculate_min_pad_to_pad_airgap()
        if min_airgap is None:
            return
        
        # Draw airgap text in screen space
        painter.save()
        painter.resetTransform()  # Switch to screen coordinates
        
        # Set text properties
        painter.setPen(QPen(QColor("#00FF00"), 2))  # Bright green
        font = QFont("Arial", 12)
        font.setBold(True)
        painter.setFont(font)
        
        # Format the airgap value
        airgap_text = f"Min Pad-to-Pad Airgap: {min_airgap:.3f} mm"
        
        # Draw text with background for better visibility
        text_rect = painter.fontMetrics().boundingRect(airgap_text)
        text_rect.adjust(-5, -2, 5, 2)
        text_rect.moveTo(10, 10)
        
        # Draw background rectangle
        painter.setPen(QPen(QColor("#000000"), 1))
        color = QColor("#000000")
        color.setAlpha(180)
        painter.setBrush(QBrush(color))
 # Semi-transparent black
        painter.drawRect(text_rect)
        
        # Draw the text
        painter.setPen(QPen(QColor("#00FF00"), 2))
        painter.setBrush(QBrush())
        painter.drawText(text_rect.adjusted(5, 2, -5, -2), Qt.AlignmentFlag.AlignLeft, airgap_text)
        
        painter.restore()

    def draw_airgap_dimension_lines(self, painter):
        """Draw dimension lines between closest pads"""
        min_airgap, closest_pads = self.calculate_min_pad_to_pad_airgap()
        if min_airgap is None or closest_pads is None:
            return
        
        if min_airgap == 0:  # Skip if pads are overlapping
            return
            
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        i, j, x_gap, y_gap = closest_pads
        
        b1 = pad_bounds_list[i]
        b2 = pad_bounds_list[j]
        
        # Set dimension line properties
        painter.setPen(QPen(QColor("#FFFF00"), 1.5/self.zoom_factor))  # Yellow dimension lines
        
        if x_gap > 0 and y_gap == 0:  # Horizontally separated
            # Draw horizontal dimension line
            y_center = (max(b1[1], b2[1]) + min(b1[3], b2[3])) / 2
            line_start = QPointF(b1[2], y_center)
            line_end = QPointF(b2[0], y_center)
            
            painter.drawLine(line_start, line_end)
            
            # Draw extension lines
            # Draw extension lines (horizontal gap case)
            painter.drawLine(QPointF(b1[2], b1[1]), QPointF(b1[2], b1[3]))  # right edge of pad 1
            painter.drawLine(QPointF(b2[0], b2[1]), QPointF(b2[0], b2[3]))  # left edge of pad 2

        elif y_gap > 0 and x_gap == 0:  # Vertically separated
            # Draw vertical dimension line
            x_center = (max(b1[0], b2[0]) + min(b1[2], b2[2])) / 2
            line_start = QPointF(x_center, b1[3])  # top edge of pad 1
            line_end   = QPointF(x_center, b2[1])  # bottom edge of pad 2
            painter.drawLine(line_start, line_end)

            # Draw extension lines (vertical gap case)
            painter.drawLine(QPointF(b1[0], b1[3]), QPointF(b1[2], b1[3]))  # top edge of pad 1
            painter.drawLine(QPointF(b2[0], b2[1]), QPointF(b2[2], b2[1]))  # bottom edge of pad 2

    def generate_pad_name(self, pad):
        """Generate padstack name based on pad type and expansions"""
        pad_type = pad['type']
        
        try:
            mask_exp = to_decimal(pad.get('mask_expansion', 0)) if pad.get('mask_enabled', True) else 0
            paste_exp = to_decimal(pad.get('paste_expansion', 0)) if pad.get('paste_enabled', True) else 0
        except (ValueError, TypeError):
            mask_exp = paste_exp = 0
        
        name = ""
        
        if pad_type == 'square':
            try:
                size = to_decimal(pad.get('size', 1))
                name = f"S{int(size * 100)}"
                if mask_exp > 0:
                    mask_size = int((size + 2 * mask_exp) * 100)
                    name += f"_M{mask_size}"
                if paste_exp > 0:
                    paste_size = int((size + 2 * paste_exp) * 100)
                    name += f"_P{paste_size}"
            except (ValueError, TypeError):
                name = "S100"
                
        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong', 'PTH_rectangle']:
            try:
                length = to_decimal(pad.get('length', 1))
                width = to_decimal(pad.get('width', 1))
                name = f"R{int(length * 100)}x{int(width * 100)}"
                if mask_exp > 0:
                    mask_l = int((length + 2 * mask_exp) * 100)
                    mask_w = int((width + 2 * mask_exp) * 100)
                    name += f"_M{mask_l}x{mask_w}"
                if paste_exp > 0:
                    paste_l = int((length + 2 * paste_exp) * 100)
                    paste_w = int((width + 2 * paste_exp) * 100)
                    name += f"_P{paste_l}x{paste_w}"
            except (ValueError, TypeError):
                name = "R100x100"

        elif pad_type == 'NPTH_rectangle':
            try:
                hole_l = to_decimal(pad.get('hole_length', 1.5))
                hole_w = to_decimal(pad.get('hole_width', 0.8))
                name = f"NPTHR{int(hole_l * 100)}x{int(hole_w * 100)}"
            except (ValueError, TypeError):
                name = "NPTHR150x80"
                
        elif pad_type == 'round':
            try:
                diameter = to_decimal(pad.get('diameter', 1))
                name = f"C{int(diameter * 100)}"  # C for circular
                if mask_exp > 0:
                    mask_dia = int((diameter + 2 * mask_exp) * 100)
                    name += f"_M{mask_dia}"
                if paste_exp > 0:
                    paste_dia = int((diameter + 2 * paste_exp) * 100)
                    name += f"_P{paste_dia}"
            except (ValueError, TypeError):
                name = "C100"
                
        elif pad_type in ['PTH', 'NPTH']:
            hole_dia = to_decimal(pad.get('hole_diameter', 0.8))
            if pad_type == 'PTH':
                pad_dia = to_decimal(pad.get('pad_diameter', 1.2))
                name = f"PTH{int(hole_dia * 100)}_P{int(pad_dia * 100)}"
            else:
                name = f"NPTH{int(hole_dia * 100)}"
                
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            hole_l = to_decimal(pad.get('hole_length', 1.5))
            hole_w = to_decimal(pad.get('hole_width', 0.8))
            if pad_type == 'PTH_oblong':
                pad_l = to_decimal(pad.get('pad_length', 2.0))
                pad_w = to_decimal(pad.get('pad_width', 1.2))
                name = f"PTHO{int(hole_l * 100)}x{int(hole_w * 100)}_P{int(pad_l * 100)}x{int(pad_w * 100)}"
            else:
                name = f"NPTHO{int(hole_l * 100)}x{int(hole_w * 100)}"
        else:
            name = f"{pad_type.upper()}"
            
        return name




class PadPositionResolver:
    def __init__(self, pads):
        self.pads = pads
        self.cache = {}
        self.resolved_positions = {}

    def clear_cache(self):
        self.cache.clear()
        self.resolved_positions.clear()

    def get_pad_by_pin(self, pin_number):
        for pad in self.pads:
            if pad.get('pin_number', None) == pin_number:
                return pad
        return None

    def get_absolute_position(self, pad, visiting=None):
        """Get absolute position with cycle detection"""
        if visiting is None:
            visiting = set()
        
        pad_pin = pad.get('pin_number', '')
        
        # Check cache first
        if pad_pin in self.cache:
            return self.cache[pad_pin]
        
        # Check for circular reference
        if pad_pin in visiting:
            print(f"Warning: Circular reference detected for pad {pad_pin}. Using origin offset.")
            try:
                x_offset = to_decimal(pad.get('x_offset', 0))
                y_offset = to_decimal(pad.get('y_offset', 0))
            except (ValueError, TypeError):
                x_offset, y_offset = 0, 0
            self.cache[pad_pin] = (x_offset, y_offset)
            return x_offset, y_offset
        
        # Add current pad to visiting set
        visiting.add(pad_pin)
        
        offset_from = pad.get('offset_from', 'origin')
        try:
            x_offset = to_decimal(pad.get('x_offset', 0))
            y_offset = to_decimal(pad.get('y_offset', 0))
        except (ValueError, TypeError):
            x_offset, y_offset = 0, 0
        
        if offset_from == 'origin':
            abs_x, abs_y = x_offset, y_offset
            self.resolved_positions[pad_pin] = (abs_x, abs_y)
        else:
            # Direct pin reference with cycle detection
            ref_pad = self.get_pad_by_pin(offset_from)
            if ref_pad and ref_pad != pad:
                try:
                    ref_x, ref_y = self.get_absolute_position(ref_pad, visiting)
                    abs_x = ref_x + x_offset
                    abs_y = ref_y + y_offset
                    self.resolved_positions[pad_pin] = (abs_x, abs_y)
                except RecursionError:
                    print(f"Warning: Recursion limit reached for pad {pad_pin}. Using origin offset.")
                    abs_x, abs_y = x_offset, y_offset
                    self.resolved_positions[pad_pin] = (abs_x, abs_y)
            else:
                # Fallback to origin if reference not found
                abs_x, abs_y = x_offset, y_offset
                self.resolved_positions[pad_pin] = (abs_x, abs_y)
        
        # Remove from visiting set before returning
        visiting.discard(pad_pin)
        
        # Cache the result
        self.cache[pad_pin] = (abs_x, abs_y)
        return abs_x, abs_y


    def resolve_all_positions(self):
        self.clear_cache()
        
        # Resolve origin-based pads first
        for pad in self.pads:
            if pad.get('offset_from', 'origin') == 'origin':
                self.get_absolute_position(pad)

        # Iteratively resolve referenced pads
        max_iterations = len(self.pads) * 2
        for _ in range(max_iterations):
            resolved_any = False
            for pad in self.pads:
                pad_pin = pad.get('pin_number', '')
                if pad_pin not in self.resolved_positions:
                    try:
                        self.get_absolute_position(pad)
                        resolved_any = True
                    except:
                        continue
            
            if not resolved_any:
                break

        return self.resolved_positions

class PadStackRow(QWidget):
    delete_requested = pyqtSignal(object)
    data_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self):
        # Main container with grouped sections
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)

        # Create group box for this padstack
        self.group_box = QGroupBox("Padstack Configuration")
        group_layout = QVBoxLayout(self.group_box)
        group_layout.setSpacing(5)

        # ===== ROW 1: Pad Type and Geometry =====
        row1_layout = QHBoxLayout()
        row1_layout.setSpacing(10)

        # Pad Type Group
        type_group = QGroupBox("Pad Type")
        type_layout = QHBoxLayout(type_group)
        type_layout.setContentsMargins(5, 5, 5, 5)

        self.type_combo = QComboBox()
        self.type_combo.addItems([
            'square', 'rectangle', 'rounded_rectangle', 'round', 'custom',
            'SMD-oblong', 'D-shape', 'PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong', 'PTH_rectangle', 'NPTH_rectangle'
        ])
        type_layout.addWidget(self.type_combo)

        row1_layout.addWidget(type_group)

        # Geometry Group (Dynamic based on pad type)
        self.geometry_group = QGroupBox("Geometry")
        self.geometry_layout = QHBoxLayout(self.geometry_group)
        self.geometry_layout.setContentsMargins(5, 5, 5, 5)
        row1_layout.addWidget(self.geometry_group)

        # Action Buttons Group
        actions_group = QGroupBox("Actions")
        actions_layout = QHBoxLayout(actions_group)
        actions_layout.setContentsMargins(5, 5, 5, 5)

        self.duplicate_btn = QPushButton("Duplicate")
        self.duplicate_btn.setMaximumWidth(80)
        self.delete_btn = QPushButton("Delete")
        self.delete_btn.setMaximumWidth(60)

        actions_layout.addWidget(self.duplicate_btn)
        actions_layout.addWidget(self.delete_btn)
        row1_layout.addWidget(actions_group)

        group_layout.addLayout(row1_layout)

        # ===== ROW 2: Position and Layer Properties =====
        row2_layout = QHBoxLayout()
        row2_layout.setSpacing(10)

        # Position Group
        position_group = QGroupBox("Position")
        position_layout = QGridLayout(position_group)
        position_layout.setContentsMargins(5, 5, 5, 5)

        position_layout.addWidget(QLabel("X Offset:"), 0, 0)
        self.x_offset = QLineEdit()
        self.x_offset.setText("0")
        self.x_offset.setMaximumWidth(100)
        position_layout.addWidget(self.x_offset, 0, 1)

        position_layout.addWidget(QLabel("Y Offset:"), 0, 2)
        self.y_offset = QLineEdit()
        self.y_offset.setText("0")
        self.y_offset.setMaximumWidth(100)
        position_layout.addWidget(self.y_offset, 0, 3)

        position_layout.addWidget(QLabel("Offset From:"), 1, 0)
        # Dynamic dropdown instead of fixed directional options
        self.offset_from = QComboBox()
        self.offset_from.setMaximumWidth(100)
        position_layout.addWidget(self.offset_from, 1, 1, 1, 2)

        position_layout.addWidget(QLabel("Pin:"), 1, 2)
        self.pin_number = QLineEdit()
        self.pin_number.setMaximumWidth(50)
        position_layout.addWidget(self.pin_number, 1, 3)

        row2_layout.addWidget(position_group)


        # Layer Properties Group
        layers_group = QGroupBox("Layer Properties")
        layers_layout = QGridLayout(layers_group)
        layers_layout.setContentsMargins(5, 5, 5, 5)

        layers_layout.addWidget(QLabel("Mask Expansion:"), 0, 0)
        self.mask_expansion = QLineEdit()
        self.mask_expansion.setText("0")
        self.mask_expansion.setMaximumWidth(100)
        layers_layout.addWidget(self.mask_expansion, 0, 1)

        layers_layout.addWidget(QLabel("Paste Expansion:"), 1, 0)
        self.paste_expansion = QLineEdit()
        self.paste_expansion.setText("0")
        self.paste_expansion.setMaximumWidth(100)
        layers_layout.addWidget(self.paste_expansion, 1, 1)

        # Add checkboxes for enabling/disabling mask and paste layers
        self.mask_enabled = QCheckBox("Enable Mask")
        self.mask_enabled.setChecked(True)
        layers_layout.addWidget(self.mask_enabled, 0, 2)

        self.paste_enabled = QCheckBox("Enable Paste")
        self.paste_enabled.setChecked(True)
        layers_layout.addWidget(self.paste_enabled, 1, 2)

        row2_layout.addWidget(layers_group)

        group_layout.addLayout(row2_layout)

        # Custom polygon widget (initially hidden)
        self.polygon_widget = CustomPolygonWidget()
        self.polygon_widget.data_changed.connect(self.data_changed.emit)
        self.polygon_widget.setVisible(False)
        group_layout.addWidget(self.polygon_widget)

        main_layout.addWidget(self.group_box)
        self.setLayout(main_layout)

        # Initialize geometry inputs
        self.update_geometry_inputs()

    def connect_signals(self):
        self.type_combo.currentTextChanged.connect(self.update_geometry_inputs)
        self.type_combo.currentTextChanged.connect(self.update_layer_visibility)
        self.type_combo.currentTextChanged.connect(self.data_changed.emit)
        self.delete_btn.clicked.connect(lambda: self.delete_requested.emit(self))

        # Connect all input signals
        self.x_offset.textChanged.connect(self.data_changed.emit)
        self.y_offset.textChanged.connect(self.data_changed.emit)
        self.mask_expansion.textChanged.connect(self.data_changed.emit)
        self.paste_expansion.textChanged.connect(self.data_changed.emit)
        self.mask_enabled.stateChanged.connect(self.data_changed.emit)
        self.paste_enabled.stateChanged.connect(self.data_changed.emit)

        self.offset_from.currentTextChanged.connect(self.data_changed.emit)
        
        # Update dropdown when pin numbers change
        self.pin_number.textChanged.connect(self.update_offset_from_options)
        self.pin_number.textChanged.connect(self.data_changed.emit)

    def update_layer_visibility(self):
        """Show/hide layer checkboxes based on pad type"""
        pad_type = self.type_combo.currentText()
        smd_types = ['square', 'rectangle', 'rounded_rectangle', 'round', 'SMD-oblong', 'D-shape', 'custom']
        
        # Show checkboxes only for SMD pad types
        is_smd = pad_type in smd_types
        self.mask_enabled.setVisible(is_smd)
        self.paste_enabled.setVisible(is_smd)

    def update_offset_from_options(self):
        """Update the offset_from dropdown with all available pin numbers"""
        # Get the parent FootprintDesigner to access all padstack rows
        parent_designer = self.get_parent_designer()
        if not parent_designer:
            return

        # Collect all pin numbers except the current one
        available_pins = []
        current_pin = self.pin_number.text().strip()

        for row in parent_designer.padstack_rows:
            if row != self: # Don't include self
                pin_text = row.pin_number.text().strip()
                if pin_text and pin_text != current_pin:
                    available_pins.append(pin_text)

        # Update the dropdown
        current_selection = self.offset_from.currentText()
        self.offset_from.blockSignals(True)
        self.offset_from.clear()
        self.offset_from.addItem('origin') # Always include origin

        # Sort pin numbers numerically if possible, otherwise alphabetically
        try:
            available_pins.sort(key=lambda x: int(x) if x.isdigit() else to_decimal('inf'))
        except:
            available_pins.sort()

        self.offset_from.addItems(available_pins)

        # Restore previous selection if still valid
        index = self.offset_from.findText(current_selection)
        if index >= 0:
            self.offset_from.setCurrentIndex(index)
        else:
            self.offset_from.setCurrentText('origin')

        self.offset_from.blockSignals(False)

    def get_parent_designer(self):
        """Find the parent FootprintDesigner instance"""
        parent = self.parent()
        while parent:
            if hasattr(parent, 'padstack_rows'):
                return parent
            parent = parent.parent()
        return None

    def update_geometry_inputs(self):
        # Clear existing geometry inputs
        for i in reversed(range(self.geometry_layout.count())):
            item = self.geometry_layout.itemAt(i)
            if item:
                widget = item.widget()
                if widget:
                    widget.setParent(None)

        pad_type = self.type_combo.currentText()

        # Show/hide polygon widget
        self.polygon_widget.setVisible(pad_type == 'custom')
        
        # Update layer visibility
        self.update_layer_visibility()

        if pad_type == 'square':
            self.geometry_layout.addWidget(QLabel("Size:"))
            self.size_input = QLineEdit()
            self.size_input.setText("1.0")
            self.size_input.setMaximumWidth(100)
            self.size_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.size_input)

        elif pad_type in ['rectangle', 'SMD-oblong']:
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

        elif pad_type == 'rounded_rectangle':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

            self.geometry_layout.addWidget(QLabel("Corner Radius:"))
            self.corner_radius_input = QLineEdit()
            self.corner_radius_input.setText("0.2")
            self.corner_radius_input.setMaximumWidth(100)
            self.corner_radius_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.corner_radius_input)

        elif pad_type in ['round']:
            self.geometry_layout.addWidget(QLabel("Diameter:"))
            self.diameter_input = QLineEdit()
            self.diameter_input.setText("1.0")
            self.diameter_input.setMaximumWidth(100)
            self.diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.diameter_input)

        elif pad_type in ['PTH', 'NPTH']:
            # Round through hole
            self.geometry_layout.addWidget(QLabel("Hole Diameter:"))
            self.hole_diameter_input = QLineEdit()
            self.hole_diameter_input.setText("0.8")
            self.hole_diameter_input.setMaximumWidth(100)
            self.hole_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_diameter_input)

            if pad_type == 'PTH':
                # PTH needs pad diameter
                self.geometry_layout.addWidget(QLabel("Pad Diameter:"))
                self.pad_diameter_input = QLineEdit()
                self.pad_diameter_input.setText("1.2")
                self.pad_diameter_input.setMaximumWidth(100)
                self.pad_diameter_input.textChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_diameter_input)

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            # Oblong through hole
            self.geometry_layout.addWidget(QLabel("Hole Length:"))
            self.hole_length_input = QLineEdit()
            self.hole_length_input.setText("1.5")
            self.hole_length_input.setMaximumWidth(100)
            self.hole_length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_length_input)

            self.geometry_layout.addWidget(QLabel("Hole Width:"))
            self.hole_width_input = QLineEdit()
            self.hole_width_input.setText("0.8")
            self.hole_width_input.setMaximumWidth(100)
            self.hole_width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_width_input)

            if pad_type == 'PTH_oblong':
                # PTH oblong needs pad dimensions
                self.geometry_layout.addWidget(QLabel("Pad Length:"))
                self.pad_length_input = QLineEdit()
                self.pad_length_input.setText("2.0")
                self.pad_length_input.setMaximumWidth(100)
                self.pad_length_input.textChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_length_input)

                self.geometry_layout.addWidget(QLabel("Pad Width:"))
                self.pad_width_input = QLineEdit()
                self.pad_width_input.setText("1.2")
                self.pad_width_input.setMaximumWidth(100)
                self.pad_width_input.textChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_width_input)

            # Add rotation control for oblong pads
            self.geometry_layout.addWidget(QLabel("Rotation:"))
            self.rotation_input = QLineEdit()
            self.rotation_input.setText("0")
            self.rotation_input.setMaximumWidth(80)
            self.rotation_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rotation_input)

        elif pad_type == 'D-shape':
            self.geometry_layout.addWidget(QLabel("Pad Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Pad Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

            self.geometry_layout.addWidget(QLabel("Corner Radius:"))
            self.corner_radius_input = QLineEdit()
            self.corner_radius_input.setText("0.2")
            self.corner_radius_input.setMaximumWidth(100)
            self.corner_radius_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.corner_radius_input)

            self.geometry_layout.addWidget(QLabel("Rotation:"))
            self.rotation_input = QLineEdit()
            self.rotation_input.setText("0")
            self.rotation_input.setMaximumWidth(80)
            self.rotation_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rotation_input)

        elif pad_type == 'PTH_rectangle':
            self.geometry_layout.addWidget(QLabel("Hole Length:"))
            self.hole_length_input = QLineEdit()
            self.hole_length_input.setText("1.5")
            self.hole_length_input.setMaximumWidth(100)
            self.hole_length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_length_input)

            self.geometry_layout.addWidget(QLabel("Hole Width:"))
            self.hole_width_input = QLineEdit()
            self.hole_width_input.setText("0.8")
            self.hole_width_input.setMaximumWidth(100)
            self.hole_width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_width_input)

            self.geometry_layout.addWidget(QLabel("Pad Length:"))
            self.pad_length_input = QLineEdit()
            self.pad_length_input.setText("2.0")
            self.pad_length_input.setMaximumWidth(100)
            self.pad_length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.pad_length_input)

            self.geometry_layout.addWidget(QLabel("Pad Width:"))
            self.pad_width_input = QLineEdit()
            self.pad_width_input.setText("1.2")
            self.pad_width_input.setMaximumWidth(100)
            self.pad_width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.pad_width_input)

            self.geometry_layout.addWidget(QLabel("Rotation:"))
            self.rotation_input = QLineEdit()
            self.rotation_input.setText("0")
            self.rotation_input.setMaximumWidth(80)
            self.rotation_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rotation_input)

        elif pad_type == 'NPTH_rectangle':
            # NPTH rectangle (rectangular hole, no pad)
            self.geometry_layout.addWidget(QLabel("Hole Length:"))
            self.hole_length_input = QLineEdit()
            self.hole_length_input.setText("1.5")
            self.hole_length_input.setMaximumWidth(100)
            self.hole_length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_length_input)

            self.geometry_layout.addWidget(QLabel("Hole Width:"))
            self.hole_width_input = QLineEdit()
            self.hole_width_input.setText("0.8")
            self.hole_width_input.setMaximumWidth(100)
            self.hole_width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_width_input)

            # Add rotation control for NPTH rectangle
            self.geometry_layout.addWidget(QLabel("Rotation:"))
            self.rotation_input = QLineEdit()
            self.rotation_input.setText("0")
            self.rotation_input.setMaximumWidth(80)
            self.rotation_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rotation_input)


        elif pad_type == 'custom':
            # Custom polygon inputs handled by polygon_widget
            self.geometry_layout.addWidget(QLabel("Custom Polygon (see below)"))

        # ADD TOLERANCE INPUT FOR THROUGH HOLE PAD TYPES
        through_hole_types = ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong', 'PTH_rectangle', 'NPTH_rectangle']
        
        if pad_type in through_hole_types:
            self.geometry_layout.addWidget(QLabel("Tolerance (mm):"))
            self.tolerance_input = QLineEdit()
            self.tolerance_input.setText("0.05")  # Default tolerance value
            self.tolerance_input.setMaximumWidth(80)
            self.tolerance_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.tolerance_input)

        # Add stretch to push everything to the left
        self.geometry_layout.addStretch()

    def get_data(self):
        data = {
            'type': self.type_combo.currentText(),
            'x_offset': self.x_offset.text(),
            'y_offset': self.y_offset.text(),
            'offset_from': self.offset_from.currentText(),
            'mask_expansion': self.mask_expansion.text(),
            'paste_expansion': self.paste_expansion.text(),
            'mask_enabled': self.mask_enabled.isChecked(),
            'paste_enabled': self.paste_enabled.isChecked(),
            'pin_number': self.pin_number.text()
        }

        pad_type = self.type_combo.currentText()

        # ADD TOLERANCE FOR THROUGH HOLE PADS
        through_hole_types = ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong', 'PTH_rectangle', 'NPTH_rectangle']
        if pad_type in through_hole_types and hasattr(self, 'tolerance_input'):
            data['tolerance'] = self.tolerance_input.text()

        if pad_type == 'square' and hasattr(self, 'size_input'):
            data['size'] = self.size_input.text()

        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong']:
            if hasattr(self, 'length_input'):
                data['length'] = self.length_input.text()
            if hasattr(self, 'width_input'):
                data['width'] = self.width_input.text()
            if pad_type == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                data['corner_radius'] = self.corner_radius_input.text()

        elif pad_type in ['round'] and hasattr(self, 'diameter_input'):
            data['diameter'] = self.diameter_input.text()

        elif pad_type in ['D-shape']:
            if hasattr(self, 'length_input'):
                data['length'] = self.length_input.text()
            if hasattr(self, 'width_input'):
                data['width'] = self.width_input.text()
            if hasattr(self, 'corner_radius_input'):
                data['corner_radius'] = self.corner_radius_input.text()
            if hasattr(self, 'rotation_input'):
                data['rotation'] = self.rotation_input.text()

        elif pad_type in ['PTH', 'NPTH']:
            if hasattr(self, 'hole_diameter_input'):
                data['hole_diameter'] = self.hole_diameter_input.text()
            if pad_type == 'PTH' and hasattr(self, 'pad_diameter_input'):
                data['pad_diameter'] = self.pad_diameter_input.text()

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if hasattr(self, 'hole_length_input'):
                data['hole_length'] = self.hole_length_input.text()
            if hasattr(self, 'hole_width_input'):
                data['hole_width'] = self.hole_width_input.text()
            if hasattr(self, 'rotation_input'):
                data['rotation'] = self.rotation_input.text()
            if pad_type == 'PTH_oblong':
                if hasattr(self, 'pad_length_input'):
                    data['pad_length'] = self.pad_length_input.text()
                if hasattr(self, 'pad_width_input'):
                    data['pad_width'] = self.pad_width_input.text()

        elif pad_type == 'PTH_rectangle':
            if hasattr(self, 'hole_length_input'):
                data['hole_length'] = self.hole_length_input.text()
            if hasattr(self, 'hole_width_input'):
                data['hole_width'] = self.hole_width_input.text()
            if hasattr(self, 'pad_length_input'):
                data['pad_length'] = self.pad_length_input.text()
            if hasattr(self, 'pad_width_input'):
                data['pad_width'] = self.pad_width_input.text()
            if hasattr(self, 'rotation_input'):
                data['rotation'] = self.rotation_input.text()

        elif pad_type == 'NPTH_rectangle':
            if hasattr(self, 'hole_length_input'):
                data['hole_length'] = self.hole_length_input.text()
            if hasattr(self, 'hole_width_input'):
                data['hole_width'] = self.hole_width_input.text()
            if hasattr(self, 'rotation_input'):
                data['rotation'] = self.rotation_input.text()

        elif pad_type == 'custom':
            data['polygon_data'] = self.polygon_widget.get_data()

        return data

    def set_data(self, data):
        self.type_combo.setCurrentText(data.get('type', 'square'))
        self.x_offset.setText(str(data.get('x_offset', 0)))
        self.y_offset.setText(str(data.get('y_offset', 0)))
        self.mask_expansion.setText(str(data.get('mask_expansion', 0)))
        self.paste_expansion.setText(str(data.get('paste_expansion', 0)))
        self.mask_enabled.setChecked(data.get('mask_enabled', True))
        self.paste_enabled.setChecked(data.get('paste_enabled', True))
        self.pin_number.setText(str(data.get('pin_number', '1')))

        # Update options first, then set the selection
        self.update_offset_from_options()
        self.offset_from.setCurrentText(data.get('offset_from', 'origin'))

        # Set type-specific data
        pad_type = data.get('type', 'square')
        # SET TOLERANCE FOR THROUGH HOLE PADS
        through_hole_types = ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong', 'PTH_rectangle', 'NPTH_rectangle']
        if pad_type in through_hole_types and hasattr(self, 'tolerance_input'):
            self.tolerance_input.setText(str(data.get('tolerance', '0.05')))

        if pad_type == 'square' and hasattr(self, 'size_input'):
            self.size_input.setText(str(data.get('size', '1.0')))

        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong']:
            if hasattr(self, 'length_input'):
                self.length_input.setText(str(data.get('length', '1.0')))
            if hasattr(self, 'width_input'):
                self.width_input.setText(str(data.get('width', '1.0')))
            if pad_type == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                self.corner_radius_input.setText(str(data.get('corner_radius', '0.2')))

        elif pad_type in ['round'] and hasattr(self, 'diameter_input'):
            self.diameter_input.setText(str(data.get('diameter', '1.0')))

        elif pad_type == 'D-shape':
            if hasattr(self, 'length_input'):
                self.length_input.setText(str(data.get('length', '1.0')))
            if hasattr(self, 'width_input'):
                self.width_input.setText(str(data.get('width', '1.0')))
            if hasattr(self, 'corner_radius_input'):
                self.corner_radius_input.setText(str(data.get('corner_radius', '0.2')))
            if hasattr(self, 'rotation_input'):
                self.rotation_input.setText(str(data.get('rotation', '0')))

        elif pad_type in ['PTH', 'NPTH']:
            if hasattr(self, 'hole_diameter_input'):
                self.hole_diameter_input.setText(str(data.get('hole_diameter', '0.8')))
            if pad_type == 'PTH' and hasattr(self, 'pad_diameter_input'):
                self.pad_diameter_input.setText(str(data.get('pad_diameter', '1.2')))

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if hasattr(self, 'hole_length_input'):
                self.hole_length_input.setText(str(data.get('hole_length', '1.5')))
            if hasattr(self, 'hole_width_input'):
                self.hole_width_input.setText(str(data.get('hole_width', '0.8')))
            if hasattr(self, 'rotation_input'):
                self.rotation_input.setText(str(data.get('rotation', '0')))
            if pad_type == 'PTH_oblong':
                if hasattr(self, 'pad_length_input'):
                    self.pad_length_input.setText(str(data.get('pad_length', '2.0')))
                if hasattr(self, 'pad_width_input'):
                    self.pad_width_input.setText(str(data.get('pad_width', '1.2')))

        elif pad_type == 'PTH_rectangle':
            if hasattr(self, 'hole_length_input'):
                self.hole_length_input.setText(str(data.get('hole_length', '1.5')))
            if hasattr(self, 'hole_width_input'):
                self.hole_width_input.setText(str(data.get('hole_width', '0.8')))
            if hasattr(self, 'pad_length_input'):
                self.pad_length_input.setText(str(data.get('pad_length', '2.0')))
            if hasattr(self, 'pad_width_input'):
                self.pad_width_input.setText(str(data.get('pad_width', '1.2')))
            if hasattr(self, 'rotation_input'):
                self.rotation_input.setText(str(data.get('rotation', '0')))

        elif pad_type == 'NPTH_rectangle':
            if hasattr(self, 'hole_length_input'):
                self.hole_length_input.setText(str(data.get('hole_length', '1.5')))
            if hasattr(self, 'hole_width_input'):
                self.hole_width_input.setText(str(data.get('hole_width', '0.8')))
            if hasattr(self, 'rotation_input'):
                self.rotation_input.setText(str(data.get('rotation', '0')))

        elif pad_type == 'custom':
            self.polygon_widget.set_data(data.get('polygon_data', {}))

class CustomLayerRow(QWidget):
    delete_requested = pyqtSignal(object)
    data_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self):
        main_layout = QVBoxLayout()

    
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)

        # Create group box for this custom layer
        self.group_box = QGroupBox("Custom Layer Configuration")
        group_layout = QVBoxLayout(self.group_box)
        group_layout.setSpacing(5)

        # Row 1: Shape and Geometry
        row1_layout = QHBoxLayout()
        row1_layout.setSpacing(10)

        # Shape Group
        shape_group = QGroupBox("Shape")
        shape_layout = QHBoxLayout(shape_group)
        shape_layout.setContentsMargins(5, 5, 5, 5)

        self.shape_combo = QComboBox()
        self.shape_combo.addItems(['rectangle', 'rounded_rectangle', 'oblong', 'custom_polygon'])
        shape_layout.addWidget(self.shape_combo)
        row1_layout.addWidget(shape_group)

        # Geometry Group (Dynamic based on shape)
        self.geometry_group = QGroupBox("Geometry")
        self.geometry_layout = QHBoxLayout(self.geometry_group)
        self.geometry_layout.setContentsMargins(5, 5, 5, 5)
        row1_layout.addWidget(self.geometry_group)

        # Actions Group
        actions_group = QGroupBox("Actions")
        actions_layout = QHBoxLayout(actions_group)
        actions_layout.setContentsMargins(5, 5, 5, 5)

        self.duplicate_btn = QPushButton("Duplicate")
        self.duplicate_btn.setMaximumWidth(80)
        self.delete_btn = QPushButton("Delete")
        self.delete_btn.setMaximumWidth(60)

        actions_layout.addWidget(self.duplicate_btn)
        actions_layout.addWidget(self.delete_btn)
        row1_layout.addWidget(actions_group)

        group_layout.addLayout(row1_layout)

        # Row 2: Layer and Position
        row2_layout = QHBoxLayout()
        row2_layout.setSpacing(10)

        # Layer Group
        layer_group = QGroupBox("Layer")
        layer_layout = QHBoxLayout(layer_group)
        layer_layout.setContentsMargins(5, 5, 5, 5)

        self.layer_combo = QComboBox()
        self.layer_combo.addItems(['mask', 'paste', 'keepout'])
        layer_layout.addWidget(self.layer_combo)
        row2_layout.addWidget(layer_group)

        # Position Group
        position_group = QGroupBox("Position")
        position_layout = QGridLayout(position_group)
        position_layout.setContentsMargins(5, 5, 5, 5)

        position_layout.addWidget(QLabel("X Offset:"), 0, 0)
        self.x_offset = QLineEdit()
        self.x_offset.setText("0")
        self.x_offset.setMaximumWidth(100)
        position_layout.addWidget(self.x_offset, 0, 1)

        position_layout.addWidget(QLabel("Y Offset:"), 0, 2)
        self.y_offset = QLineEdit()
        self.y_offset.setText("0")
        self.y_offset.setMaximumWidth(100)
        position_layout.addWidget(self.y_offset, 0, 3)

        position_layout.addWidget(QLabel("Offset From:"), 1, 0)
        self.offset_from = QComboBox()
        self.offset_from.setMaximumWidth(100)
        position_layout.addWidget(self.offset_from, 1, 1, 1, 2)

        row2_layout.addWidget(position_group)
        group_layout.addLayout(row2_layout)

        # Custom polygon widget (initially hidden)
        self.polygon_widget = CustomPolygonWidget()
        self.polygon_widget.data_changed.connect(self.data_changed.emit)
        self.polygon_widget.setVisible(False)
        group_layout.addWidget(self.polygon_widget)

        main_layout.addWidget(self.group_box)
        self.setLayout(main_layout)

        # Initialize geometry inputs
        self.update_geometry_inputs()

    def connect_signals(self):
        self.shape_combo.currentTextChanged.connect(self.update_geometry_inputs)
        self.shape_combo.currentTextChanged.connect(self.data_changed.emit)
        self.delete_btn.clicked.connect(lambda: self.delete_requested.emit(self))

        # Connect all input signals
        self.x_offset.textChanged.connect(self.data_changed.emit)
        self.y_offset.textChanged.connect(self.data_changed.emit)
        self.layer_combo.currentTextChanged.connect(self.data_changed.emit)
        self.offset_from.currentTextChanged.connect(self.data_changed.emit)
        
        # ADD THIS LINE - Connect polygon widget signals
        self.polygon_widget.data_changed.connect(self.data_changed.emit)


    def update_geometry_inputs(self):
        # Clear existing geometry inputs
        for i in reversed(range(self.geometry_layout.count())):
            item = self.geometry_layout.itemAt(i)
            if item:
                widget = item.widget()
                if widget:
                    widget.setParent(None)

        shape = self.shape_combo.currentText()

        # Show/hide polygon widget
        self.polygon_widget.setVisible(shape == 'custom_polygon')
        # ADD THIS: Force layout update when showing polygon widget
        if shape == 'custom_polygon':
            self.polygon_widget.updateGeometry()       

        if shape == 'rectangle':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

        elif shape == 'rounded_rectangle':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

            self.geometry_layout.addWidget(QLabel("Corner Radius:"))
            self.corner_radius_input = QLineEdit()
            self.corner_radius_input.setText("0.2")
            self.corner_radius_input.setMaximumWidth(100)
            self.corner_radius_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.corner_radius_input)

        elif shape == 'oblong':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("2.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

            # ADD ROTATION CONTROL FOR OBLONG
            self.geometry_layout.addWidget(QLabel("Rotation:"))
            self.rotation_input = QLineEdit()
            self.rotation_input.setText("0")
            self.rotation_input.setMaximumWidth(80)
            self.rotation_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rotation_input)
        
        elif shape == 'custom_polygon':
            self.geometry_layout.addWidget(QLabel("Custom Polygon (see below)"))

        # Add stretch to push everything to the left
        self.geometry_layout.addStretch()

    def get_data(self):
        data = {
            'shape': self.shape_combo.currentText(),
            'layer': self.layer_combo.currentText(),
            'x_offset': self.x_offset.text(),
            'y_offset': self.y_offset.text(),
            'offset_from': self.offset_from.currentText()
        }

        shape = self.shape_combo.currentText()

        if shape in ['rectangle', 'rounded_rectangle', 'oblong']:
            if hasattr(self, 'length_input'):
                data['length'] = self.length_input.text()
            if hasattr(self, 'width_input'):
                data['width'] = self.width_input.text()
            if shape == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                data['corner_radius'] = self.corner_radius_input.text()
            # ADD ROTATION FOR OBLONG
            if shape == 'oblong' and hasattr(self, 'rotation_input'):
                data['rotation'] = self.rotation_input.text()

        elif shape == 'custom_polygon':
            data['polygon_data'] = self.polygon_widget.get_data()

        return data

    def set_data(self, data):
        self.shape_combo.setCurrentText(data.get('shape', 'rectangle'))
        self.layer_combo.setCurrentText(data.get('layer', 'mask'))
        self.x_offset.setText(str(data.get('x_offset', '0')))
        self.y_offset.setText(str(data.get('y_offset', '0')))
        self.offset_from.setCurrentText(data.get('offset_from', 'origin'))

        # Set shape-specific data
        shape = data.get('shape', 'rectangle')

        if shape in ['rectangle', 'rounded_rectangle', 'oblong']:
            if hasattr(self, 'length_input'):
                self.length_input.setText(str(data.get('length', '1.0')))
            if hasattr(self, 'width_input'):
                self.width_input.setText(str(data.get('width', '1.0')))
            if shape == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                self.corner_radius_input.setText(str(data.get('corner_radius', '0.2')))

            # ADD ROTATION FOR OBLONG
            if shape == 'oblong' and hasattr(self, 'rotation_input'):
                self.rotation_input.setText(str(data.get('rotation', '0')))

        elif shape == 'custom_polygon':
            self.polygon_widget.set_data(data.get('polygon_data', {}))

class ThermalViaRow(QWidget):
    delete_requested = pyqtSignal(object)
    data_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self):
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)

        # Create group box for this thermal via
        self.group_box = QGroupBox("Thermal Via Configuration")
        group_layout = QVBoxLayout(self.group_box)
        group_layout.setSpacing(5)

        # Row 1: Type and Geometry
        row1_layout = QHBoxLayout()
        row1_layout.setSpacing(10)

        # Type Group
        type_group = QGroupBox("Type")
        type_layout = QHBoxLayout(type_group)
        type_layout.setContentsMargins(5, 5, 5, 5)

        self.type_combo = QComboBox()
        self.type_combo.addItems(['grid_array', 'single'])
        type_layout.addWidget(self.type_combo)
        row1_layout.addWidget(type_group)

        # Geometry Group (Dynamic based on type)
        self.geometry_group = QGroupBox("Geometry")
        self.geometry_layout = QHBoxLayout(self.geometry_group)
        self.geometry_layout.setContentsMargins(5, 5, 5, 5)
        row1_layout.addWidget(self.geometry_group)

        # Actions Group
        actions_group = QGroupBox("Actions")
        actions_layout = QHBoxLayout(actions_group)
        actions_layout.setContentsMargins(5, 5, 5, 5)

        self.duplicate_btn = QPushButton("Duplicate")
        self.duplicate_btn.setMaximumWidth(80)
        self.delete_btn = QPushButton("Delete")
        self.delete_btn.setMaximumWidth(60)

        actions_layout.addWidget(self.duplicate_btn)
        actions_layout.addWidget(self.delete_btn)
        row1_layout.addWidget(actions_group)

        group_layout.addLayout(row1_layout)

        # Row 2: Position
        row2_layout = QHBoxLayout()
        row2_layout.setSpacing(10)

        # Position Group
        # Position Group
        position_group = QGroupBox("Position")
        position_layout = QGridLayout(position_group)
        position_layout.setContentsMargins(5, 5, 5, 5)
        
        position_layout.addWidget(QLabel("X Offset:"), 0, 0)
        self.x_offset = QLineEdit()
        self.x_offset.setText("0")
        self.x_offset.setMaximumWidth(100)
        position_layout.addWidget(self.x_offset, 0, 1)
        
        position_layout.addWidget(QLabel("Y Offset:"), 0, 2)
        self.y_offset = QLineEdit()
        self.y_offset.setText("0")
        self.y_offset.setMaximumWidth(100)
        position_layout.addWidget(self.y_offset, 0, 3)
        
        position_layout.addWidget(QLabel("Offset From:"), 1, 0)
        self.offset_from = QComboBox()
        self.offset_from.setMaximumWidth(100)
        position_layout.addWidget(self.offset_from, 1, 1, 1, 2)
        
        # ADD THIS NEW PIN NUMBER FIELD:
        position_layout.addWidget(QLabel("Via Pin:"), 1, 3)
        self.pin_number = QLineEdit()
        self.pin_number.setMaximumWidth(50)
        position_layout.addWidget(self.pin_number, 1, 4)
        
        row2_layout.addWidget(position_group)
        group_layout.addLayout(row2_layout)

        main_layout.addWidget(self.group_box)
        self.setLayout(main_layout)

        # Initialize geometry inputs
        self.update_geometry_inputs()

    def connect_signals(self):
        self.type_combo.currentTextChanged.connect(self.update_geometry_inputs)
        self.type_combo.currentTextChanged.connect(self.data_changed.emit)
        self.delete_btn.clicked.connect(lambda: self.delete_requested.emit(self))

        # Connect all input signals
        self.x_offset.textChanged.connect(self.data_changed.emit)
        self.y_offset.textChanged.connect(self.data_changed.emit)
        self.offset_from.currentTextChanged.connect(self.data_changed.emit)
        
        # ADD THESE NEW SIGNAL CONNECTIONS:
        self.pin_number.textChanged.connect(self.update_offset_from_options)
        self.pin_number.textChanged.connect(self.data_changed.emit)

    def update_offset_from_options(self):
        """Update offset_from options when pin number changes"""
        parent_designer = self.get_parent_designer()
        if parent_designer:
            parent_designer.update_all_offset_dropdowns()

    def get_parent_designer(self):
        """Find the parent FootprintDesigner instance"""
        parent = self.parent()
        while parent:
            if hasattr(parent, 'thermal_via_rows'):
                return parent
            parent = parent.parent()
        return None


    def update_geometry_inputs(self):
        # Clear existing geometry inputs
        for i in reversed(range(self.geometry_layout.count())):
            item = self.geometry_layout.itemAt(i)
            if item:
                widget = item.widget()
                if widget:
                    widget.setParent(None)

        via_type = self.type_combo.currentText()

        if via_type == 'single':
            self.geometry_layout.addWidget(QLabel("Via Diameter:"))
            self.via_diameter_input = QLineEdit()
            self.via_diameter_input.setText("0.2")
            self.via_diameter_input.setMaximumWidth(100)
            self.via_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.via_diameter_input)

            self.geometry_layout.addWidget(QLabel("Drill Diameter:"))
            self.drill_diameter_input = QLineEdit()
            self.drill_diameter_input.setText("0.1")
            self.drill_diameter_input.setMaximumWidth(100)
            self.drill_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.drill_diameter_input)

        elif via_type == 'grid_array':
            self.geometry_layout.addWidget(QLabel("Rows:"))
            self.rows_input = QLineEdit()
            self.rows_input.setText("2")
            self.rows_input.setMaximumWidth(80)
            self.rows_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rows_input)

            self.geometry_layout.addWidget(QLabel("Columns:"))
            self.columns_input = QLineEdit()
            self.columns_input.setText("2")
            self.columns_input.setMaximumWidth(80)
            self.columns_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.columns_input)

            self.geometry_layout.addWidget(QLabel("Row Spacing:"))
            self.row_spacing_input = QLineEdit()
            self.row_spacing_input.setText("1.0")
            self.row_spacing_input.setMaximumWidth(100)
            self.row_spacing_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.row_spacing_input)

            self.geometry_layout.addWidget(QLabel("Col Spacing:"))
            self.col_spacing_input = QLineEdit()
            self.col_spacing_input.setText("1.0")
            self.col_spacing_input.setMaximumWidth(100)
            self.col_spacing_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.col_spacing_input)

            self.geometry_layout.addWidget(QLabel("Via Diameter:"))
            self.via_diameter_input = QLineEdit()
            self.via_diameter_input.setText("0.2")
            self.via_diameter_input.setMaximumWidth(100)
            self.via_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.via_diameter_input)

            self.geometry_layout.addWidget(QLabel("Drill Diameter:"))
            self.drill_diameter_input = QLineEdit()
            self.drill_diameter_input.setText("0.1")
            self.drill_diameter_input.setMaximumWidth(100)
            self.drill_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.drill_diameter_input)

        # Add stretch to push everything to the left
        self.geometry_layout.addStretch()


        

    def get_data(self):
        data = {
            'type': self.type_combo.currentText(),
            'x_offset': self.x_offset.text(),
            'y_offset': self.y_offset.text(),
            'offset_from': self.offset_from.currentText(),
            'pin_number': self.pin_number.text()  # ADD THIS LINE
        }

        via_type = self.type_combo.currentText()

        if via_type == 'single':
            if hasattr(self, 'via_diameter_input'):
                data['via_diameter'] = self.via_diameter_input.text()
            if hasattr(self, 'drill_diameter_input'):
                data['drill_diameter'] = self.drill_diameter_input.text()

        elif via_type == 'grid_array':
            if hasattr(self, 'rows_input'):
                data['rows'] = self.rows_input.text()
            if hasattr(self, 'columns_input'):
                data['columns'] = self.columns_input.text()
            if hasattr(self, 'row_spacing_input'):
                data['row_spacing'] = self.row_spacing_input.text()
            if hasattr(self, 'col_spacing_input'):
                data['col_spacing'] = self.col_spacing_input.text()
            if hasattr(self, 'via_diameter_input'):
                data['via_diameter'] = self.via_diameter_input.text()
            if hasattr(self, 'drill_diameter_input'):
                data['drill_diameter'] = self.drill_diameter_input.text()

        return data

    def set_data(self, data):
        self.type_combo.setCurrentText(data.get('type', 'single'))
        self.x_offset.setText(str(data.get('x_offset', '0')))
        self.y_offset.setText(str(data.get('y_offset', '0')))
        self.offset_from.setCurrentText(data.get('offset_from', 'origin'))
        self.pin_number.setText(str(data.get('pin_number', 'V1')))  # ADD THIS LINE

        # Set type-specific data
        via_type = data.get('type', 'single')

        if via_type == 'single':
            if hasattr(self, 'via_diameter_input'):
                self.via_diameter_input.setText(str(data.get('via_diameter', '0.2')))
            if hasattr(self, 'drill_diameter_input'):
                self.drill_diameter_input.setText(str(data.get('drill_diameter', '0.1')))

        elif via_type == 'grid_array':
            if hasattr(self, 'rows_input'):
                self.rows_input.setText(str(data.get('rows', '2')))
            if hasattr(self, 'columns_input'):
                self.columns_input.setText(str(data.get('columns', '2')))
            if hasattr(self, 'row_spacing_input'):
                self.row_spacing_input.setText(str(data.get('row_spacing', '1.0')))
            if hasattr(self, 'col_spacing_input'):
                self.col_spacing_input.setText(str(data.get('col_spacing', '1.0')))
            if hasattr(self, 'via_diameter_input'):
                self.via_diameter_input.setText(str(data.get('via_diameter', '0.2')))
            if hasattr(self, 'drill_diameter_input'):
                self.drill_diameter_input.setText(str(data.get('drill_diameter', '0.1')))

class SettingsPanel(QWidget):
    settings_changed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self.setup_styling()

    def setup_ui(self):
        # Create main layout with scroll area
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(5, 5, 5, 5)

        # Create scroll area
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)

        # Create scrollable content widget
        content_widget = QWidget()
        layout = QVBoxLayout(content_widget)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(15)

        # Title
        title = QLabel("Settings")
        title.setStyleSheet("font-size: 16px; font-weight: bold; color: #ffffff; margin-bottom: 10px;")
        layout.addWidget(title)

        # Only include footprint-related settings
        self.setup_body_settings(layout)
        self.add_separator(layout)
        self.setup_courtyard_settings(layout)
        self.add_separator(layout)
        self.setup_silkscreen_settings(layout)
        self.add_separator(layout)
        self.setup_fiducial_settings(layout)
        self.add_separator(layout)
        self.setup_text_settings(layout)

        layout.addStretch()

        # Set the content widget to scroll area
        scroll_area.setWidget(content_widget)
        main_layout.addWidget(scroll_area)

    def add_separator(self, layout):
        """Add a separator line"""
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setStyleSheet("color: #555;")
        layout.addWidget(separator)

    def setup_text_settings(self, layout):
        """Setup text formatting settings"""
        text_group = QGroupBox("Text Settings")
        text_layout = QGridLayout(text_group)
        
        text_layout.addWidget(QLabel("Text Height (mm):"), 0, 0)
        self.text_height = QLineEdit()
        self.text_height.setText("0.5")
        self.text_height.textChanged.connect(self.settings_changed.emit)
        text_layout.addWidget(self.text_height, 0, 1)

        text_layout.addWidget(QLabel("Text Width (mm):"), 1, 0)
        self.text_width = QLineEdit()
        self.text_width.setText("0.1")
        self.text_width.textChanged.connect(self.settings_changed.emit)
        text_layout.addWidget(self.text_width, 1, 1)

        text_layout.addWidget(QLabel("Text Line Width:"), 2, 0)
        self.text_line_width = QLineEdit()
        self.text_line_width.setText("1.8")
        self.text_line_width.textChanged.connect(self.settings_changed.emit)
        text_layout.addWidget(self.text_line_width, 2, 1)

        layout.addWidget(text_group)

    def setup_body_settings(self, layout):
        body_group = QGroupBox("Body Settings")
        body_layout = QGridLayout(body_group)
        
        body_layout.addWidget(QLabel("Body Line Width:"), 0, 0)
        self.body_line_width = QLineEdit()
        self.body_line_width.setText("0.05")
        self.body_line_width.textChanged.connect(self.settings_changed.emit)
        body_layout.addWidget(self.body_line_width, 0, 1)
        
        layout.addWidget(body_group)

    def setup_courtyard_settings(self, layout):
        courtyard_group = QGroupBox("Courtyard Settings")
        courtyard_layout = QGridLayout(courtyard_group)
        
        courtyard_layout.addWidget(QLabel("Courtyard Expansion:"), 0, 0)
        self.courtyard_expansion = QLineEdit()
        self.courtyard_expansion.setText("0.25")
        self.courtyard_expansion.textChanged.connect(self.settings_changed.emit)
        courtyard_layout.addWidget(self.courtyard_expansion, 0, 1)

        courtyard_layout.addWidget(QLabel("Courtyard Line Width:"), 1, 0)
        self.courtyard_line_width = QLineEdit()
        self.courtyard_line_width.setText("0.1")
        self.courtyard_line_width.textChanged.connect(self.settings_changed.emit)
        courtyard_layout.addWidget(self.courtyard_line_width, 1, 1)

        layout.addWidget(courtyard_group)

    def setup_silkscreen_settings(self, layout):
        silkscreen_group = QGroupBox("Silkscreen Settings")
        silkscreen_layout = QGridLayout(silkscreen_group)
        
        silkscreen_layout.addWidget(QLabel("Silkscreen Airgap:"), 0, 0)
        self.silkscreen_airgap = QLineEdit()
        self.silkscreen_airgap.setText("0.15")
        self.silkscreen_airgap.textChanged.connect(self.settings_changed.emit)
        silkscreen_layout.addWidget(self.silkscreen_airgap, 0, 1)

        silkscreen_layout.addWidget(QLabel("Silkscreen Line Width:"), 1, 0)
        self.silkscreen_line_width = QLineEdit()
        self.silkscreen_line_width.setText("0.15")
        self.silkscreen_line_width.textChanged.connect(self.settings_changed.emit)
        silkscreen_layout.addWidget(self.silkscreen_line_width, 1, 1)

        layout.addWidget(silkscreen_group)

    def setup_fiducial_settings(self, layout):
        """Setup fiducial settings with keepout"""
        fiducial_group = QGroupBox("Fiducial Settings")
        fiducial_layout = QGridLayout(fiducial_group)
        
        fiducial_layout.addWidget(QLabel("Fiducial Pad Diameter (mm):"), 0, 0)
        self.fiducial_diameter = QLineEdit()
        self.fiducial_diameter.setText("1.0")
        self.fiducial_diameter.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_diameter, 0, 1)

        fiducial_layout.addWidget(QLabel("Mask Opening (mm):"), 1, 0)
        self.fiducial_mask_opening = QLineEdit()
        self.fiducial_mask_opening.setText("2.0")
        self.fiducial_mask_opening.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_mask_opening, 1, 1)

        fiducial_layout.addWidget(QLabel("Keepout Diameter (mm):"), 2, 0)
        self.fiducial_keepout_diameter = QLineEdit()
        self.fiducial_keepout_diameter.setText("3.0")
        self.fiducial_keepout_diameter.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_keepout_diameter, 2, 1)

        fiducial_layout.addWidget(QLabel("X Offset from Body Corner:"), 3, 0)
        self.fiducial_x_offset = QLineEdit()
        self.fiducial_x_offset.setText("2.0")
        self.fiducial_x_offset.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_x_offset, 3, 1)

        fiducial_layout.addWidget(QLabel("Y Offset from Body Corner:"), 4, 0)
        self.fiducial_y_offset = QLineEdit()
        self.fiducial_y_offset.setText("2.0")
        self.fiducial_y_offset.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_y_offset, 4, 1)

        layout.addWidget(fiducial_group)

    def setup_styling(self):
        self.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLabel {
                color: #ffffff;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
                color: #ffffff;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
        """)

    def get_settings(self):
        return {
            'body_line_width': self.body_line_width.text(),
            'courtyard_expansion': self.courtyard_expansion.text(),
            'courtyard_line_width': self.courtyard_line_width.text(),
            'silkscreen_airgap': self.silkscreen_airgap.text(),
            'silkscreen_line_width': self.silkscreen_line_width.text(),
            'text_height': self.text_height.text(),
            'text_width': self.text_width.text(),
            'text_line_width': self.text_line_width.text(),
            'fiducial_diameter': self.fiducial_diameter.text(),
            'fiducial_mask_opening': self.fiducial_mask_opening.text(),
            'fiducial_keepout_diameter': self.fiducial_keepout_diameter.text(),
            'fiducial_x_offset': self.fiducial_x_offset.text(),
            'fiducial_y_offset': self.fiducial_y_offset.text()
        }

    def set_settings(self, settings):
        self.body_line_width.setText(str(settings.get('body_line_width', '0.05')))
        self.courtyard_expansion.setText(str(settings.get('courtyard_expansion', '0.25')))
        self.courtyard_line_width.setText(str(settings.get('courtyard_line_width', '0.1')))
        self.silkscreen_airgap.setText(str(settings.get('silkscreen_airgap', '0.15')))
        self.silkscreen_line_width.setText(str(settings.get('silkscreen_line_width', '0.15')))
        self.text_height.setText(str(settings.get('text_height', '0.5')))
        self.text_width.setText(str(settings.get('text_width', '0.1')))
        self.text_line_width.setText(str(settings.get('text_line_width', '1.8')))
        self.fiducial_diameter.setText(str(settings.get('fiducial_diameter', '1.0')))
        self.fiducial_mask_opening.setText(str(settings.get('fiducial_mask_opening', '2.0')))
        self.fiducial_keepout_diameter.setText(str(settings.get('fiducial_keepout_diameter', '3.0')))
        self.fiducial_x_offset.setText(str(settings.get('fiducial_x_offset', '2.0')))
        self.fiducial_y_offset.setText(str(settings.get('fiducial_y_offset', '2.0')))

class UpdateThread(QThread):
    update_signal = pyqtSignal(dict)

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.running = True

    def run(self):
        while self.running:
            data = self.main_window.get_footprint_data()
            self.update_signal.emit(data)
            self.msleep(100) # Update every 100ms

    def stop(self):
        self.running = False

class FootprintDesigner(QMainWindow):
    def __init__(self):
        super().__init__()
        self.padstack_rows = []
        self.custom_layer_rows = []
        self.thermal_via_rows = []
        self.current_save_file = None
        self.auto_update_origin = True
        self.fiducials_enabled = False  # NEW
        self.setup_ui()
        self.setup_dark_theme()
        self.start_update_thread()
        self.load_app_settings()  # NEW




    def setup_dark_theme(self):
        self.setStyleSheet("""
            QMainWindow {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLineEdit, QDoubleSpinBox, QSpinBox, QComboBox {
                background-color: #3c3c3c;
                border: 1px solid #555;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
            QScrollArea {
                background-color: #2b2b2b;
                border: none;
            }
            QFrame {
                border: 1px solid #555;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
            }
            QToolBar {
                background-color: #3c3c3c;
                border: 1px solid #555;
                spacing: 3px;
            }
            QToolBar::separator {
                width: 2px;
                background-color: #555;
                margin: 0 5px;
            }
        """)

    def setup_ui(self):
        self.setWindowTitle("Footprint Designer")
        self.setGeometry(100, 100, 1400, 800)
        self.showMaximized()

        # Create toolbar
        self.create_toolbar()

        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main splitter (3 panels: left, center, right)
        main_splitter = QSplitter(Qt.Orientation.Horizontal)
        central_widget.setLayout(QHBoxLayout())
        central_widget.layout().addWidget(main_splitter)

        # Left panel
        left_panel = self.create_left_panel()
        main_splitter.addWidget(left_panel)

        # Center panel (renderer)
        self.renderer = FootprintRenderer()
        main_splitter.addWidget(self.renderer)
        self.renderer.footprint_designer_ref = self
    

        # Initialize renderer with proper origin values
        self.update_renderer_origin()

        


        # Right panel (settings) - initially hidden
        self.settings_panel = SettingsPanel()
        self.settings_panel.settings_changed.connect(self.on_settings_changed)
        self.settings_panel.setVisible(False)
        self.settings_panel.setMaximumWidth(350)
        self.settings_panel.setMinimumWidth(300)
        main_splitter.addWidget(self.settings_panel)

        # Set initial splitter proportions
        main_splitter.setSizes([800, 700, 0]) # Left, Center, Right (hidden)

    def create_toolbar(self):
        """Create toolbar with left and right aligned buttons"""
        toolbar = QToolBar()
        self.addToolBar(toolbar)

        # Left side buttons
        toolbar.addAction("New", self.new_footprint)
        toolbar.addAction("Save", self.save_data)
        toolbar.addAction("Save As", self.save_data_as)
        toolbar.addAction("Open", self.load_data)

        # Add dropdown for script generation
        self.script_combo = QComboBox()
        self.script_combo.addItems(["Altium", "Allegro", "PADS", "Xpedition"])
        self.script_combo.setMaximumWidth(100)
        toolbar.addWidget(QLabel("Generate:"))
        toolbar.addWidget(self.script_combo)
        toolbar.addAction("Script", self.generate_footprint_script)

        toolbar.addSeparator()

        # Show Silkscreen toggle action
        self.silkscreen_action = toolbar.addAction("Show Silkscreen", self.toggle_silkscreen)
        self.silkscreen_action.setCheckable(True)
        self.silkscreen_action.setChecked(True)

        # Add Fiducial toggle
        self.fiducial_action = toolbar.addAction("+ Add Fiducial", self.toggle_fiducials)
        self.fiducial_action.setCheckable(True)
        self.fiducial_action.setChecked(False)

        toolbar.addSeparator()
        toolbar.addAction("+ Add Padstack", self.add_padstack_row)
        toolbar.addAction("+ Custom Layer", self.add_custom_layer_row)
        toolbar.addAction("+ Thermal Via", self.add_thermal_via_row)

        toolbar.addSeparator()
        toolbar.addAction("Fit to View", self.fit_to_view)

        # Add stretch to push Account and Settings to the right
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        toolbar.addWidget(spacer)

        # Right side buttons
        toolbar.addAction("Account", self.show_account_dialog)  # NEW ACCOUNT BUTTON
        toolbar.addAction("Settings", self.toggle_settings_panel)

    def show_account_dialog(self):
        """Show account management dialog"""
        dialog = AccountDialog(self)
        dialog.exec()

    def load_app_settings(self):
        """Load application settings (only footprint-related settings now)"""
        settings = SettingsManager.load_settings()
        self.settings_panel.set_settings(settings)

    def save_app_settings(self):
        """Save application settings (only footprint-related settings now)"""
        settings = self.settings_panel.get_settings()
        SettingsManager.save_settings(settings)

    def get_footprint_data(self):
        settings = self.settings_panel.get_settings()
        data = {
            'part_number': self.part_number.text(),
            'footprint_name': self.footprint_name.text(),
            'body_length': self.body_length.text(),
            'body_width': self.body_width.text(),
            'body_height': self.body_height.text(),
            'body_shape': self.body_shape_combobox.currentText(),
            'origin_offset_x': self.origin_offset_x_input.text(),
            'origin_offset_y': self.origin_offset_y_input.text(),
            'auto_update_origin': self.auto_update_origin,
            'courtyard_expansion': settings['courtyard_expansion'],
            'silkscreen_airgap': settings['silkscreen_airgap'],
            'silkscreen_enabled': self.silkscreen_action.isChecked(),
            'fiducials_enabled': self.fiducials_enabled,
            'padstacks': [row.get_data() for row in self.padstack_rows],
            'custom_layers': [row.get_data() for row in self.custom_layer_rows],
            'thermal_vias': [row.get_data() for row in self.thermal_via_rows],
            'body_line_width': settings['body_line_width'],
            'courtyard_line_width': settings['courtyard_line_width'],
            'silkscreen_line_width': settings['silkscreen_line_width'],
            'settings': {
                'fiducial_diameter': settings['fiducial_diameter'],
                'fiducial_mask_opening': settings['fiducial_mask_opening'],
                'fiducial_keepout_diameter': settings['fiducial_keepout_diameter'],
                'fiducial_x_offset': settings['fiducial_x_offset'],
                'fiducial_y_offset': settings['fiducial_y_offset'],
            },
            'text_settings': {
                'text_height': settings['text_height'],
                'text_width': settings['text_width'],
                'text_line_width': settings['text_line_width']
            }
            # Removed: script output paths and current_user - these are now in separate account settings
        }
        return data


    def toggle_silkscreen(self):
        """Toggle silkscreen visibility"""
        self.on_data_changed()

    def toggle_fiducials(self):
        """Toggle fiducial visibility"""
        self.fiducials_enabled = self.fiducial_action.isChecked()
        self.on_data_changed()

    def load_app_settings(self):
        """Load application settings"""
        settings = SettingsManager.load_settings()
        self.settings_panel.set_settings(settings)

    def save_app_settings(self):
        """Save application settings"""
        settings = self.settings_panel.get_settings()
        SettingsManager.save_settings(settings)


    def toggle_settings_panel(self):
        """Toggle the visibility of settings panel"""
        is_visible = self.settings_panel.isVisible()
        self.settings_panel.setVisible(not is_visible)

        # Adjust splitter sizes
        if not is_visible:
            # Show settings panel
            self.centralWidget().layout().itemAt(0).widget().setSizes([700, 600, 300])
        else:
            # Hide settings panel
            self.centralWidget().layout().itemAt(0).widget().setSizes([800, 700, 0])

    def on_settings_changed(self):
        """Handle settings changes"""
        # Update renderer with new settings
        self.renderer.update()

    def create_left_panel(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Header section
        header_frame = QFrame()
        header_frame.setFrameStyle(QFrame.Shape.StyledPanel)
        header_layout = QGridLayout(header_frame)

        # Header inputs - Row 0
        header_layout.addWidget(QLabel("Part Number:"), 0, 0)
        self.part_number = QLineEdit()
        header_layout.addWidget(self.part_number, 0, 1, 1, 2)
        header_layout.addWidget(QLabel("Footprint Name:"), 0, 3)
        self.footprint_name = QLineEdit()
        header_layout.addWidget(self.footprint_name, 0, 4, 1, 2)

        # Row 1 - Body dimensions and Origin Offset controls
        header_layout.addWidget(QLabel("Body Length:"), 1, 0)
        self.body_length = QLineEdit()
        self.body_length.setText("5.0")
        header_layout.addWidget(self.body_length, 1, 1)
        
        header_layout.addWidget(QLabel("Body Width:"), 1, 2)
        self.body_width = QLineEdit()
        self.body_width.setText("3.0")
        header_layout.addWidget(self.body_width, 1, 3)

        # NEW: Origin offset from top-left corner
        header_layout.addWidget(QLabel("Origin X Offset:"), 1, 4)
        self.origin_offset_x_input = QLineEdit()
        self.origin_offset_x_input.setText("2.5")  # Default to length/2
        header_layout.addWidget(self.origin_offset_x_input, 1, 5)

        # Row 2 - Body Height, Shape, and Y offset
        header_layout.addWidget(QLabel("Body Height:"), 2, 0)
        self.body_height = QLineEdit()
        self.body_height.setText("1.0")
        header_layout.addWidget(self.body_height, 2, 1)

        header_layout.addWidget(QLabel("Body Shape:"), 2, 2)
        self.body_shape_combobox = QComboBox()
        self.body_shape_combobox.addItems(["rectangle", "round"])
        self.body_shape_combobox.setCurrentIndex(0)
        header_layout.addWidget(self.body_shape_combobox, 2, 3)

        header_layout.addWidget(QLabel("Origin Y Offset:"), 2, 4)
        self.origin_offset_y_input = QLineEdit()
        self.origin_offset_y_input.setText("1.5")  # Default to width/2
        header_layout.addWidget(self.origin_offset_y_input, 2, 5)

        layout.addWidget(header_frame)

        # Auto-update tracking
        self.auto_update_origin = True

        # Connect signals
        self.body_length.textChanged.connect(self.on_body_dimensions_changed)
        self.body_width.textChanged.connect(self.on_body_dimensions_changed)
        self.origin_offset_x_input.textChanged.connect(self.on_origin_manual_change)
        self.origin_offset_y_input.textChanged.connect(self.on_origin_manual_change)
        
        # Other connections
        self.part_number.textChanged.connect(self.on_data_changed)
        self.footprint_name.textChanged.connect(self.on_data_changed)
        self.body_height.textChanged.connect(self.on_data_changed)
        self.body_shape_combobox.currentTextChanged.connect(self.on_data_changed)

        # Rest of the method (scroll area, etc.)
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.container = QWidget()
        self.container_layout = QVBoxLayout(self.container)
        self.container_layout.addStretch()
        scroll_area.setWidget(self.container)
        layout.addWidget(scroll_area)

        # Initialize origin offset
        self.update_origin_offset_values()
        
        # Add initial padstack
        self.add_padstack_row()
        
        return widget

    def on_origin_manual_change(self):
        """Handle manual changes to origin offset - disable auto-update"""
        self.auto_update_origin = False
        self.update_renderer_origin()
        self.on_data_changed()

    def on_body_dimensions_changed(self):
        """Handle body dimension changes - auto-update origin if enabled"""
        if self.auto_update_origin:
            self.update_origin_offset_values()
        self.update_renderer_origin()
        self.on_data_changed()

    def update_origin_offset_values(self):
        """Update origin offset values based on body dimensions"""
        try:
            length = to_decimal(self.body_length.text())
            width = to_decimal(self.body_width.text())
        except (ValueError, TypeError):
            length = 5.0
            width = 3.0

        # Set offset to center of body (length/2, width/2)+
        x_offset = -length / 2
        y_offset = width / 2

        # Block signals to prevent triggering manual change handler
        self.origin_offset_x_input.blockSignals(True)
        self.origin_offset_y_input.blockSignals(True)
        
        self.origin_offset_x_input.setText(f"{x_offset}")
        self.origin_offset_y_input.setText(f"{y_offset}")
        
        self.origin_offset_x_input.blockSignals(False)
        self.origin_offset_y_input.blockSignals(False)
        
        # Re-enable auto-update since this was programmatic
        self.auto_update_origin = True

    def update_renderer_origin(self):
        """Update the renderer with current origin offset values"""
        try:
            x_offset = to_decimal(self.origin_offset_x_input.text())
            y_offset = to_decimal(self.origin_offset_y_input.text())
        except (ValueError, TypeError):
            x_offset = y_offset = 0.0

        if hasattr(self, 'renderer'):
            self.renderer.origin_offset_x = x_offset
            self.renderer.origin_offset_y = y_offset
            self.renderer.update()



    def on_origin_offset_inputs_changed(self):
        """Handle changes to origin offset input fields"""
        # Always update if the inputs are enabled (regardless of checkbox state)
        if self.origin_offset_x_input.isEnabled() or self.origin_offset_y_input.isEnabled():
            self.update_origin_offset_from_inputs()
        
        # Also trigger general data change
        self.on_data_changed()



    def new_footprint(self):
        """Create a new footprint (reset all fields)"""
        reply = QMessageBox.question(
            self,
            'New Footprint',
            'Are you sure you want to create a new footprint? All current data will be lost.',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            # Clear current file path
            self.current_save_file = None

            # Clear all input fields
            self.part_number.setText('')
            self.footprint_name.setText('')
            self.body_length.setText('5.0')
            self.body_width.setText('3.0')
            self.body_height.setText('1.0')
            self.body_shape_combobox.setCurrentIndex(0)

            # Set default origin offset values
            self.origin_offset_x_input.setText("-2.5")  # Default to length/2
            self.origin_offset_y_input.setText("1.5")  # Default to width/2
            self.auto_update_origin = True
            self.update_origin_offset_values()


            # Reset silkscreen action
            self.silkscreen_action.setChecked(True)
          
            default_settings = {
                'body_line_width': '0.05',
                'courtyard_expansion': '0.25',
                'courtyard_line_width': '0.1',
                'silkscreen_airgap': '0.15',
                'silkscreen_line_width': '0.15',
            }
            self.settings_panel.set_settings(default_settings)

            # Clear all padstacks
            for row in self.padstack_rows[:]:
                self.delete_padstack_row(row)

            # Clear all custom layers
            for row in self.custom_layer_rows[:]:
                self.delete_custom_layer_row(row)

            # Clear all thermal vias
            for row in self.thermal_via_rows[:]:
                self.delete_thermal_via_row(row)

            # Add one default padstack
            self.add_padstack_row()

    def save_data_as(self):
        """Save footprint data with new filename"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Save Footprint As", "",
            "LibSienna Footprint Files (*.LibSienna);;All Files (*)"
        )
        
        if filename:
            # Ensure consistent file extension (case-insensitive check)
            if not filename.lower().endswith('.libsienna'):
                filename += '.LibSienna'
                
            self.current_save_file = filename
            data = self.get_footprint_data()
            success = LibSiennaFileFormat.save_footprint(data, filename)
            if success:
                # Also save app settings
                self.save_app_settings()
                QMessageBox.information(self, "Success", f"Footprint saved successfully as {os.path.basename(filename)}!")
            else:
                QMessageBox.critical(self, "Error", "Failed to save footprint file!")


    def save_data(self):
        """Save footprint data and app settings"""
        # Save footprint data to LibSienna file
        if self.current_save_file is None:
            self.save_data_as()
        else:
            data = self.get_footprint_data()
            success = LibSiennaFileFormat.save_footprint(data, self.current_save_file)
            if success:
                # Also save app settings
                self.save_app_settings()
                QMessageBox.information(self, "Success", f"Footprint updated successfully!\n{os.path.basename(self.current_save_file)}")
            else:
                QMessageBox.critical(self, "Error", "Failed to save footprint file!")


    def load_data(self):
        """Load footprint data from custom LibSienna format"""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "Load Footprint",
            "",
            "LibSienna Footprint Files (*.LibSienna *.libsienna);;All Files (*)"  # Accept both cases
        )
        
        if filename:
            print(f"Selected file: {filename}")  # Debug info
            data = LibSiennaFileFormat.load_footprint(filename)
            if data:
                try:
                    self.set_footprint_data(data)
                    # Set current file path so Save will work
                    self.current_save_file = filename
                    QMessageBox.information(
                        self,
                        "Success",
                        f"Footprint loaded successfully from {os.path.basename(filename)}!"
                    )
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to apply loaded data:\n{str(e)}")
            else:
                QMessageBox.critical(self, "Error", "Failed to load footprint file!\nCheck console for details.")


    def fit_to_view(self):
        self.renderer.auto_fit = True
        self.renderer.fit_to_view()
        self.renderer.update()

    def add_padstack_row(self):
        row = PadStackRow()
        row.delete_requested.connect(self.delete_padstack_row)
        row.data_changed.connect(self.on_data_changed)
        row.duplicate_btn.clicked.connect(lambda: self.duplicate_padstack_row(row))

        self.padstack_rows.append(row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, row)

        # Set pin number automatically
        row.pin_number.setText(str(len(self.padstack_rows)))

        # Update all offset_from dropdowns
        self.update_all_offset_dropdowns()

    def delete_padstack_row(self, row):
        if len(self.padstack_rows) > 0:
            self.padstack_rows.remove(row)
            row.setParent(None)
            # Update all remaining offset_from dropdowns
            self.update_all_offset_dropdowns()

    def duplicate_padstack_row(self, original_row):
        new_row = PadStackRow()
        new_row.delete_requested.connect(self.delete_padstack_row)
        new_row.data_changed.connect(self.on_data_changed)
        new_row.duplicate_btn.clicked.connect(lambda: self.duplicate_padstack_row(new_row))

        # Copy data from original
        data = original_row.get_data()
        data['pin_number'] = str(len(self.padstack_rows) + 1)
        
        # NEW: Handle offset_from pin number increment
        offset_from = data.get('offset_from', 'origin')
        if offset_from != 'origin':
            try:
                # Try to convert to int and increment by 1
                pin_num = int(offset_from)
                data['offset_from'] = str(pin_num + 1)
            except ValueError:
                # If it's not a numeric pin (like 'V1' for thermal vias), keep it as is
                # You could add more logic here if needed for other pin formats
                pass

        # Add to layout FIRST so update_offset_from_options can find all rows
        self.padstack_rows.append(new_row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, new_row)

        # Update all dropdowns to include the new pin numbers
        self.update_all_offset_dropdowns()

        # NOW set the data - the dropdown will have the correct options
        new_row.set_data(data)


    def add_custom_layer_row(self):
        row = CustomLayerRow()
        row.delete_requested.connect(self.delete_custom_layer_row)
        row.data_changed.connect(self.on_data_changed)
        row.duplicate_btn.clicked.connect(lambda: self.duplicate_custom_layer_row(row))

        self.custom_layer_rows.append(row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, row)

        # Update all offset_from dropdowns
        self.update_all_offset_dropdowns()

    def delete_custom_layer_row(self, row):
        if row in self.custom_layer_rows:
            self.custom_layer_rows.remove(row)
            row.setParent(None)
            self.update_all_offset_dropdowns()

    def duplicate_custom_layer_row(self, original_row):
        new_row = CustomLayerRow()
        new_row.delete_requested.connect(self.delete_custom_layer_row)
        new_row.data_changed.connect(self.on_data_changed)
        new_row.duplicate_btn.clicked.connect(lambda: self.duplicate_custom_layer_row(new_row))

        # Copy data from original
        data = original_row.get_data()

        # Add to layout
        self.custom_layer_rows.append(new_row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, new_row)

        # Update dropdowns and set data
        self.update_all_offset_dropdowns()
        new_row.set_data(data)

    def add_thermal_via_row(self):
        row = ThermalViaRow()
        row.delete_requested.connect(self.delete_thermal_via_row)
        row.data_changed.connect(self.on_data_changed)
        row.duplicate_btn.clicked.connect(lambda: self.duplicate_thermal_via_row(row))
        
        self.thermal_via_rows.append(row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, row)

        # Set via pin number automatically
        row.pin_number.setText(f"V{len(self.thermal_via_rows)}")  # ADD THIS LINE

        # Update all offset_from dropdowns
        self.update_all_offset_dropdowns()


    def delete_thermal_via_row(self, row):
        if row in self.thermal_via_rows:
            self.thermal_via_rows.remove(row)
            row.setParent(None)
            self.update_all_offset_dropdowns()

    def duplicate_thermal_via_row(self, original_row):
        new_row = ThermalViaRow()
        new_row.delete_requested.connect(self.delete_thermal_via_row)
        new_row.data_changed.connect(self.on_data_changed)
        new_row.duplicate_btn.clicked.connect(lambda: self.duplicate_thermal_via_row(new_row))

        # Copy data from original
        data = original_row.get_data()
        data['pin_number'] = f"V{len(self.thermal_via_rows) + 1}"  # ADD THIS LINE

        # Add to layout
        self.thermal_via_rows.append(new_row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, new_row)

        # Update dropdowns and set data
        self.update_all_offset_dropdowns()
        new_row.set_data(data)


    def update_all_offset_dropdowns(self):
        """Update all offset_from dropdowns when pads/vias are added/removed"""
        # Collect all available pad pin numbers
        available_pad_pins = []
        for row in self.padstack_rows:
            pin_text = row.pin_number.text().strip()
            if pin_text:
                available_pad_pins.append(pin_text)
        
        # Collect all available thermal via pin numbers
        available_via_pins = []
        for row in self.thermal_via_rows:
            pin_text = row.pin_number.text().strip()
            if pin_text:
                available_via_pins.append(pin_text)

        # Update padstack dropdowns (only pad pins)
        for row in self.padstack_rows:
            row.update_offset_from_options()

        # Update custom layer dropdowns (only pad pins)
        for row in self.custom_layer_rows:
            current_selection = row.offset_from.currentText()
            row.offset_from.blockSignals(True)
            row.offset_from.clear()
            row.offset_from.addItem('origin')
            row.offset_from.addItems(available_pad_pins)

            # Restore previous selection if still valid
            index = row.offset_from.findText(current_selection)
            if index >= 0:
                row.offset_from.setCurrentIndex(index)
            else:
                row.offset_from.setCurrentText('origin')
            row.offset_from.blockSignals(False)

        # Update thermal via dropdowns (pad pins + thermal via pins)
        for row in self.thermal_via_rows:
            current_selection = row.offset_from.currentText()
            current_pin = row.pin_number.text().strip()
            
            row.offset_from.blockSignals(True)
            row.offset_from.clear()
            row.offset_from.addItem('origin')
            
            # Add pad pins
            row.offset_from.addItems(available_pad_pins)
            
            # Add thermal via pins (excluding current row's own pin)
            for via_pin in available_via_pins:
                if via_pin != current_pin:  # Don't include self-reference
                    row.offset_from.addItem(via_pin)

            # Restore previous selection if still valid
            index = row.offset_from.findText(current_selection)
            if index >= 0:
                row.offset_from.setCurrentIndex(index)
            else:
                row.offset_from.setCurrentText('origin')
            row.offset_from.blockSignals(False)


    def on_data_changed(self):
        # This will be handled by the update thread
        pass

    def set_footprint_data(self, data):
        self.part_number.setText(data.get('part_number', ''))
        self.footprint_name.setText(data.get('footprint_name', ''))
        self.body_length.setText(str(data.get('body_length', Decimal('5.0'))))
        self.body_width.setText(str(data.get('body_width', Decimal('3.0'))))
        self.body_height.setText(str(data.get('body_height', Decimal('1.0'))))
        self.body_shape_combobox.setCurrentText(data.get('body_shape', 'rectangle'))
        
        # Set origin offset values
        self.origin_offset_x_input.setText(str(data.get('origin_offset_x', Decimal('-2.5'))))
        self.origin_offset_y_input.setText(str(data.get('origin_offset_y', Decimal('1.5'))))
        self.auto_update_origin = data.get('auto_update_origin', True)
        
        # Update renderer
        self.update_renderer_origin()
    
        
        self.silkscreen_action.setChecked(data.get('silkscreen_enabled', True))
        
        # Update settings panel
        settings = {
            'body_line_width': data.get('body_line_width', '0.05'),
            'courtyard_expansion': data.get('courtyard_expansion', '0.25'),
            'courtyard_line_width': data.get('courtyard_line_width', '0.1'),
            'silkscreen_airgap': data.get('silkscreen_airgap', '0.15'),
            'silkscreen_line_width': data.get('silkscreen_line_width', '0.15'),
            'text_height': data.get('text_settings', {}).get('text_height', '0.5'),
            'text_width': data.get('text_settings', {}).get('text_width', '0.1'),
            'text_line_width': data.get('text_settings', {}).get('text_line_width', '1.8'),
        }
        self.settings_panel.set_settings(settings)
        
        # Clear existing rows
        for row in self.padstack_rows[:]:
            self.delete_padstack_row(row)
        for row in self.custom_layer_rows[:]:
            self.delete_custom_layer_row(row)
        for row in self.thermal_via_rows[:]:
            self.delete_thermal_via_row(row)
        
        # Add padstacks from data
        for pad_data in data.get('padstacks', []):
            self.add_padstack_row()
            self.padstack_rows[-1].set_data(pad_data)
        
        # Add custom layers from data
        for layer_data in data.get('custom_layers', []):
            self.add_custom_layer_row()
            self.custom_layer_rows[-1].set_data(layer_data)
        
        # Add thermal vias from data
        for via_data in data.get('thermal_vias', []):
            self.add_thermal_via_row()
            self.thermal_via_rows[-1].set_data(via_data)

    def generate_fiducial_padstack_name(self, fiducial_settings):
        """Generate fiducial padstack name based on settings"""
        try:
            diameter = to_decimal(fiducial_settings.get('fiducial_diameter', '1.0'))
            mask_opening = to_decimal(fiducial_settings.get('fiducial_mask_opening', '2.0'))
            keepout_diameter = to_decimal(fiducial_settings.get('fiducial_keepout_diameter', '3.0'))
            
            # Create name based on dimensions (in 0.1mm units)
            name = f"FID_C{int(diameter * 100)}"
            
            if mask_opening > diameter:
                mask_size = int(mask_opening * 100)
                name += f"_M{mask_size}"
                
            if keepout_diameter > mask_opening:
                keepout_size = int(keepout_diameter * 100)
                name += f"_K{keepout_size}"
                
            return name
        except (ValueError, TypeError):
            return "FID_C100_M200_K300"  # Default fiducial name

    def get_unique_padstack_names(self, include_fiducials=False):
        """Get list of unique padstack names used in the footprint"""
        data = self.get_footprint_data()
        unique_names = []
        seen_names = set()
        
        # Regular pads
        for pad in data.get('padstacks', []):
            pad_name = self.generate_pad_name_for_script(pad)
            if pad_name not in seen_names:
                unique_names.append(pad_name)
                seen_names.add(pad_name)
        
        # Add fiducials if enabled and requested
        if include_fiducials and data.get('fiducials_enabled', False):
            fiducial_settings = data.get('settings', {})
            fiducial_name = self.generate_fiducial_padstack_name(fiducial_settings)
            if fiducial_name not in seen_names:
                unique_names.append(fiducial_name)
                seen_names.add(fiducial_name)
        
        return unique_names


        
    def generate_footprint_script(self):
        """Generate footprint script based on selected CAD tool"""
        cad_tool = self.script_combo.currentText()
        
        if cad_tool == "Altium":
            self.generate_altium_script()
        elif cad_tool == "Allegro":
            self.generate_allegro_script()
        elif cad_tool == "PADS":
            self.generate_pads_script()
        elif cad_tool == "Xpedition":
            self.generate_xpedition_script()

    def generate_altium_script(self):
        """Generate footprint script from current data and save to a text file"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        account_settings = AccountManager.load_account_settings()
        
        lines = []
        
        # Scale factor for unit conversion (mm to mils)
        SCALE = Decimal('39.37')
        
        # GET ORIGIN OFFSET VALUES
        origin_offset_x = to_decimal(data.get('origin_offset_x', '0'))
        origin_offset_y = to_decimal(data.get('origin_offset_y', '0'))
        
        # Footprint name
        footprint_name = data.get('footprint_name', 'Unnamed')
        lines.append(f"StartFootprints\n\nFootprint (Name \"{footprint_name}\"),")
        
        # Body dimensions
        body_length = to_decimal(data.get('body_length', '0'))
        body_width = to_decimal(data.get('body_width', '0'))
        body_line_width = to_decimal(data.get('body_line_width', '0.05'))
        
        # Position body with top-left corner offset by origin offset
        # In PCB coordinate system with origin offset applied
        tl = (origin_offset_x, origin_offset_y)                                    # Top-left at origin offset
        tr = (origin_offset_x + body_length, origin_offset_y)                      # Top-right
        bl = (origin_offset_x, origin_offset_y - body_width)                       # Bottom-left  
        br = (origin_offset_x + body_length, origin_offset_y - body_width)         # Bottom-right
        
        # Body shape generation with origin offset applied
        body_shape = data.get('body_shape', 'rectangle')
        if body_shape == 'rectangle':
            lines.append(f"Line (Width {body_line_width*SCALE}) (Start {(tl[0]*SCALE)}, {(tl[1]*SCALE)}) (End {(tr[0]*SCALE)}, {(tr[1]*SCALE)}) (Layer Mechanical13)")
            lines.append(f"Line (Width {body_line_width*SCALE}) (Start {(bl[0]*SCALE)}, {(bl[1]*SCALE)}) (End {(tl[0]*SCALE)}, {(tl[1]*SCALE)}) (Layer Mechanical13)")
            lines.append(f"Line (Width {body_line_width*SCALE}) (Start {(tr[0]*SCALE)}, {(tr[1]*SCALE)}) (End {(br[0]*SCALE)}, {(br[1]*SCALE)}) (Layer Mechanical13)")
            lines.append(f"Line (Width {body_line_width*SCALE}) (Start {(br[0]*SCALE)}, {(br[1]*SCALE)}) (End {(bl[0]*SCALE)}, {(bl[1]*SCALE)}) (Layer Mechanical13)")
        else:
            # For round body, center it within the offset rectangle
            radius = max(body_length, body_width) / Decimal('2')
            center_x = origin_offset_x + (body_length / Decimal('2'))
            center_y = origin_offset_y - (body_width / Decimal('2'))
            lines.append(f"Arc (Width 1.7) (Location {(center_x*SCALE)}, {(center_y*SCALE)}) (Radius {(radius*SCALE)}) (StartAngle 0) (EndAngle 360) (Layer Mechanical13)")

        # Generate pads and collect pad bounds
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        
        # Collect pad bounds for silkscreen gap calculation
        pad_bounds_list = []
        for pad in pads:
            abs_x, abs_y = resolver.get_absolute_position(pad)
            pad_bounds = self.calculate_pad_bounds_for_script(pad, abs_x, abs_y)
            if pad_bounds:
                pad_bounds_list.append(pad_bounds)

        # Helper function for merging intervals
        def merge_intervals(intervals):
            """Merge overlapping intervals in the form [(start, end), ...]"""
            if not intervals:
                return []
            intervals = sorted(intervals, key=lambda x: x[0])
            merged = [intervals[0]]
            for current in intervals[1:]:
                last = merged[-1]
                if current[0] <= last[1]:
                    merged[-1] = (last[0], max(last[1], current[1]))
                else:
                    merged.append(current)
            return merged

        # Add the silkscreen generation function
        def generate_silkscreen_lines_with_gaps(x1, y1, x2, y2, pad_bounds_list, gap, orientation):
            segments = []
            if orientation == 'horizontal':
                start_pos = min(x1, x2)
                end_pos = max(x1, x2)
                line_y = y1
                intersections = []
                
                for (px_min, py_min, px_max, py_max) in pad_bounds_list:
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if horizontal line intersects with expanded pad
                    if (pad_min_y <= line_y <= pad_max_y and 
                        pad_max_x >= start_pos and pad_min_x <= end_pos):
                        inter_start = max(start_pos, pad_min_x)
                        inter_end = min(end_pos, pad_max_x)
                        intersections.append((inter_start, inter_end))
                
                # Merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Generate line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        segments.append((current_pos, line_y, gap_start, line_y))
                    current_pos = gap_end
                if current_pos < end_pos:
                    segments.append((current_pos, line_y, end_pos, line_y))
                    
            else:  # vertical
                start_pos = min(y1, y2)
                end_pos = max(y1, y2)
                line_x = x1
                intersections = []
                
                for (px_min, py_min, px_max, py_max) in pad_bounds_list:
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if vertical line intersects with expanded pad
                    if (pad_min_x <= line_x <= pad_max_x and 
                        pad_max_y >= start_pos and pad_min_y <= end_pos):
                        inter_start = max(start_pos, pad_min_y)
                        inter_end = min(end_pos, pad_max_y)
                        intersections.append((inter_start, inter_end))
                
                # Merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Generate line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        segments.append((line_x, current_pos, line_x, gap_start))
                    current_pos = gap_end
                if current_pos < end_pos:
                    segments.append((line_x, current_pos, line_x, end_pos))
                    
            return segments

        # Generate silkscreen with gaps if enabled
        if data.get('silkscreen_enabled', True):
            silkscreen_gap1 = to_decimal(data.get('silkscreen_airgap', '0.15'))
            silkscreen_line_width = to_decimal(data.get('silkscreen_line_width', '0.15'))
            silkscreen_gap = silkscreen_gap1+(silkscreen_line_width/2)  
            # Generate silkscreen lines with gaps for each side of body rectangle
            silk_lines = []
            # Top line (from top-left to top-right)
            silk_lines += generate_silkscreen_lines_with_gaps(tl[0], tl[1], tr[0], tr[1], pad_bounds_list, silkscreen_gap, 'horizontal')
            # Bottom line (from bottom-left to bottom-right)
            silk_lines += generate_silkscreen_lines_with_gaps(bl[0], bl[1], br[0], br[1], pad_bounds_list, silkscreen_gap, 'horizontal')
            # Left line (from bottom-left to top-left)
            silk_lines += generate_silkscreen_lines_with_gaps(bl[0], bl[1], tl[0], tl[1], pad_bounds_list, silkscreen_gap, 'vertical')
            # Right line (from bottom-right to top-right)
            silk_lines += generate_silkscreen_lines_with_gaps(br[0], br[1], tr[0], tr[1], pad_bounds_list, silkscreen_gap, 'vertical')
            
            # Add silkscreen segment lines to script
            for (x1_, y1_, x2_, y2_) in silk_lines:
                lines.append(f"Line (Width {silkscreen_line_width * SCALE}) (Start {(x1_*SCALE)}, {(y1_*SCALE)}) (End {(x2_*SCALE)}, {(y2_*SCALE)}) (Layer TopOverlay)")

        # Generate Courtyard Layer - Calculate each side separately
        base_expansion = to_decimal(data.get('courtyard_expansion', '0.25'))
        courtyard_line_width = to_decimal(data.get('courtyard_line_width', '0.1'))
        body_line_width = to_decimal(data.get('body_line_width', '0.05'))

        courtyard_line_W = courtyard_line_width / 2
        body_line_w = body_line_width / 2
        body_linecourtyard = courtyard_line_W + body_line_w

        # Calculate pad bounds for courtyard (same as renderer)
        pad_bounds_list = []
        for pad in pads:
            abs_x, abs_y = resolver.get_absolute_position(pad)
            pad_bounds = self.calculate_pad_bounds_for_script(pad, abs_x, abs_y)
            if pad_bounds:
                pad_bounds_list.append(pad_bounds)

        # Calculate overall pad bounds
        pad_bounds_for_courtyard = None
        if pad_bounds_list:
            min_x = min(pb[0] for pb in pad_bounds_list)
            min_y = min(pb[1] for pb in pad_bounds_list)
            max_x = max(pb[2] for pb in pad_bounds_list)
            max_y = max(pb[3] for pb in pad_bounds_list)
            pad_bounds_for_courtyard = [min_x, min_y, max_x, max_y]

        # Body bounds with origin offset applied
        body_bounds_adjusted = [
            tl[0],  # min_x (left edge)
            bl[1],  # min_y (bottom edge)
            tr[0],  # max_x (right edge)
            tl[1]   # max_y (top edge)
        ]

        # Determine outermost bounds for each side separately
        outermost_left = None
        outermost_right = None
        outermost_top = None
        outermost_bottom = None
        outermost_bounds_type_left = None
        outermost_bounds_type_right = None
        outermost_bounds_type_top = None
        outermost_bounds_type_bottom = None

        if body_bounds_adjusted and pad_bounds_for_courtyard:
            # Left side
            if body_bounds_adjusted[0] <= pad_bounds_for_courtyard[0]:
                outermost_left = body_bounds_adjusted[0]
                outermost_bounds_type_left = 'body'
            else:
                outermost_left = pad_bounds_for_courtyard[0]
                outermost_bounds_type_left = 'pad'
            
            # Right side
            if body_bounds_adjusted[2] >= pad_bounds_for_courtyard[2]:
                outermost_right = body_bounds_adjusted[2]
                outermost_bounds_type_right = 'body'
            else:
                outermost_right = pad_bounds_for_courtyard[2]
                outermost_bounds_type_right = 'pad'
            
            # Bottom side
            if body_bounds_adjusted[1] <= pad_bounds_for_courtyard[1]:
                outermost_bottom = body_bounds_adjusted[1]
                outermost_bounds_type_bottom = 'body'
            else:
                outermost_bottom = pad_bounds_for_courtyard[1]
                outermost_bounds_type_bottom = 'pad'
            
            # Top side
            if body_bounds_adjusted[3] >= pad_bounds_for_courtyard[3]:
                outermost_top = body_bounds_adjusted[3]
                outermost_bounds_type_top = 'body'
            else:
                outermost_top = pad_bounds_for_courtyard[3]
                outermost_bounds_type_top = 'pad'

        elif body_bounds_adjusted:
            outermost_left = body_bounds_adjusted[0]
            outermost_right = body_bounds_adjusted[2]
            outermost_bottom = body_bounds_adjusted[1]
            outermost_top = body_bounds_adjusted[3]
            outermost_bounds_type_left = outermost_bounds_type_right = outermost_bounds_type_top = outermost_bounds_type_bottom = 'body'

        elif pad_bounds_for_courtyard:
            outermost_left = pad_bounds_for_courtyard[0]
            outermost_right = pad_bounds_for_courtyard[2]
            outermost_bottom = pad_bounds_for_courtyard[1]
            outermost_top = pad_bounds_for_courtyard[3]
            outermost_bounds_type_left = outermost_bounds_type_right = outermost_bounds_type_top = outermost_bounds_type_bottom = 'pad'

        if outermost_left is not None:
            # Calculate expansion for each side based on what's outermost on that side
            expansion_left = base_expansion
            if outermost_bounds_type_left == 'pad':
                expansion_left += courtyard_line_W
            elif outermost_bounds_type_left == 'body':
                expansion_left += body_linecourtyard

            expansion_right = base_expansion
            if outermost_bounds_type_right == 'pad':
                expansion_right += courtyard_line_W
            elif outermost_bounds_type_right == 'body':
                expansion_right += body_linecourtyard

            expansion_bottom = base_expansion
            if outermost_bounds_type_bottom == 'pad':
                expansion_bottom += courtyard_line_W
            elif outermost_bounds_type_bottom == 'body':
                expansion_bottom += body_linecourtyard

            expansion_top = base_expansion
            if outermost_bounds_type_top == 'pad':
                expansion_top += courtyard_line_W
            elif outermost_bounds_type_top == 'body':
                expansion_top += body_linecourtyard

            # Calculate courtyard bounds with separate expansions for each side
            courtyard_bounds = [
                outermost_left - expansion_left,      # min_x (left)
                outermost_bottom - expansion_bottom,  # min_y (bottom)
                outermost_right + expansion_right,    # max_x (right) 
                outermost_top + expansion_top         # max_y (top)
            ]
            
            courtyard_bl = (courtyard_bounds[0], courtyard_bounds[1])

            # Generate courtyard rectangle with each side calculated separately
            lines.append(f"Line (Width {(courtyard_line_width*SCALE)}) (Start {(courtyard_bounds[0]*SCALE)}, {(courtyard_bounds[3]*SCALE)}) (End {(courtyard_bounds[2]*SCALE)}, {(courtyard_bounds[3]*SCALE)}) (Layer Mechanical15)")  # Top
            lines.append(f"Line (Width {(courtyard_line_width*SCALE)}) (Start {(courtyard_bounds[0]*SCALE)}, {(courtyard_bounds[1]*SCALE)}) (End {(courtyard_bounds[0]*SCALE)}, {(courtyard_bounds[3]*SCALE)}) (Layer Mechanical15)")  # Left
            lines.append(f"Line (Width {(courtyard_line_width*SCALE)}) (Start {(courtyard_bounds[2]*SCALE)}, {(courtyard_bounds[1]*SCALE)}) (End {(courtyard_bounds[2]*SCALE)}, {(courtyard_bounds[3]*SCALE)}) (Layer Mechanical15)")  # Right
            lines.append(f"Line (Width {(courtyard_line_width*SCALE)}) (Start {(courtyard_bounds[0]*SCALE)}, {(courtyard_bounds[1]*SCALE)}) (End {(courtyard_bounds[2]*SCALE)}, {(courtyard_bounds[1]*SCALE)}) (Layer Mechanical15)")  # Bottom



        # Generate Fiducials
        # Generate Fiducials with proper padstack names
        if data.get('fiducials_enabled', False):
            fiducial_settings = data.get('settings', {})
            fiducial_padstack_name = self.generate_fiducial_padstack_name(fiducial_settings)
            
            fid_diameter = to_decimal(fiducial_settings.get('fiducial_diameter', '1.0'))
            fid_mask = to_decimal(fiducial_settings.get('fiducial_mask_opening', '2.0'))
            fid_keepout = to_decimal(fiducial_settings.get('fiducial_keepout_diameter', '3.0'))
            fid_x_offset = to_decimal(fiducial_settings.get('fiducial_x_offset', '2.0'))
            fid_y_offset = to_decimal(fiducial_settings.get('fiducial_y_offset', '2.0'))

            # Calculate fiducial positions
            body_length = to_decimal(data.get('body_length', '5.0'))
            body_width = to_decimal(data.get('body_width', '3.0'))
            
            # Body corners with origin offset
            tr = (origin_offset_x + body_length, origin_offset_y)  # Top-right
            bl = (origin_offset_x, origin_offset_y - body_width)   # Bottom-left

            # Fiducial positions
            fid_positions = [
                (tr[0] + fid_x_offset, tr[1] + fid_y_offset, "FID1"),  # Top-right
                (bl[0] - fid_x_offset, bl[1] - fid_y_offset, "FID2"),  # Bottom-left
            ]

            for fid_x, fid_y, fid_name in fid_positions:
                # Create fiducial pad with proper padstack reference
                lines.append(f"Pad (Name \"{fid_name}\") (Location {fid_x*SCALE}, {fid_y*SCALE}) (Surface True) (Rotation 0) (ExpandMask {fid_mask*SCALE}) (ExpandPaste 0.0)")
                lines.append(f"PadShape (Size {fid_diameter*SCALE}, {fid_diameter*SCALE}) (Shape Round) (Layer Top)")
                lines.append("EndPad")
                
                # Add keepout area
                lines.append(f"Arc (Width 1.0) (Location {(fid_x*SCALE)}, {(fid_y*SCALE)}) (Radius {fid_keepout*SCALE}) (StartAngle 0) (EndAngle 360) (KeepOut True) (Layer mechanical13)")
            # [Rest of the function remains the same - pads, custom layers, thermal vias, text generation]
        # Collect unique padstack names
        unique_names = []
        seen_names = set()
        for pad in pads:
            pad_name = self.generate_pad_name_for_script(pad)
            if pad_name not in seen_names:
                unique_names.append(pad_name)
                seen_names.add(pad_name)

        # Get text settings
        text_height = to_decimal(settings.get('text_height', '0.5')) * SCALE
        text_width = to_decimal(settings.get('text_width', '0.1')) * SCALE
        text_line_width = to_decimal(settings.get('text_line_width', '1.8'))

        # Calculate position below courtyard for text
        base_y = (courtyard_bl[1] - Decimal('1')) * SCALE  # Below courtyard

        for pad in pads:
            pad_type = pad.get('type', 'square')
            name = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)
            rotation = 0

            expand_mask = to_decimal(pad.get('mask_expansion', '0'))
            expand_paste = to_decimal(pad.get('paste_expansion', '0'))

            # Check if mask/paste are enabled
            mask_enabled = pad.get('mask_enabled', True)
            paste_enabled = pad.get('paste_enabled', True)
            
            if not mask_enabled:
                expand_mask = Decimal('0')
            if not paste_enabled:
                expand_paste = Decimal('0')

            surface = 'True' if pad_type not in ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong', 'PTH_rectangle'] else 'False'

            if pad_type == 'square':
                size = to_decimal(pad.get('size', '1'))
                lines.append(f"Pad (Name \"{name}\") (Location {(abs_x*SCALE)}, {(abs_y*SCALE)}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {(expand_mask*SCALE)}) (ExpandPaste {(expand_paste*SCALE)})")
                lines.append(f"PadShape (Size {(size*SCALE)}, {(size*SCALE)}) (Shape Rectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'rectangle':
                length = to_decimal(pad.get('length', '1'))
                width = to_decimal(pad.get('width', '1'))
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE}, {abs_y*SCALE}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE}) (ExpandPaste {expand_paste*SCALE})")
                lines.append(f"PadShape (Size {length*SCALE}, {(width*SCALE)}) (Shape Rectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'SMD-oblong':
                length = to_decimal(pad.get('length', '1'))
                width = to_decimal(pad.get('width', '1'))
                lines.append(f"Pad (Name \"{name}\") (Location {(abs_x*SCALE)}, {(abs_y*SCALE)}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {(expand_mask*SCALE)}) (ExpandPaste {(expand_paste*SCALE)})")
                lines.append(f"PadShape (Size {(length*SCALE)}, {(width*SCALE)}) (Shape Rounded) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'rounded_rectangle':
                length = to_decimal(pad.get('length', '1'))
                width = to_decimal(pad.get('width', '1'))
                lines.append(f"Pad (Name \"{name}\") (Location {(abs_x*SCALE)}, {(abs_y*SCALE)}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {(expand_mask*SCALE)}) (ExpandPaste {(expand_paste*SCALE)})")
                lines.append(f"PadShape (Size {(length*SCALE)}, {(width*SCALE)}) (Shape RoundedRectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type in ['round', 'D-shape']:
                diameter = to_decimal(pad.get('diameter', '1'))
                lines.append(f"Pad (Name \"{name}\") (Location {(abs_x*SCALE)}, {(abs_y*SCALE)}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {(expand_mask*SCALE)}) (ExpandPaste {(expand_paste*SCALE)})")
                lines.append(f"PadShape (Size {(diameter*SCALE)}, {(diameter*SCALE)}) (Shape Rounded) (Layer Top)")
                lines.append("EndPad")

            elif pad_type in ['PTH', 'NPTH']:
                hole_diameter = to_decimal(pad.get('hole_diameter', '0.8'))
                lines.append(f"Pad (Name \"{name}\") (Location {(abs_x*SCALE)}, {(abs_y*SCALE)}) (Slotted False) (HoleSize {(hole_diameter*SCALE)}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {(expand_mask*SCALE)}) (ExpandPaste {(expand_paste*SCALE)})")
                
                if pad_type == 'PTH':
                    pad_diameter = to_decimal(pad.get('pad_diameter', '1.2'))
                    lines.append(f"PadShape (Size {(pad_diameter*SCALE)}, {(pad_diameter*SCALE)}) (Shape Rounded) (Layer Top)")
                    lines.append(f"PadShape (Size {(pad_diameter*SCALE)}, {(pad_diameter*SCALE)}) (Shape Rounded) (Layer Bottom)")
                lines.append("EndPad")

            elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
                hole_length = to_decimal(pad.get('hole_length', '1.5'))
                hole_width = to_decimal(pad.get('hole_width', '0.8'))
                pad_rotation = to_decimal(pad.get('rotation', '0'))
                
                lines.append(f"Pad (Name \"{name}\") (Location {(abs_x*SCALE)}, {(abs_y*SCALE)}) (Slotted True) (SlotWidth {(hole_width*SCALE)}) (SlotHeight {(hole_length*SCALE)}) (Surface {surface}) (Rotation {(pad_rotation)}) (ExpandMask {(expand_mask*SCALE)}) (ExpandPaste {(expand_paste*SCALE)})")
                
                if pad_type == 'PTH_oblong':
                    pad_length = to_decimal(pad.get('pad_length', '2.0'))
                    pad_width = to_decimal(pad.get('pad_width', '1.2'))
                    lines.append(f"PadShape (Size {(pad_length*SCALE)}, {(pad_width*SCALE)}) (Shape Rounded) (Layer Top)")
                    lines.append(f"PadShape (Size {(pad_length*SCALE)}, {(pad_width*SCALE)}) (Shape Rounded) (Layer Bottom)")
                lines.append("EndPad")

            elif pad_type == 'PTH_rectangle':
                hole_length = to_decimal(pad.get('hole_length', '1.5'))
                hole_width = to_decimal(pad.get('hole_width', '0.8'))
                pad_length = to_decimal(pad.get('pad_length', '2.0'))
                pad_width = to_decimal(pad.get('pad_width', '1.2'))
                pad_rotation = to_decimal(pad.get('rotation', '0'))
                
                lines.append(f"Pad (Name \"{name}\") (Location {(abs_x*SCALE)}, {(abs_y*SCALE)}) (Slotted True) (SlotWidth {(hole_width*SCALE)}) (SlotHeight {(hole_length*SCALE)}) (Surface {surface}) (Rotation {(pad_rotation)}) (ExpandMask {(expand_mask*SCALE)}) (ExpandPaste {(expand_paste*SCALE)})")
                lines.append(f"PadShape (Size {(pad_length*SCALE)}, {(pad_width*SCALE)}) (Shape Rectangular) (Layer Top)")
                lines.append(f"PadShape (Size {(pad_length*SCALE)}, {(pad_width*SCALE)}) (Shape Rectangular) (Layer Bottom)")
                lines.append("EndPad")

            elif pad_type == 'custom':
                # Generate custom polygon using actual polygon points
                polygon_points = self.renderer.calculate_polygon_points_absolute(pad, abs_x, abs_y)
                
                if polygon_points and len(polygon_points) >= 3:
                    # Convert polygon points to scaled coordinates
                    scaled_points = [((p.x() * SCALE), (p.y() * SCALE)) for p in polygon_points]
                    point_count = len(scaled_points)
                    
                    # Generate copper layer polygon (TopLayer)
                    lines.append(f"Polygon (PointCount {point_count}) (Layer TopLayer)")
                    for px, py in scaled_points:
                        lines.append(f"Point ({px}, {py})")
                    lines.append("EndPolygon")
                    
                    # Generate mask layer polygon (TopSolder) if mask enabled and has expansion
                    if mask_enabled and expand_mask != Decimal('0'):
                        expanded_points = self.renderer.expand_polygon_uniformly(polygon_points, expand_mask)
                        if expanded_points:
                            scaled_mask_points = [((p.x() * SCALE), (p.y() * SCALE)) for p in expanded_points]
                            mask_point_count = len(scaled_mask_points)
                            lines.append(f"Polygon (PointCount {mask_point_count}) (Layer TopSolder)")
                            for px, py in scaled_mask_points:
                                lines.append(f"Point ({px}, {py})")
                            lines.append("EndPolygon")
                    
                    # Generate paste layer polygon (TopPaste) if paste enabled and has expansion
                    if paste_enabled and expand_paste != Decimal('0'):
                        expanded_points = self.renderer.expand_polygon_uniformly(polygon_points, expand_paste)
                        if expanded_points:
                            scaled_paste_points = [((p.x() * SCALE), (p.y() * SCALE)) for p in expanded_points]
                            paste_point_count = len(scaled_paste_points)
                            lines.append(f"Polygon (PointCount {paste_point_count}) (Layer TopPaste)")
                            for px, py in scaled_paste_points:
                                lines.append(f"Point ({px}, {py})")
                            lines.append("EndPolygon")
                else:
                    # Fallback to simple rectangle if polygon calculation fails
                    lines.append(f"Pad (Name \"{name}\") (Location {(abs_x*SCALE)}, {(abs_y*SCALE)}) (Surface {surface}) (Rotation {rotation})")
                    lines.append(f"PadShape (Size {(Decimal('1.0')*SCALE)}, {(Decimal('1.0')*SCALE)}) (Shape Rectangular) (Layer Top)")
                    lines.append("EndPad")

        # Generate Custom Layers
        custom_layers = data.get('custom_layers', [])
        for layer in custom_layers:
            layer_type = layer.get('layer', 'mask')
            shape = layer.get('shape', 'rectangle')
            
            x_offset = to_decimal(layer.get('x_offset', '0'))
            y_offset = to_decimal(layer.get('y_offset', '0'))

            # Handle offset_from (simplified)
            offset_from = layer.get('offset_from', 'origin')
            if offset_from != 'origin':
                # Add logic to resolve reference positions if needed
                pass

            # Determine Altium layer based on type
            altium_layer = "TopSolder" if layer_type == "mask" else "TopPaste" if layer_type == "paste" else "Mechanical1"

            if shape == 'rectangle':
                length = to_decimal(layer.get('length', '1'))
                width = to_decimal(layer.get('width', '1'))
                
                # Draw rectangle
                x1, y1 = (x_offset - length/Decimal('2')) * SCALE, (y_offset - width/Decimal('2')) * SCALE
                x2, y2 = (x_offset + length/Decimal('2')) * SCALE, (y_offset + width/Decimal('2')) * SCALE
                lines.append(f"Line (Width 0.1) (Start {(x1)}, {(y1)}) (End {(x2)}, {(y1)}) (Layer {altium_layer})")
                lines.append(f"Line (Width 0.1) (Start {(x2)}, {(y1)}) (End {(x2)}, {(y2)}) (Layer {altium_layer})")
                lines.append(f"Line (Width 0.1) (Start {(x2)}, {(y2)}) (End {(x1)}, {(y2)}) (Layer {altium_layer})")
                lines.append(f"Line (Width 0.1) (Start {(x1)}, {(y2)}) (End {(x1)}, {(y1)}) (Layer {altium_layer})")

        # Generate Thermal Vias
        thermal_vias = data.get('thermal_vias', [])
        for via in thermal_vias:
            via_type = via.get('type', 'single')
            
            x_offset = to_decimal(via.get('x_offset', '0'))
            y_offset = to_decimal(via.get('y_offset', '0'))

            # Handle offset_from (simplified)
            offset_from = via.get('offset_from', 'origin')
            if offset_from != 'origin':
                # Add logic to resolve reference positions if needed
                pass

            if via_type == 'single':
                via_diameter = to_decimal(via.get('via_diameter', '0.2'))
                drill_diameter = to_decimal(via.get('drill_diameter', '0.1'))

                lines.append(f"Via (Location {(x_offset*SCALE)}, {(y_offset*SCALE)}) (Size {(via_diameter*SCALE)}) (DrillSize {(drill_diameter*SCALE)})")

            elif via_type == 'grid_array':
                rows = int(via.get('rows', 2))
                columns = int(via.get('columns', 2))
                row_spacing = to_decimal(via.get('row_spacing', '1.0'))
                col_spacing = to_decimal(via.get('col_spacing', '1.0'))
                via_diameter = to_decimal(via.get('via_diameter', '0.2'))
                drill_diameter = to_decimal(via.get('drill_diameter', '0.1'))

                # Use Decimal arithmetic for grid calculations
                start_x = x_offset - (Decimal(str(columns - 1)) * col_spacing / Decimal('2'))
                start_y = y_offset - (Decimal(str(rows - 1)) * row_spacing / Decimal('2'))

                # Collect unique padstack names (including fiducials)
                unique_names = self.get_unique_padstack_names(include_fiducials=True)

                # Get text settings
                text_height = to_decimal(settings.get('text_height', '0.5')) * SCALE
                text_width = to_decimal(settings.get('text_width', '0.1')) * SCALE
                text_line_width = to_decimal(settings.get('text_line_width', '1.8'))

                # Calculate position below courtyard for text
                base_expansion = to_decimal(data.get('courtyard_expansion', '0.25'))
                
                # Calculate courtyard bottom (simplified)
                body_bottom = origin_offset_y - to_decimal(data.get('body_width', '3.0'))
                base_y = (body_bottom - base_expansion - Decimal('1')) * SCALE  # Below courtyard

                # Add unique padstack name texts below footprint
                for i, pad_name in enumerate(unique_names):
                    text_x = Decimal('0')  # Center at origin
                    text_y = base_y - (Decimal(str(i)) * (text_height + Decimal('0.2') * SCALE))  # Stack vertically
                    lines.append(f'Text (Location {(text_x):.1f}, {(text_y):.1f}) (Line Width {(text_line_width)}) (Height {(text_height):.1f}) (Width {(text_width):.1f}) (Rotation 0) (Layer Mechanical13) (Value "{pad_name}")')

                lines.append("EndFootprint\nEndFootprints")
        # Join lines and save
        script = '\n'.join(lines)
        output_path = account_settings.get('altium_output_path', os.path.expanduser("~/Documents/Altium"))
        os.makedirs(output_path, exist_ok=True)
        footprint_name = data.get('footprint_name', 'Unnamed')
        file_name = os.path.join(output_path, f"{footprint_name}_footprint.txt")

        try:
            with open(file_name, "w") as f:
                f.write(script)
            self.show_script_dialog("Altium Script Generated", file_name, script)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save script file:\n{str(e)}")

    # Add this helper method to the FootprintDesigner class
    def generate_pad_name_for_script(self, pad):
        """Generate pad name for script - same logic as renderer"""
        return self.renderer.generate_pad_name(pad)


    def generate_pad_name(self, pad):
        """Generate padstack name based on pad type and expansions"""
        pad_type = pad['type']
        
        try:
            mask_exp = to_decimal(pad.get('mask_expansion', 0)) if pad.get('mask_enabled', True) else 0
            paste_exp = to_decimal(pad.get('paste_expansion', 0)) if pad.get('paste_enabled', True) else 0
        except (ValueError, TypeError):
            mask_exp = paste_exp = 0
        
        name = ""
        
        if pad_type == 'square':
            try:
                size = to_decimal(pad.get('size', 1))
                name = f"S{int(size * 100)}"
                if mask_exp > 0:
                    mask_size = int((size + 2 * mask_exp) * 100)
                    name += f"_M{mask_size}"
                if paste_exp > 0:           
                    paste_size = int((size + 2 * paste_exp) * 100)
                    name += f"_P{paste_size}"
            except (ValueError, TypeError):
                name = "S100"
                
        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong', 'PTH_rectangle']:
            try:
                length = to_decimal(pad.get('length', 1))
                width = to_decimal(pad.get('width', 1))
                name = f"R{int(length * 100)}x{int(width * 100)}"
                if mask_exp > 0:
                    mask_l = int((length + 2 * mask_exp) * 100)
                    mask_w = int((width + 2 * mask_exp) * 100)
                    name += f"_M{mask_l}x{mask_w}"
                if paste_exp > 0:
                    paste_l = int((length + 2 * paste_exp) * 100)
                    paste_w = int((width + 2 * paste_exp) * 100)
                    name += f"_P{paste_l}x{paste_w}"
            except (ValueError, TypeError):
                name = "R100x100"
                
        elif pad_type == 'round':
            try:
                diameter = to_decimal(pad.get('diameter', 1))
                name = f"C{int(diameter * 100)}"  # C for circular
                if mask_exp > 0:
                    mask_dia = int((diameter + 2 * mask_exp) * 100)
                    name += f"_M{mask_dia}"
                if paste_exp > 0:
                    paste_dia = int((diameter + 2 * paste_exp) * 100)
                    name += f"_P{paste_dia}"
            except (ValueError, TypeError):
                name = "C100"
                
        elif pad_type in ['PTH', 'NPTH']:
            hole_dia = to_decimal(pad.get('hole_diameter', 0.8))
            if pad_type == 'PTH':
                pad_dia = to_decimal(pad.get('pad_diameter', 1.2))
                name = f"PTH{int(hole_dia * 100)}_P{int(pad_dia * 100)}"
            else:
                name = f"NPTH{int(hole_dia * 100)}"
                
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            hole_l = to_decimal(pad.get('hole_length', 1.5))
            hole_w = to_decimal(pad.get('hole_width', 0.8))
            if pad_type == 'PTH_oblong':
                pad_l = to_decimal(pad.get('pad_length', 2.0))
                pad_w = to_decimal(pad.get('pad_width', 1.2))
                name = f"PTHO{int(hole_l * 100)}x{int(hole_w * 100)}_P{int(pad_l * 100)}x{int(pad_w * 100)}"
            else:
                name = f"NPTHO{int(hole_l * 100)}x{int(hole_w * 100)}"
        else:
            name = f"{pad_type.upper()}"
            
        return name
  
    def generate_allegro_script(self):
        """Generate Allegro PCB Editor SKILL script"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        lines = []
        footprint_name = data.get('footprint_name', 'Unnamed')
        
        # SKILL script header
        lines.append("; Allegro PCB Editor SKILL Script")
        lines.append(f"; Footprint: {footprint_name}")
        lines.append("; Generated by LibSienna Footprint Designer")
        lines.append("")
        
        lines.append("(defun create_footprint ()")
        lines.append("  (let ()")
        lines.append(f'    (printf "Creating footprint: {footprint_name}\\n")')
        lines.append("")
        
        # Get pads and resolver
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        
        # Step 1: Create unique padstack definitions
        lines.append("    ; ===== PADSTACK DEFINITIONS =====")
        unique_padstacks = {}
        
        for pad in pads:
            padstack_name = self.generate_pad_name_for_script(pad)
            
            if padstack_name not in unique_padstacks:
                unique_padstacks[padstack_name] = True
                pad_type = pad.get('type', 'square')
                
                lines.append(f"    ; Creating padstack: {padstack_name}")
                lines.append(f'    (axlPadstackEdit ?name "{padstack_name}" ?action "create")')
                
                if pad_type == 'square':
                    size = to_decimal(pad.get('size', 1))
                    lines.append(f'    (axlPadstackEditDefinition ?layer "TOP" ?shape "rectangle" ?width {size} ?height {size})')
                    lines.append(f'    (axlPadstackEditDefinition ?layer "BOTTOM" ?shape "rectangle" ?width {size} ?height {size})')
                    
                    mask_exp = to_decimal(pad.get('mask_expansion', 0))
                    if mask_exp != 0:
                        mask_size = size + (2 * mask_exp)
                        lines.append(f'    (axlPadstackEditDefinition ?layer "SOLDERMASK_TOP" ?shape "rectangle" ?width {mask_size} ?height {mask_size})')
                        lines.append(f'    (axlPadstackEditDefinition ?layer "SOLDERMASK_BOTTOM" ?shape "rectangle" ?width {mask_size} ?height {mask_size})')
                    
                    paste_exp = to_decimal(pad.get('paste_expansion', 0))
                    if paste_exp != 0:
                        paste_size = size + (2 * paste_exp)
                        lines.append(f'    (axlPadstackEditDefinition ?layer "PASTEMASK_TOP" ?shape "rectangle" ?width {paste_size} ?height {paste_size})')
                        
                elif pad_type in ['rectangle', 'SMD-oblong', 'rounded_rectangle']:
                    length = to_decimal(pad.get('length', 1))
                    width = to_decimal(pad.get('width', 1))
                    shape = "rectangle" if pad_type == 'rectangle' else "oblong"
                    
                    lines.append(f'    (axlPadstackEditDefinition ?layer "TOP" ?shape "{shape}" ?width {length} ?height {width})')
                    lines.append(f'    (axlPadstackEditDefinition ?layer "BOTTOM" ?shape "{shape}" ?width {length} ?height {width})')
                    
                    mask_exp = to_decimal(pad.get('mask_expansion', 0))
                    if mask_exp != 0:
                        mask_l = length + (2 * mask_exp)
                        mask_w = width + (2 * mask_exp)
                        lines.append(f'    (axlPadstackEditDefinition ?layer "SOLDERMASK_TOP" ?shape "{shape}" ?width {mask_l} ?height {mask_w})')
                        lines.append(f'    (axlPadstackEditDefinition ?layer "SOLDERMASK_BOTTOM" ?shape "{shape}" ?width {mask_l} ?height {mask_w})')
                    
                    paste_exp = to_decimal(pad.get('paste_expansion', 0))
                    if paste_exp != 0:
                        paste_l = length + (2 * paste_exp)
                        paste_w = width + (2 * paste_exp)
                        lines.append(f'    (axlPadstackEditDefinition ?layer "PASTEMASK_TOP" ?shape "{shape}" ?width {paste_l} ?height {paste_w})')
                        
                elif pad_type == 'round':
                    diameter = to_decimal(pad.get('diameter', 1))
                    lines.append(f'    (axlPadstackEditDefinition ?layer "TOP" ?shape "circle" ?diameter {diameter})')
                    lines.append(f'    (axlPadstackEditDefinition ?layer "BOTTOM" ?shape "circle" ?diameter {diameter})')
                    
                    mask_exp = to_decimal(pad.get('mask_expansion', 0))
                    if mask_exp != 0:
                        mask_dia = diameter + (2 * mask_exp)
                        lines.append(f'    (axlPadstackEditDefinition ?layer "SOLDERMASK_TOP" ?shape "circle" ?diameter {mask_dia})')
                        lines.append(f'    (axlPadstackEditDefinition ?layer "SOLDERMASK_BOTTOM" ?shape "circle" ?diameter {mask_dia})')
                    
                elif pad_type in ['PTH', 'NPTH']:
                    hole_dia = to_decimal(pad.get('hole_diameter', 0.8))
                    lines.append(f'    (axlPadstackEditDefinition ?layer "DRILL" ?diameter {hole_dia})')
                    
                    if pad_type == 'PTH':
                        pad_dia = to_decimal(pad.get('pad_diameter', 1.2))
                        lines.append(f'    (axlPadstackEditDefinition ?layer "TOP" ?shape "circle" ?diameter {pad_dia})')
                        lines.append(f'    (axlPadstackEditDefinition ?layer "BOTTOM" ?shape "circle" ?diameter {pad_dia})')
                        lines.append('    (axlPadstackEditDefinition ?layer "INTERNAL" ?shape "circle" ?diameter ' + str(pad_dia) + ')')
                
                lines.append('    (axlPadstackEditSave)')
                lines.append('    (axlPadstackEditClose)')
                lines.append("")
        
        # Step 2: Create symbol and place pads
        lines.append("    ; ===== SYMBOL CREATION =====")
        lines.append(f'    (axlSymbolCreate ?name "{footprint_name}")')
        lines.append("")
        
        lines.append("    ; ===== PAD PLACEMENT =====")
        for pad in pads:
            padstack_name = self.generate_pad_name_for_script(pad)
            pin_number = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)
            
            lines.append(f'    ; Placing pad {pin_number}')
            lines.append(f'    (axlPinCreate ?name "{pin_number}" ?padstack "{padstack_name}" ?xy (list {abs_x} {abs_y}))')
        
        lines.append("")
        
        # Step 3: Generate package geometry
        origin_offset_x = to_decimal(data.get('origin_offset_x', '0'))
        origin_offset_y = to_decimal(data.get('origin_offset_y', '0'))
        body_length = to_decimal(data.get('body_length', '0'))
        body_width = to_decimal(data.get('body_width', '0'))
        
        if body_length > 0 and body_width > 0:
            lines.append("    ; ===== PACKAGE GEOMETRY =====")
            
            # Calculate body corners
            tl_x = origin_offset_x
            tl_y = origin_offset_y
            tr_x = origin_offset_x + body_length
            tr_y = origin_offset_y
            bl_x = origin_offset_x
            bl_y = origin_offset_y - body_width
            br_x = origin_offset_x + body_length
            br_y = origin_offset_y - body_width
            
            body_width_line = to_decimal(data.get('body_line_width', '0.05'))
            
            lines.append(f'    (axlShapeCreate ?layer "PACKAGE_GEOMETRY" ?type "line"')
            lines.append(f'                   ?xy1 (list {tl_x} {tl_y}) ?xy2 (list {tr_x} {tr_y})')
            lines.append(f'                   ?width {body_width_line})')
            lines.append(f'    (axlShapeCreate ?layer "PACKAGE_GEOMETRY" ?type "line"')
            lines.append(f'                   ?xy1 (list {tr_x} {tr_y}) ?xy2 (list {br_x} {br_y})')
            lines.append(f'                   ?width {body_width_line})')
            lines.append(f'    (axlShapeCreate ?layer "PACKAGE_GEOMETRY" ?type "line"')
            lines.append(f'                   ?xy1 (list {br_x} {br_y}) ?xy2 (list {bl_x} {bl_y})')
            lines.append(f'                   ?width {body_width_line})')
            lines.append(f'    (axlShapeCreate ?layer "PACKAGE_GEOMETRY" ?type "line"')
            lines.append(f'                   ?xy1 (list {bl_x} {bl_y}) ?xy2 (list {tl_x} {tl_y})')
            lines.append(f'                   ?width {body_width_line})')
            lines.append("")
        
        # Step 4: Generate silkscreen
        if data.get('silkscreen_enabled', True) and body_length > 0 and body_width > 0:
            lines.append("    ; ===== SILKSCREEN =====")
            silk_width = to_decimal(data.get('silkscreen_line_width', '0.15'))
            
            lines.append(f'    (axlShapeCreate ?layer "SILKSCREEN_TOP" ?type "line"')
            lines.append(f'                   ?xy1 (list {tl_x} {tl_y}) ?xy2 (list {tr_x} {tr_y})')
            lines.append(f'                   ?width {silk_width})')
            lines.append(f'    (axlShapeCreate ?layer "SILKSCREEN_TOP" ?type "line"')
            lines.append(f'                   ?xy1 (list {tr_x} {tr_y}) ?xy2 (list {br_x} {br_y})')
            lines.append(f'                   ?width {silk_width})')
            lines.append(f'    (axlShapeCreate ?layer "SILKSCREEN_TOP" ?type "line"')
            lines.append(f'                   ?xy1 (list {br_x} {br_y}) ?xy2 (list {bl_x} {bl_y})')
            lines.append(f'                   ?width {silk_width})')
            lines.append(f'    (axlShapeCreate ?layer "SILKSCREEN_TOP" ?type "line"')
            lines.append(f'                   ?xy1 (list {bl_x} {bl_y}) ?xy2 (list {tl_x} {tl_y})')
            lines.append(f'                   ?width {silk_width})')
            lines.append("")
        
        # Footer
        lines.append('    (axlSymbolSave)')
        lines.append('    (axlSymbolClose)')
        lines.append(f'    (printf "Footprint {footprint_name} created successfully\\n")')
        lines.append("  )")
        lines.append(")")
        lines.append("")
        lines.append("; Execute the function")
        lines.append("(create_footprint)")
        
        # Save script
        script = '\n'.join(lines)
        output_path = settings.get('allegro_output_path', os.path.expanduser("~/Documents/Allegro"))
        os.makedirs(output_path, exist_ok=True)
        file_name = os.path.join(output_path, f"{footprint_name}_allegro.il")
        
        try:
            with open(file_name, "w") as f:
                f.write(script)
            self.show_script_dialog("Allegro SKILL Script Generated", file_name, script)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save Allegro SKILL script: {str(e)}")


    def generate_pads_script(self):
        """Generate comprehensive PADS Layout script with padstack definitions"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        lines = []
        footprint_name = data.get('footprint_name', 'Unnamed')
        
        # PADS script header
        lines.append("! PADS Layout Script - Enhanced Version")
        lines.append(f"! Footprint: {footprint_name}")
        lines.append(f"! Generated by LibSienna Footprint Designer")
        lines.append("")
        
        # Get pads and resolver
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        
        # Step 1: Create unique padstack definitions
        lines.append("! ===== PADSTACK DEFINITIONS =====")
        lines.append("*DEFINE_PADSTACK*")
        
        unique_padstacks = {}
        padstack_counter = 1
        
        for pad in pads:
            padstack_name = self.generate_pad_name_for_script(pad)
            
            if padstack_name not in unique_padstacks:
                unique_padstacks[padstack_name] = f"PAD{padstack_counter:03d}"
                pad_type = pad.get('type', 'square')
                
                lines.append(f"! Padstack: {padstack_name}")
                lines.append(f"{unique_padstacks[padstack_name]} {padstack_name}")
                
                if pad_type == 'square':
                    size = to_decimal(pad.get('size', 1)) * 1000  # Convert to mils
                    lines.append(f"  TOP    S{size:.0f}")
                    lines.append(f"  BOTTOM S{size:.0f}")
                    mask_exp = to_decimal(pad.get('mask_expansion', 0)) * 1000
                    if mask_exp > 0:
                        mask_size = size + (2 * mask_exp)
                        lines.append(f"  SOLDERMASK S{mask_size:.0f}")
                    paste_exp = to_decimal(pad.get('paste_expansion', 0)) * 1000
                    if paste_exp > 0:
                        paste_size = size + (2 * paste_exp)
                        lines.append(f"  PASTE S{paste_size:.0f}")
                        
                elif pad_type in ['rectangle', 'SMD-oblong', 'rounded_rectangle']:
                    length = to_decimal(pad.get('length', 1)) * 1000
                    width = to_decimal(pad.get('width', 1)) * 1000
                    shape = "R" if pad_type == 'rectangle' else "O"  # O for oblong/rounded
                    lines.append(f"  TOP    {shape}{length:.0f}X{width:.0f}")
                    lines.append(f"  BOTTOM {shape}{length:.0f}X{width:.0f}")
                    mask_exp = to_decimal(pad.get('mask_expansion', 0)) * 1000
                    if mask_exp > 0:
                        mask_l = length + (2 * mask_exp)
                        mask_w = width + (2 * mask_exp)
                        lines.append(f"  SOLDERMASK {shape}{mask_l:.0f}X{mask_w:.0f}")
                    paste_exp = to_decimal(pad.get('paste_expansion', 0)) * 1000
                    if paste_exp > 0:
                        paste_l = length + (2 * paste_exp)
                        paste_w = width + (2 * paste_exp)
                        lines.append(f"  PASTE {shape}{paste_l:.0f}X{paste_w:.0f}")
                        
                elif pad_type == 'round':
                    diameter = to_decimal(pad.get('diameter', 1)) * 1000
                    lines.append(f"  TOP    C{diameter:.0f}")
                    lines.append(f"  BOTTOM C{diameter:.0f}")
                    mask_exp = to_decimal(pad.get('mask_expansion', 0)) * 1000
                    if mask_exp > 0:
                        mask_dia = diameter + (2 * mask_exp)
                        lines.append(f"  SOLDERMASK C{mask_dia:.0f}")
                    paste_exp = to_decimal(pad.get('paste_expansion', 0)) * 1000
                    if paste_exp > 0:
                        paste_dia = diameter + (2 * paste_exp)
                        lines.append(f"  PASTE C{paste_dia:.0f}")
                        
                elif pad_type in ['PTH', 'NPTH']:
                    hole_dia = to_decimal(pad.get('hole_diameter', 0.8)) * 1000
                    if pad_type == 'PTH':
                        pad_dia = to_decimal(pad.get('pad_diameter', 1.2)) * 1000
                        lines.append(f"  TOP    C{pad_dia:.0f}")
                        lines.append(f"  BOTTOM C{pad_dia:.0f}")
                    lines.append(f"  DRILL  {hole_dia:.0f}")
                    
                elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
                    hole_length = to_decimal(pad.get('hole_length', 1.5)) * 1000
                    hole_width = to_decimal(pad.get('hole_width', 0.8)) * 1000
                    if pad_type == 'PTH_oblong':
                        pad_length = to_decimal(pad.get('pad_length', 2.0)) * 1000
                        pad_width = to_decimal(pad.get('pad_width', 1.2)) * 1000
                        lines.append(f"  TOP    O{pad_length:.0f}X{pad_width:.0f}")
                        lines.append(f"  BOTTOM O{pad_length:.0f}X{pad_width:.0f}")
                    lines.append(f"  DRILL  O{hole_length:.0f}X{hole_width:.0f}")
                    
                lines.append("")
                padstack_counter += 1
        
        lines.append("*END_DEFINE_PADSTACK*")
        lines.append("")
        
        # Step 2: Create part definition with pad placements
        lines.append("! ===== PART DEFINITION =====")
        lines.append("*PART*")
        lines.append(f"{footprint_name}")
        lines.append("")
        
        lines.append("! Pad placements:")
        for pad in pads:
            padstack_name = self.generate_pad_name_for_script(pad)
            pin_number = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)
            
            # Convert to mils and reference the padstack
            x_mils = abs_x * 1000
            y_mils = abs_y * 1000
            
            lines.append(f"{pin_number} {x_mils:.0f} {y_mils:.0f} {unique_padstacks[padstack_name]}")
        
        lines.append("")
        
        # Step 3: Generate silkscreen
        if data.get('silkscreen_enabled', True):
            lines.append("! ===== SILKSCREEN =====")
            
            # Get origin offset and body dimensions
            origin_offset_x = to_decimal(data.get('origin_offset_x', '0'))
            origin_offset_y = to_decimal(data.get('origin_offset_y', '0'))
            body_length = to_decimal(data.get('body_length', '0'))
            body_width = to_decimal(data.get('body_width', '0'))
            
            if body_length > 0 and body_width > 0:
                # Calculate body corners with origin offset (in mils)
                tl_x = origin_offset_x * 1000
                tl_y = origin_offset_y * 1000
                tr_x = (origin_offset_x + body_length) * 1000
                tr_y = origin_offset_y * 1000
                bl_x = origin_offset_x * 1000
                bl_y = (origin_offset_y - body_width) * 1000
                br_x = (origin_offset_x + body_length) * 1000
                br_y = (origin_offset_y - body_width) * 1000
                
                silkscreen_width = to_decimal(data.get('silkscreen_line_width', '0.15')) * 1000
                
                lines.append("! Body outline silkscreen")
                lines.append(f"LINE {tl_x:.0f} {tl_y:.0f} {tr_x:.0f} {tr_y:.0f} {silkscreen_width:.0f} SILK_TOP")
                lines.append(f"LINE {tr_x:.0f} {tr_y:.0f} {br_x:.0f} {br_y:.0f} {silkscreen_width:.0f} SILK_TOP")
                lines.append(f"LINE {br_x:.0f} {br_y:.0f} {bl_x:.0f} {bl_y:.0f} {silkscreen_width:.0f} SILK_TOP")
                lines.append(f"LINE {bl_x:.0f} {bl_y:.0f} {tl_x:.0f} {tl_y:.0f} {silkscreen_width:.0f} SILK_TOP")
            
            lines.append("")
        
        # Step 4: Add assembly layer
        lines.append("! ===== ASSEMBLY LAYER =====")
        if body_length > 0 and body_width > 0:
            assembly_width = to_decimal(data.get('body_line_width', '0.05')) * 1000
            lines.append("! Body outline assembly")
            lines.append(f"LINE {tl_x:.0f} {tl_y:.0f} {tr_x:.0f} {tr_y:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
            lines.append(f"LINE {tr_x:.0f} {tr_y:.0f} {br_x:.0f} {br_y:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
            lines.append(f"LINE {br_x:.0f} {br_y:.0f} {bl_x:.0f} {bl_y:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
            lines.append(f"LINE {bl_x:.0f} {bl_y:.0f} {tl_x:.0f} {tl_y:.0f} {assembly_width:.0f} ASSEMBLY_TOP")
        
        lines.append("")
        lines.append("*END*")
        
        # Save script
        script = '\n'.join(lines)
        output_path = settings.get('pads_output_path', os.path.expanduser("~/Documents/PADS"))
        os.makedirs(output_path, exist_ok=True)
        file_name = os.path.join(output_path, f"{footprint_name}_pads_enhanced.pt")
        
        try:
            with open(file_name, "w") as f:
                f.write(script)
            self.show_script_dialog("Enhanced PADS Script Generated", file_name, script)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save PADS script: {str(e)}")


    def generate_xpedition_script(self):
        """Generate Xpedition Layout script"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        
        lines = []
        footprint_name = data.get('footprint_name', 'Unnamed')
        
        # Xpedition script header
        lines.append("# Xpedition Layout Script")
        lines.append(f"# Footprint: {footprint_name}")
        lines.append("")
        
        lines.append("BeginPart")
        lines.append(f"PartName = {footprint_name}")
        
        # Generate pads
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        
        for pad in pads:
            pad_type = pad.get('type', 'square')
            name = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)
            
            lines.append(f"BeginPin")
            lines.append(f"PinName = {name}")
            lines.append(f"X = {abs_x}")
            lines.append(f"Y = {abs_y}")
            
            if pad_type == 'square':
                size = to_decimal(pad.get('size', 1))
                lines.append(f"PadShape = Rectangle")
                lines.append(f"PadWidth = {size}")
                lines.append(f"PadHeight = {size}")
            elif pad_type in ['rectangle', 'SMD-oblong']:
                length = to_decimal(pad.get('length', 1))
                width = to_decimal(pad.get('width', 1))
                lines.append(f"PadShape = Rectangle")
                lines.append(f"PadWidth = {length}")
                lines.append(f"PadHeight = {width}")
            elif pad_type == 'round':
                diameter = to_decimal(pad.get('diameter', 1))
                lines.append(f"PadShape = Circle")
                lines.append(f"PadDiameter = {diameter}")
            elif pad_type in ['PTH', 'NPTH']:
                hole_dia = to_decimal(pad.get('hole_diameter', 0.8))
                pad_dia = to_decimal(pad.get('pad_diameter', 1.2)) if pad_type == 'PTH' else hole_dia
                lines.append(f"PadShape = Circle")
                lines.append(f"PadDiameter = {pad_dia}")
                lines.append(f"HoleDiameter = {hole_dia}")
            
            lines.append("EndPin")
        
        lines.append("EndPart")
        
        # Save script
        script = '\n'.join(lines)
        output_path = settings.get('xpedition_output_path', os.path.expanduser("~/Documents/Xpedition"))
        os.makedirs(output_path, exist_ok=True)
        file_name = os.path.join(output_path, f"{footprint_name}_xpedition.txt")
        
        try:
            with open(file_name, "w") as f:
                f.write(script)
            self.show_script_dialog("Xpedition Script Generated", file_name, script)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save Xpedition script: {str(e)}")

    def show_script_dialog(self, title, filename, script):
        """Show script generation dialog"""
        dialog = QMessageBox(self)
        dialog.setWindowTitle(title)
        dialog.setText(f"Script saved to:\n{filename}")
        dialog.setDetailedText(script)
        dialog.setIcon(QMessageBox.Icon.Information)
        dialog.exec()

    def calculate_pad_bounds_for_script(self, pad, abs_x, abs_y):
        """Calculate pad bounds for script generation"""
        pad_type = pad.get('type', 'square')
        
        # Convert inputs to Decimal
        abs_x = to_decimal(str(abs_x))
        abs_y = to_decimal(str(abs_y))
        
        if pad_type == 'square':
            size = to_decimal(pad.get('size', '1'))
            half_size = size / Decimal('2')
            return (abs_x - half_size, abs_y - half_size, abs_x + half_size, abs_y + half_size)
            
        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong']:
            length = to_decimal(pad.get('length', '1'))
            width = to_decimal(pad.get('width', '1'))
            half_length = length / Decimal('2')
            half_width = width / Decimal('2')
            return (abs_x - half_length, abs_y - half_width, abs_x + half_length, abs_y + half_width)
            
        elif pad_type == 'PTH_rectangle':
            pad_length = to_decimal(pad.get('pad_length', '2.0'))
            pad_width = to_decimal(pad.get('pad_width', '1.2'))
            half_length = pad_length / Decimal('2')
            half_width = pad_width / Decimal('2')
            return (abs_x - half_length, abs_y - half_width, abs_x + half_length, abs_y + half_width)
            
        elif pad_type in ['round', 'D-shape']:
            diameter = to_decimal(pad.get('diameter', '1'))
            half_diameter = diameter / Decimal('2')
            return (abs_x - half_diameter, abs_y - half_diameter, abs_x + half_diameter, abs_y + half_diameter)
            
        elif pad_type in ['PTH', 'NPTH']:
            if pad_type == 'PTH':
                diameter = to_decimal(pad.get('pad_diameter', '1.2'))
            else:
                diameter = to_decimal(pad.get('hole_diameter', '0.8'))
            half_diameter = diameter / Decimal('2')
            return (abs_x - half_diameter, abs_y - half_diameter, abs_x + half_diameter, abs_y + half_diameter)
        
        # ADD MISSING CASES:
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if pad_type == 'PTH_oblong':
                length = to_decimal(pad.get('pad_length', '2.0'))
                width = to_decimal(pad.get('pad_width', '1.2'))
            else:
                length = to_decimal(pad.get('hole_length', '1.5'))
                width = to_decimal(pad.get('hole_width', '0.8'))
            
            # Handle rotation
            rotation = pad.get('rotation', 0)
            try:
                rotation_deg = float(to_decimal(str(rotation)))
            except (ValueError, TypeError):
                rotation_deg = 0
            
            if rotation_deg != 0:
                return self._calculate_rotated_bounds_for_script(abs_x, abs_y, length, width, rotation_deg)
            else:
                half_length = length / Decimal('2')
                half_width = width / Decimal('2')
                return (abs_x - half_length, abs_y - half_width, abs_x + half_length, abs_y + half_width)
        
        elif pad_type == 'NPTH_rectangle':  # ADD THIS MISSING CASE
            hole_length = to_decimal(pad.get('hole_length', '1.5'))
            hole_width = to_decimal(pad.get('hole_width', '0.8'))
            
            # Handle rotation
            rotation = pad.get('rotation', 0)
            try:
                rotation_deg = float(to_decimal(str(rotation)))
            except (ValueError, TypeError):
                rotation_deg = 0
            
            if rotation_deg != 0:
                return self._calculate_rotated_bounds_for_script(abs_x, abs_y, hole_length, hole_width, rotation_deg)
            else:
                half_length = hole_length / Decimal('2')
                half_width = hole_width / Decimal('2')
                return (abs_x - half_length, abs_y - half_width, abs_x + half_length, abs_y + half_width)
        
        elif pad_type == 'custom':
            # Handle custom polygon bounds
            polygon_points = self.calculate_polygon_points_absolute(pad, abs_x, abs_y)
            if polygon_points:
                xs = [p.x() for p in polygon_points]
                ys = [p.y() for p in polygon_points]
                return (min(xs), min(ys), max(xs), max(ys))
        
        # Default fallback
        half_unit = Decimal('0.5')
        return (abs_x - half_unit, abs_y - half_unit, abs_x + half_unit, abs_y + half_unit)



    def start_update_thread(self):
        self.update_thread = UpdateThread(self)
        self.update_thread.update_signal.connect(self.renderer.update_footprint)
        self.update_thread.start()

    def closeEvent(self, event):
        """Save settings on close"""
        self.save_app_settings()
        if hasattr(self, 'update_thread'):
            self.update_thread.stop()
            self.update_thread.wait()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)

    # Set application-wide dark theme
    app.setStyle('Fusion')
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(43, 43, 43))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Base, QColor(60, 60, 60))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(80, 80, 80))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Text, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Button, QColor(74, 74, 74))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 0, 0))
    palette.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(0, 0, 0))
    app.setPalette(palette)

    window = FootprintDesigner()
    window.show()

    sys.exit(app.exec())
