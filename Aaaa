def calculate_price(self):
    """Calculate PCB price based on database data with exact filtering"""
    try:
        # Validate inputs
        if not all([
            self.customer_input.text().strip(),
            self.job_input.text().strip(),
            self.pcb_part_input.text().strip(),
            self.length_input.text(),
            self.width_input.text()
        ]):
            QMessageBox.warning(self, "Input Error", "Please fill all required fields!")
            return

        # Get input values
        customer_name = self.customer_input.text().strip()
        job_number = self.job_input.text().strip()
        pcb_part_number = self.pcb_part_input.text().strip()
        unit = self.unit_combo.currentText()
        
        try:
            length = float(self.length_input.text())
            width = float(self.width_input.text())
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Length and Width must be numeric.")
            return

        # Build EXACT filter conditions
        filter_conditions = []
        params = []
        active_filters = []
        
        # Apply exact filters for each selected option
        for field, combo in self.filter_combos.items():
            selected_value = combo.currentText().strip()
            if selected_value and selected_value != "Any":
                # EXACT MATCH only
                filter_conditions.append(f"{field} = ?")
                params.append(selected_value)
                active_filters.append(f"{field}: {selected_value}")

        # Base query - get all valid records
        base_query = '''
            SELECT Quantity, Length, Width, PricePerUnit, TotalCostINR, FabricatorName, 
                   Layers, material, BoardThickness, CuInner, CuOuter, SurfaceFinish,
                   Impedance, Soldermask, Silkscreen, back_drill, blind_via, berried_via
            FROM pcb_data
            WHERE PricePerUnit IS NOT NULL 
            AND PricePerUnit != '' 
            AND Length > 0 
            AND Width > 0
        '''
        
        # Add exact filter conditions
        if filter_conditions:
            complete_query = base_query + " AND " + " AND ".join(filter_conditions)
        else:
            complete_query = base_query
            
        # Order by highest price per unit
        complete_query += " ORDER BY CAST(REPLACE(REPLACE(PricePerUnit, ',', ''), '$', '') AS REAL) DESC"

        print(f"FILTER DEBUG:")
        print(f"Query: {complete_query}")
        print(f"Parameters: {params}")
        print(f"Active Filters: {active_filters}")
        
        self.parent.cursor.execute(complete_query, params)
        matches = self.parent.cursor.fetchall()

        if not matches:
            if active_filters:
                filter_msg = "Applied Filters:\n" + "\n".join(f"• {f}" for f in active_filters)
                QMessageBox.information(self, "No Match Found", 
                                      f"No records found matching your exact criteria:\n\n{filter_msg}\n\nTry different filter values or select 'Any' for some filters.")
            else:
                QMessageBox.information(self, "No Data", "No valid PCB data found in database.")
            return

        print(f"Found {len(matches)} exact matches")
        
        # Show all matching records info
        print("MATCHING RECORDS:")
        for i, match in enumerate(matches[:5]):  # Show first 5 matches
            fabricator = match[5]
            layers = match[6]
            material = match[7] 
            price = match[3]
            print(f"{i+1}. {fabricator} - {layers} layers, {material}, Price: {price}")

        # Use the best match (highest price per unit)
        best_match = matches[0]
        (ref_qty, ref_length, ref_width, ref_price_per_unit_str, ref_total_cost, ref_fabricator,
         ref_layers, ref_material, ref_thickness, ref_cu_inner, ref_cu_outer, ref_surface_finish,
         ref_impedance, ref_soldermask, ref_silkscreen, ref_back_drill, ref_blind_via, ref_buried_via) = best_match
        
        # Convert price to number
        try:
            # Remove currency symbols and commas
            clean_price = str(ref_price_per_unit_str).replace('$', '').replace('₹', '').replace(',', '').strip()
            ref_price_per_unit = float(clean_price)
        except (ValueError, TypeError):
            QMessageBox.warning(self, "Data Error", f"Invalid price format in database: {ref_price_per_unit_str}")
            return

        # Calculate area and price per square unit
        ref_area = float(ref_length) * float(ref_width)
        if ref_area <= 0:
            QMessageBox.warning(self, "Data Error", "Invalid PCB dimensions in reference data.")
            return
            
        price_per_sq_unit = ref_price_per_unit / ref_area

        # Calculate price for user's PCB
        input_area = length * width
        per_unit_price = price_per_sq_unit * input_area

        # Create reference specs for display
        reference_specs = {
            'Fabricator': ref_fabricator,
            'Layers': ref_layers,
            'Material': ref_material,
            'Board Thickness': f"{ref_thickness} mil" if ref_thickness else "N/A",
            'Cu Inner': ref_cu_inner or "N/A",
            'Cu Outer': ref_cu_outer or "N/A",
            'Surface Finish': ref_surface_finish or "N/A",
            'Impedance': ref_impedance or "N/A",
            'Soldermask': ref_soldermask or "N/A",
            'Silkscreen': ref_silkscreen or "N/A",
            'Back Drill': ref_back_drill or "N/A",
            'Blind Via': ref_blind_via or "N/A",
            'Buried Via': ref_buried_via or "N/A"
        }

        # Update results table
        self.populate_filtered_results(
            customer_name, job_number, pcb_part_number, unit,
            length, width, input_area, ref_length, ref_width,
            ref_price_per_unit, price_per_sq_unit, per_unit_price,
            reference_specs, active_filters, len(matches)
        )

        print(f"SUCCESS: Final calculated price per unit: ₹{per_unit_price:.2f}")

    except Exception as e:
        print(f"CALCULATION ERROR: {e}")
        QMessageBox.critical(self, "Error", f"Calculation failed: {str(e)}")
