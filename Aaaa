package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/gin-contrib/sessions"
	"github.com/gin-contrib/sessions/cookie"
	"github.com/gin-gonic/gin"
	"github.com/xuri/excelize/v2"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// ============================================================================
// Database & Global Configuration
// ============================================================================

var db *gorm.DB

func initDB() {
	// UPDATE THIS STRING WITH YOUR POSTGRES CREDENTIALS
	dsn := "host=localhost user=postgres password=5842 dbname=sienna_ecad_tools_db port=5432 sslmode=disable TimeZone=Asia/Kolkata"

	var err error
	db, err = gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	// Auto Migrate the schema
	err = db.AutoMigrate(
		&User{},
		&Project{},
		&ProjectStage{},
		&ProjectMember{},
		&Task{},
		&ScheduleHistory{},
		&Notification{},
		&ActivityLog{},
		&StageDailyTask{},
		&DailyTaskRescheduleHistory{},
		&HoldDate{},
	)
	if err != nil {
		log.Fatal("Failed to migrate database:", err)
	}

	createDefaultAdmin()
}

// ============================================================================
// Database Models
// ============================================================================

type User struct {
	ID           uint      `gorm:"primaryKey" json:"id"`
	Username     string    `gorm:"unique;not null" json:"username"`
	Email        string    `gorm:"unique;not null" json:"email"`
	PasswordHash string    `gorm:"not null" json:"-"`
	Role         string    `gorm:"default:'employee'" json:"role"`
	CreatedAt    time.Time `gorm:"default:current_timestamp" json:"created_at"`
}

type Project struct {
	ID                      uint      `gorm:"primaryKey" json:"id"`
	Name                    string    `gorm:"not null" json:"name"`
	Description             string    `gorm:"type:text" json:"description"`
	Status                  string    `gorm:"default:'active'" json:"status"`
	StartDate               time.Time `gorm:"type:date" json:"start_date"`
	EndDate                 time.Time `gorm:"type:date" json:"end_date"`
	Progress                int       `gorm:"default:0" json:"progress"`
	CreatedBy               uint      `json:"created_by"`
	CreatedAt               time.Time `gorm:"default:current_timestamp" json:"created_at"`
	WorkingSaturdays        string    `gorm:"type:text;default:'[]'" json:"working_saturdays"` // Stored as JSON string
	CurrentRescheduleNumber int       `gorm:"default:0" json:"current_reschedule_number"`
}

type ProjectStage struct {
	ID           uint      `gorm:"primaryKey" json:"id"`
	ProjectID    uint      `gorm:"not null" json:"project_id"`
	Name         string    `gorm:"not null" json:"name"`
	Order        int       `gorm:"not null" json:"order"`
	DurationDays int       `gorm:"default:0" json:"duration_days"`
	Status       string    `gorm:"default:'pending'" json:"status"`
	Progress     int       `gorm:"default:0" json:"progress"`
	StartDate    time.Time `gorm:"type:date" json:"start_date"`
	EndDate      time.Time `gorm:"type:date" json:"end_date"`
	ManagerID    *uint     `json:"manager_id"`
}

type ProjectMember struct {
	ID        uint      `gorm:"primaryKey" json:"id"`
	ProjectID uint      `gorm:"not null" json:"project_id"`
	UserID    uint      `gorm:"not null" json:"user_id"`
	AddedAt   time.Time `gorm:"default:current_timestamp" json:"added_at"`
}

type Task struct {
	ID          uint       `gorm:"primaryKey" json:"id"`
	Title       string     `gorm:"not null" json:"title"`
	Description string     `gorm:"type:text" json:"description"`
	ProjectID   *uint      `json:"project_id"`
	AssignedTo  *uint      `json:"assigned_to"`
	Priority    string     `gorm:"default:'medium'" json:"priority"`
	Status      string     `gorm:"default:'pending'" json:"status"`
	Deadline    *time.Time `gorm:"type:date" json:"deadline"`
	CreatedAt   time.Time  `gorm:"default:current_timestamp" json:"created_at"`
	CompletedAt *time.Time `json:"completed_at"`
}

type ScheduleHistory struct {
	ID               uint      `gorm:"primaryKey" json:"id"`
	ProjectID        uint      `gorm:"not null" json:"project_id"`
	StageID          *uint     `json:"stage_id"`
	RescheduleNumber int       `gorm:"default:1" json:"reschedule_number"`
	OriginalDate     time.Time `gorm:"type:date" json:"original_date"`
	NewDate          time.Time `gorm:"type:date" json:"new_date"`
	Reason           string    `gorm:"type:text" json:"reason"`
	RescheduledBy    uint      `json:"rescheduled_by"`
	RescheduledAt    time.Time `gorm:"default:current_timestamp" json:"rescheduled_at"`
}

type Notification struct {
	ID        uint      `gorm:"primaryKey" json:"id"`
	UserID    uint      `gorm:"not null" json:"user_id"`
	Message   string    `gorm:"not null" json:"message"`
	IsRead    bool      `gorm:"default:false" json:"is_read"`
	CreatedAt time.Time `gorm:"default:current_timestamp" json:"created_at"`
}

type ActivityLog struct {
	ID        uint      `gorm:"primaryKey" json:"id"`
	UserID    uint      `gorm:"not null" json:"user_id"`
	Action    string    `gorm:"not null" json:"action"`
	Timestamp time.Time `gorm:"default:current_timestamp" json:"timestamp"`
}

type StageDailyTask struct {
	ID                 uint       `gorm:"primaryKey" json:"id"`
	StageID            uint       `gorm:"not null" json:"stage_id"`
	ProjectID          uint       `gorm:"not null" json:"project_id"`
	DayNumber          int        `gorm:"not null" json:"day_number"`
	ScheduledDate      time.Time  `gorm:"type:date;not null" json:"scheduled_date"`
	OriginalDate       *time.Time `gorm:"type:date" json:"original_date"`
	Status             string     `gorm:"default:'pending'" json:"status"`
	CompletedAt        *time.Time `json:"completed_at"`
	RescheduledReason  string     `gorm:"type:text" json:"rescheduled_reason"`
	RescheduleCount    int        `gorm:"default:0" json:"reschedule_count"`
	CreatedAt          time.Time  `gorm:"default:current_timestamp" json:"created_at"`
}

type DailyTaskRescheduleHistory struct {
	ID               uint      `gorm:"primaryKey" json:"id"`
	ProjectID        uint      `gorm:"not null" json:"project_id"`
	StageID          uint      `gorm:"not null" json:"stage_id"`
	TaskID           uint      `gorm:"not null" json:"task_id"`
	DayNumber        int       `gorm:"not null" json:"day_number"`
	RescheduleNumber int       `gorm:"default:1" json:"reschedule_number"`
	OriginalDate     time.Time `gorm:"type:date;not null" json:"original_date"`
	NewDate          time.Time `gorm:"type:date;not null" json:"new_date"`
	DaysShifted      int       `gorm:"not null" json:"days_shifted"`
	Reason           string    `gorm:"type:text" json:"reason"`
	RescheduledBy    uint      `json:"rescheduled_by"`
	RescheduledAt    time.Time `gorm:"default:current_timestamp" json:"rescheduled_at"`
}

type HoldDate struct {
	ID        uint      `gorm:"primaryKey" json:"id"`
	ProjectID uint      `gorm:"not null" json:"project_id"`
	StageID   uint      `gorm:"not null" json:"stage_id"`
	HoldDate  time.Time `gorm:"type:date;not null" json:"hold_date"`
	Reason    string    `gorm:"type:text" json:"reason"`
	CreatedBy uint      `json:"created_by"`
	CreatedAt time.Time `gorm:"default:current_timestamp" json:"created_at"`
}

// ============================================================================
// Configuration Constants
// ============================================================================

var DEFAULT_STAGES = []map[string]interface{}{
	{"name": "Foot prints - library - FP-LIB", "order": 1, "duration_days": 3},
	{"name": "Scrubbing - SCRB", "order": 2, "duration_days": 2},
	{"name": "Schematic - SCH", "order": 3, "duration_days": 7},
	{"name": "Length Matching - LM", "order": 4, "duration_days": 4},
	{"name": "Deliverables - DLBS", "order": 5, "duration_days": 3},
	{"name": "Placement - PLC", "order": 6, "duration_days": 5},
	{"name": "Placement - review - PLC-R", "order": 7, "duration_days": 3},
	{"name": "Routing - RTNG", "order": 8, "duration_days": 2},
	{"name": "Routing - Review - RTNG-R", "order": 9, "duration_days": 7},
	{"name": "Post Screen - P-SI", "order": 10, "duration_days": 4},
	{"name": "Fan out - FNT", "order": 11, "duration_days": 3},
	{"name": "Silk Screen - SLK", "order": 12, "duration_days": 5},
	{"name": "Approval - APRVL", "order": 13, "duration_days": 3},
	{"name": "Fab setup - FB-STP", "order": 14, "duration_days": 5},
}

// ============================================================================
// Helper Functions
// ============================================================================

func getCurrentUser(c *gin.Context) *User {
	session := sessions.Default(c)
	userID := session.Get("user_id")
	if userID == nil {
		return nil
	}
	var user User
	if err := db.First(&user, userID).Error; err != nil {
		return nil
	}
	return &user
}

func logActivity(userID uint, action string) {
	logEntry := ActivityLog{UserID: userID, Action: action, Timestamp: time.Now()}
	db.Create(&logEntry)
}

func createNotification(userID uint, message string) {
	notif := Notification{UserID: userID, Message: message, IsRead: false}
	db.Create(&notif)
}

// Auth Middleware
func AuthRequired() gin.HandlerFunc {
	return func(c *gin.Context) {
		session := sessions.Default(c)
		user := session.Get("user_id")
		if user == nil {
			// If it's an API call, return 401, otherwise redirect
			if strings.HasPrefix(c.Request.URL.Path, "/api/") {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
			} else {
				c.Redirect(http.StatusFound, "/login")
			}
			c.Abort()
			return
		}
		c.Next()
	}
}

// Date Logic Helpers
func isWorkingDay(date time.Time, includeSaturday bool, workingSaturdays map[string]bool) bool {
	weekday := date.Weekday()
	dateStr := date.Format("2006-01-02")

	if weekday == time.Sunday {
		return false
	}
	if weekday == time.Saturday {
		if _, exists := workingSaturdays[dateStr]; exists {
			return true
		}
		return false
	}
	return true
}

func addWorkingDays(startDate time.Time, days int, includeSaturday bool, workingSaturdays map[string]bool) time.Time {
	if days == 0 {
		return startDate
	}
	currentDate := startDate
	direction := 1
	if days < 0 {
		direction = -1
	}
	daysRemaining := abs(days)

	for daysRemaining > 0 {
		currentDate = currentDate.AddDate(0, 0, direction)
		if isWorkingDay(currentDate, includeSaturday, workingSaturdays) {
			daysRemaining--
		}
	}
	return currentDate
}

func getNextWorkingDay(date time.Time, includeSaturday bool, workingSaturdays map[string]bool) time.Time {
	checkDate := date
	for !isWorkingDay(checkDate, includeSaturday, workingSaturdays) {
		checkDate = checkDate.AddDate(0, 0, 1)
	}
	return checkDate
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// Struct for calculation stages
type StageCalculation struct {
	Name         string    `json:"name"`
	Order        int       `json:"order"`
	DurationDays int       `json:"duration_days"`
	StartDate    time.Time `json:"start_date"`
	EndDate      time.Time `json:"end_date"`
	ManagerID    *uint     `json:"manager_id"`
}

type StageInput struct {
	Name         string `json:"name"`
	Order        int    `json:"order"`
	DurationDays int    `json:"duration_days"`
	StartDate    string `json:"start_date"` // "YYYY-MM-DD"
	ManagerID    *uint  `json:"manager_id"`
}

func calculateStageDates(projectStartDate time.Time, stagesData []StageInput, includeSaturday bool, workingSaturdays map[string]bool) []StageCalculation {
	var calculatedStages []StageCalculation
	currentDate := getNextWorkingDay(projectStartDate, false, workingSaturdays)

	for _, stageInfo := range stagesData {
		var stageStartDate time.Time
		if stageInfo.StartDate != "" {
			parsedStart, _ := time.Parse("2006-01-02", stageInfo.StartDate)
			stageStartDate = getNextWorkingDay(parsedStart, false, workingSaturdays)
		} else {
			stageStartDate = currentDate
		}

		duration := stageInfo.DurationDays
		if duration == 0 {
			duration = 1
		}
		
		var stageEndDate time.Time
		if stageInfo.DurationDays > 0 {
			stageEndDate = addWorkingDays(stageStartDate, stageInfo.DurationDays-1, false, workingSaturdays)
		} else {
			stageEndDate = stageStartDate
		}

		calculatedStages = append(calculatedStages, StageCalculation{
			Name:         stageInfo.Name,
			Order:        stageInfo.Order,
			DurationDays: stageInfo.DurationDays,
			StartDate:    stageStartDate,
			EndDate:      stageEndDate,
			ManagerID:    stageInfo.ManagerID,
		})

		if stageInfo.StartDate == "" {
			currentDate = addWorkingDays(stageEndDate, 1, false, workingSaturdays)
		}
	}
	return calculatedStages
}

func generateDailyTasksForProject(projectID uint, workingSaturdays map[string]bool) error {
	var project Project
	if err := db.First(&project, projectID).Error; err != nil {
		return err
	}

	var stages []ProjectStage
	db.Where("project_id = ?", projectID).Order("\"order\" asc").Find(&stages)

	for _, stage := range stages {
		// Delete existing
		db.Where("stage_id = ?", stage.ID).Delete(&StageDailyTask{})

		if stage.StartDate.IsZero() || stage.EndDate.IsZero() {
			continue
		}

		currentDate := stage.StartDate
		dayNumber := 1

		for !currentDate.After(stage.EndDate) {
			if isWorkingDay(currentDate, false, workingSaturdays) {
				task := StageDailyTask{
					StageID:       stage.ID,
					ProjectID:     projectID,
					DayNumber:     dayNumber,
					ScheduledDate: currentDate,
					Status:        "pending",
				}
				db.Create(&task)
				dayNumber++
			}
			currentDate = currentDate.AddDate(0, 0, 1)
		}
	}
	return nil
}

func updateProjectProgress(projectID uint) {
	var stages []ProjectStage
	db.Where("project_id = ?", projectID).Find(&stages)

	if len(stages) == 0 {
		return
	}

	totalProgress := 0
	completedCount := 0
	inProgressCount := 0

	for _, s := range stages {
		totalProgress += s.Progress
		if s.Status == "completed" {
			completedCount++
		}
		if s.Status == "in-progress" {
			inProgressCount++
		}
	}

	avgProgress := totalProgress / len(stages)
	
	status := "active"
	if completedCount == len(stages) {
		status = "completed"
	} else if inProgressCount > 0 || completedCount > 0 {
		status = "active"
	}

	db.Model(&Project{}).Where("id = ?", projectID).Updates(map[string]interface{}{
		"progress": avgProgress,
		"status":   status,
	})
}

// ============================================================================
// Controllers / Handlers
// ============================================================================

func loginHandler(c *gin.Context) {
	if c.Request.Method == "GET" {
		c.HTML(http.StatusOK, "login.html", nil)
		return
	}

	var input struct {
		Username string `json:"username"`
		Password string `json:"password"`
	}
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"success": false, "message": "Invalid input"})
		return
	}

	var user User
	if err := db.Where("username = ?", input.Username).First(&user).Error; err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"success": false, "message": "Invalid credentials"})
		return
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(input.Password)); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"success": false, "message": "Invalid credentials"})
		return
	}

	session := sessions.Default(c)
	session.Set("user_id", user.ID)
	session.Set("username", user.Username)
	session.Save()

	c.JSON(http.StatusOK, gin.H{"success": true})
}

func logoutHandler(c *gin.Context) {
	session := sessions.Default(c)
	session.Clear()
	session.Save()
	c.Redirect(http.StatusFound, "/login")
}

func createProjectHandler(c *gin.Context) {
	var input struct {
		Name             string       `json:"name"`
		Description      string       `json:"description"`
		StartDate        string       `json:"start_date"` // YYYY-MM-DD
		IncludeSaturday  bool         `json:"include_saturday"`
		WorkingSaturdays []string     `json:"working_saturdays"`
		Stages           []StageInput `json:"stages"`
		Members          []uint       `json:"members"`
	}

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	user := getCurrentUser(c)
	
	// Parse Start Date
	projectStartDate := time.Now()
	if input.StartDate != "" {
		parsed, err := time.Parse("2006-01-02", input.StartDate)
		if err == nil {
			projectStartDate = parsed
		}
	}

	// Prepare Working Saturdays Set
	wsMap := make(map[string]bool)
	for _, d := range input.WorkingSaturdays {
		wsMap[d] = true
	}
	wsJSON, _ := json.Marshal(input.WorkingSaturdays)

	// Calculate Stages
	calcStages := calculateStageDates(projectStartDate, input.Stages, input.IncludeSaturday, wsMap)

	projectEndDate := projectStartDate
	if len(calcStages) > 0 {
		projectEndDate = calcStages[len(calcStages)-1].EndDate
	}

	// Transaction
	tx := db.Begin()

	project := Project{
		Name:             input.Name,
		Description:      input.Description,
		StartDate:        projectStartDate,
		EndDate:          projectEndDate,
		CreatedBy:        user.ID,
		WorkingSaturdays: string(wsJSON),
	}

	if err := tx.Create(&project).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	for _, cs := range calcStages {
		stage := ProjectStage{
			ProjectID:    project.ID,
			Name:         cs.Name,
			Order:        cs.Order,
			DurationDays: cs.DurationDays,
			StartDate:    cs.StartDate,
			EndDate:      cs.EndDate,
			ManagerID:    cs.ManagerID,
		}
		tx.Create(&stage)
	}

	for _, memberID := range input.Members {
		member := ProjectMember{ProjectID: project.ID, UserID: memberID}
		tx.Create(&member)
		// Notification would go here (need helper inside tx)
	}

	tx.Commit()

	// Generate Daily Tasks (post commit)
	generateDailyTasksForProject(project.ID, wsMap)
	logActivity(user.ID, fmt.Sprintf("Created job: %s", project.Name))

	c.JSON(http.StatusCreated, gin.H{"success": true, "id": project.ID})
}

func getProjectDetailsHandler(c *gin.Context) {
	idStr := c.Param("project_id")
	pid, _ := strconv.Atoi(idStr)
	projectID := uint(pid)

	var project Project
	if err := db.First(&project, projectID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Project not found"})
		return
	}

	var stages []ProjectStage
	db.Where("project_id = ?", projectID).Order("\"order\" asc").Find(&stages)

	var tasks []Task
	db.Where("project_id = ?", projectID).Find(&tasks)

	var members []ProjectMember
	db.Where("project_id = ?", projectID).Find(&members)

	var history []ScheduleHistory
	db.Where("project_id = ?", projectID).Order("rescheduled_at desc").Find(&history)

	// Parse JSON
	var wsList []string
	json.Unmarshal([]byte(project.WorkingSaturdays), &wsList)

	// Build Response
	memberList := []gin.H{}
	for _, m := range members {
		var u User
		db.First(&u, m.UserID)
		memberList = append(memberList, gin.H{
			"id": u.ID, "username": u.Username, "email": u.Email,
		})
	}

	// Task Stats
	taskStats := map[string]int{"pending": 0, "in-progress": 0, "completed": 0}
	for _, t := range tasks {
		taskStats[t.Status]++
	}

	// Stage Completion
	completedStages := 0
	for _, s := range stages {
		if s.Status == "completed" {
			completedStages++
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"id":                  project.ID,
		"name":                project.Name,
		"description":         project.Description,
		"status":              project.Status,
		"progress":            project.Progress,
		"start_date":          project.StartDate.Format("2006-01-02"),
		"end_date":            project.EndDate.Format("2006-01-02"),
		"saturdayWorkingDays": wsList,
		"stages":              stages,
		"members":             memberList,
		"task_stats":          taskStats,
		"stage_completion": gin.H{
			"completed": completedStages,
			"total":     len(stages),
		},
		"schedule_history": history,
	})
}

func rescheduleStageHandler(c *gin.Context) {
	idStr := c.Param("project_id")
	pid, _ := strconv.Atoi(idStr)
	projectID := uint(pid)

	var input struct {
		StageID          uint     `json:"stage_id"`
		Days             int      `json:"days"`
		Reason           string   `json:"reason"`
		WorkingSaturdays []string `json:"working_saturdays"`
	}
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	user := getCurrentUser(c)

	var project Project
	if err := db.First(&project, projectID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Project not found"})
		return
	}

	var stage ProjectStage
	if err := db.First(&stage, input.StageID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Stage not found"})
		return
	}

	// Logic
	project.CurrentRescheduleNumber++
	globalResNum := project.CurrentRescheduleNumber

	wsMap := make(map[string]bool)
	for _, d := range input.WorkingSaturdays {
		wsMap[d] = true
	}

	originalStart := stage.StartDate
	originalEnd := stage.EndDate

	// Calculate HOLD dates
	if input.Days != 0 && !originalStart.IsZero() && !originalEnd.IsZero() {
		// Collect original working dates
		origDates := make(map[string]bool)
		curr := originalStart
		for !curr.After(originalEnd) {
			if isWorkingDay(curr, false, wsMap) {
				origDates[curr.Format("2006-01-02")] = true
			}
			curr = curr.AddDate(0, 0, 1)
		}

		newStart := addWorkingDays(originalStart, input.Days, false, wsMap)
		newEnd := addWorkingDays(originalEnd, input.Days, false, wsMap)

		// Collect new working dates
		newDates := make(map[string]bool)
		curr = newStart
		for !curr.After(newEnd) {
			if isWorkingDay(curr, false, wsMap) {
				newDates[curr.Format("2006-01-02")] = true
			}
			curr = curr.AddDate(0, 0, 1)
		}

		// Find diff -> Hold Dates
		for dStr := range origDates {
			if !newDates[dStr] {
				hDate, _ := time.Parse("2006-01-02", dStr)
				db.Create(&HoldDate{
					ProjectID: projectID,
					StageID:   stage.ID,
					HoldDate:  hDate,
					Reason:    input.Reason,
					CreatedBy: user.ID,
				})
			}
		}

		// Update Stage Dates
		stage.StartDate = newStart
		stage.EndDate = newEnd
		db.Save(&stage)

		// Update Subsequent Stages
		var subsequentStages []ProjectStage
		db.Where("project_id = ? AND \"order\" > ? AND status != 'completed'", projectID, stage.Order).Order("\"order\" asc").Find(&subsequentStages)

		for _, sub := range subsequentStages {
			if !sub.StartDate.IsZero() {
				sub.StartDate = addWorkingDays(sub.StartDate, input.Days, false, wsMap)
			}
			if !sub.EndDate.IsZero() {
				sub.EndDate = addWorkingDays(sub.EndDate, input.Days, false, wsMap)
			}
			db.Save(&sub)
		}
	}

	// Create History
	history := ScheduleHistory{
		ProjectID:        projectID,
		StageID:          &stage.ID,
		RescheduleNumber: globalResNum,
		OriginalDate:     originalStart,
		NewDate:          stage.StartDate,
		Reason:           input.Reason,
		RescheduledBy:    user.ID,
	}
	db.Create(&history)

	// Update Project Metadata
	var allStages []ProjectStage
	db.Where("project_id = ?", projectID).Find(&allStages)
	maxEnd := time.Time{}
	for _, s := range allStages {
		if s.EndDate.After(maxEnd) {
			maxEnd = s.EndDate
		}
	}
	wsJSON, _ := json.Marshal(input.WorkingSaturdays)
	project.EndDate = maxEnd
	project.WorkingSaturdays = string(wsJSON)
	db.Save(&project)

	// Regenerate Daily Tasks
	generateDailyTasksForProject(projectID, wsMap)

	logActivity(user.ID, fmt.Sprintf("Rescheduled stage '%s' (Global #%d)", stage.Name, globalResNum))

	c.JSON(http.StatusOK, gin.H{
		"success":           true,
		"reschedule_number": globalResNum,
		"new_start":         stage.StartDate.Format("2006-01-02"),
		"new_end":           stage.EndDate.Format("2006-01-02"),
	})
}

func rescheduleDailyTaskHandler(c *gin.Context) {
	// Parse params
	pid, _ := strconv.Atoi(c.Param("project_id"))
	sid, _ := strconv.Atoi(c.Param("stage_id"))
	tid, _ := strconv.Atoi(c.Param("task_id"))
	projectID, stageID, taskID := uint(pid), uint(sid), uint(tid)

	var input struct {
		Days             int      `json:"days"`
		Reason           string   `json:"reason"`
		WorkingSaturdays []string `json:"working_saturdays"`
	}
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	user := getCurrentUser(c)
	
	var task StageDailyTask
	if err := db.First(&task, taskID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Task not found"})
		return
	}
	
	if task.Status == "completed" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot reschedule completed task"})
		return
	}

	var project Project
	db.First(&project, projectID)
	project.CurrentRescheduleNumber++
	globalResNum := project.CurrentRescheduleNumber
	db.Save(&project)

	task.RescheduleCount++
	
	originalDate := task.ScheduledDate
	if task.OriginalDate != nil {
		originalDate = *task.OriginalDate
	}
	
	if task.OriginalDate == nil {
		cp := task.ScheduledDate
		task.OriginalDate = &cp
	}

	wsMap := make(map[string]bool)
	for _, d := range input.WorkingSaturdays {
		wsMap[d] = true
	}

	newDate := addWorkingDays(task.ScheduledDate, input.Days, false, wsMap)
	task.ScheduledDate = newDate
	task.Status = "rescheduled"
	task.RescheduledReason = input.Reason
	db.Save(&task)

	// Create Histories
	taskHist := DailyTaskRescheduleHistory{
		ProjectID: projectID, StageID: stageID, TaskID: taskID,
		DayNumber: task.DayNumber, RescheduleNumber: globalResNum,
		OriginalDate: originalDate, NewDate: newDate,
		DaysShifted: abs(input.Days), Reason: input.Reason,
		RescheduledBy: user.ID,
	}
	db.Create(&taskHist)

	// Also stage history for excel compatibility
	var stage ProjectStage
	db.First(&stage, stageID)
	stageHist := ScheduleHistory{
		ProjectID: projectID, StageID: &stageID, RescheduleNumber: globalResNum,
		OriginalDate: stage.StartDate, NewDate: newDate, 
		Reason: fmt.Sprintf("Daily task reschedule: Day %d", task.DayNumber),
		RescheduledBy: user.ID,
	}
	db.Create(&stageHist)

	// Update Subsequent
	var nextTasks []StageDailyTask
	db.Where("stage_id = ? AND day_number > ? AND status != 'completed'", stageID, task.DayNumber).Find(&nextTasks)
	for _, nt := range nextTasks {
		nt.RescheduleCount++
		ntOrig := nt.ScheduledDate
		if nt.OriginalDate != nil {
			ntOrig = *nt.OriginalDate
		} else {
			cp := nt.ScheduledDate
			nt.OriginalDate = &cp
		}

		newNextDate := addWorkingDays(nt.ScheduledDate, input.Days, false, wsMap)
		nt.ScheduledDate = newNextDate
		nt.Status = "rescheduled"
		if nt.RescheduledReason == "" {
			nt.RescheduledReason = fmt.Sprintf("Auto-shifted due to Day %d", task.DayNumber)
		}
		db.Save(&nt)

		db.Create(&DailyTaskRescheduleHistory{
			ProjectID: projectID, StageID: stageID, TaskID: nt.ID,
			DayNumber: nt.DayNumber, RescheduleNumber: globalResNum,
			OriginalDate: ntOrig, NewDate: newNextDate,
			DaysShifted: abs(input.Days), Reason: "Auto-reschedule",
			RescheduledBy: user.ID,
		})
	}

	// Update Stage Range
	var allTasks []StageDailyTask
	db.Where("stage_id = ?", stageID).Order("scheduled_date asc").Find(&allTasks)
	if len(allTasks) > 0 {
		stage.StartDate = allTasks[0].ScheduledDate
		stage.EndDate = allTasks[len(allTasks)-1].ScheduledDate
		db.Save(&stage)
	}

	c.JSON(http.StatusOK, gin.H{"success": true, "new_date": newDate})
}

func exportExcelHandler(c *gin.Context) {
	pid, _ := strconv.Atoi(c.Param("project_id"))
	projectID := uint(pid)

	var project Project
	if err := db.First(&project, projectID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Project not found"})
		return
	}

	var stages []ProjectStage
	db.Where("project_id = ?", projectID).Order("\"order\" asc").Find(&stages)

	// Parse Saturdays
	wsMap := make(map[string]bool)
	var wsList []string
	if err := json.Unmarshal([]byte(project.WorkingSaturdays), &wsList); err == nil {
		for _, s := range wsList {
			wsMap[s] = true
		}
	}

	// 1. Prepare Reschedule Map
	// Map: row (1-4) -> date string -> list of stage abbrs
	rescheduleMap := make(map[int]map[string][]string)
	for i := 1; i <= 4; i++ {
		rescheduleMap[i] = make(map[string][]string)
	}

	for _, stage := range stages {
		parts := strings.Split(stage.Name, "-")
		abbr := stage.Name
		if len(parts) > 1 {
			abbr = strings.TrimSpace(parts[len(parts)-1])
		} else if len(stage.Name) > 6 {
			abbr = stage.Name[:6]
		}

		var histories []DailyTaskRescheduleHistory
		db.Where("project_id = ? AND stage_id = ?", projectID, stage.ID).Find(&histories)
		
		uniqueNums := make(map[int]bool)
		for _, h := range histories {
			uniqueNums[h.RescheduleNumber] = true
		}
		var sortedNums []int
		for k := range uniqueNums {
			sortedNums = append(sortedNums, k)
		}
		sort.Ints(sortedNums)

		for idx, rNum := range sortedNums {
			targetRow := idx + 1
			if targetRow > 4 {
				continue
			}
			for _, h := range histories {
				if h.RescheduleNumber == rNum {
					dStr := h.NewDate.Format("2006-01-02")
					if _, exists := rescheduleMap[targetRow][dStr]; !exists {
						rescheduleMap[targetRow][dStr] = []string{}
					}
					// check duplicate
					exists := false
					for _, v := range rescheduleMap[targetRow][dStr] {
						if v == abbr { exists = true; break }
					}
					if !exists {
						rescheduleMap[targetRow][dStr] = append(rescheduleMap[targetRow][dStr], abbr)
					}
				}
			}
		}
	}

	// 2. Setup Excel
	f := excelize.NewFile()
	sheetName := "Schedule_Tracker"
	f.SetSheetName("Sheet1", sheetName)

	// Styles
	styleOrangeHeader, _ := f.NewStyle(&excelize.Style{Fill: excelize.Fill{Type: "pattern", Color: []string{"#FFA500"}, Pattern: 1}, Font: &excelize.Font{Bold: true}})
	styleGrayHeader, _ := f.NewStyle(&excelize.Style{Fill: excelize.Fill{Type: "pattern", Color: []string{"#C0C0C0"}, Pattern: 1}})
	styleLightBlue, _ := f.NewStyle(&excelize.Style{Fill: excelize.Fill{Type: "pattern", Color: []string{"#B4C7E7"}, Pattern: 1}, Font: &excelize.Font{Bold: true}})
	styleYellow, _ := f.NewStyle(&excelize.Style{Fill: excelize.Fill{Type: "pattern", Color: []string{"#FFFF00"}, Pattern: 1}})
	styleGreen, _ := f.NewStyle(&excelize.Style{Fill: excelize.Fill{Type: "pattern", Color: []string{"#00FF00"}, Pattern: 1}})
	styleCyan, _ := f.NewStyle(&excelize.Style{Fill: excelize.Fill{Type: "pattern", Color: []string{"#00FFFF"}, Pattern: 1}})
	styleOrange, _ := f.NewStyle(&excelize.Style{Fill: excelize.Fill{Type: "pattern", Color: []string{"#FFA500"}, Pattern: 1}})
	styleBorder, _ := f.NewStyle(&excelize.Style{Border: []excelize.Border{{Type: "left", Color: "000000", Style: 1}, {Type: "top", Color: "000000", Style: 1}, {Type: "bottom", Color: "000000", Style: 1}, {Type: "right", Color: "000000", Style: 1}}})
	
	// Timeline
	allDates := []time.Time{}
	curr := project.StartDate
	for !curr.After(project.EndDate) {
		allDates = append(allDates, curr)
		curr = curr.AddDate(0, 0, 1)
	}

	currentRow := 1

	// Stage Legend Table
	stageList := []string{}
	for _, s := range stages {
		parts := strings.Split(s.Name, "-")
		if len(parts) >= 2 {
			cat := strings.TrimSpace(strings.Join(parts[:len(parts)-1], "-"))
			abbr := strings.TrimSpace(parts[len(parts)-1])
			stageList = append(stageList, fmt.Sprintf("%s -%s", cat, abbr))
		} else {
			stageList = append(stageList, s.Name)
		}
	}

	colIdx := 0
	tableRow := currentRow
	for _, txt := range stageList {
		colName, _ := excelize.ColumnNumberToName(colIdx + 1)
		cell := fmt.Sprintf("%s%d", colName, tableRow)
		f.SetCellValue(sheetName, cell, txt)
		f.SetCellStyle(sheetName, cell, cell, styleBorder)
		colIdx++
		if colIdx >= 5 {
			colIdx = 0
			tableRow++
		}
	}
	if colIdx > 0 {
		tableRow++
	}
	currentRow = tableRow + 2

	// Headers
	// Month-Year
	startColName, _ := excelize.ColumnNumberToName(3)
	endColName, _ := excelize.ColumnNumberToName(len(allDates) + 2)
	f.MergeCell(sheetName, fmt.Sprintf("%s%d", startColName, currentRow), fmt.Sprintf("%s%d", endColName, currentRow))
	f.SetCellValue(sheetName, fmt.Sprintf("C%d", currentRow), allDates[0].Format("Jan-06"))
	f.SetCellStyle(sheetName, fmt.Sprintf("C%d", currentRow), fmt.Sprintf("C%d", currentRow), styleOrangeHeader)
	f.SetCellStyle(sheetName, fmt.Sprintf("B%d", currentRow), fmt.Sprintf("B%d", currentRow), styleGrayHeader)
	headerRow1 := currentRow
	currentRow++

	// Days
	f.SetCellStyle(sheetName, fmt.Sprintf("B%d", currentRow), fmt.Sprintf("B%d", currentRow), styleGrayHeader)
	for i, d := range allDates {
		colName, _ := excelize.ColumnNumberToName(i + 3)
		cell := fmt.Sprintf("%s%d", colName, currentRow)
		f.SetCellValue(sheetName, cell, d.Day())
		f.SetCellStyle(sheetName, cell, cell, styleLightBlue)
		f.SetCellStyle(sheetName, cell, cell, styleBorder)
	}
	headerRow2 := currentRow
	currentRow++

	// Merge Left Headers
	f.MergeCell(sheetName, fmt.Sprintf("A%d", headerRow1), fmt.Sprintf("A%d", headerRow2))
	f.SetCellValue(sheetName, fmt.Sprintf("A%d", headerRow1), project.Name)
	f.SetCellStyle(sheetName, fmt.Sprintf("A%d", headerRow1), fmt.Sprintf("A%d", headerRow1), styleLightBlue)
	
	f.MergeCell(sheetName, fmt.Sprintf("B%d", headerRow1), fmt.Sprintf("B%d", headerRow2))
	f.SetCellValue(sheetName, fmt.Sprintf("B%d", headerRow1), "Date")
	f.SetCellStyle(sheetName, fmt.Sprintf("B%d", headerRow1), fmt.Sprintf("B%d", headerRow1), styleLightBlue)

	// PLANNED
	f.SetCellValue(sheetName, fmt.Sprintf("B%d", currentRow), "Planned")
	f.SetCellStyle(sheetName, fmt.Sprintf("B%d", currentRow), fmt.Sprintf("B%d", currentRow), styleBorder)

	plannedMap := make(map[string][]string)
	for _, s := range stages {
		if !s.StartDate.IsZero() && !s.EndDate.IsZero() {
			parts := strings.Split(s.Name, "-")
			abbr := strings.TrimSpace(parts[len(parts)-1])
			d := s.StartDate
			for !d.After(s.EndDate) {
				if isWorkingDay(d, false, wsMap) {
					ds := d.Format("2006-01-02")
					plannedMap[ds] = append(plannedMap[ds], abbr)
				}
				d = d.AddDate(0, 0, 1)
			}
		}
	}

	for i, d := range allDates {
		ds := d.Format("2006-01-02")
		colName, _ := excelize.ColumnNumberToName(i + 3)
		cell := fmt.Sprintf("%s%d", colName, currentRow)
		
		if vals, ok := plannedMap[ds]; ok {
			uniqueVals := removeDuplicateStrings(vals)
			f.SetCellValue(sheetName, cell, strings.Join(uniqueVals, ","))
		}
		f.SetCellStyle(sheetName, cell, cell, styleBorder)
		
		isSun := d.Weekday() == time.Sunday
		isNonWorkSat := d.Weekday() == time.Saturday && !wsMap[ds]
		if isSun || isNonWorkSat {
			f.SetCellStyle(sheetName, cell, cell, styleYellow)
		}
	}
	currentRow++

	// RESCHEDULES 1-4
	for r := 1; r <= 4; r++ {
		f.SetCellValue(sheetName, fmt.Sprintf("B%d", currentRow), fmt.Sprintf("Reschedule -%d", r))
		f.SetCellStyle(sheetName, fmt.Sprintf("B%d", currentRow), fmt.Sprintf("B%d", currentRow), styleBorder)
		
		rData := rescheduleMap[r]
		for i, d := range allDates {
			ds := d.Format("2006-01-02")
			colName, _ := excelize.ColumnNumberToName(i + 3)
			cell := fmt.Sprintf("%s%d", colName, currentRow)

			if vals, ok := rData[ds]; ok {
				uniqueVals := removeDuplicateStrings(vals)
				f.SetCellValue(sheetName, cell, strings.Join(uniqueVals, ","))
			}
			f.SetCellStyle(sheetName, cell, cell, styleBorder)
			
			isSun := d.Weekday() == time.Sunday
			isNonWorkSat := d.Weekday() == time.Saturday && !wsMap[ds]
			if isSun || isNonWorkSat {
				f.SetCellStyle(sheetName, cell, cell, styleYellow)
			}
		}
		currentRow++
	}

	// ACTUAL
	f.SetCellValue(sheetName, fmt.Sprintf("B%d", currentRow), "Actual")
	f.SetCellStyle(sheetName, fmt.Sprintf("B%d", currentRow), fmt.Sprintf("B%d", currentRow), styleGrayHeader)

	// Build Actual Maps
	actualMap := make(map[string][]struct{abbr string; status string})
	holdMap := make(map[string][]string)

	for _, s := range stages {
		parts := strings.Split(s.Name, "-")
		abbr := strings.TrimSpace(parts[len(parts)-1])
		
		var sTasks []StageDailyTask
		db.Where("stage_id = ?", s.ID).Find(&sTasks)
		for _, t := range sTasks {
			ds := t.ScheduledDate.Format("2006-01-02")
			actualMap[ds] = append(actualMap[ds], struct{abbr string; status string}{abbr, t.Status})

			if t.OriginalDate != nil && !t.OriginalDate.Equal(t.ScheduledDate) {
				hds := t.OriginalDate.Format("2006-01-02")
				holdMap[hds] = append(holdMap[hds], abbr)
			}
		}
	}

	for i, d := range allDates {
		ds := d.Format("2006-01-02")
		colName, _ := excelize.ColumnNumberToName(i + 3)
		cell := fmt.Sprintf("%s%d", colName, currentRow)
		f.SetCellStyle(sheetName, cell, cell, styleBorder)

		activeItems := actualMap[ds]
		activeAbbrs := make(map[string]bool)
		for _, item := range activeItems { activeAbbrs[item.abbr] = true }

		holds := holdMap[ds]
		realHolds := []string{}
		for _, h := range holds {
			if !activeAbbrs[h] {
				realHolds = append(realHolds, h)
			}
		}

		parts := []string{}
		if len(realHolds) > 0 {
			parts = append(parts, fmt.Sprintf("%s=HOLD", strings.Join(removeDuplicateStrings(realHolds), ",")))
		}
		if len(activeItems) > 0 {
			sl := []string{}
			for k := range activeAbbrs { sl = append(sl, k) }
			parts = append(parts, strings.Join(sl, ","))
		}
		f.SetCellValue(sheetName, cell, strings.Join(parts, ","))

		// Coloring
		isSun := d.Weekday() == time.Sunday
		isNonWorkSat := d.Weekday() == time.Saturday && !wsMap[ds]

		if isSun || isNonWorkSat {
			f.SetCellStyle(sheetName, cell, cell, styleYellow)
		} else if len(realHolds) > 0 {
			f.SetCellStyle(sheetName, cell, cell, styleOrange)
		} else if len(activeItems) > 0 {
			hasCompleted := false
			hasRescheduled := false
			for _, item := range activeItems {
				if item.status == "completed" { hasCompleted = true }
				if item.status == "rescheduled" { hasRescheduled = true }
			}
			if hasCompleted {
				f.SetCellStyle(sheetName, cell, cell, styleGreen)
			} else if hasRescheduled {
				f.SetCellStyle(sheetName, cell, cell, styleCyan)
			}
		}
	}
	currentRow++

	// REMARKS
	f.SetCellValue(sheetName, fmt.Sprintf("B%d", currentRow), "Remarks")
	f.SetCellStyle(sheetName, fmt.Sprintf("B%d", currentRow), fmt.Sprintf("B%d", currentRow), styleBorder)
	
	for i, d := range allDates {
		ds := d.Format("2006-01-02")
		colName, _ := excelize.ColumnNumberToName(i + 3)
		cell := fmt.Sprintf("%s%d", colName, currentRow)
		f.SetCellStyle(sheetName, cell, cell, styleBorder)

		// Check for hold to add remark
		activeItems := actualMap[ds]
		activeAbbrs := make(map[string]bool)
		for _, item := range activeItems { activeAbbrs[item.abbr] = true }
		holds := holdMap[ds]
		realHolds := []string{}
		for _, h := range holds {
			if !activeAbbrs[h] { realHolds = append(realHolds, h) }
		}

		if len(realHolds) > 0 {
			// Find reason
			reason := "Waiting for issue tracker"
			// Logic to find specific task reason is complex in loop, simplifying:
			f.SetCellValue(sheetName, cell, reason)
		}

		isSun := d.Weekday() == time.Sunday
		isNonWorkSat := d.Weekday() == time.Saturday && !wsMap[ds]
		if isSun || isNonWorkSat {
			f.SetCellStyle(sheetName, cell, cell, styleYellow)
		}
	}

	// Buffer output
	buf, _ := f.WriteToBuffer()
	c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s_Tracker.xlsx", project.Name))
	c.Data(http.StatusOK, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", buf.Bytes())
}

func removeDuplicateStrings(strSlice []string) []string {
	allKeys := make(map[string]bool)
	list := []string{}
	for _, item := range strSlice {
		if _, value := allKeys[item]; !value {
			allKeys[item] = true
			list = append(list, item)
		}
	}
	sort.Strings(list)
	return list
}

// ============================================================================
// Main Application Setup
// ============================================================================

func createDefaultAdmin() {
	var user User
	err := db.Where("username = ?", "admin").First(&user).Error
	if err == gorm.ErrRecordNotFound {
		hash, _ := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
		admin := User{
			Username:     "admin",
			Email:        "admin@example.com",
			PasswordHash: string(hash),
			Role:         "admin",
		}
		db.Create(&admin)
		log.Println("Default admin user created")
	}
}

func main() {
	initDB()

	r := gin.Default()

	// Session Middleware
	store := cookie.NewStore([]byte("secret123")) // Replace with secure key
	r.Use(sessions.Sessions("mysession", store))

	// Load HTML Templates (Assuming you have a 'templates' folder like Flask)
	// You need to copy your .html files to a folder named "templates"
	r.LoadHTMLGlob("templates/*")
	
	// Routes
	r.GET("/", AuthRequired(), func(c *gin.Context) {
		c.Redirect(http.StatusFound, "/dashboard")
	})

	r.GET("/login", loginHandler)
	r.POST("/login", loginHandler)
	r.GET("/logout", logoutHandler)

	r.GET("/dashboard", AuthRequired(), func(c *gin.Context) {
		user := getCurrentUser(c)
		c.HTML(http.StatusOK, "index.html", gin.H{"current_user": user})
	})
	
	r.GET("/stage_popup.html", func(c *gin.Context) {
		c.HTML(http.StatusOK, "stage_popup.html", nil)
	})

	// API Group
	api := r.Group("/api")
	api.Use(AuthRequired())
	{
		api.GET("/default-stages", func(c *gin.Context) {
			c.JSON(http.StatusOK, DEFAULT_STAGES)
		})

		api.GET("/stats", func(c *gin.Context) {
			var totalP, activeP, totalT, compT, totalE int64
			db.Model(&Project{}).Count(&totalP)
			db.Model(&Project{}).Where("status = ?", "active").Count(&activeP)
			db.Model(&Task{}).Count(&totalT)
			db.Model(&Task{}).Where("status = ?", "completed").Count(&compT)
			db.Model(&User{}).Where("role = ?", "employee").Count(&totalE)
			c.JSON(http.StatusOK, gin.H{
				"total_projects": totalP, "active_projects": activeP,
				"total_tasks": totalT, "completed_tasks": compT,
				"total_employees": totalE,
			})
		})

		api.GET("/projects", func(c *gin.Context) {
			var projects []Project
			db.Order("created_at desc").Find(&projects)
			c.JSON(http.StatusOK, projects)
		})
		api.POST("/projects", createProjectHandler)
		api.GET("/projects/:project_id/details", getProjectDetailsHandler)
		api.POST("/projects/:project_id/reschedule", rescheduleStageHandler)
		
		api.DELETE("/projects/:project_id", func(c *gin.Context) {
			pid := c.Param("project_id")
			// Cascade Delete logic usually handled by DB FKs, but explicit here:
			db.Where("project_id = ?", pid).Delete(&ProjectStage{})
			db.Where("project_id = ?", pid).Delete(&ProjectMember{})
			db.Where("project_id = ?", pid).Delete(&Task{})
			db.Where("project_id = ?", pid).Delete(&ScheduleHistory{})
			db.Where("id = ?", pid).Delete(&Project{})
			c.JSON(http.StatusOK, gin.H{"success": true})
		})

		api.GET("/projects/:project_id/stages/:stage_id/daily-tasks", func(c *gin.Context) {
			pid := c.Param("project_id")
			sid := c.Param("stage_id")
			var tasks []StageDailyTask
			db.Where("project_id = ? AND stage_id = ?", pid, sid).Order("day_number asc").Find(&tasks)
			c.JSON(http.StatusOK, tasks)
		})

		api.PUT("/projects/:project_id/stages/:stage_id/daily-tasks/:task_id/complete", func(c *gin.Context) {
			tid := c.Param("task_id")
			now := time.Now()
			db.Model(&StageDailyTask{}).Where("id = ?", tid).Updates(map[string]interface{}{
				"status": "completed",
				"completed_at": now,
			})
			c.JSON(http.StatusOK, gin.H{"success": true})
		})

		api.POST("/projects/:project_id/stages/:stage_id/daily-tasks/:task_id/reschedule", rescheduleDailyTaskHandler)
		
		api.GET("/projects/:project_id/export-excel", exportExcelHandler)

		// Basic Task Routes (Kanban/List)
		api.GET("/tasks", func(c *gin.Context) {
			var tasks []Task
			db.Order("created_at desc").Find(&tasks)
			c.JSON(http.StatusOK, tasks)
		})
		api.POST("/tasks", func(c *gin.Context) {
			var t Task
			if err := c.ShouldBindJSON(&t); err != nil {
				c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
				return
			}
			db.Create(&t)
			c.JSON(http.StatusCreated, gin.H{"success": true, "id": t.ID})
		})
		
		api.GET("/employees", func(c *gin.Context) {
			var users []User
			db.Find(&users)
			c.JSON(http.StatusOK, users)
		})
		
		api.GET("/activity-logs", func(c *gin.Context) {
			var logs []ActivityLog
			db.Order("timestamp desc").Limit(10).Find(&logs)
			// Join with user name manually or via preload
			result := []gin.H{}
			for _, l := range logs {
				var u User
				db.First(&u, l.UserID)
				result = append(result, gin.H{
					"user": u.Username, "action": l.Action, "timestamp": l.Timestamp.Format("2006-01-02 15:04"),
				})
			}
			c.JSON(http.StatusOK, result)
		})
	}

	r.Run(":5000")
}
