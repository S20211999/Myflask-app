          except (ValueError, TypeError):
                painter.drawRoundedRect(QRectF(x-0.5, y-0.5, 1, 1), 0.5, 0.5)

        elif pad_type == 'rounded_rectangle':
            try:
                length = float(pad.get('length', 1)) + 2*expansion
                width = float(pad.get('width', 1)) + 2*expansion
                radius = float(pad.get('corner_radius', 0.2))
                painter.drawRoundedRect(QRectF(x-length/2, y-width/2, length, width), radius, radius)
            except (ValueError, TypeError):
                painter.drawRoundedRect(QRectF(x-0.5, y-0.5, 1, 1), 0.2, 0.2)

        elif pad_type == 'round':
            try:
                diameter = float(pad.get('diameter', 1)) + 2*expansion
                painter.drawEllipse(QRectF(x-diameter/2, y-diameter/2, diameter, diameter))
            except (ValueError, TypeError):
                painter.drawEllipse(QRectF(x-0.5, y-0.5, 1, 1))

        elif pad_type == 'D-shape':
            # D-shape is rounded rectangle with one side corner radius
            try:
                length = float(pad.get('length', 1)) + 2*expansion
                width = float(pad.get('width', 1)) + 2*expansion
                corner_radius = float(pad.get('corner_radius', 0.2))
                rotation = float(pad.get('rotation', 0)) if pad.get('rotation') else 0
            except (ValueError, TypeError):
                length, width, corner_radius, rotation = 1, 1, 0.2, 0

            painter.save()
            if rotation != 0:
                painter.translate(x, y)
                painter.rotate(rotation)
                painter.translate(-x, -y)

            # Create D-shape path (rounded rectangle with rounded corners on one side)
            path = QPainterPath()
            half_length = length / 2
            half_width = width / 2
            r = corner_radius

            # Start from left-top corner
            path.moveTo(x - half_length, y - half_width)
            # Top line to rounded corner
            path.lineTo(x + half_length - r, y - half_width)
            # Top-right rounded corner
            path.quadTo(x + half_length, y - half_width, x + half_length, y - half_width + r)
            # Right side line
            path.lineTo(x + half_length, y + half_width - r)
            # Bottom-right rounded corner
            path.quadTo(x + half_length, y + half_width, x + half_length - r, y + half_width)
            # Bottom line
            path.lineTo(x - half_length, y + half_width)
            # Close path (left side straight)
            path.closeSubpath()

            painter.drawPath(path)
            painter.restore()

        elif pad_type in ['PTH', 'NPTH']:
            if expansion == 0: # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                try:
                    hole_diameter = float(pad.get('hole_diameter', 0.8))
                except (ValueError, TypeError):
                    hole_diameter = 0.8
                    
                # Draw hole (black circle)
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                painter.drawEllipse(QRectF(x-hole_diameter/2, y-hole_diameter/2, hole_diameter, hole_diameter))

                # Draw pad for PTH only
                if pad_type == 'PTH':
                    painter.setPen(QPen(QColor("#FF0000"), 2/self.zoom_factor)) # Red for copper
                    painter.setBrush(QBrush()) # No fill for pad outline
                    try:
                        pad_diameter = float(pad.get('pad_diameter', 1.2))
                    except (ValueError, TypeError):
                        pad_diameter = 1.2
                    painter.drawEllipse(QRectF(x-pad_diameter/2, y-pad_diameter/2, pad_diameter, pad_diameter))

                # Restore original pen
                painter.setPen(saved_pen)
            else: # Drawing mask/paste expansion - PRESERVE CALLER'S PEN COLOR
                if pad_type == 'PTH':
                    try:
                        pad_diameter = float(pad.get('pad_diameter', 1.2)) + 2*expansion
                        painter.drawEllipse(QRectF(x-pad_diameter/2, y-pad_diameter/2, pad_diameter, pad_diameter))
                    except (ValueError, TypeError):
                        painter.drawEllipse(QRectF(x-0.6, y-0.6, 1.2, 1.2))
                else: # NPTH
                    try:
                        hole_diameter = float(pad.get('hole_diameter', 0.8)) + 2*expansion
                        painter.drawEllipse(QRectF(x-hole_diameter/2, y-hole_diameter/2, hole_diameter, hole_diameter))
                    except (ValueError, TypeError):
                        painter.drawEllipse(QRectF(x-0.4, y-0.4, 0.8, 0.8))

        elif pad_type == 'PTH_rectangle':
            # PTH_rectangle is like PTH_oblong but with sharp rectangular corners
            # Apply rotation if specified
            rotation = pad.get('rotation', 0)
            painter.save()
            
            # Convert rotation to float if it's a string
            try:
                rotation_value = float(rotation) if rotation else 0
            except (ValueError, TypeError):
                rotation_value = 0
            
            if rotation_value != 0:
                painter.translate(x, y)
                painter.rotate(rotation_value)
                painter.translate(-x, -y)
            
            if expansion == 0: # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                try:
                    hole_length = float(pad.get('hole_length', 1.5))
                    hole_width = float(pad.get('hole_width', 0.8))
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8
                    
                # Draw rectangular hole (black) - NO ROUNDING
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                # Draw rectangle (not rounded rectangle)
                painter.drawRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width))

                # Draw rectangular pad (sharp corners)
                painter.setPen(QPen(QColor("#FF0000"), 2/self.zoom_factor)) # Red for copper
                painter.setBrush(QBrush()) # No fill for pad outline
                try:
                    pad_length = float(pad.get('pad_length', 2.0))
                    pad_width = float(pad.get('pad_width', 1.2))
                except (ValueError, TypeError):
                    pad_length, pad_width = 2.0, 1.2
                # Draw rectangle (not rounded rectangle)
                painter.drawRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width))

                # Restore original pen
                painter.setPen(saved_pen)
            else: # Drawing mask/paste expansion - PRESERVE CALLER'S PEN COLOR
                try:
                    pad_length = float(pad.get('pad_length', 2.0)) + 2*expansion
                    pad_width = float(pad.get('pad_width', 1.2)) + 2*expansion
                except (ValueError, TypeError):
                    pad_length, pad_width = 2.0, 1.2
                # Draw rectangle (not rounded rectangle)
                painter.drawRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width))
            
            painter.restore()

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            # Apply rotation if specified
            rotation = pad.get('rotation', 0)
            painter.save()
            
            # Convert rotation to float if it's a string
            try:
                rotation_value = float(rotation) if rotation else 0
            except (ValueError, TypeError):
                rotation_value = 0
            
            if rotation_value != 0:
                painter.translate(x, y)
                painter.rotate(rotation_value)
                painter.translate(-x, -y)
            
            if expansion == 0: # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                try:
                    hole_length = float(pad.get('hole_length', 1.5))
                    hole_width = float(pad.get('hole_width', 0.8))
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8
                    
                # Draw oblong hole (black)
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                # Draw oblong as rounded rectangle
                radius = hole_width / 2
                painter.drawRoundedRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width), radius, radius)

                # Draw pad for PTH oblong only
                if pad_type == 'PTH_oblong':
                    painter.setPen(QPen(QColor("#FF0000"), 2/self.zoom_factor)) # Red for copper
                    painter.setBrush(QBrush()) # No fill for pad outline
                    try:
                        pad_length = float(pad.get('pad_length', 2.0))
                        pad_width = float(pad.get('pad_width', 1.2))
                    except (ValueError, TypeError):
                        pad_length, pad_width = 2.0, 1.2
                    pad_radius = pad_width / 2
                    painter.drawRoundedRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width), pad_radius, pad_radius)

                # Restore original pen
                painter.setPen(saved_pen)
            else: # Drawing mask/paste expansion - PRESERVE CALLER'S PEN COLOR
                if pad_type == 'PTH_oblong':
                    try:
                        pad_length = float(pad.get('pad_length', 2.0)) + 2*expansion
                        pad_width = float(pad.get('pad_width', 1.2)) + 2*expansion
                    except (ValueError, TypeError):
                        pad_length, pad_width = 2.0, 1.2
                    pad_radius = pad_width / 2
                    painter.drawRoundedRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width), pad_radius, pad_radius)
                else: # NPTH_oblong
                    try:
                        hole_length = float(pad.get('hole_length', 1.5)) + 2*expansion
                        hole_width = float(pad.get('hole_width', 0.8)) + 2*expansion
                    except (ValueError, TypeError):
                        hole_length, hole_width = 1.5, 0.8
                    radius = hole_width / 2
                    painter.drawRoundedRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width), radius, radius)
            
            painter.restore()

        elif pad_type == 'PTH_rectangle':
            # PTH_rectangle is rectangular through-hole with rotation
            try:
                rotation = float(pad.get('rotation', 0)) if pad.get('rotation') else 0
            except (ValueError, TypeError):
                rotation = 0

            painter.save()
            if rotation != 0:
                painter.translate(x, y)
                painter.rotate(rotation)
                painter.translate(-x, -y)

            if expansion == 0: # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                try:
                    hole_length = float(pad.get('hole_length', 1.5))
                    hole_width = float(pad.get('hole_width', 0.8))
                    pad_length = float(pad.get('pad_length', 2.0))
                    pad_width = float(pad.get('pad_width', 1.2))
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8
                    pad_length, pad_width = 2.0, 1.2
                    
                # Draw rectangular hole (black)
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                painter.drawRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width))

                # Draw rectangular pad (red outline)
                painter.setPen(QPen(QColor("#FF0000"), 2/self.zoom_factor))
                painter.setBrush(QBrush()) # No fill for pad outline
                painter.drawRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width))

                # Restore original pen
                painter.setPen(saved_pen)
            else: # Drawing mask/paste expansion
                try:
                    pad_length = float(pad.get('pad_length', 2.0)) + 2*expansion
                    pad_width = float(pad.get('pad_width', 1.2)) + 2*expansion
                except (ValueError, TypeError):
                    pad_length, pad_width = 2.0, 1.2
                painter.drawRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width))
            
            painter.restore()

        elif pad_type == 'custom':
            # Draw custom polygon using absolute position
            polygon_points = self.calculate_polygon_points_absolute(pad, x, y)
            if polygon_points:
                # Apply expansion to polygon - FIXED VERSION
                if expansion != 0:
                    # Calculate proper uniform expansion using offset algorithm
                    expanded_points = self.expand_polygon_uniformly(polygon_points, expansion)
                    polygon_points = expanded_points if expanded_points else polygon_points

                polygon = QPolygonF(polygon_points)
                painter.drawPolygon(polygon)
        # Draw custom polygon using absolute position   

    def expand_polygon_uniformly(self, points, expansion):
        """Expand polygon by moving each edge outward by the expansion amount"""
        if not points or len(points) < 3 or expansion == 0:
            return points
        
        try:
            expanded_points = []
            n = len(points)
            
            for i in range(n):
                # Get current vertex and adjacent vertices
                prev_i = (i - 1) % n
                next_i = (i + 1) % n
                
                curr = points[i]
                prev = points[prev_i]
                next = points[next_i]
                
                # Calculate edge vectors
                edge1 = QPointF(curr.x() - prev.x(), curr.y() - prev.y())  # incoming edge
                edge2 = QPointF(next.x() - curr.x(), next.y() - curr.y())  # outgoing edge
                
                # Calculate outward normals for each edge
                # (rotate 90Â° clockwise for outward normal)
                normal1 = QPointF(edge1.y(), -edge1.x())
                normal2 = QPointF(edge2.y(), -edge2.x())
                
                # Normalize the normals
                len1 = math.sqrt(normal1.x()**2 + normal1.y()**2)
                len2 = math.sqrt(normal2.x()**2 + normal2.y()**2)
                
                if len1 > 0:
                    normal1 = QPointF(normal1.x() / len1, normal1.y() / len1)
                if len2 > 0:
                    normal2 = QPointF(normal2.x() / len2, normal2.y() / len2)
                
                # Average the normals to get the direction to move this vertex
                avg_normal = QPointF(
                    (normal1.x() + normal2.x()) / 2,
                    (normal1.y() + normal2.y()) / 2
                )
                
                # Normalize the average normal
                avg_len = math.sqrt(avg_normal.x()**2 + avg_normal.y()**2)
                if avg_len > 0:
                    avg_normal = QPointF(avg_normal.x() / avg_len, avg_normal.y() / avg_len)
                
                # Calculate the actual expansion distance
                # For sharp corners, we need to expand more to maintain edge offset
                dot_product = normal1.x() * normal2.x() + normal1.y() * normal2.y()
                sin_half_angle = math.sqrt((1 - dot_product) / 2)
                
                # Avoid division by zero for straight lines
                expansion_factor = 1.0 / sin_half_angle if sin_half_angle > 0.01 else 1.0
                
                # Limit extreme expansions for very sharp angles
                expansion_factor = min(expansion_factor, 10.0)
                
                # Move the vertex outward
                offset_distance = -expansion * expansion_factor
                new_point = QPointF(
                    curr.x() + avg_normal.x() * offset_distance,
                    curr.y() + avg_normal.y() * offset_distance
                )
                
                expanded_points.append(new_point)
            
            return expanded_points
            
        except Exception as e:
            print(f"Polygon expansion error: {e}")
            return points


    def draw_custom_layers(self, painter):
        """Draw custom layers (mask, paste, keepout)"""
        custom_layers = self.footprint_data.get('custom_layers', [])
        
        for layer in custom_layers:
            layer_type = layer.get('layer', 'mask')
            shape = layer.get('shape', 'rectangle')
            
            # Get position
            try:
                x_offset = float(layer.get('x_offset', 0))
                y_offset = float(layer.get('y_offset', 0))
            except (ValueError, TypeError):
                x_offset, y_offset = 0, 0
                
            # Handle offset_from
            offset_from = layer.get('offset_from', 'origin')
            if offset_from != 'origin':
                # Get reference pad position
                absolute_positions = self.calculate_pad_absolute_positions()
                pads = self.footprint_data.get('padstacks', [])
                ref_pad = None
                for i, pad in enumerate(pads):
                    if pad.get('pin_number') == offset_from:
                        if i in absolute_positions:
                            ref_x, ref_y = absolute_positions[i]
                            x_offset += ref_x
                            y_offset += ref_y
                        break
            
            # Set color based on layer type
            if layer_type == 'mask':
                painter.setPen(QPen(QColor("#8A2BE2"), 2/self.zoom_factor))  # Purple
            elif layer_type == 'paste':
                painter.setPen(QPen(QColor("#C0C0C0"), 2/self.zoom_factor))  # Silver
            elif layer_type == 'keepout':
                painter.setPen(QPen(QColor("#FF4500"), 2/self.zoom_factor))  # Orange Red
            
            painter.setBrush(QBrush())  # No fill
            
            # Draw shape
            if shape == 'rectangle':
                try:
                    length = float(layer.get('length', 1))
                    width = float(layer.get('width', 1))
                    painter.drawRect(QRectF(x_offset - length/2, y_offset - width/2, length, width))
                except (ValueError, TypeError):
                    painter.drawRect(QRectF(x_offset - 0.5, y_offset - 0.5, 1, 1))
                    
            elif shape == 'rounded_rectangle':
                try:
                    length = float(layer.get('length', 1))
                    width = float(layer.get('width', 1))
                    radius = float(layer.get('corner_radius', 0.2))
                    painter.drawRoundedRect(QRectF(x_offset - length/2, y_offset - width/2, length, width), radius, radius)
                except (ValueError, TypeError):
                    painter.drawRoundedRect(QRectF(x_offset - 0.5, y_offset - 0.5, 1, 1), 0.2, 0.2)
                    
            elif shape == 'oblong':
                try:
                    length = float(layer.get('length', 2))
                    width = float(layer.get('width', 1))
                    radius = width / 2
                    painter.drawRoundedRect(QRectF(x_offset - length/2, y_offset - width/2, length, width), radius, radius)
                except (ValueError, TypeError):
                    painter.drawRoundedRect(QRectF(x_offset - 1, y_offset - 0.5, 2, 1), 0.5, 0.5)
                    
            elif shape == 'custom_polygon':
                # Handle custom polygon similar to pad custom polygons
                polygon_points = self.calculate_custom_layer_polygon_points(layer, x_offset, y_offset)
                if polygon_points:
                    polygon = QPolygonF(polygon_points)
                    painter.drawPolygon(polygon)

    def draw_thermal_vias(self, painter):
        """Draw thermal vias"""
        thermal_vias = self.footprint_data.get('thermal_vias', [])
        
        for via in thermal_vias:
            via_type = via.get('type', 'single')
            
            # Get position
            try:
                x_offset = float(via.get('x_offset', 0))
                y_offset = float(via.get('y_offset', 0))
            except (ValueError, TypeError):
                x_offset, y_offset = 0, 0
                
            # Handle offset_from - UPDATED TO INCLUDE THERMAL VIA PINS
            offset_from = via.get('offset_from', 'origin')
            if offset_from != 'origin':
                # First check pad positions
                absolute_positions = self.calculate_pad_absolute_positions()
                pads = self.footprint_data.get('padstacks', [])
                found_reference = False
                
                # Check pad pins first
                for i, pad in enumerate(pads):
                    if pad.get('pin_number') == offset_from:
                        if i in absolute_positions:
                            ref_x, ref_y = absolute_positions[i]
                            x_offset += ref_x
                            y_offset += ref_y
                            found_reference = True
                            break
                
                # If not found in pads, check thermal via pins
                if not found_reference:
                    thermal_vias_list = self.footprint_data.get('thermal_vias', [])
                    for other_via in thermal_vias_list:
                        if other_via.get('pin_number') == offset_from and other_via != via:
                            # Calculate position of the reference thermal via
                            try:
                                ref_x_offset = float(other_via.get('x_offset', 0))
                                ref_y_offset = float(other_via.get('y_offset', 0))
                            except (ValueError, TypeError):
                                ref_x_offset, ref_y_offset = 0, 0
                            
                            # Handle recursive offset_from for the reference via
                            ref_offset_from = other_via.get('offset_from', 'origin')
                            if ref_offset_from != 'origin':
                                # Recursively resolve reference via position
                                # Check pads for the reference via's offset
                                for j, ref_pad in enumerate(pads):
                                    if ref_pad.get('pin_number') == ref_offset_from:
                                        if j in absolute_positions:
                                            ref_pad_x, ref_pad_y = absolute_positions[j]
                                            ref_x_offset += ref_pad_x
                                            ref_y_offset += ref_pad_y
                                            break
                            
                            x_offset += ref_x_offset
                            y_offset += ref_y_offset
                            found_reference = True
                            break
            
            # Set via appearance
            painter.setPen(QPen(QColor("#00CED1"), 2/self.zoom_factor)) # Dark Turquoise for via
            painter.setBrush(QBrush(QColor("#008B8B"))) # Dark Cyan fill
            
            # Rest of the drawing code remains the same...
            if via_type == 'single':
                try:
                    via_diameter = float(via.get('via_diameter', 0.2))
                    drill_diameter = float(via.get('drill_diameter', 0.1))
                except (ValueError, TypeError):
                    via_diameter, drill_diameter = 0.2, 0.1
                    
                # Draw via pad
                painter.drawEllipse(QRectF(x_offset - via_diameter/2, y_offset - via_diameter/2,
                                        via_diameter, via_diameter))
                
                # Draw drill hole (black)
                painter.setPen(QPen(QColor("#000000"), 1/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                painter.drawEllipse(QRectF(x_offset - drill_diameter/2, y_offset - drill_diameter/2,
                                        drill_diameter, drill_diameter))
                                        
            elif via_type == 'grid_array':
                try:
                    rows = int(via.get('rows', 2))
                    columns = int(via.get('columns', 2))
                    row_spacing = float(via.get('row_spacing', 1.0))
                    col_spacing = float(via.get('col_spacing', 1.0))
                    via_diameter = float(via.get('via_diameter', 0.2))
                    drill_diameter = float(via.get('drill_diameter', 0.1))
                except (ValueError, TypeError):
                    rows, columns = 2, 2
                    row_spacing, col_spacing = 1.0, 1.0
                    via_diameter, drill_diameter = 0.2, 0.1
                
                # Calculate grid starting position (centered)
                start_x = x_offset - (columns - 1) * col_spacing / 2
                start_y = y_offset - (rows - 1) * row_spacing / 2
                
                for row in range(rows):
                    for col in range(columns):
                        via_x = start_x + col * col_spacing
                        via_y = start_y + row * row_spacing
                        
                        # Draw via pad
                        painter.setPen(QPen(QColor("#00CED1"), 2/self.zoom_factor))
                        painter.setBrush(QBrush(QColor("#008B8B")))
                        painter.drawEllipse(QRectF(via_x - via_diameter/2, via_y - via_diameter/2,
                                                via_diameter, via_diameter))
                        
                        # Draw drill hole
                        painter.setPen(QPen(QColor("#000000"), 1/self.zoom_factor))
                        painter.setBrush(QBrush(QColor("#000000")))
                        painter.drawEllipse(QRectF(via_x - drill_diameter/2, via_y - drill_diameter/2,
                                                drill_diameter, drill_diameter))

    def calculate_custom_layer_polygon_points(self, layer, abs_x, abs_y):
        """Calculate polygon points for custom layer shapes"""
        polygon_data = layer.get('polygon_data', {})
        lines_data = polygon_data.get('lines', [])
        
        if not lines_data:
            return []
        
        # Similar to pad polygon calculation
        raw_points = []
        current_x = abs_x
        current_y = abs_y
        raw_points.append((current_x, current_y))
        
        for line_data in lines_data:
            try:
                line_size = float(line_data.get('line_size', 1.0))
            except (ValueError, TypeError):
                line_size = 1.0
                
            direction = line_data.get('direction', 'right')
            
            if direction == 'right':
                current_x += line_size
            elif direction == 'down':
                current_y -= line_size
            elif direction == 'left':
                current_x -= line_size
            elif direction == 'up':
                current_y += line_size
                
            raw_points.append((current_x, current_y))
        
        # Convert to QPointF
        points = [QPointF(x, y) for x, y in raw_points]
        return points


    def draw_origin(self, painter):
        """Draw origin crosshair"""
        # Draw origin crosshair
        painter.setPen(QPen(QColor("#FFFF00"), 2/self.zoom_factor)) # Yellow crosshair

        # Crosshair size
        cross_size = 10 / self.zoom_factor

        # Horizontal line
        painter.drawLine(QPointF(-cross_size, 0), QPointF(cross_size, 0))

        # Vertical line
        painter.drawLine(QPointF(0, -cross_size), QPointF(0, cross_size))

        # Origin circle
        painter.setPen(QPen(QColor("#FFFF00"), 1/self.zoom_factor))
        painter.setBrush(QBrush()) # No fill
        painter.drawEllipse(QPointF(0, 0), 3/self.zoom_factor, 3/self.zoom_factor)

    def wheelEvent(self, event):
        """Handle mouse wheel events with cursor-centered zoom - FIXED VERSION"""
        zoom_in_factor = 1.2
        zoom_out_factor = 1 / zoom_in_factor

        # Get mouse position
        mouse_pos = event.position()

        # Store old zoom factor
        old_zoom = self.zoom_factor

        # Determine zoom direction
        if event.angleDelta().y() > 0:
            zoom_factor = zoom_in_factor
        else:
            zoom_factor = zoom_out_factor

        # Update zoom factor with limits
        new_zoom = self.zoom_factor * zoom_factor
        new_zoom = max(0.1, min(new_zoom, 1000)) # Clamp zoom
        self.zoom_factor = new_zoom

        # Calculate widget center
        center_x = self.width() / 2
        center_y = self.height() / 2

        # Mouse position relative to center (in widget coordinates)
        mouse_rel_x = mouse_pos.x() - center_x
        mouse_rel_y = mouse_pos.y() - center_y

        # Calculate scene coordinates more accurately
        # Convert mouse position to scene coordinates BEFORE zoom change
        scene_x = (mouse_rel_x - self.offset_x) / old_zoom
        scene_y = (mouse_rel_y - self.offset_y) / (-old_zoom) # Note: negative for Y-flip

        # Calculate new offsets to keep the scene point under the mouse
        self.offset_x = mouse_rel_x - scene_x * self.zoom_factor
        self.offset_y = mouse_rel_y - scene_y * (-self.zoom_factor) # Note: negative for Y-flip

        # Disable auto fit when manually zooming
        self.auto_fit = False
        self.update()


    def calculate_all_pad_pitches(self):
        """Calculate center-to-center pitch distances between all pad pairs"""
        pads = self.footprint_data.get('padstacks', [])
        if len(pads) < 2:
            return []
        
        pitches = []
        positions = self.calculate_pad_absolute_positions()
        
        # Calculate pitches between all pad pairs
        for i in range(len(pads)):
            for j in range(i + 1, len(pads)):
                if i not in positions or j not in positions:
                    continue
                    
                x1, y1 = positions[i]
                x2, y2 = positions[j]
                
                dx = abs(x2 - x1)
                dy = abs(y2 - y1)
                
                # Add horizontal pitch if significant
                if dx > 0.01:  # Minimum threshold to avoid noise
                    pitches.append({
                        'pad_pair': (i, j),
                        'direction': 'horizontal',
                        'pitch': dx,
                        'start_pos': QPointF(min(x1, x2), (y1 + y2) / 2),
                        'end_pos': QPointF(max(x1, x2), (y1 + y2) / 2)
                    })
                
                # Add vertical pitch if significant  
                if dy > 0.01:
                    pitches.append({
                        'pad_pair': (i, j),
                        'direction': 'vertical', 
                        'pitch': dy,
                        'start_pos': QPointF((x1 + x2) / 2, min(y1, y2)),
                        'end_pos': QPointF((x1 + x2) / 2, max(y1, y2))
                    })
        
        return pitches


    def calculate_min_pad_to_pad_airgap(self):
        """Calculate minimum edge-to-edge distance between all pads"""
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if len(pad_bounds_list) < 2:
            return None, None

        min_gap = float('inf')
        closest_pads = None

        for i in range(len(pad_bounds_list)):
            for j in range(i + 1, len(pad_bounds_list)):
                # Unpack bounds
                x1_min, y1_min, x1_max, y1_max = pad_bounds_list[i]
                x2_min, y2_min, x2_max, y2_max = pad_bounds_list[j]

                # Horizontal gap
                if x1_max < x2_min:  # b1 right edge < b2 left edge
                    x_gap = x2_min - x1_max
                elif x2_max < x1_min:  # b2 right edge < b1 left edge
                    x_gap = x1_min - x2_max
                else:
                    x_gap = 0  # Overlapping in X

                # Vertical gap
                if y1_max < y2_min:  # b1 top edge < b2 bottom edge
                    y_gap = y2_min - y1_max
                elif y2_max < y1_min:  # b2 top edge < b1 bottom edge
                    y_gap = y1_min - y2_max
                else:
                    y_gap = 0  # Overlapping in Y

                # Actual distance
                if x_gap == 0 and y_gap == 0:
                    dist = 0  # Overlapping pads
                elif x_gap == 0:
                    dist = y_gap  # Vertically separated
                elif y_gap == 0:
                    dist = x_gap  # Horizontally separated
                else:
                    dist = math.sqrt(x_gap**2 + y_gap**2)  # Corner-to-corner

                if dist < min_gap:
                    min_gap = dist
                    closest_pads = (i, j, x_gap, y_gap)

        return (min_gap if min_gap != float('inf') else None), closest_pads

    def calculate_all_pad_airgaps(self):
        """Calculate only X and Y edge-to-edge pad clearances."""
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if len(pad_bounds_list) < 2:
            return []
        
        airgaps = []
        
        for i in range(len(pad_bounds_list)):
            for j in range(i + 1, len(pad_bounds_list)):
                b1 = pad_bounds_list[i]  # [min_x, min_y, max_x, max_y]
                b2 = pad_bounds_list[j]

                h_start = h_end = v_start = v_end = None
                x_gap = y_gap = 0

                # --- Horizontal gap (edge-to-edge) ---
                if b1[2] < b2[0]:  # pad1 right to pad2 left
                    x_gap = b2[0] - b1[2]
                    h_start = QPointF(b1[2], (b1[1] + b1[3]) / 2)
                    h_end   = QPointF(b2[0], (b2[1] + b2[3]) / 2)
                elif b2[2] < b1[0]:  # pad2 right to pad1 left
                    x_gap = b1[0] - b2[2]
                    h_start = QPointF(b2[2], (b2[1] + b2[3]) / 2)
                    h_end   = QPointF(b1[0], (b1[1] + b1[3]) / 2)

                # --- Vertical gap (edge-to-edge) ---
                if b1[3] < b2[1]:  # pad1 top to pad2 bottom
                    y_gap = b2[1] - b1[3]
                    v_start = QPointF((b1[0] + b1[2]) / 2, b1[3])
                    v_end   = QPointF((b2[0] + b2[2]) / 2, b2[1])
                elif b2[3] < b1[1]:  # pad2 top to pad1 bottom
                    y_gap = b1[1] - b2[3]
                    v_start = QPointF((b2[0] + b2[2]) / 2, b2[3])
                    v_end   = QPointF((b1[0] + b1[2]) / 2, b1[1])

                airgaps.append({
                    'pads': (i, j),
                    'x_gap': x_gap,
                    'y_gap': y_gap,
                    'h_line': (h_start, h_end) if h_start and h_end else None,
                    'v_line': (v_start, v_end) if v_start and v_end else None,
                })
        
        return airgaps


    def draw_dimension_line_with_label(self, painter, start_point, end_point, value_mm, label_prefix, color, label_offset=QPointF(0,0)):
        """Draw a dimension line with colored 'pill' label in mm with optional offset."""
        if not start_point or not end_point or value_mm <= 0:
            return

        # 1) Dimension line
        painter.setPen(QPen(color, 1.5/self.zoom_factor))
        painter.drawLine(start_point, end_point)

        # 2) End ticks
        ext = 3/self.zoom_factor
        v = QPointF(end_point.x() - start_point.x(), end_point.y() - start_point.y())
        L = math.hypot(v.x(), v.y())
        if L > 0:
            n = QPointF(v.x()/L, v.y()/L)
            p = QPointF(-n.y(), n.x())
            painter.drawLine(QPointF(start_point.x()+p.x()*ext, start_point.y()+p.y()*ext),
                            QPointF(start_point.x()-p.x()*ext, start_point.y()-p.y()*ext))
            painter.drawLine(QPointF(end_point.x()+p.x()*ext, end_point.y()+p.y()*ext),
                            QPointF(end_point.x()-p.x()*ext, end_point.y()-p.y()*ext))

        # 3) Label (world midpoint -> screen) with offset
        mid = QPointF((start_point.x()+end_point.x())/2, (start_point.y()+end_point.y())/2)
        screen_mid = painter.worldTransform().map(mid)
        
        # Apply offset to prevent label overlap
        screen_mid += label_offset

        label_text = f"{label_prefix}:{value_mm}mm"

        painter.save()
        painter.resetTransform()
        font = QFont("Arial", 9)
        font.setBold(True)
        painter.setFont(font)
        fm = painter.fontMetrics()
        rect = fm.boundingRect(label_text)
        rect.moveCenter(screen_mid.toPoint())
        rect.adjust(-4, -2, 4, 2)

        bg = QColor(color)
        bg.setAlpha(200)
        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush(bg))
        painter.drawRoundedRect(rect, 4, 4)

        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush())
        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, label_text)
        painter.restore()

    def draw_all_airgap_dimensions(self, painter):
        """Draw air gap dimensions only between selected pads (if exactly 2 selected)"""
        if len(self.selected_pads) != 2:
            return

        pad_indices = list(self.selected_pads)
        i, j = pad_indices[0], pad_indices[1]

        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if i >= len(pad_bounds_list) or j >= len(pad_bounds_list):
            return

        b1 = pad_bounds_list[i]  # (x_min, y_min, x_max, y_max)
        b2 = pad_bounds_list[j]

        # Calculate horizontal gap (X)
        h_start = h_end = None
        x_gap = 0

        if b1[2] < b2[0]:  # pad1 right edge < pad2 left edge
            x_gap = b2[0] - b1[2]
            h_start = QPointF(b1[2], (b1[1] + b1[3]) / 2)
            h_end   = QPointF(b2[0], (b2[1] + b2[3]) / 2)

        elif b2[2] < b1[0]:  # pad2 right edge < pad1 left edge
            x_gap = b1[0] - b2[2]
            h_start = QPointF(b2[2], (b2[1] + b2[3]) / 2)
            h_end   = QPointF(b1[0], (b1[1] + b1[3]) / 2)

        # Calculate vertical gap (Y)
        v_start = v_end = None
        y_gap = 0

        if b1[3] < b2[1]:  # pad1 top < pad2 bottom
            y_gap = b2[1] - b1[3]
            v_start = QPointF((b1[0] + b1[2]) / 2, b1[3])
            v_end   = QPointF((b2[0] + b2[2]) / 2, b2[1])

        elif b2[3] < b1[1]:  # pad2 top < pad1 bottom
            y_gap = b1[1] - b2[3]
            v_start = QPointF((b2[0] + b2[2]) / 2, b2[3])
            v_end   = QPointF((b1[0] + b1[2]) / 2, b1[1])

        # Draw dimension lines
        if h_start and h_end and x_gap > 0:
            label_offset = QPointF(0, -15)
            self.draw_dimension_line_with_label(
                painter, h_start, h_end, x_gap, "X Gap", QColor("#00FFFF"), label_offset
            )

        if v_start and v_end and y_gap > 0:
            label_offset = QPointF(15, 0)
            self.draw_dimension_line_with_label(
                painter, v_start, v_end, y_gap, "Y Gap", QColor("#FFFF00"), label_offset
            )

    def draw_all_pitch_dimensions(self, painter):
        """Draw pitch dimensions only between selected pads (if exactly 2 selected)"""
        if len(self.selected_pads) != 2:
            return
        
        pad_indices = list(self.selected_pads)
        i, j = pad_indices[0], pad_indices[1]
        
        positions = self.calculate_pad_absolute_positions()
        if i not in positions or j not in positions:
            return
        
        x1, y1 = positions[i]
        x2, y2 = positions[j]
        
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        
        # Draw horizontal pitch if significant
        if dx > 0.01:
            start = QPointF(min(x1, x2), (y1 + y2) / 2)
            end = QPointF(max(x1, x2), (y1 + y2) / 2)
            label_offset = QPointF(0, -25)  # Offset to avoid overlap
            self.draw_dimension_line_with_label(
                painter, start, end, dx, "Pitch X", QColor("#FFA500"), label_offset
            )
        
        # Draw vertical pitch if significant
        if dy > 0.01:
            start = QPointF((x1 + x2) / 2, min(y1, y2))
            end = QPointF((x1 + x2) / 2, max(y1, y2))
            label_offset = QPointF(25, 0)  # Offset to avoid overlap
            self.draw_dimension_line_with_label(
                painter, start, end, dy, "Pitch Y", QColor("#FFA500"), label_offset
            )


    def draw_minimum_airgap_summary(self, painter):
        """Draw minimum airgap summary in top-left corner"""
        airgaps = self.calculate_all_pad_airgaps()
        if not airgaps:
            return
        
        # Find minimum values
        min_x = min((a['x_gap'] for a in airgaps if a['x_gap'] > 0), default=None)
        min_y = min((a['y_gap'] for a in airgaps if a['y_gap'] > 0), default=None)
        min_overall = min((min(a['x_gap'], a['y_gap']) for a in airgaps 
                        if a['x_gap'] > 0 or a['y_gap'] > 0), default=None)
        
        if min_overall is None:
            return
        
        painter.save()
        painter.resetTransform()
        
        # Create summary text
        summary_lines = []
        if min_overall is not None:
            summary_lines.append(f"Min Airgap: {min_overall:.3f}mm")
        if min_x is not None:
            summary_lines.append(f"Min X Gap: {min_x:.3f}mm")
        if min_y is not None:
            summary_lines.append(f"Min Y Gap: {min_y:.3f}mm")
        
        # Set font
        font = QFont("Arial", 10)
        font.setBold(True)
        painter.setFont(font)
        
        # Calculate text area
        fm = painter.fontMetrics()
        max_width = max(fm.horizontalAdvance(line) for line in summary_lines)
        line_height = fm.height()
        total_height = len(summary_lines) * line_height + 10
        
        # Draw background
        bg_rect = QRectF(10, 10, max_width + 20, total_height)
        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush(QColor("#000000", 180)))
        painter.drawRect(bg_rect)
        
        # Draw text lines
        y_offset = 10
        painter.setPen(QPen(QColor("#00FF00"), 1))
        for line in summary_lines:
            painter.drawText(20, y_offset + line_height, line)
            y_offset += line_height
        
        painter.restore()

    def draw_selection_instructions(self, painter):
        """Draw instruction text for pad selection"""
        painter.save()
        painter.resetTransform()  # Switch to screen coordinates
        
        instructions = []
        
        if self.show_airgap_checkbox.isChecked() or self.show_pitch_checkbox.isChecked():
            if len(self.selected_pads) == 0:
                instructions.append("Click on 2 pads to measure dimensions")
            elif len(self.selected_pads) == 1:
                instructions.append("Click on 1 more pad to measure")
            elif len(self.selected_pads) == 2:
                instructions.append("Dimensions shown between selected pads")
                instructions.append("Click elsewhere to clear selection")
        
        if instructions:
            # Position at bottom-left
            y_start = self.height() - 60
            
            painter.setPen(QPen(QColor("#FFFFFF"), 1))
            font = QFont("Arial", 10)
            painter.setFont(font)
            
            for i, instruction in enumerate(instructions):
                # Draw background for better visibility
                text_rect = painter.fontMetrics().boundingRect(instruction)
                text_rect.moveTo(10, y_start + i * 20)
                text_rect.adjust(-3, -1, 3, 1)
                
                painter.setBrush(QBrush(QColor(0, 0, 0, 150)))
                painter.drawRect(text_rect)
                
                painter.setBrush(QBrush())
                painter.drawText(10, y_start + i * 20 + 15, instruction)
        
        painter.restore()



    def draw_pad_airgap_dimension(self, painter):
        """Draw pad-to-pad airgap dimension in screen space"""
        min_airgap, closest_pads = self.calculate_min_pad_to_pad_airgap()
        if min_airgap is None:
            return
        
        # Draw airgap text in screen space
        painter.save()
        painter.resetTransform()  # Switch to screen coordinates
        
        # Set text properties
        painter.setPen(QPen(QColor("#00FF00"), 2))  # Bright green
        font = QFont("Arial", 12)
        font.setBold(True)
        painter.setFont(font)
        
        # Format the airgap value
        airgap_text = f"Min Pad-to-Pad Airgap: {min_airgap:.3f} mm"
        
        # Draw text with background for better visibility
        text_rect = painter.fontMetrics().boundingRect(airgap_text)
        text_rect.adjust(-5, -2, 5, 2)
        text_rect.moveTo(10, 10)
        
        # Draw background rectangle
        painter.setPen(QPen(QColor("#000000"), 1))
        color = QColor("#000000")
        color.setAlpha(180)
        painter.setBrush(QBrush(color))
 # Semi-transparent black
        painter.drawRect(text_rect)
        
        # Draw the text
        painter.setPen(QPen(QColor("#00FF00"), 2))
        painter.setBrush(QBrush())
        painter.drawText(text_rect.adjusted(5, 2, -5, -2), Qt.AlignmentFlag.AlignLeft, airgap_text)
        
        painter.restore()

    def draw_airgap_dimension_lines(self, painter):
        """Draw dimension lines between closest pads"""
        min_airgap, closest_pads = self.calculate_min_pad_to_pad_airgap()
        if min_airgap is None or closest_pads is None:
            return
        
        if min_airgap == 0:  # Skip if pads are overlapping
            return
            
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        i, j, x_gap, y_gap = closest_pads
        
        b1 = pad_bounds_list[i]
        b2 = pad_bounds_list[j]
        
        # Set dimension line properties
        painter.setPen(QPen(QColor("#FFFF00"), 1.5/self.zoom_factor))  # Yellow dimension lines
        
        if x_gap > 0 and y_gap == 0:  # Horizontally separated
            # Draw horizontal dimension line
            y_center = (max(b1[1], b2[1]) + min(b1[3], b2[3])) / 2
            line_start = QPointF(b1[2], y_center)
            line_end = QPointF(b2[0], y_center)
            
            painter.drawLine(line_start, line_end)
            
            # Draw extension lines
            # Draw extension lines (horizontal gap case)
            painter.drawLine(QPointF(b1[2], b1[1]), QPointF(b1[2], b1[3]))  # right edge of pad 1
            painter.drawLine(QPointF(b2[0], b2[1]), QPointF(b2[0], b2[3]))  # left edge of pad 2

        elif y_gap > 0 and x_gap == 0:  # Vertically separated
            # Draw vertical dimension line
            x_center = (max(b1[0], b2[0]) + min(b1[2], b2[2])) / 2
            line_start = QPointF(x_center, b1[3])  # top edge of pad 1
            line_end   = QPointF(x_center, b2[1])  # bottom edge of pad 2
            painter.drawLine(line_start, line_end)

            # Draw extension lines (vertical gap case)
            painter.drawLine(QPointF(b1[0], b1[3]), QPointF(b1[2], b1[3]))  # top edge of pad 1
            painter.drawLine(QPointF(b2[0], b2[1]), QPointF(b2[2], b2[1]))  # bottom edge of pad 2

    def generate_pad_name(self, pad):
        """Generate padstack name based on pad type and expansions"""
        pad_type = pad['type']
        
        try:
            mask_exp = float(pad.get('mask_expansion', 0)) if pad.get('mask_enabled', True) else 0
            paste_exp = float(pad.get('paste_expansion', 0)) if pad.get('paste_enabled', True) else 0
        except (ValueError, TypeError):
            mask_exp = paste_exp = 0
        
        name = ""
        
        if pad_type == 'square':
            try:
                size = float(pad.get('size', 1))
                name = f"S{int(size * 100)}"
                if mask_exp > 0:
                    mask_size = int((size + 2 * mask_exp) * 100)
                    name += f"_M{mask_size}"
                if paste_exp > 0:
                    paste_size = int((size + 2 * paste_exp) * 100)
                    name += f"_P{paste_size}"
            except (ValueError, TypeError):
                name = "S100"
                
        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong', 'PTH_rectangle']:
            try:
                length = float(pad.get('length', 1))
                width = float(pad.get('width', 1))
                name = f"R{int(length * 100)}x{int(width * 100)}"
                if mask_exp > 0:
                    mask_l = int((length + 2 * mask_exp) * 100)
                    mask_w = int((width + 2 * mask_exp) * 100)
                    name += f"_M{mask_l}x{mask_w}"
                if paste_exp > 0:
                    paste_l = int((length + 2 * paste_exp) * 100)
                    paste_w = int((width + 2 * paste_exp) * 100)
                    name += f"_P{paste_l}x{paste_w}"
            except (ValueError, TypeError):
                name = "R100x100"
                
        elif pad_type == 'round':
            try:
                diameter = float(pad.get('diameter', 1))
                name = f"C{int(diameter * 100)}"  # C for circular
                if mask_exp > 0:
                    mask_dia = int((diameter + 2 * mask_exp) * 100)
                    name += f"_M{mask_dia}"
                if paste_exp > 0:
                    paste_dia = int((diameter + 2 * paste_exp) * 100)
                    name += f"_P{paste_dia}"
            except (ValueError, TypeError):
                name = "C100"
                
        elif pad_type in ['PTH', 'NPTH']:
            hole_dia = float(pad.get('hole_diameter', 0.8))
            if pad_type == 'PTH':
                pad_dia = float(pad.get('pad_diameter', 1.2))
                name = f"PTH{int(hole_dia * 100)}_P{int(pad_dia * 100)}"
            else:
                name = f"NPTH{int(hole_dia * 100)}"
                
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            hole_l = float(pad.get('hole_length', 1.5))
            hole_w = float(pad.get('hole_width', 0.8))
            if pad_type == 'PTH_oblong':
                pad_l = float(pad.get('pad_length', 2.0))
                pad_w = float(pad.get('pad_width', 1.2))
                name = f"PTHO{int(hole_l * 100)}x{int(hole_w * 100)}_P{int(pad_l * 100)}x{int(pad_w * 100)}"
            else:
                name = f"NPTHO{int(hole_l * 100)}x{int(hole_w * 100)}"
        else:
            name = f"{pad_type.upper()}"
            
        return name



class PadPositionResolver:
    def __init__(self, pads):
        self.pads = pads
        self.cache = {}
        self.resolved_positions = {}

    def clear_cache(self):
        self.cache.clear()
        self.resolved_positions.clear()

    def get_pad_by_pin(self, pin_number):
        for pad in self.pads:
            if pad.get('pin_number', None) == pin_number:
                return pad
        return None

    def get_absolute_position(self, pad, visiting=None):
        """Get absolute position with cycle detection"""
        if visiting is None:
            visiting = set()
        
        pad_pin = pad.get('pin_number', '')
        
        # Check cache first
        if pad_pin in self.cache:
            return self.cache[pad_pin]
        
        # Check for circular reference
        if pad_pin in visiting:
            print(f"Warning: Circular reference detected for pad {pad_pin}. Using origin offset.")
            try:
                x_offset = float(pad.get('x_offset', 0))
                y_offset = float(pad.get('y_offset', 0))
            except (ValueError, TypeError):
                x_offset, y_offset = 0, 0
            self.cache[pad_pin] = (x_offset, y_offset)
            return x_offset, y_offset
        
        # Add current pad to visiting set
        visiting.add(pad_pin)
        
        offset_from = pad.get('offset_from', 'origin')
        try:
            x_offset = float(pad.get('x_offset', 0))
            y_offset = float(pad.get('y_offset', 0))
        except (ValueError, TypeError):
            x_offset, y_offset = 0, 0
        
        if offset_from == 'origin':
            abs_x, abs_y = x_offset, y_offset
            self.resolved_positions[pad_pin] = (abs_x, abs_y)
        else:
            # Direct pin reference with cycle detection
            ref_pad = self.get_pad_by_pin(offset_from)
            if ref_pad and ref_pad != pad:
                try:
                    ref_x, ref_y = self.get_absolute_position(ref_pad, visiting)
                    abs_x = ref_x + x_offset
                    abs_y = ref_y + y_offset
                    self.resolved_positions[pad_pin] = (abs_x, abs_y)
                except RecursionError:
                    print(f"Warning: Recursion limit reached for pad {pad_pin}. Using origin offset.")
                    abs_x, abs_y = x_offset, y_offset
                    self.resolved_positions[pad_pin] = (abs_x, abs_y)
            else:
                # Fallback to origin if reference not found
                abs_x, abs_y = x_offset, y_offset
                self.resolved_positions[pad_pin] = (abs_x, abs_y)
        
        # Remove from visiting set before returning
        visiting.discard(pad_pin)
        
        # Cache the result
        self.cache[pad_pin] = (abs_x, abs_y)
        return abs_x, abs_y


    def resolve_all_positions(self):
        self.clear_cache()
        
        # Resolve origin-based pads first
        for pad in self.pads:
            if pad.get('offset_from', 'origin') == 'origin':
                self.get_absolute_position(pad)

        # Iteratively resolve referenced pads
        max_iterations = len(self.pads) * 2
        for _ in range(max_iterations):
            resolved_any = False
            for pad in self.pads:
                pad_pin = pad.get('pin_number', '')
                if pad_pin not in self.resolved_positions:
                    try:
                        self.get_absolute_position(pad)
                        resolved_any = True
                    except:
                        continue
            
            if not resolved_any:
                break

        return self.resolved_positions

class PadStackRow(QWidget):
    delete_requested = pyqtSignal(object)
    data_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self):
        # Main container with grouped sections
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)

        # Create group box for this padstack
        self.group_box = QGroupBox("Padstack Configuration")
        group_layout = QVBoxLayout(self.group_box)
        group_layout.setSpacing(5)

        # ===== ROW 1: Pad Type and Geometry =====
        row1_layout = QHBoxLayout()
        row1_layout.setSpacing(10)

        # Pad Type Group
        type_group = QGroupBox("Pad Type")
        type_layout = QHBoxLayout(type_group)
        type_layout.setContentsMargins(5, 5, 5, 5)

        self.type_combo = QComboBox()
        self.type_combo.addItems([
            'square', 'rectangle', 'rounded_rectangle', 'round', 'custom',
            'SMD-oblong', 'D-shape', 'PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong', 'PTH_rectangle'
        ])
        type_layout.addWidget(self.type_combo)

        row1_layout.addWidget(type_group)

        # Geometry Group (Dynamic based on pad type)
        self.geometry_group = QGroupBox("Geometry")
        self.geometry_layout = QHBoxLayout(self.geometry_group)
        self.geometry_layout.setContentsMargins(5, 5, 5, 5)
        row1_layout.addWidget(self.geometry_group)

        # Action Buttons Group
        actions_group = QGroupBox("Actions")
        actions_layout = QHBoxLayout(actions_group)
        actions_layout.setContentsMargins(5, 5, 5, 5)

        self.duplicate_btn = QPushButton("Duplicate")
        self.duplicate_btn.setMaximumWidth(80)
        self.delete_btn = QPushButton("Delete")
        self.delete_btn.setMaximumWidth(60)

        actions_layout.addWidget(self.duplicate_btn)
        actions_layout.addWidget(self.delete_btn)
        row1_layout.addWidget(actions_group)

        group_layout.addLayout(row1_layout)

        # ===== ROW 2: Position and Layer Properties =====
        row2_layout = QHBoxLayout()
        row2_layout.setSpacing(10)

        # Position Group
        position_group = QGroupBox("Position")
        position_layout = QGridLayout(position_group)
        position_layout.setContentsMargins(5, 5, 5, 5)

        position_layout.addWidget(QLabel("X Offset:"), 0, 0)
        self.x_offset = QLineEdit()
        self.x_offset.setText("0")
        self.x_offset.setMaximumWidth(100)
        position_layout.addWidget(self.x_offset, 0, 1)

        position_layout.addWidget(QLabel("Y Offset:"), 0, 2)
        self.y_offset = QLineEdit()
        self.y_offset.setText("0")
        self.y_offset.setMaximumWidth(100)
        position_layout.addWidget(self.y_offset, 0, 3)

        position_layout.addWidget(QLabel("Offset From:"), 1, 0)
        # Dynamic dropdown instead of fixed directional options
        self.offset_from = QComboBox()
        self.offset_from.setMaximumWidth(100)
        position_layout.addWidget(self.offset_from, 1, 1, 1, 2)

        position_layout.addWidget(QLabel("Pin:"), 1, 2)
        self.pin_number = QLineEdit()
        self.pin_number.setMaximumWidth(50)
        position_layout.addWidget(self.pin_number, 1, 3)

        row2_layout.addWidget(position_group)

        # Layer Properties Group
        layers_group = QGroupBox("Layer Properties")
        layers_layout = QGridLayout(layers_group)
        layers_layout.setContentsMargins(5, 5, 5, 5)

        layers_layout.addWidget(QLabel("Mask Expansion:"), 0, 0)
        self.mask_expansion = QLineEdit()
        self.mask_expansion.setText("0")
        self.mask_expansion.setMaximumWidth(100)
        layers_layout.addWidget(self.mask_expansion, 0, 1)

        layers_layout.addWidget(QLabel("Paste Expansion:"), 1, 0)
        self.paste_expansion = QLineEdit()
        self.paste_expansion.setText("0")
        self.paste_expansion.setMaximumWidth(100)
        layers_layout.addWidget(self.paste_expansion, 1, 1)

        # Add checkboxes for enabling/disabling mask and paste layers
        self.mask_enabled = QCheckBox("Enable Mask")
        self.mask_enabled.setChecked(True)
        layers_layout.addWidget(self.mask_enabled, 0, 2)

        self.paste_enabled = QCheckBox("Enable Paste")
        self.paste_enabled.setChecked(True)
        layers_layout.addWidget(self.paste_enabled, 1, 2)

        row2_layout.addWidget(layers_group)

        group_layout.addLayout(row2_layout)

        # Custom polygon widget (initially hidden)
        self.polygon_widget = CustomPolygonWidget()
        self.polygon_widget.data_changed.connect(self.data_changed.emit)
        self.polygon_widget.setVisible(False)
        group_layout.addWidget(self.polygon_widget)

        main_layout.addWidget(self.group_box)
        self.setLayout(main_layout)

        # Initialize geometry inputs
        self.update_geometry_inputs()

    def connect_signals(self):
        self.type_combo.currentTextChanged.connect(self.update_geometry_inputs)
        self.type_combo.currentTextChanged.connect(self.update_layer_visibility)
        self.type_combo.currentTextChanged.connect(self.data_changed.emit)
        self.delete_btn.clicked.connect(lambda: self.delete_requested.emit(self))

        # Connect all input signals
        self.x_offset.textChanged.connect(self.data_changed.emit)
        self.y_offset.textChanged.connect(self.data_changed.emit)
        self.mask_expansion.textChanged.connect(self.data_changed.emit)
        self.paste_expansion.textChanged.connect(self.data_changed.emit)
        self.mask_enabled.stateChanged.connect(self.data_changed.emit)
        self.paste_enabled.stateChanged.connect(self.data_changed.emit)

        self.offset_from.currentTextChanged.connect(self.data_changed.emit)
        
        # Update dropdown when pin numbers change
        self.pin_number.textChanged.connect(self.update_offset_from_options)
        self.pin_number.textChanged.connect(self.data_changed.emit)

    def update_layer_visibility(self):
        """Show/hide layer checkboxes based on pad type"""
        pad_type = self.type_combo.currentText()
        smd_types = ['square', 'rectangle', 'rounded_rectangle', 'round', 'SMD-oblong', 'D-shape', 'custom']
        
        # Show checkboxes only for SMD pad types
        is_smd = pad_type in smd_types
        self.mask_enabled.setVisible(is_smd)
        self.paste_enabled.setVisible(is_smd)

    def update_offset_from_options(self):
        """Update the offset_from dropdown with all available pin numbers"""
        # Get the parent FootprintDesigner to access all padstack rows
        parent_designer = self.get_parent_designer()
        if not parent_designer:
            return

        # Collect all pin numbers except the current one
        available_pins = []
        current_pin = self.pin_number.text().strip()

        for row in parent_designer.padstack_rows:
            if row != self: # Don't include self
                pin_text = row.pin_number.text().strip()
                if pin_text and pin_text != current_pin:
                    available_pins.append(pin_text)

        # Update the dropdown
        current_selection = self.offset_from.currentText()
        self.offset_from.blockSignals(True)
        self.offset_from.clear()
        self.offset_from.addItem('origin') # Always include origin

        # Sort pin numbers numerically if possible, otherwise alphabetically
        try:
            available_pins.sort(key=lambda x: int(x) if x.isdigit() else float('inf'))
        except:
            available_pins.sort()

        self.offset_from.addItems(available_pins)

        # Restore previous selection if still valid
        index = self.offset_from.findText(current_selection)
        if index >= 0:
            self.offset_from.setCurrentIndex(index)
        else:
            self.offset_from.setCurrentText('origin')

        self.offset_from.blockSignals(False)

    def get_parent_designer(self):
        """Find the parent FootprintDesigner instance"""
        parent = self.parent()
        while parent:
            if hasattr(parent, 'padstack_rows'):
                return parent
            parent = parent.parent()
        return None

    def update_geometry_inputs(self):
        # Clear existing geometry inputs
        for i in reversed(range(self.geometry_layout.count())):
            item = self.geometry_layout.itemAt(i)
            if item:
                widget = item.widget()
                if widget:
                    widget.setParent(None)

        pad_type = self.type_combo.currentText()

        # Show/hide polygon widget
        self.polygon_widget.setVisible(pad_type == 'custom')
        
        # Update layer visibility
        self.update_layer_visibility()

        if pad_type == 'square':
            self.geometry_layout.addWidget(QLabel("Size:"))
            self.size_input = QLineEdit()
            self.size_input.setText("1.0")
            self.size_input.setMaximumWidth(100)
            self.size_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.size_input)

        elif pad_type in ['rectangle', 'SMD-oblong']:
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

        elif pad_type == 'rounded_rectangle':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

            self.geometry_layout.addWidget(QLabel("Corner Radius:"))
            self.corner_radius_input = QLineEdit()
            self.corner_radius_input.setText("0.2")
            self.corner_radius_input.setMaximumWidth(100)
            self.corner_radius_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.corner_radius_input)

        elif pad_type in ['round']:
            self.geometry_layout.addWidget(QLabel("Diameter:"))
            self.diameter_input = QLineEdit()
            self.diameter_input.setText("1.0")
            self.diameter_input.setMaximumWidth(100)
            self.diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.diameter_input)

        elif pad_type in ['PTH', 'NPTH']:
            # Round through hole
            self.geometry_layout.addWidget(QLabel("Hole Diameter:"))
            self.hole_diameter_input = QLineEdit()
            self.hole_diameter_input.setText("0.8")
            self.hole_diameter_input.setMaximumWidth(100)
            self.hole_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_diameter_input)

            if pad_type == 'PTH':
                # PTH needs pad diameter
                self.geometry_layout.addWidget(QLabel("Pad Diameter:"))
                self.pad_diameter_input = QLineEdit()
                self.pad_diameter_input.setText("1.2")
                self.pad_diameter_input.setMaximumWidth(100)
                self.pad_diameter_input.textChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_diameter_input)

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            # Oblong through hole
            self.geometry_layout.addWidget(QLabel("Hole Length:"))
            self.hole_length_input = QLineEdit()
            self.hole_length_input.setText("1.5")
            self.hole_length_input.setMaximumWidth(100)
            self.hole_length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_length_input)

            self.geometry_layout.addWidget(QLabel("Hole Width:"))
            self.hole_width_input = QLineEdit()
            self.hole_width_input.setText("0.8")
            self.hole_width_input.setMaximumWidth(100)
            self.hole_width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_width_input)

            if pad_type == 'PTH_oblong':
                # PTH oblong needs pad dimensions
                self.geometry_layout.addWidget(QLabel("Pad Length:"))
                self.pad_length_input = QLineEdit()
                self.pad_length_input.setText("2.0")
                self.pad_length_input.setMaximumWidth(100)
                self.pad_length_input.textChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_length_input)

                self.geometry_layout.addWidget(QLabel("Pad Width:"))
                self.pad_width_input = QLineEdit()
                self.pad_width_input.setText("1.2")
                self.pad_width_input.setMaximumWidth(100)
                self.pad_width_input.textChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_width_input)

            # Add rotation control for oblong pads
            self.geometry_layout.addWidget(QLabel("Rotation:"))
            self.rotation_input = QLineEdit()
            self.rotation_input.setText("0")
            self.rotation_input.setMaximumWidth(80)
            self.rotation_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rotation_input)

        elif pad_type == 'D-shape':
            self.geometry_layout.addWidget(QLabel("Pad Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Pad Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

            self.geometry_layout.addWidget(QLabel("Corner Radius:"))
            self.corner_radius_input = QLineEdit()
            self.corner_radius_input.setText("0.2")
            self.corner_radius_input.setMaximumWidth(100)
            self.corner_radius_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.corner_radius_input)

            self.geometry_layout.addWidget(QLabel("Rotation:"))
            self.rotation_input = QLineEdit()
            self.rotation_input.setText("0")
            self.rotation_input.setMaximumWidth(80)
            self.rotation_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rotation_input)

        elif pad_type == 'PTH_rectangle':
            self.geometry_layout.addWidget(QLabel("Hole Length:"))
            self.hole_length_input = QLineEdit()
            self.hole_length_input.setText("1.5")
            self.hole_length_input.setMaximumWidth(100)
            self.hole_length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_length_input)

            self.geometry_layout.addWidget(QLabel("Hole Width:"))
            self.hole_width_input = QLineEdit()
            self.hole_width_input.setText("0.8")
            self.hole_width_input.setMaximumWidth(100)
            self.hole_width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_width_input)

            self.geometry_layout.addWidget(QLabel("Pad Length:"))
            self.pad_length_input = QLineEdit()
            self.pad_length_input.setText("2.0")
            self.pad_length_input.setMaximumWidth(100)
            self.pad_length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.pad_length_input)

            self.geometry_layout.addWidget(QLabel("Pad Width:"))
            self.pad_width_input = QLineEdit()
            self.pad_width_input.setText("1.2")
            self.pad_width_input.setMaximumWidth(100)
            self.pad_width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.pad_width_input)

            self.geometry_layout.addWidget(QLabel("Rotation:"))
            self.rotation_input = QLineEdit()
            self.rotation_input.setText("0")
            self.rotation_input.setMaximumWidth(80)
            self.rotation_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rotation_input)


        elif pad_type == 'custom':
            # Custom polygon inputs handled by polygon_widget
            self.geometry_layout.addWidget(QLabel("Custom Polygon (see below)"))

        # Add stretch to push everything to the left
        self.geometry_layout.addStretch()

    def get_data(self):
        data = {
            'type': self.type_combo.currentText(),
            'x_offset': self.x_offset.text(),
            'y_offset': self.y_offset.text(),
            'offset_from': self.offset_from.currentText(),
            'mask_expansion': self.mask_expansion.text(),
            'paste_expansion': self.paste_expansion.text(),
            'mask_enabled': self.mask_enabled.isChecked(),
            'paste_enabled': self.paste_enabled.isChecked(),
            'pin_number': self.pin_number.text()
        }

        pad_type = self.type_combo.currentText()

        if pad_type == 'square' and hasattr(self, 'size_input'):
            data['size'] = self.size_input.text()

        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong']:
            if hasattr(self, 'length_input'):
                data['length'] = self.length_input.text()
            if hasattr(self, 'width_input'):
                data['width'] = self.width_input.text()
            if pad_type == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                data['corner_radius'] = self.corner_radius_input.text()

        elif pad_type in ['round'] and hasattr(self, 'diameter_input'):
            data['diameter'] = self.diameter_input.text()

        elif pad_type in ['D-shape']:
            if hasattr(self, 'length_input'):
                data['length'] = self.length_input.text()
            if hasattr(self, 'width_input'):
                data['width'] = self.width_input.text()
            if hasattr(self, 'corner_radius_input'):
                data['corner_radius'] = self.corner_radius_input.text()
            if hasattr(self, 'rotation_input'):
                data['rotation'] = self.rotation_input.text()

        elif pad_type in ['PTH', 'NPTH']:
            if hasattr(self, 'hole_diameter_input'):
                data['hole_diameter'] = self.hole_diameter_input.text()
            if pad_type == 'PTH' and hasattr(self, 'pad_diameter_input'):
                data['pad_diameter'] = self.pad_diameter_input.text()

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if hasattr(self, 'hole_length_input'):
                data['hole_length'] = self.hole_length_input.text()
            if hasattr(self, 'hole_width_input'):
                data['hole_width'] = self.hole_width_input.text()
            if hasattr(self, 'rotation_input'):
                data['rotation'] = self.rotation_input.text()
            if pad_type == 'PTH_oblong':
                if hasattr(self, 'pad_length_input'):
                    data['pad_length'] = self.pad_length_input.text()
                if hasattr(self, 'pad_width_input'):
                    data['pad_width'] = self.pad_width_input.text()

        elif pad_type == 'PTH_rectangle':
            if hasattr(self, 'hole_length_input'):
                data['hole_length'] = self.hole_length_input.text()
            if hasattr(self, 'hole_width_input'):
                data['hole_width'] = self.hole_width_input.text()
            if hasattr(self, 'pad_length_input'):
                data['pad_length'] = self.pad_length_input.text()
            if hasattr(self, 'pad_width_input'):
                data['pad_width'] = self.pad_width_input.text()
            if hasattr(self, 'rotation_input'):
                data['rotation'] = self.rotation_input.text()

        elif pad_type == 'custom':
            data['polygon_data'] = self.polygon_widget.get_data()

        return data

    def set_data(self, data):
        self.type_combo.setCurrentText(data.get('type', 'square'))
        self.x_offset.setText(str(data.get('x_offset', 0)))
        self.y_offset.setText(str(data.get('y_offset', 0)))
        self.mask_expansion.setText(str(data.get('mask_expansion', 0)))
        self.paste_expansion.setText(str(data.get('paste_expansion', 0)))
        self.mask_enabled.setChecked(data.get('mask_enabled', True))
        self.paste_enabled.setChecked(data.get('paste_enabled', True))
        self.pin_number.setText(str(data.get('pin_number', '1')))

        # Update options first, then set the selection
        self.update_offset_from_options()
        self.offset_from.setCurrentText(data.get('offset_from', 'origin'))

        # Set type-specific data
        pad_type = data.get('type', 'square')

        if pad_type == 'square' and hasattr(self, 'size_input'):
            self.size_input.setText(str(data.get('size', '1.0')))

        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong']:
            if hasattr(self, 'length_input'):
                self.length_input.setText(str(data.get('length', '1.0')))
            if hasattr(self, 'width_input'):
                self.width_input.setText(str(data.get('width', '1.0')))
            if pad_type == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                self.corner_radius_input.setText(str(data.get('corner_radius', '0.2')))

        elif pad_type in ['round'] and hasattr(self, 'diameter_input'):
            self.diameter_input.setText(str(data.get('diameter', '1.0')))

        elif pad_type == 'D-shape':
            if hasattr(self, 'length_input'):
                self.length_input.setText(str(data.get('length', '1.0')))
            if hasattr(self, 'width_input'):
                self.width_input.setText(str(data.get('width', '1.0')))
            if hasattr(self, 'corner_radius_input'):
                self.corner_radius_input.setText(str(data.get('corner_radius', '0.2')))
            if hasattr(self, 'rotation_input'):
                self.rotation_input.setText(str(data.get('rotation', '0')))

        elif pad_type in ['PTH', 'NPTH']:
            if hasattr(self, 'hole_diameter_input'):
                self.hole_diameter_input.setText(str(data.get('hole_diameter', '0.8')))
            if pad_type == 'PTH' and hasattr(self, 'pad_diameter_input'):
                self.pad_diameter_input.setText(str(data.get('pad_diameter', '1.2')))

        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if hasattr(self, 'hole_length_input'):
                self.hole_length_input.setText(str(data.get('hole_length', '1.5')))
            if hasattr(self, 'hole_width_input'):
                self.hole_width_input.setText(str(data.get('hole_width', '0.8')))
            if hasattr(self, 'rotation_input'):
                self.rotation_input.setText(str(data.get('rotation', '0')))
            if pad_type == 'PTH_oblong':
                if hasattr(self, 'pad_length_input'):
                    self.pad_length_input.setText(str(data.get('pad_length', '2.0')))
                if hasattr(self, 'pad_width_input'):
                    self.pad_width_input.setText(str(data.get('pad_width', '1.2')))

        elif pad_type == 'PTH_rectangle':
            if hasattr(self, 'hole_length_input'):
                self.hole_length_input.setText(str(data.get('hole_length', '1.5')))
            if hasattr(self, 'hole_width_input'):
                self.hole_width_input.setText(str(data.get('hole_width', '0.8')))
            if hasattr(self, 'pad_length_input'):
                self.pad_length_input.setText(str(data.get('pad_length', '2.0')))
            if hasattr(self, 'pad_width_input'):
                self.pad_width_input.setText(str(data.get('pad_width', '1.2')))
            if hasattr(self, 'rotation_input'):
                self.rotation_input.setText(str(data.get('rotation', '0')))

        elif pad_type == 'custom':
            self.polygon_widget.set_data(data.get('polygon_data', {}))

class CustomLayerRow(QWidget):
    delete_requested = pyqtSignal(object)
    data_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self):
        main_layout = QVBoxLayout()

    
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)

        # Create group box for this custom layer
        self.group_box = QGroupBox("Custom Layer Configuration")
        group_layout = QVBoxLayout(self.group_box)
        group_layout.setSpacing(5)

        # Row 1: Shape and Geometry
        row1_layout = QHBoxLayout()
        row1_layout.setSpacing(10)

        # Shape Group
        shape_group = QGroupBox("Shape")
        shape_layout = QHBoxLayout(shape_group)
        shape_layout.setContentsMargins(5, 5, 5, 5)

        self.shape_combo = QComboBox()
        self.shape_combo.addItems(['rectangle', 'rounded_rectangle', 'oblong', 'custom_polygon'])
        shape_layout.addWidget(self.shape_combo)
        row1_layout.addWidget(shape_group)

        # Geometry Group (Dynamic based on shape)
        self.geometry_group = QGroupBox("Geometry")
        self.geometry_layout = QHBoxLayout(self.geometry_group)
        self.geometry_layout.setContentsMargins(5, 5, 5, 5)
        row1_layout.addWidget(self.geometry_group)

        # Actions Group
        actions_group = QGroupBox("Actions")
        actions_layout = QHBoxLayout(actions_group)
        actions_layout.setContentsMargins(5, 5, 5, 5)

        self.duplicate_btn = QPushButton("Duplicate")
        self.duplicate_btn.setMaximumWidth(80)
        self.delete_btn = QPushButton("Delete")
        self.delete_btn.setMaximumWidth(60)

        actions_layout.addWidget(self.duplicate_btn)
        actions_layout.addWidget(self.delete_btn)
        row1_layout.addWidget(actions_group)

        group_layout.addLayout(row1_layout)

        # Row 2: Layer and Position
        row2_layout = QHBoxLayout()
        row2_layout.setSpacing(10)

        # Layer Group
        layer_group = QGroupBox("Layer")
        layer_layout = QHBoxLayout(layer_group)
        layer_layout.setContentsMargins(5, 5, 5, 5)

        self.layer_combo = QComboBox()
        self.layer_combo.addItems(['mask', 'paste', 'keepout'])
        layer_layout.addWidget(self.layer_combo)
        row2_layout.addWidget(layer_group)

        # Position Group
        position_group = QGroupBox("Position")
        position_layout = QGridLayout(position_group)
        position_layout.setContentsMargins(5, 5, 5, 5)

        position_layout.addWidget(QLabel("X Offset:"), 0, 0)
        self.x_offset = QLineEdit()
        self.x_offset.setText("0")
        self.x_offset.setMaximumWidth(100)
        position_layout.addWidget(self.x_offset, 0, 1)

        position_layout.addWidget(QLabel("Y Offset:"), 0, 2)
        self.y_offset = QLineEdit()
        self.y_offset.setText("0")
        self.y_offset.setMaximumWidth(100)
        position_layout.addWidget(self.y_offset, 0, 3)

        position_layout.addWidget(QLabel("Offset From:"), 1, 0)
        self.offset_from = QComboBox()
        self.offset_from.setMaximumWidth(100)
        position_layout.addWidget(self.offset_from, 1, 1, 1, 2)

        row2_layout.addWidget(position_group)
        group_layout.addLayout(row2_layout)

        # Custom polygon widget (initially hidden)
        self.polygon_widget = CustomPolygonWidget()
        self.polygon_widget.data_changed.connect(self.data_changed.emit)
        self.polygon_widget.setVisible(False)
        group_layout.addWidget(self.polygon_widget)

        main_layout.addWidget(self.group_box)
        self.setLayout(main_layout)

        # Initialize geometry inputs
        self.update_geometry_inputs()

    def connect_signals(self):
        self.shape_combo.currentTextChanged.connect(self.update_geometry_inputs)
        self.shape_combo.currentTextChanged.connect(self.data_changed.emit)
        self.delete_btn.clicked.connect(lambda: self.delete_requested.emit(self))

        # Connect all input signals
        self.x_offset.textChanged.connect(self.data_changed.emit)
        self.y_offset.textChanged.connect(self.data_changed.emit)
        self.layer_combo.currentTextChanged.connect(self.data_changed.emit)
        self.offset_from.currentTextChanged.connect(self.data_changed.emit)

    def update_geometry_inputs(self):
        # Clear existing geometry inputs
        for i in reversed(range(self.geometry_layout.count())):
            item = self.geometry_layout.itemAt(i)
            if item:
                widget = item.widget()
                if widget:
                    widget.setParent(None)

        shape = self.shape_combo.currentText()

        # Show/hide polygon widget
        self.polygon_widget.setVisible(shape == 'custom_polygon')

        if shape == 'rectangle':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

        elif shape == 'rounded_rectangle':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("1.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

            self.geometry_layout.addWidget(QLabel("Corner Radius:"))
            self.corner_radius_input = QLineEdit()
            self.corner_radius_input.setText("0.2")
            self.corner_radius_input.setMaximumWidth(100)
            self.corner_radius_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.corner_radius_input)

        elif shape == 'oblong':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QLineEdit()
            self.length_input.setText("2.0")
            self.length_input.setMaximumWidth(100)
            self.length_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)

            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QLineEdit()
            self.width_input.setText("1.0")
            self.width_input.setMaximumWidth(100)
            self.width_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)

        elif shape == 'custom_polygon':
            self.geometry_layout.addWidget(QLabel("Custom Polygon (see below)"))

        # Add stretch to push everything to the left
        self.geometry_layout.addStretch()

    def get_data(self):
        data = {
            'shape': self.shape_combo.currentText(),
            'layer': self.layer_combo.currentText(),
            'x_offset': self.x_offset.text(),
            'y_offset': self.y_offset.text(),
            'offset_from': self.offset_from.currentText()
        }

        shape = self.shape_combo.currentText()

        if shape in ['rectangle', 'rounded_rectangle', 'oblong']:
            if hasattr(self, 'length_input'):
                data['length'] = self.length_input.text()
            if hasattr(self, 'width_input'):
                data['width'] = self.width_input.text()
            if shape == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                data['corner_radius'] = self.corner_radius_input.text()

        elif shape == 'custom_polygon':
            data['polygon_data'] = self.polygon_widget.get_data()

        return data

    def set_data(self, data):
        self.shape_combo.setCurrentText(data.get('shape', 'rectangle'))
        self.layer_combo.setCurrentText(data.get('layer', 'mask'))
        self.x_offset.setText(str(data.get('x_offset', '0')))
        self.y_offset.setText(str(data.get('y_offset', '0')))
        self.offset_from.setCurrentText(data.get('offset_from', 'origin'))

        # Set shape-specific data
        shape = data.get('shape', 'rectangle')

        if shape in ['rectangle', 'rounded_rectangle', 'oblong']:
            if hasattr(self, 'length_input'):
                self.length_input.setText(str(data.get('length', '1.0')))
            if hasattr(self, 'width_input'):
                self.width_input.setText(str(data.get('width', '1.0')))
            if shape == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                self.corner_radius_input.setText(str(data.get('corner_radius', '0.2')))

        elif shape == 'custom_polygon':
            self.polygon_widget.set_data(data.get('polygon_data', {}))

class ThermalViaRow(QWidget):
    delete_requested = pyqtSignal(object)
    data_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self):
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)

        # Create group box for this thermal via
        self.group_box = QGroupBox("Thermal Via Configuration")
        group_layout = QVBoxLayout(self.group_box)
        group_layout.setSpacing(5)

        # Row 1: Type and Geometry
        row1_layout = QHBoxLayout()
        row1_layout.setSpacing(10)

        # Type Group
        type_group = QGroupBox("Type")
        type_layout = QHBoxLayout(type_group)
        type_layout.setContentsMargins(5, 5, 5, 5)

        self.type_combo = QComboBox()
        self.type_combo.addItems(['grid_array', 'single'])
        type_layout.addWidget(self.type_combo)
        row1_layout.addWidget(type_group)

        # Geometry Group (Dynamic based on type)
        self.geometry_group = QGroupBox("Geometry")
        self.geometry_layout = QHBoxLayout(self.geometry_group)
        self.geometry_layout.setContentsMargins(5, 5, 5, 5)
        row1_layout.addWidget(self.geometry_group)

        # Actions Group
        actions_group = QGroupBox("Actions")
        actions_layout = QHBoxLayout(actions_group)
        actions_layout.setContentsMargins(5, 5, 5, 5)

        self.duplicate_btn = QPushButton("Duplicate")
        self.duplicate_btn.setMaximumWidth(80)
        self.delete_btn = QPushButton("Delete")
        self.delete_btn.setMaximumWidth(60)

        actions_layout.addWidget(self.duplicate_btn)
        actions_layout.addWidget(self.delete_btn)
        row1_layout.addWidget(actions_group)

        group_layout.addLayout(row1_layout)

        # Row 2: Position
        row2_layout = QHBoxLayout()
        row2_layout.setSpacing(10)

        # Position Group
        # Position Group
        position_group = QGroupBox("Position")
        position_layout = QGridLayout(position_group)
        position_layout.setContentsMargins(5, 5, 5, 5)
        
        position_layout.addWidget(QLabel("X Offset:"), 0, 0)
        self.x_offset = QLineEdit()
        self.x_offset.setText("0")
        self.x_offset.setMaximumWidth(100)
        position_layout.addWidget(self.x_offset, 0, 1)
        
        position_layout.addWidget(QLabel("Y Offset:"), 0, 2)
        self.y_offset = QLineEdit()
        self.y_offset.setText("0")
        self.y_offset.setMaximumWidth(100)
        position_layout.addWidget(self.y_offset, 0, 3)
        
        position_layout.addWidget(QLabel("Offset From:"), 1, 0)
        self.offset_from = QComboBox()
        self.offset_from.setMaximumWidth(100)
        position_layout.addWidget(self.offset_from, 1, 1, 1, 2)
        
        # ADD THIS NEW PIN NUMBER FIELD:
        position_layout.addWidget(QLabel("Via Pin:"), 1, 3)
        self.pin_number = QLineEdit()
        self.pin_number.setMaximumWidth(50)
        position_layout.addWidget(self.pin_number, 1, 4)
        
        row2_layout.addWidget(position_group)
        group_layout.addLayout(row2_layout)

        main_layout.addWidget(self.group_box)
        self.setLayout(main_layout)

        # Initialize geometry inputs
        self.update_geometry_inputs()

    def connect_signals(self):
        self.type_combo.currentTextChanged.connect(self.update_geometry_inputs)
        self.type_combo.currentTextChanged.connect(self.data_changed.emit)
        self.delete_btn.clicked.connect(lambda: self.delete_requested.emit(self))

        # Connect all input signals
        self.x_offset.textChanged.connect(self.data_changed.emit)
        self.y_offset.textChanged.connect(self.data_changed.emit)
        self.offset_from.currentTextChanged.connect(self.data_changed.emit)
        
        # ADD THESE NEW SIGNAL CONNECTIONS:
        self.pin_number.textChanged.connect(self.update_offset_from_options)
        self.pin_number.textChanged.connect(self.data_changed.emit)

    def update_offset_from_options(self):
        """Update offset_from options when pin number changes"""
        parent_designer = self.get_parent_designer()
        if parent_designer:
            parent_designer.update_all_offset_dropdowns()

    def get_parent_designer(self):
        """Find the parent FootprintDesigner instance"""
        parent = self.parent()
        while parent:
            if hasattr(parent, 'thermal_via_rows'):
                return parent
            parent = parent.parent()
        return None


    def update_geometry_inputs(self):
        # Clear existing geometry inputs
        for i in reversed(range(self.geometry_layout.count())):
            item = self.geometry_layout.itemAt(i)
            if item:
                widget = item.widget()
                if widget:
                    widget.setParent(None)

        via_type = self.type_combo.currentText()

        if via_type == 'single':
            self.geometry_layout.addWidget(QLabel("Via Diameter:"))
            self.via_diameter_input = QLineEdit()
            self.via_diameter_input.setText("0.2")
            self.via_diameter_input.setMaximumWidth(100)
            self.via_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.via_diameter_input)

            self.geometry_layout.addWidget(QLabel("Drill Diameter:"))
            self.drill_diameter_input = QLineEdit()
            self.drill_diameter_input.setText("0.1")
            self.drill_diameter_input.setMaximumWidth(100)
            self.drill_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.drill_diameter_input)

        elif via_type == 'grid_array':
            self.geometry_layout.addWidget(QLabel("Rows:"))
            self.rows_input = QLineEdit()
            self.rows_input.setText("2")
            self.rows_input.setMaximumWidth(80)
            self.rows_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.rows_input)

            self.geometry_layout.addWidget(QLabel("Columns:"))
            self.columns_input = QLineEdit()
            self.columns_input.setText("2")
            self.columns_input.setMaximumWidth(80)
            self.columns_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.columns_input)

            self.geometry_layout.addWidget(QLabel("Row Spacing:"))
            self.row_spacing_input = QLineEdit()
            self.row_spacing_input.setText("1.0")
            self.row_spacing_input.setMaximumWidth(100)
            self.row_spacing_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.row_spacing_input)

            self.geometry_layout.addWidget(QLabel("Col Spacing:"))
            self.col_spacing_input = QLineEdit()
            self.col_spacing_input.setText("1.0")
            self.col_spacing_input.setMaximumWidth(100)
            self.col_spacing_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.col_spacing_input)

            self.geometry_layout.addWidget(QLabel("Via Diameter:"))
            self.via_diameter_input = QLineEdit()
            self.via_diameter_input.setText("0.2")
            self.via_diameter_input.setMaximumWidth(100)
            self.via_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.via_diameter_input)

            self.geometry_layout.addWidget(QLabel("Drill Diameter:"))
            self.drill_diameter_input = QLineEdit()
            self.drill_diameter_input.setText("0.1")
            self.drill_diameter_input.setMaximumWidth(100)
            self.drill_diameter_input.textChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.drill_diameter_input)

        # Add stretch to push everything to the left
        self.geometry_layout.addStretch()


        

    def get_data(self):
        data = {
            'type': self.type_combo.currentText(),
            'x_offset': self.x_offset.text(),
            'y_offset': self.y_offset.text(),
            'offset_from': self.offset_from.currentText(),
            'pin_number': self.pin_number.text()  # ADD THIS LINE
        }

        via_type = self.type_combo.currentText()

        if via_type == 'single':
            if hasattr(self, 'via_diameter_input'):
                data['via_diameter'] = self.via_diameter_input.text()
            if hasattr(self, 'drill_diameter_input'):
                data['drill_diameter'] = self.drill_diameter_input.text()

        elif via_type == 'grid_array':
            if hasattr(self, 'rows_input'):
                data['rows'] = self.rows_input.text()
            if hasattr(self, 'columns_input'):
                data['columns'] = self.columns_input.text()
            if hasattr(self, 'row_spacing_input'):
                data['row_spacing'] = self.row_spacing_input.text()
            if hasattr(self, 'col_spacing_input'):
                data['col_spacing'] = self.col_spacing_input.text()
            if hasattr(self, 'via_diameter_input'):
                data['via_diameter'] = self.via_diameter_input.text()
            if hasattr(self, 'drill_diameter_input'):
                data['drill_diameter'] = self.drill_diameter_input.text()

        return data

    def set_data(self, data):
        self.type_combo.setCurrentText(data.get('type', 'single'))
        self.x_offset.setText(str(data.get('x_offset', '0')))
        self.y_offset.setText(str(data.get('y_offset', '0')))
        self.offset_from.setCurrentText(data.get('offset_from', 'origin'))
        self.pin_number.setText(str(data.get('pin_number', 'V1')))  # ADD THIS LINE

        # Set type-specific data
        via_type = data.get('type', 'single')

        if via_type == 'single':
            if hasattr(self, 'via_diameter_input'):
                self.via_diameter_input.setText(str(data.get('via_diameter', '0.2')))
            if hasattr(self, 'drill_diameter_input'):
                self.drill_diameter_input.setText(str(data.get('drill_diameter', '0.1')))

        elif via_type == 'grid_array':
            if hasattr(self, 'rows_input'):
                self.rows_input.setText(str(data.get('rows', '2')))
            if hasattr(self, 'columns_input'):
                self.columns_input.setText(str(data.get('columns', '2')))
            if hasattr(self, 'row_spacing_input'):
                self.row_spacing_input.setText(str(data.get('row_spacing', '1.0')))
            if hasattr(self, 'col_spacing_input'):
                self.col_spacing_input.setText(str(data.get('col_spacing', '1.0')))
            if hasattr(self, 'via_diameter_input'):
                self.via_diameter_input.setText(str(data.get('via_diameter', '0.2')))
            if hasattr(self, 'drill_diameter_input'):
                self.drill_diameter_input.setText(str(data.get('drill_diameter', '0.1')))

class SettingsPanel(QWidget):
    settings_changed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_user = None
        self.setup_ui()
        self.setup_styling()

    def setup_ui(self):
        # Create main layout with scroll area
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(5, 5, 5, 5)
        
        # Create scroll area
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)

        
        # Create scrollable content widget
        content_widget = QWidget()
        layout = QVBoxLayout(content_widget)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(15)

        # Title
        title = QLabel("Settings")
        title.setStyleSheet("font-size: 16px; font-weight: bold; color: #ffffff; margin-bottom: 10px;")
        layout.addWidget(title)

        # All existing sections
        self.setup_user_section(layout)
        self.add_separator(layout)
        self.setup_body_settings(layout)
        self.add_separator(layout)
        self.setup_courtyard_settings(layout)
        self.add_separator(layout)
        self.setup_silkscreen_settings(layout)
        self.add_separator(layout)
        self.setup_fiducial_settings(layout)  # NEW
        self.add_separator(layout)
        self.setup_script_settings(layout)
        self.setup_text_settings(layout)

        layout.addStretch()
        
        # Set the content widget to scroll area
        scroll_area.setWidget(content_widget)
        main_layout.addWidget(scroll_area)

    def add_separator(self, layout):
        """Add a separator line"""
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setStyleSheet("color: #555;")
        layout.addWidget(separator)

    def setup_text_settings(self, layout):
        """Setup text formatting settings"""
        text_group = QGroupBox("Text Settings")
        text_layout = QGridLayout(text_group)
        
        text_layout.addWidget(QLabel("Text Height (mm):"), 0, 0)
        self.text_height = QLineEdit()
        self.text_height.setText("0.5")
        self.text_height.textChanged.connect(self.settings_changed.emit)
        text_layout.addWidget(self.text_height, 0, 1)
        
        text_layout.addWidget(QLabel("Text Width (mm):"), 1, 0)
        self.text_width = QLineEdit()
        self.text_width.setText("0.1")
        self.text_width.textChanged.connect(self.settings_changed.emit)
        text_layout.addWidget(self.text_width, 1, 1)
        
        text_layout.addWidget(QLabel("Text Line Width:"), 2, 0)
        self.text_line_width = QLineEdit()
        self.text_line_width.setText("1.8")
        self.text_line_width.textChanged.connect(self.settings_changed.emit)
        text_layout.addWidget(self.text_line_width, 2, 1)
        
        layout.addWidget(text_group)

    def setup_user_section(self, layout):
        user_group = QGroupBox("User Account")
        user_layout = QVBoxLayout(user_group)

        # User display/login
        self.user_display = QLabel("Not logged in")
        self.user_display.setStyleSheet("color: #ffffff; margin: 5px;")
        user_layout.addWidget(self.user_display)

        # Login form (initially visible)
        self.login_frame = QFrame()
        login_layout = QGridLayout(self.login_frame)

        login_layout.addWidget(QLabel("Username:"), 0, 0)
        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter username")
        login_layout.addWidget(self.username_input, 0, 1)

        login_layout.addWidget(QLabel("Password:"), 1, 0)
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText("Enter password")
        login_layout.addWidget(self.password_input, 1, 1)

        self.login_btn = QPushButton("Login")
        self.login_btn.clicked.connect(self.handle_login)
        login_layout.addWidget(self.login_btn, 2, 0, 1, 2)

        user_layout.addWidget(self.login_frame)

        # Logout button (initially hidden)
        self.logout_btn = QPushButton("Logout")
        self.logout_btn.clicked.connect(self.handle_logout)
        self.logout_btn.setVisible(False)
        user_layout.addWidget(self.logout_btn)

        layout.addWidget(user_group)

    def setup_body_settings(self, layout):
        body_group = QGroupBox("Body Settings")
        body_layout = QGridLayout(body_group)

        body_layout.addWidget(QLabel("Body Line Width:"), 0, 0)
        self.body_line_width = QLineEdit()
        self.body_line_width.setText("1.5")
        self.body_line_width.textChanged.connect(self.settings_changed.emit)
        body_layout.addWidget(self.body_line_width, 0, 1)

        layout.addWidget(body_group)

    def setup_courtyard_settings(self, layout):
        courtyard_group = QGroupBox("Courtyard Settings")
        courtyard_layout = QGridLayout(courtyard_group)

        courtyard_layout.addWidget(QLabel("Courtyard Expansion:"), 0, 0)
        self.courtyard_expansion = QLineEdit()
        self.courtyard_expansion.setText("0.25")
        self.courtyard_expansion.textChanged.connect(self.settings_changed.emit)
        courtyard_layout.addWidget(self.courtyard_expansion, 0, 1)

        courtyard_layout.addWidget(QLabel("Courtyard Line Width:"), 1, 0)
        self.courtyard_line_width = QLineEdit()
        self.courtyard_line_width.setText("0.1")
        self.courtyard_line_width.textChanged.connect(self.settings_changed.emit)
        courtyard_layout.addWidget(self.courtyard_line_width, 1, 1)

        layout.addWidget(courtyard_group)

    def setup_silkscreen_settings(self, layout):
        silkscreen_group = QGroupBox("Silkscreen Settings")
        silkscreen_layout = QGridLayout(silkscreen_group)

        silkscreen_layout.addWidget(QLabel("Silkscreen Airgap:"), 0, 0)
        self.silkscreen_airgap = QLineEdit()
        self.silkscreen_airgap.setText("0.15")
        self.silkscreen_airgap.textChanged.connect(self.settings_changed.emit)
        silkscreen_layout.addWidget(self.silkscreen_airgap, 0, 1)

        silkscreen_layout.addWidget(QLabel("Silkscreen Line Width:"), 1, 0)
        self.silkscreen_line_width = QLineEdit()
        self.silkscreen_line_width.setText("0.15")
        self.silkscreen_line_width.textChanged.connect(self.settings_changed.emit)
        silkscreen_layout.addWidget(self.silkscreen_line_width, 1, 1)

        layout.addWidget(silkscreen_group)

    def setup_script_settings(self, layout):
        script_group = QGroupBox("Script Output Settings")
        script_layout = QGridLayout(script_group)

        script_layout.addWidget(QLabel("Altium Script Output Path:"), 0, 0)
        path_layout = QHBoxLayout()

        self.script_output_path = QLineEdit()
        self.script_output_path.setPlaceholderText("Select output directory...")
        self.script_output_path.setText(os.path.expanduser("~/Documents"))
        path_layout.addWidget(self.script_output_path)

        browse_btn = QPushButton("Browse...")
        browse_btn.clicked.connect(self.browse_output_path)
        browse_btn.setMaximumWidth(80)
        path_layout.addWidget(browse_btn)

        script_layout.addLayout(path_layout, 0, 1)
        layout.addWidget(script_group)

    def browse_output_path(self):
        path = QFileDialog.getExistingDirectory(
            self,
            "Select Script Output Directory",
            self.script_output_path.text()
        )

        if path:
            self.script_output_path.setText(path)
            self.settings_changed.emit()

    def handle_login(self):
        username = self.username_input.text().strip()
        password = self.password_input.text().strip()

        if not username or not password:
            QMessageBox.warning(self, "Login", "Please enter both username and password")
            return

        # Simple mock authentication - replace with real authentication
        if username and password: # Accept any non-empty credentials for demo
            self.current_user = username
            self.user_display.setText(f"Welcome, {username}")
            self.login_frame.setVisible(False)
            self.logout_btn.setVisible(True)

            # Clear password for security
            self.password_input.clear()
            QMessageBox.information(self, "Login", f"Successfully logged in as {username}")
        else:
            QMessageBox.warning(self, "Login", "Invalid credentials")

    def handle_logout(self):
        self.current_user = None
        self.user_display.setText("Not logged in")
        self.login_frame.setVisible(True)
        self.logout_btn.setVisible(False)
        self.username_input.clear()
        self.password_input.clear()

    def setup_styling(self):
        self.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLabel {
                color: #ffffff;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
                color: #ffffff;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
        """)

    def setup_fiducial_settings(self, layout):
        """Setup fiducial settings with keepout"""
        fiducial_group = QGroupBox("Fiducial Settings")
        fiducial_layout = QGridLayout(fiducial_group)
        
        fiducial_layout.addWidget(QLabel("Fiducial Pad Diameter (mm):"), 0, 0)
        self.fiducial_diameter = QLineEdit()
        self.fiducial_diameter.setText("1.0")
        self.fiducial_diameter.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_diameter, 0, 1)

        fiducial_layout.addWidget(QLabel("Mask Opening (mm):"), 1, 0)
        self.fiducial_mask_opening = QLineEdit()
        self.fiducial_mask_opening.setText("2.0")
        self.fiducial_mask_opening.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_mask_opening, 1, 1)

        # NEW: Keepout diameter setting
        fiducial_layout.addWidget(QLabel("Keepout Diameter (mm):"), 2, 0)
        self.fiducial_keepout_diameter = QLineEdit()
        self.fiducial_keepout_diameter.setText("3.0")
        self.fiducial_keepout_diameter.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_keepout_diameter, 2, 1)

        fiducial_layout.addWidget(QLabel("X Offset from Body Corner:"), 3, 0)
        self.fiducial_x_offset = QLineEdit()
        self.fiducial_x_offset.setText("2.0")
        self.fiducial_x_offset.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_x_offset, 3, 1)

        fiducial_layout.addWidget(QLabel("Y Offset from Body Corner:"), 4, 0)
        self.fiducial_y_offset = QLineEdit()
        self.fiducial_y_offset.setText("2.0")
        self.fiducial_y_offset.textChanged.connect(self.settings_changed.emit)
        fiducial_layout.addWidget(self.fiducial_y_offset, 4, 1)

        layout.addWidget(fiducial_group)

    def setup_script_settings(self, layout):
        """Enhanced script settings with multiple CAD tool support"""
        script_group = QGroupBox("Script Output Settings")
        script_layout = QGridLayout(script_group)

        # Altium Script Output Path
        script_layout.addWidget(QLabel("Altium Script Output:"), 0, 0)
        path_layout1 = QHBoxLayout()
        self.altium_output_path = QLineEdit()
        self.altium_output_path.setPlaceholderText("Select Altium output directory...")
        self.altium_output_path.setText(os.path.expanduser("~/Documents/Altium"))
        path_layout1.addWidget(self.altium_output_path)
        browse_btn1 = QPushButton("Browse...")
        browse_btn1.clicked.connect(lambda: self.browse_output_path(self.altium_output_path, "Altium"))
        browse_btn1.setMaximumWidth(80)
        path_layout1.addWidget(browse_btn1)
        script_layout.addLayout(path_layout1, 0, 1)

        # Allegro Script Output Path
        script_layout.addWidget(QLabel("Allegro Script Output:"), 1, 0)
        path_layout2 = QHBoxLayout()
        self.allegro_output_path = QLineEdit()
        self.allegro_output_path.setPlaceholderText("Select Allegro output directory...")
        self.allegro_output_path.setText(os.path.expanduser("~/Documents/Allegro"))
        path_layout2.addWidget(self.allegro_output_path)
        browse_btn2 = QPushButton("Browse...")
        browse_btn2.clicked.connect(lambda: self.browse_output_path(self.allegro_output_path, "Allegro"))
        browse_btn2.setMaximumWidth(80)
        path_layout2.addWidget(browse_btn2)
        script_layout.addLayout(path_layout2, 1, 1)

        # PADS Script Output Path
        script_layout.addWidget(QLabel("PADS Script Output:"), 2, 0)
        path_layout3 = QHBoxLayout()
        self.pads_output_path = QLineEdit()
        self.pads_output_path.setPlaceholderText("Select PADS output directory...")
        self.pads_output_path.setText(os.path.expanduser("~/Documents/PADS"))
        path_layout3.addWidget(self.pads_output_path)
        browse_btn3 = QPushButton("Browse...")
        browse_btn3.clicked.connect(lambda: self.browse_output_path(self.pads_output_path, "PADS"))
        browse_btn3.setMaximumWidth(80)
        path_layout3.addWidget(browse_btn3)
        script_layout.addLayout(path_layout3, 2, 1)

        # Xpedition Script Output Path
        script_layout.addWidget(QLabel("Xpedition Script Output:"), 3, 0)
        path_layout4 = QHBoxLayout()
        self.xpedition_output_path = QLineEdit()
        self.xpedition_output_path.setPlaceholderText("Select Xpedition output directory...")
        self.xpedition_output_path.setText(os.path.expanduser("~/Documents/Xpedition"))
        path_layout4.addWidget(self.xpedition_output_path)
        browse_btn4 = QPushButton("Browse...")
        browse_btn4.clicked.connect(lambda: self.browse_output_path(self.xpedition_output_path, "Xpedition"))
        browse_btn4.setMaximumWidth(80)
        path_layout4.addWidget(browse_btn4)
        script_layout.addLayout(path_layout4, 3, 1)

        layout.addWidget(script_group)

    def browse_output_path(self, line_edit, tool_name):
        """Browse for output path"""
        path = QFileDialog.getExistingDirectory(
            self,
            f"Select {tool_name} Script Output Directory",
            line_edit.text()
        )
        if path:
            line_edit.setText(path)
            self.settings_changed.emit()

    def get_settings(self):
        return {
            'body_line_width': self.body_line_width.text(),
            'courtyard_expansion': self.courtyard_expansion.text(),
            'courtyard_line_width': self.courtyard_line_width.text(),
            'silkscreen_airgap': self.silkscreen_airgap.text(),
            'silkscreen_line_width': self.silkscreen_line_width.text(),
            'altium_output_path': self.altium_output_path.text(),
            'allegro_output_path': self.allegro_output_path.text(),
            'pads_output_path': self.pads_output_path.text(),
            'xpedition_output_path': self.xpedition_output_path.text(),
            'text_height': self.text_height.text(),
            'text_width': self.text_width.text(),
            'text_line_width': self.text_line_width.text(),
            'fiducial_diameter': self.fiducial_diameter.text(),
            'fiducial_mask_opening': self.fiducial_mask_opening.text(),
            'fiducial_keepout_diameter': self.fiducial_keepout_diameter.text(),  # NEW
            'fiducial_x_offset': self.fiducial_x_offset.text(),
            'fiducial_y_offset': self.fiducial_y_offset.text(),
            'current_user': self.current_user
        }

    def set_settings(self, settings):
        self.body_line_width.setText(str(settings.get('body_line_width', '1.5')))
        self.courtyard_expansion.setText(str(settings.get('courtyard_expansion', '0.25')))
        self.courtyard_line_width.setText(str(settings.get('courtyard_line_width', '0.1')))
        self.silkscreen_airgap.setText(str(settings.get('silkscreen_airgap', '0.15')))
        self.silkscreen_line_width.setText(str(settings.get('silkscreen_line_width', '0.15')))
        self.altium_output_path.setText(str(settings.get('altium_output_path', os.path.expanduser("~/Documents/Altium"))))
        self.allegro_output_path.setText(str(settings.get('allegro_output_path', os.path.expanduser("~/Documents/Allegro"))))
        self.pads_output_path.setText(str(settings.get('pads_output_path', os.path.expanduser("~/Documents/PADS"))))
        self.xpedition_output_path.setText(str(settings.get('xpedition_output_path', os.path.expanduser("~/Documents/Xpedition"))))
        self.text_height.setText(str(settings.get('text_height', '0.5')))
        self.text_width.setText(str(settings.get('text_width', '0.1')))
        self.text_line_width.setText(str(settings.get('text_line_width', '1.8')))
        self.fiducial_diameter.setText(str(settings.get('fiducial_diameter', '1.0')))
        self.fiducial_mask_opening.setText(str(settings.get('fiducial_mask_opening', '2.0')))
        self.fiducial_keepout_diameter.setText(str(settings.get('fiducial_keepout_diameter', '3.0')))
        self.fiducial_x_offset.setText(str(settings.get('fiducial_x_offset', '2.0')))
        self.fiducial_y_offset.setText(str(settings.get('fiducial_y_offset', '2.0')))
        
        user = settings.get('current_user')
        if user:
            self.current_user = user
            self.user_display.setText(f"Welcome, {user}")
            self.login_frame.setVisible(False)
            self.logout_btn.setVisible(True)


class UpdateThread(QThread):
    update_signal = pyqtSignal(dict)

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.running = True

    def run(self):
        while self.running:
            data = self.main_window.get_footprint_data()
            self.update_signal.emit(data)
            self.msleep(100) # Update every 100ms

    def stop(self):
        self.running = False

class FootprintDesigner(QMainWindow):
    def __init__(self):
        super().__init__()
        self.padstack_rows = []
        self.custom_layer_rows = []
        self.thermal_via_rows = []
        self.current_save_file = None
        self.auto_update_origin = True
        self.fiducials_enabled = False  # NEW
        self.setup_ui()
        self.setup_dark_theme()
        self.start_update_thread()
        self.load_app_settings()  # NEW




    def setup_dark_theme(self):
        self.setStyleSheet("""
            QMainWindow {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLineEdit, QDoubleSpinBox, QSpinBox, QComboBox {
                background-color: #3c3c3c;
                border: 1px solid #555;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
            QScrollArea {
                background-color: #2b2b2b;
                border: none;
            }
            QFrame {
                border: 1px solid #555;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
            }
            QToolBar {
                background-color: #3c3c3c;
                border: 1px solid #555;
                spacing: 3px;
            }
            QToolBar::separator {
                width: 2px;
                background-color: #555;
                margin: 0 5px;
            }
        """)

    def setup_ui(self):
        self.setWindowTitle("Footprint Designer")
        self.setGeometry(100, 100, 1400, 800)
        self.showMaximized()

        # Create toolbar
        self.create_toolbar()

        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main splitter (3 panels: left, center, right)
        main_splitter = QSplitter(Qt.Orientation.Horizontal)
        central_widget.setLayout(QHBoxLayout())
        central_widget.layout().addWidget(main_splitter)

        # Left panel
        left_panel = self.create_left_panel()
        main_splitter.addWidget(left_panel)

        # Center panel (renderer)
        self.renderer = FootprintRenderer()
        main_splitter.addWidget(self.renderer)
        self.renderer.footprint_designer_ref = self
    

        # Initialize renderer with proper origin values
        self.update_renderer_origin()

        


        # Right panel (settings) - initially hidden
        self.settings_panel = SettingsPanel()
        self.settings_panel.settings_changed.connect(self.on_settings_changed)
        self.settings_panel.setVisible(False)
        self.settings_panel.setMaximumWidth(350)
        self.settings_panel.setMinimumWidth(300)
        main_splitter.addWidget(self.settings_panel)

        # Set initial splitter proportions
        main_splitter.setSizes([800, 700, 0]) # Left, Center, Right (hidden)

    def create_toolbar(self):
        """Create toolbar with left and right aligned buttons"""
        toolbar = QToolBar()
        self.addToolBar(toolbar)

        # Left side buttons
        toolbar.addAction("New", self.new_footprint)
        toolbar.addAction("Save", self.save_data)
        toolbar.addAction("Save As", self.save_data_as)
        toolbar.addAction("Open", self.load_data)
        
        # Add dropdown for script generation
        self.script_combo = QComboBox()
        self.script_combo.addItems(["Altium", "Allegro", "PADS", "Xpedition"])
        self.script_combo.setMaximumWidth(100)
        toolbar.addWidget(QLabel("Generate:"))
        toolbar.addWidget(self.script_combo)
        toolbar.addAction("Script", self.generate_footprint_script)
        
        toolbar.addSeparator()

        # Show Silkscreen toggle action
        self.silkscreen_action = toolbar.addAction("Show Silkscreen", self.toggle_silkscreen)
        self.silkscreen_action.setCheckable(True)
        self.silkscreen_action.setChecked(True)
        
        # Add Fiducial toggle
        self.fiducial_action = toolbar.addAction("+ Add Fiducial", self.toggle_fiducials)
        self.fiducial_action.setCheckable(True)
        self.fiducial_action.setChecked(False)
        
        toolbar.addSeparator()

        toolbar.addAction("+ Add Padstack", self.add_padstack_row)
        toolbar.addAction("+ Custom Layer", self.add_custom_layer_row)
        toolbar.addAction("+ Thermal Via", self.add_thermal_via_row)
        
        toolbar.addSeparator()
        toolbar.addAction("Fit to View", self.fit_to_view)

        # Add stretch to push Settings to the right
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        toolbar.addWidget(spacer)

        # Right side button
        toolbar.addAction("Settings", self.toggle_settings_panel)

    def toggle_silkscreen(self):
        """Toggle silkscreen visibility"""
        self.on_data_changed()

    def toggle_fiducials(self):
        """Toggle fiducial visibility"""
        self.fiducials_enabled = self.fiducial_action.isChecked()
        self.on_data_changed()

    def load_app_settings(self):
        """Load application settings"""
        settings = SettingsManager.load_settings()
        self.settings_panel.set_settings(settings)

    def save_app_settings(self):
        """Save application settings"""
        settings = self.settings_panel.get_settings()
        SettingsManager.save_settings(settings)


    def toggle_settings_panel(self):
        """Toggle the visibility of settings panel"""
        is_visible = self.settings_panel.isVisible()
        self.settings_panel.setVisible(not is_visible)

        # Adjust splitter sizes
        if not is_visible:
            # Show settings panel
            self.centralWidget().layout().itemAt(0).widget().setSizes([700, 600, 300])
        else:
            # Hide settings panel
            self.centralWidget().layout().itemAt(0).widget().setSizes([800, 700, 0])

    def on_settings_changed(self):
        """Handle settings changes"""
        # Update renderer with new settings
        self.renderer.update()

    def create_left_panel(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Header section
        header_frame = QFrame()
        header_frame.setFrameStyle(QFrame.Shape.StyledPanel)
        header_layout = QGridLayout(header_frame)

        # Header inputs - Row 0
        header_layout.addWidget(QLabel("Part Number:"), 0, 0)
        self.part_number = QLineEdit()
        header_layout.addWidget(self.part_number, 0, 1, 1, 2)
        header_layout.addWidget(QLabel("Footprint Name:"), 0, 3)
        self.footprint_name = QLineEdit()
        header_layout.addWidget(self.footprint_name, 0, 4, 1, 2)

        # Row 1 - Body dimensions and Origin Offset controls
        header_layout.addWidget(QLabel("Body Length:"), 1, 0)
        self.body_length = QLineEdit()
        self.body_length.setText("5.0")
        header_layout.addWidget(self.body_length, 1, 1)
        
        header_layout.addWidget(QLabel("Body Width:"), 1, 2)
        self.body_width = QLineEdit()
        self.body_width.setText("3.0")
        header_layout.addWidget(self.body_width, 1, 3)

        # NEW: Origin offset from top-left corner
        header_layout.addWidget(QLabel("Origin X Offset:"), 1, 4)
        self.origin_offset_x_input = QLineEdit()
        self.origin_offset_x_input.setText("2.5")  # Default to length/2
        header_layout.addWidget(self.origin_offset_x_input, 1, 5)

        # Row 2 - Body Height, Shape, and Y offset
        header_layout.addWidget(QLabel("Body Height:"), 2, 0)
        self.body_height = QLineEdit()
        self.body_height.setText("1.0")
        header_layout.addWidget(self.body_height, 2, 1)

        header_layout.addWidget(QLabel("Body Shape:"), 2, 2)
        self.body_shape_combobox = QComboBox()
        self.body_shape_combobox.addItems(["rectangle", "round"])
        self.body_shape_combobox.setCurrentIndex(0)
        header_layout.addWidget(self.body_shape_combobox, 2, 3)

        header_layout.addWidget(QLabel("Origin Y Offset:"), 2, 4)
        self.origin_offset_y_input = QLineEdit()
        self.origin_offset_y_input.setText("1.5")  # Default to width/2
        header_layout.addWidget(self.origin_offset_y_input, 2, 5)

        layout.addWidget(header_frame)

        # Auto-update tracking
        self.auto_update_origin = True

        # Connect signals
        self.body_length.textChanged.connect(self.on_body_dimensions_changed)
        self.body_width.textChanged.connect(self.on_body_dimensions_changed)
        self.origin_offset_x_input.textChanged.connect(self.on_origin_manual_change)
        self.origin_offset_y_input.textChanged.connect(self.on_origin_manual_change)
        
        # Other connections
        self.part_number.textChanged.connect(self.on_data_changed)
        self.footprint_name.textChanged.connect(self.on_data_changed)
        self.body_height.textChanged.connect(self.on_data_changed)
        self.body_shape_combobox.currentTextChanged.connect(self.on_data_changed)

        # Rest of the method (scroll area, etc.)
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.container = QWidget()
        self.container_layout = QVBoxLayout(self.container)
        self.container_layout.addStretch()
        scroll_area.setWidget(self.container)
        layout.addWidget(scroll_area)

        # Initialize origin offset
        self.update_origin_offset_values()
        
        # Add initial padstack
        self.add_padstack_row()
        
        return widget

    def on_origin_manual_change(self):
        """Handle manual changes to origin offset - disable auto-update"""
        self.auto_update_origin = False
        self.update_renderer_origin()
        self.on_data_changed()

    def on_body_dimensions_changed(self):
        """Handle body dimension changes - auto-update origin if enabled"""
        if self.auto_update_origin:
            self.update_origin_offset_values()
        self.update_renderer_origin()
        self.on_data_changed()

    def update_origin_offset_values(self):
        """Update origin offset values based on body dimensions"""
        try:
            length = float(self.body_length.text())
            width = float(self.body_width.text())
        except (ValueError, TypeError):
            length = 5.0
            width = 3.0

        # Set offset to center of body (length/2, width/2)+
        x_offset = -length / 2
        y_offset = width / 2

        # Block signals to prevent triggering manual change handler
        self.origin_offset_x_input.blockSignals(True)
        self.origin_offset_y_input.blockSignals(True)
        
        self.origin_offset_x_input.setText(f"{x_offset}")
        self.origin_offset_y_input.setText(f"{y_offset}")
        
        self.origin_offset_x_input.blockSignals(False)
        self.origin_offset_y_input.blockSignals(False)
        
        # Re-enable auto-update since this was programmatic
        self.auto_update_origin = True

    def update_renderer_origin(self):
        """Update the renderer with current origin offset values"""
        try:
            x_offset = float(self.origin_offset_x_input.text())
            y_offset = float(self.origin_offset_y_input.text())
        except (ValueError, TypeError):
            x_offset = y_offset = 0.0

        if hasattr(self, 'renderer'):
            self.renderer.origin_offset_x = x_offset
            self.renderer.origin_offset_y = y_offset
            self.renderer.update()



    def on_origin_offset_inputs_changed(self):
        """Handle changes to origin offset input fields"""
        # Always update if the inputs are enabled (regardless of checkbox state)
        if self.origin_offset_x_input.isEnabled() or self.origin_offset_y_input.isEnabled():
            self.update_origin_offset_from_inputs()
        
        # Also trigger general data change
        self.on_data_changed()



    def new_footprint(self):
        """Create a new footprint (reset all fields)"""
        reply = QMessageBox.question(
            self,
            'New Footprint',
            'Are you sure you want to create a new footprint? All current data will be lost.',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            # Clear current file path
            self.current_save_file = None

            # Clear all input fields
            self.part_number.setText('')
            self.footprint_name.setText('')
            self.body_length.setText('5.0')
            self.body_width.setText('3.0')
            self.body_height.setText('1.0')
            self.body_shape_combobox.setCurrentIndex(0)

            # Set default origin offset values
            self.origin_offset_x_input.setText("-2.5")  # Default to length/2
            self.origin_offset_y_input.setText("1.5")  # Default to width/2
            self.auto_update_origin = True
            self.update_origin_offset_values()


            # Reset silkscreen action
            self.silkscreen_action.setChecked(True)
          
            default_settings = {
                'body_line_width': '1.5',
                'courtyard_expansion': '0.25',
                'courtyard_line_width': '0.1',
                'silkscreen_airgap': '0.15',
                'silkscreen_line_width': '0.15',
                'script_output_path': os.path.expanduser("~/Documents"),
                'current_user': None
            }
            self.settings_panel.set_settings(default_settings)

            # Clear all padstacks
            for row in self.padstack_rows[:]:
                self.delete_padstack_row(row)

            # Clear all custom layers
            for row in self.custom_layer_rows[:]:
                self.delete_custom_layer_row(row)

            # Clear all thermal vias
            for row in self.thermal_via_rows[:]:
                self.delete_thermal_via_row(row)

            # Add one default padstack
            self.add_padstack_row()

    def save_data_as(self):
        """Save footprint data with new filename"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Save Footprint As", "",
            "LibSienna Footprint Files (*.LibSienna);;All Files (*)"
        )
        
        if filename:
            # Ensure consistent file extension (case-insensitive check)
            if not filename.lower().endswith('.libsienna'):
                filename += '.LibSienna'
                
            self.current_save_file = filename
            data = self.get_footprint_data()
            success = LibSiennaFileFormat.save_footprint(data, filename)
            if success:
                # Also save app settings
                self.save_app_settings()
                QMessageBox.information(self, "Success", f"Footprint saved successfully as {os.path.basename(filename)}!")
            else:
                QMessageBox.critical(self, "Error", "Failed to save footprint file!")


    def save_data(self):
        """Save footprint data and app settings"""
        # Save footprint data to LibSienna file
        if self.current_save_file is None:
            self.save_data_as()
        else:
            data = self.get_footprint_data()
            success = LibSiennaFileFormat.save_footprint(data, self.current_save_file)
            if success:
                # Also save app settings
                self.save_app_settings()
                QMessageBox.information(self, "Success", f"Footprint updated successfully!\n{os.path.basename(self.current_save_file)}")
            else:
                QMessageBox.critical(self, "Error", "Failed to save footprint file!")


    def load_data(self):
        """Load footprint data from custom LibSienna format"""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "Load Footprint",
            "",
            "LibSienna Footprint Files (*.LibSienna *.libsienna);;All Files (*)"  # Accept both cases
        )
        
        if filename:
            print(f"Selected file: {filename}")  # Debug info
            data = LibSiennaFileFormat.load_footprint(filename)
            if data:
                try:
                    self.set_footprint_data(data)
                    # Set current file path so Save will work
                    self.current_save_file = filename
                    QMessageBox.information(
                        self,
                        "Success",
                        f"Footprint loaded successfully from {os.path.basename(filename)}!"
                    )
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to apply loaded data:\n{str(e)}")
            else:
                QMessageBox.critical(self, "Error", "Failed to load footprint file!\nCheck console for details.")


    def fit_to_view(self):
        self.renderer.auto_fit = True
        self.renderer.fit_to_view()
        self.renderer.update()

    def add_padstack_row(self):
        row = PadStackRow()
        row.delete_requested.connect(self.delete_padstack_row)
        row.data_changed.connect(self.on_data_changed)
        row.duplicate_btn.clicked.connect(lambda: self.duplicate_padstack_row(row))

        self.padstack_rows.append(row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, row)

        # Set pin number automatically
        row.pin_number.setText(str(len(self.padstack_rows)))

        # Update all offset_from dropdowns
        self.update_all_offset_dropdowns()

    def delete_padstack_row(self, row):
        if len(self.padstack_rows) > 0:
            self.padstack_rows.remove(row)
            row.setParent(None)
            # Update all remaining offset_from dropdowns
            self.update_all_offset_dropdowns()

    def duplicate_padstack_row(self, original_row):
        new_row = PadStackRow()
        new_row.delete_requested.connect(self.delete_padstack_row)
        new_row.data_changed.connect(self.on_data_changed)
        new_row.duplicate_btn.clicked.connect(lambda: self.duplicate_padstack_row(new_row))

        # Copy data from original
        data = original_row.get_data()
        data['pin_number'] = str(len(self.padstack_rows) + 1)
        
        # NEW: Handle offset_from pin number increment
        offset_from = data.get('offset_from', 'origin')
        if offset_from != 'origin':
            try:
                # Try to convert to int and increment by 1
                pin_num = int(offset_from)
                data['offset_from'] = str(pin_num + 1)
            except ValueError:
                # If it's not a numeric pin (like 'V1' for thermal vias), keep it as is
                # You could add more logic here if needed for other pin formats
                pass

        # Add to layout FIRST so update_offset_from_options can find all rows
        self.padstack_rows.append(new_row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, new_row)

        # Update all dropdowns to include the new pin numbers
        self.update_all_offset_dropdowns()

        # NOW set the data - the dropdown will have the correct options
        new_row.set_data(data)


    def add_custom_layer_row(self):
        row = CustomLayerRow()
        row.delete_requested.connect(self.delete_custom_layer_row)
        row.data_changed.connect(self.on_data_changed)
        row.duplicate_btn.clicked.connect(lambda: self.duplicate_custom_layer_row(row))

        self.custom_layer_rows.append(row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, row)

        # Update all offset_from dropdowns
        self.update_all_offset_dropdowns()

    def delete_custom_layer_row(self, row):
        if row in self.custom_layer_rows:
            self.custom_layer_rows.remove(row)
            row.setParent(None)
            self.update_all_offset_dropdowns()

    def duplicate_custom_layer_row(self, original_row):
        new_row = CustomLayerRow()
        new_row.delete_requested.connect(self.delete_custom_layer_row)
        new_row.data_changed.connect(self.on_data_changed)
        new_row.duplicate_btn.clicked.connect(lambda: self.duplicate_custom_layer_row(new_row))

        # Copy data from original
        data = original_row.get_data()

        # Add to layout
        self.custom_layer_rows.append(new_row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, new_row)

        # Update dropdowns and set data
        self.update_all_offset_dropdowns()
        new_row.set_data(data)

    def add_thermal_via_row(self):
        row = ThermalViaRow()
        row.delete_requested.connect(self.delete_thermal_via_row)
        row.data_changed.connect(self.on_data_changed)
        row.duplicate_btn.clicked.connect(lambda: self.duplicate_thermal_via_row(row))
        
        self.thermal_via_rows.append(row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, row)

        # Set via pin number automatically
        row.pin_number.setText(f"V{len(self.thermal_via_rows)}")  # ADD THIS LINE

        # Update all offset_from dropdowns
        self.update_all_offset_dropdowns()


    def delete_thermal_via_row(self, row):
        if row in self.thermal_via_rows:
            self.thermal_via_rows.remove(row)
            row.setParent(None)
            self.update_all_offset_dropdowns()

    def duplicate_thermal_via_row(self, original_row):
        new_row = ThermalViaRow()
        new_row.delete_requested.connect(self.delete_thermal_via_row)
        new_row.data_changed.connect(self.on_data_changed)
        new_row.duplicate_btn.clicked.connect(lambda: self.duplicate_thermal_via_row(new_row))

        # Copy data from original
        data = original_row.get_data()
        data['pin_number'] = f"V{len(self.thermal_via_rows) + 1}"  # ADD THIS LINE

        # Add to layout
        self.thermal_via_rows.append(new_row)
        self.container_layout.insertWidget(len(self.padstack_rows) + len(self.custom_layer_rows) + len(self.thermal_via_rows) - 1, new_row)

        # Update dropdowns and set data
        self.update_all_offset_dropdowns()
        new_row.set_data(data)


    def update_all_offset_dropdowns(self):
        """Update all offset_from dropdowns when pads/vias are added/removed"""
        # Collect all available pad pin numbers
        available_pad_pins = []
        for row in self.padstack_rows:
            pin_text = row.pin_number.text().strip()
            if pin_text:
                available_pad_pins.append(pin_text)
        
        # Collect all available thermal via pin numbers
        available_via_pins = []
        for row in self.thermal_via_rows:
            pin_text = row.pin_number.text().strip()
            if pin_text:
                available_via_pins.append(pin_text)

        # Update padstack dropdowns (only pad pins)
        for row in self.padstack_rows:
            row.update_offset_from_options()

        # Update custom layer dropdowns (only pad pins)
        for row in self.custom_layer_rows:
            current_selection = row.offset_from.currentText()
            row.offset_from.blockSignals(True)
            row.offset_from.clear()
            row.offset_from.addItem('origin')
            row.offset_from.addItems(available_pad_pins)

            # Restore previous selection if still valid
            index = row.offset_from.findText(current_selection)
            if index >= 0:
                row.offset_from.setCurrentIndex(index)
            else:
                row.offset_from.setCurrentText('origin')
            row.offset_from.blockSignals(False)

        # Update thermal via dropdowns (pad pins + thermal via pins)
        for row in self.thermal_via_rows:
            current_selection = row.offset_from.currentText()
            current_pin = row.pin_number.text().strip()
            
            row.offset_from.blockSignals(True)
            row.offset_from.clear()
            row.offset_from.addItem('origin')
            
            # Add pad pins
            row.offset_from.addItems(available_pad_pins)
            
            # Add thermal via pins (excluding current row's own pin)
            for via_pin in available_via_pins:
                if via_pin != current_pin:  # Don't include self-reference
                    row.offset_from.addItem(via_pin)

            # Restore previous selection if still valid
            index = row.offset_from.findText(current_selection)
            if index >= 0:
                row.offset_from.setCurrentIndex(index)
            else:
                row.offset_from.setCurrentText('origin')
            row.offset_from.blockSignals(False)


    def on_data_changed(self):
        # This will be handled by the update thread
        pass

    def get_footprint_data(self):
        settings = self.settings_panel.get_settings()
        data = {
            'part_number': self.part_number.text(),
            'footprint_name': self.footprint_name.text(),
            'body_length': self.body_length.text(),
            'body_width': self.body_width.text(),
            'body_height': self.body_height.text(),
            'body_shape': self.body_shape_combobox.currentText(),
            'origin_offset_x': self.origin_offset_x_input.text(),
            'origin_offset_y': self.origin_offset_y_input.text(),
            'auto_update_origin': self.auto_update_origin,
            'courtyard_expansion': settings['courtyard_expansion'],
            'silkscreen_airgap': settings['silkscreen_airgap'],
            'silkscreen_enabled': self.silkscreen_action.isChecked(),
            'fiducials_enabled': self.fiducials_enabled,
            'padstacks': [row.get_data() for row in self.padstack_rows],
            'custom_layers': [row.get_data() for row in self.custom_layer_rows],
            'thermal_vias': [row.get_data() for row in self.thermal_via_rows],
            'body_line_width': settings['body_line_width'],
            'courtyard_line_width': settings['courtyard_line_width'],
            'silkscreen_line_width': settings['silkscreen_line_width'],
            'settings': {
                'fiducial_diameter': settings['fiducial_diameter'],
                'fiducial_mask_opening': settings['fiducial_mask_opening'],
                'fiducial_keepout_diameter': settings['fiducial_keepout_diameter'],  # NEW
                'fiducial_x_offset': settings['fiducial_x_offset'],
                'fiducial_y_offset': settings['fiducial_y_offset'],
            },
            'text_settings': {
                'text_height': settings['text_height'],
                'text_width': settings['text_width'],
                'text_line_width': settings['text_line_width']
            }
        }
        return data




    def set_footprint_data(self, data):
        self.part_number.setText(data.get('part_number', ''))
        self.footprint_name.setText(data.get('footprint_name', ''))
        self.body_length.setText(str(data.get('body_length', '5.0')))
        self.body_width.setText(str(data.get('body_width', '3.0')))
        self.body_height.setText(str(data.get('body_height', '1.0')))
        self.body_shape_combobox.setCurrentText(data.get('body_shape', 'rectangle'))
        
        # Set origin offset values
        self.origin_offset_x_input.setText(str(data.get('origin_offset_x', '2.5')))
        self.origin_offset_y_input.setText(str(data.get('origin_offset_y', '1.5')))
        self.auto_update_origin = data.get('auto_update_origin', True)
        
        # Update renderer
        self.update_renderer_origin()
    
        
        self.silkscreen_action.setChecked(data.get('silkscreen_enabled', True))
        
        # Update settings panel
        settings = {
            'body_line_width': data.get('body_line_width', '1.5'),
            'courtyard_expansion': data.get('courtyard_expansion', '0.25'),
            'courtyard_line_width': data.get('courtyard_line_width', '0.1'),
            'silkscreen_airgap': data.get('silkscreen_airgap', '0.15'),
            'silkscreen_line_width': data.get('silkscreen_line_width', '0.15'),
            'script_output_path': data.get('script_output_path', os.path.expanduser("~/Documents")),
            'text_height': data.get('text_settings', {}).get('text_height', '0.5'),
            'text_width': data.get('text_settings', {}).get('text_width', '0.1'),
            'text_line_width': data.get('text_settings', {}).get('text_line_width', '1.8'),
            'current_user': data.get('current_user', None)
        }
        self.settings_panel.set_settings(settings)
        
        # Clear existing rows
        for row in self.padstack_rows[:]:
            self.delete_padstack_row(row)
        for row in self.custom_layer_rows[:]:
            self.delete_custom_layer_row(row)
        for row in self.thermal_via_rows[:]:
            self.delete_thermal_via_row(row)
        
        # Add padstacks from data
        for pad_data in data.get('padstacks', []):
            self.add_padstack_row()
            self.padstack_rows[-1].set_data(pad_data)
        
        # Add custom layers from data
        for layer_data in data.get('custom_layers', []):
            self.add_custom_layer_row()
            self.custom_layer_rows[-1].set_data(layer_data)
        
        # Add thermal vias from data
        for via_data in data.get('thermal_vias', []):
            self.add_thermal_via_row()
            self.thermal_via_rows[-1].set_data(via_data)
        
    def generate_footprint_script(self):
        """Generate footprint script based on selected CAD tool"""
        cad_tool = self.script_combo.currentText()
        
        if cad_tool == "Altium":
            self.generate_altium_script()
        elif cad_tool == "Allegro":
            self.generate_allegro_script()
        elif cad_tool == "PADS":
            self.generate_pads_script()
        elif cad_tool == "Xpedition":
            self.generate_xpedition_script()

    def generate_altium_script(self):
        """Generate footprint script from current data and save to a text file"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        lines = []

        # Scale factor for unit conversion (mm to mils)
        SCALE = 39.37

        # Footprint name
        footprint_name = data.get('footprint_name', 'Unnamed')
        lines.append(f"StartFootprints\n\nFootprint (Name \"{footprint_name}\"),")

        # Body dimensions
        try:
            body_length = float(data.get('body_length', 0))
            body_width = float(data.get('body_width', 0))
        except (ValueError, TypeError):
            body_length = body_width = 0

        half_length = body_length / 2
        half_width = body_width / 2

        # Define corners of body rectangle
        bl = (-half_length, -half_width)
        tl = (-half_length, half_width)
        tr = (half_length, half_width)
        br = (half_length, -half_width)

        # Body shape generation
        body_shape = data.get('body_shape', 'rectangle')
        if body_shape == 'rectangle':
            lines.append(f"Line (Width 1.7) (Start {tl[0]*SCALE:.2f}, {tl[1]*SCALE:.2f}) (End {tr[0]*SCALE:.2f}, {tr[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {bl[0]*SCALE:.2f}, {bl[1]*SCALE:.2f}) (End {tl[0]*SCALE:.2f}, {tl[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {tr[0]*SCALE:.2f}, {tr[1]*SCALE:.2f}) (End {br[0]*SCALE:.2f}, {br[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {br[0]*SCALE:.2f}, {br[1]*SCALE:.2f}) (End {bl[0]*SCALE:.2f}, {bl[1]*SCALE:.2f}) (Layer Mechanical13)")
        else:
            radius = max(half_length, half_width)
            lines.append(f"Line (Width 1.7) (Center (0, 0)) (Radius {radius*SCALE:.2f}) (Layer Mechanical13)")

        # Generate pads and collect pad bounds
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        
        # Collect pad bounds for silkscreen gap calculation
        pad_bounds_list = []
        for pad in pads:
            abs_x, abs_y = resolver.get_absolute_position(pad)
            pad_bounds = self.calculate_pad_bounds_for_script(pad, abs_x, abs_y)
            if pad_bounds:
                pad_bounds_list.append(pad_bounds)

        # Helper function for merging intervals
        def merge_intervals(intervals):
            """Merge overlapping intervals in the form [(start, end), ...]"""
            if not intervals:
                return []
            intervals = sorted(intervals, key=lambda x: x[0])
            merged = [intervals[0]]
            for current in intervals[1:]:
                last = merged[-1]
                if current[0] <= last[1]:
                    merged[-1] = (last[0], max(last[1], current[1]))
                else:
                    merged.append(current)
            return merged

        # Add the silkscreen generation function
        def generate_silkscreen_lines_with_gaps(x1, y1, x2, y2, pad_bounds_list, gap, orientation):
            segments = []
            if orientation == 'horizontal':
                start_pos = min(x1, x2)
                end_pos = max(x1, x2)
                line_y = y1
                intersections = []
                
                for (px_min, py_min, px_max, py_max) in pad_bounds_list:
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if horizontal line intersects with expanded pad
                    if (pad_min_y <= line_y <= pad_max_y and 
                        pad_max_x >= start_pos and pad_min_x <= end_pos):
                        inter_start = max(start_pos, pad_min_x)
                        inter_end = min(end_pos, pad_max_x)
                        intersections.append((inter_start, inter_end))
                
                # Merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Generate line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        segments.append((current_pos, line_y, gap_start, line_y))
                    current_pos = gap_end
                if current_pos < end_pos:
                    segments.append((current_pos, line_y, end_pos, line_y))
                    
            else:  # vertical
                start_pos = min(y1, y2)
                end_pos = max(y1, y2)
                line_x = x1
                intersections = []
                
                for (px_min, py_min, px_max, py_max) in pad_bounds_list:
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if vertical line intersects with expanded pad
                    if (pad_min_x <= line_x <= pad_max_x and 
                        pad_max_y >= start_pos and pad_min_y <= end_pos):
                        inter_start = max(start_pos, pad_min_y)
                        inter_end = min(end_pos, pad_max_y)
                        intersections.append((inter_start, inter_end))
                
                # Merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Generate line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        segments.append((line_x, current_pos, line_x, gap_start))
                    current_pos = gap_end
                if current_pos < end_pos:
                    segments.append((line_x, current_pos, line_x, end_pos))
                    
            return segments

        # Generate silkscreen with gaps if enabled
        if data.get('silkscreen_enabled', True):
            try:
                silkscreen_gap = float(data.get('silkscreen_airgap', 0.15))
            except (ValueError, TypeError):
                silkscreen_gap = 0.15
            
            # Generate silkscreen lines with gaps for each side of body rectangle
            silk_lines = []
            # Top line
            silk_lines += generate_silkscreen_lines_with_gaps(-half_length, half_width, half_length, half_width, pad_bounds_list, silkscreen_gap, 'horizontal')
            # Bottom line  
            silk_lines += generate_silkscreen_lines_with_gaps(-half_length, -half_width, half_length, -half_width, pad_bounds_list, silkscreen_gap, 'horizontal')
            # Left line
            silk_lines += generate_silkscreen_lines_with_gaps(-half_length, -half_width, -half_length, half_width, pad_bounds_list, silkscreen_gap, 'vertical')
            # Right line
            silk_lines += generate_silkscreen_lines_with_gaps(half_length, -half_width, half_length, half_width, pad_bounds_list, silkscreen_gap, 'vertical')
            
            # Add silkscreen segment lines to script
            for (x1_, y1_, x2_, y2_) in silk_lines:
                lines.append(f"Line (Width 6) (Start {x1_*SCALE:.2f}, {y1_*SCALE:.2f}) (End {x2_*SCALE:.2f}, {y2_*SCALE:.2f}) (Layer TopOverlay)")



        # Generate Courtyard Layer
        try:
            expansion = float(data.get('courtyard_expansion', 0.25))
            courtyard_line_width = float(data.get('courtyard_line_width', 0.1))
        except (ValueError, TypeError):
            expansion = 0.25
            courtyard_line_width = 0.1

        # Calculate courtyard bounds
        courtyard_bl = (bl[0] - expansion, bl[1] - expansion)
        courtyard_tl = (tl[0] - expansion, tl[1] + expansion)
        courtyard_tr = (tr[0] + expansion, tr[1] + expansion)
        courtyard_br = (br[0] + expansion, br[1] - expansion)

        lines.append(f"Line (Width {courtyard_line_width}) (Start {courtyard_tl[0]*SCALE:.2f}, {courtyard_tl[1]*SCALE:.2f}) (End {courtyard_tr[0]*SCALE:.2f}, {courtyard_tr[1]*SCALE:.2f}) (Layer Mechanical15)")
        lines.append(f"Line (Width {courtyard_line_width}) (Start {courtyard_bl[0]*SCALE:.2f}, {courtyard_bl[1]*SCALE:.2f}) (End {courtyard_tl[0]*SCALE:.2f}, {courtyard_tl[1]*SCALE:.2f}) (Layer Mechanical15)")
        lines.append(f"Line (Width {courtyard_line_width}) (Start {courtyard_tr[0]*SCALE:.2f}, {courtyard_tr[1]*SCALE:.2f}) (End {courtyard_br[0]*SCALE:.2f}, {courtyard_br[1]*SCALE:.2f}) (Layer Mechanical15)")
        lines.append(f"Line (Width {courtyard_line_width}) (Start {courtyard_br[0]*SCALE:.2f}, {courtyard_br[1]*SCALE:.2f}) (End {courtyard_bl[0]*SCALE:.2f}, {courtyard_bl[1]*SCALE:.2f}) (Layer Mechanical15)")


        # Generate Fiducials
        if data.get('fiducials_enabled', False):
            fiducial_settings = data.get('settings', {})
            try:
                fid_diameter = float(fiducial_settings.get('fiducial_diameter', 1.0))
                fid_mask = float(fiducial_settings.get('fiducial_mask_opening', 2.0))
                fid_x_offset = float(fiducial_settings.get('fiducial_x_offset', 2.0))
                fid_y_offset = float(fiducial_settings.get('fiducial_y_offset', 2.0))
            except (ValueError, TypeError):
                fid_diameter, fid_mask, fid_x_offset, fid_y_offset = 1.0, 2.0, 2.0, 2.0

            # Top-right and bottom-left fiducials
            fid_positions = [
                (tr[0] + fid_x_offset, tr[1] + fid_y_offset),  # Top-right
                (bl[0] - fid_x_offset, bl[1] - fid_y_offset),  # Bottom-left
            ]

            for i, (fid_x, fid_y) in enumerate(fid_positions, 1):
                lines.append(f"Pad (Name \"FID{i}\") (Location {fid_x*SCALE:.2f}, {fid_y*SCALE:.2f}) (Surface True) (Rotation 0)")
                lines.append(f"PadShape (Size {fid_diameter*SCALE:.2f}, {fid_diameter*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                lines.append("EndPad")

        # Generate pads with ALL types including missing ones
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)

        # Collect unique padstack names
        unique_names = []
        seen_names = set()
        for pad in pads:
            pad_name = self.generate_pad_name_for_script(pad)
            if pad_name not in seen_names:
                unique_names.append(pad_name)
                seen_names.add(pad_name)

        # Get text settings
        try:
            text_height = float(settings.get('text_height', 0.5)) * SCALE
            text_width = float(settings.get('text_width', 0.1)) * SCALE
            text_line_width = float(settings.get('text_line_width', 1.8))
        except (ValueError, TypeError):
            text_height, text_width, text_line_width = 50, 3, 1.8

        # Calculate position below courtyard for text
        base_y = (courtyard_bl[1] - 0.5) * SCALE  # Below courtyard

        for pad in pads:
            pad_type = pad.get('type', 'square')
            name = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)
            rotation = 0

            try:
                expand_mask = float(pad.get('mask_expansion', 0))
                expand_paste = float(pad.get('paste_expansion', 0))
            except (ValueError, TypeError):
                expand_mask = expand_paste = 0

            # Check if mask/paste are enabled
            mask_enabled = pad.get('mask_enabled', True)
            paste_enabled = pad.get('paste_enabled', True)
            
            if not mask_enabled:
                expand_mask = 0
            if not paste_enabled:
                expand_paste = 0

            surface = 'True' if pad_type not in ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong', 'PTH_rectangle'] else 'False'

            if pad_type == 'square':
                try:
                    size = float(pad.get('size', 1))
                except (ValueError, TypeError):
                    size = 1
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {size*SCALE:.2f}, {size*SCALE:.2f}) (Shape Rectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'rectangle':
                try:
                    length = float(pad.get('length', 1))
                    width = float(pad.get('width', 1))
                except (ValueError, TypeError):
                    length = width = 1
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {length*SCALE:.2f}, {width*SCALE:.2f}) (Shape Rectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'SMD-oblong':  # MISSING - NOW ADDED
                try:
                    length = float(pad.get('length', 1))
                    width = float(pad.get('width', 1))
                except (ValueError, TypeError):
                    length = width = 1
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {length*SCALE:.2f}, {width*SCALE:.2f}) (Shape RoundedRectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'rounded_rectangle':
                try:
                    length = float(pad.get('length', 1))
                    width = float(pad.get('width', 1))
                except (ValueError, TypeError):
                    length = width = 1
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {length*SCALE:.2f}, {width*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                lines.append("EndPad")

            elif pad_type in ['round', 'D-shape']:
                try:
                    diameter = float(pad.get('diameter', 1))
                except (ValueError, TypeError):
                    diameter = 1
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {diameter*SCALE:.2f}, {diameter*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                lines.append("EndPad")

            elif pad_type in ['PTH', 'NPTH']:
                try:
                    hole_diameter = float(pad.get('hole_diameter', 0.8))
                except (ValueError, TypeError):
                    hole_diameter = 0.8
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Slotted False) (HoleSize {hole_diameter*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                
                if pad_type == 'PTH':
                    try:
                        pad_diameter = float(pad.get('pad_diameter', 1.2))
                    except (ValueError, TypeError):
                        pad_diameter = 1.2
                    lines.append(f"PadShape (Size {pad_diameter*SCALE:.2f}, {pad_diameter*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                    lines.append(f"PadShape (Size {pad_diameter*SCALE:.2f}, {pad_diameter*SCALE:.2f}) (Shape Rounded) (Layer Bottom)")
                lines.append("EndPad")

            elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
                try:
                    hole_length = float(pad.get('hole_length', 1.5))
                    hole_width = float(pad.get('hole_width', 0.8))
                    pad_rotation = float(pad.get('rotation', 0))
                except (ValueError, TypeError):
                    hole_length, hole_width, pad_rotation = 1.5, 0.8, 0
                
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Slotted True) (SlotWidth {hole_width*SCALE:.2f}) (SlotHeight {hole_length*SCALE:.2f}) (Surface {surface}) (Rotation {pad_rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                
                if pad_type == 'PTH_oblong':
                    try:
                        pad_length = float(pad.get('pad_length', 2.0))
                        pad_width = float(pad.get('pad_width', 1.2))
                    except (ValueError, TypeError):
                        pad_length, pad_width = 2.0, 1.2
                    lines.append(f"PadShape (Size {pad_length*SCALE:.2f}, {pad_width*SCALE:.2f}) (Shape RoundedRectangular) (Layer Top)")
                    lines.append(f"PadShape (Size {pad_length*SCALE:.2f}, {pad_width*SCALE:.2f}) (Shape RoundedRectangular) (Layer Bottom)")
                lines.append("EndPad")

            elif pad_type == 'PTH_rectangle':  # MISSING - NOW ADDED
                try:
                    hole_length = float(pad.get('hole_length', 1.5))
                    hole_width = float(pad.get('hole_width', 0.8))
                    pad_length = float(pad.get('pad_length', 2.0))
                    pad_width = float(pad.get('pad_width', 1.2))
                    pad_rotation = float(pad.get('rotation', 0))
                except (ValueError, TypeError):
                    hole_length, hole_width = 1.5, 0.8
                    pad_length, pad_width = 2.0, 1.2
                    pad_rotation = 0
                
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Slotted True) (SlotWidth {hole_width*SCALE:.2f}) (SlotHeight {hole_length*SCALE:.2f}) (Surface {surface}) (Rotation {pad_rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {pad_length*SCALE:.2f}, {pad_width*SCALE:.2f}) (Shape Rectangular) (Layer Top)")
                lines.append(f"PadShape (Size {pad_length*SCALE:.2f}, {pad_width*SCALE:.2f}) (Shape Rectangular) (Layer Bottom)")
                lines.append("EndPad")

            elif pad_type == 'custom':
                # Generate custom polygon using actual polygon points
                polygon_points = self.renderer.calculate_polygon_points_absolute(pad, abs_x, abs_y)
                
                if polygon_points and len(polygon_points) >= 3:
                    # Convert polygon points to scaled coordinates
                    scaled_points = [(p.x() * SCALE, p.y() * SCALE) for p in polygon_points]
                    point_count = len(scaled_points)
                    
                    # Generate copper layer polygon (TopLayer)
                    lines.append(f"Polygon (PointCount {point_count}) (Layer TopLayer)")
                    for px, py in scaled_points:
                        lines.append(f"Point ({px:.2f}, {py:.2f})")
                    lines.append("EndPolygon")
                    
                    # Generate mask layer polygon (TopSolder) if mask enabled and has expansion
                    if mask_enabled and expand_mask != 0:
                        expanded_points = self.renderer.expand_polygon_uniformly(polygon_points, expand_mask)
                        if expanded_points:
                            scaled_mask_points = [(p.x() * SCALE, p.y() * SCALE) for p in expanded_points]
                            mask_point_count = len(scaled_mask_points)
                            lines.append(f"Polygon (PointCount {mask_point_count}) (Layer TopSolder)")
                            for px, py in scaled_mask_points:
                                lines.append(f"Point ({px:.2f}, {py:.2f})")
                            lines.append("EndPolygon")

                    
                    # Generate paste layer polygon (TopPaste) if paste enabled and has expansion
                    if paste_enabled and expand_paste != 0:
                        expanded_points = self.renderer.expand_polygon_uniformly(polygon_points, expand_paste)
                        if expanded_points:
                            scaled_paste_points = [(p.x() * SCALE, p.y() * SCALE) for p in expanded_points]
                            paste_point_count = len(scaled_paste_points)
                            lines.append(f"Polygon (PointCount {paste_point_count}) (Layer TopPaste)")
                            for px, py in scaled_paste_points:
                                lines.append(f"Point ({px:.2f}, {py:.2f})")
                            lines.append("EndPolygon")

                else:
                    # Fallback to simple rectangle if polygon calculation fails
                    lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation})")
                    lines.append(f"PadShape (Size {1.0*SCALE:.2f}, {1.0*SCALE:.2f}) (Shape Rectangular) (Layer Top)")
                    lines.append("EndPad")


        # Generate Custom Layers
        custom_layers = data.get('custom_layers', [])
        for layer in custom_layers:
            layer_type = layer.get('layer', 'mask')
            shape = layer.get('shape', 'rectangle')
            
            try:
                x_offset = float(layer.get('x_offset', 0))
                y_offset = float(layer.get('y_offset', 0))
            except (ValueError, TypeError):
                x_offset, y_offset = 0, 0

            # Handle offset_from (simplified)
            offset_from = layer.get('offset_from', 'origin')
            if offset_from != 'origin':
                # Add logic to resolve reference positions if needed
                pass

            # Determine Altium layer based on type
            altium_layer = "TopSolder" if layer_type == "mask" else "TopPaste" if layer_type == "paste" else "Mechanical1"

            if shape == 'rectangle':
                try:
                    length = float(layer.get('length', 1))
                    width = float(layer.get('width', 1))
                except (ValueError, TypeError):
                    length = width = 1
                
                # Draw rectangle
                x1, y1 = (x_offset - length/2) * SCALE, (y_offset - width/2) * SCALE
                x2, y2 = (x_offset + length/2) * SCALE, (y_offset + width/2) * SCALE
                lines.append(f"Line (Width 0.1) (Start {x1:.2f}, {y1:.2f}) (End {x2:.2f}, {y1:.2f}) (Layer {altium_layer})")
                lines.append(f"Line (Width 0.1) (Start {x2:.2f}, {y1:.2f}) (End {x2:.2f}, {y2:.2f}) (Layer {altium_layer})")
                lines.append(f"Line (Width 0.1) (Start {x2:.2f}, {y2:.2f}) (End {x1:.2f}, {y2:.2f}) (Layer {altium_layer})")
                lines.append(f"Line (Width 0.1) (Start {x1:.2f}, {y2:.2f}) (End {x1:.2f}, {y1:.2f}) (Layer {altium_layer})")

        # Generate Thermal Vias
        thermal_vias = data.get('thermal_vias', [])
        for via in thermal_vias:
            via_type = via.get('type', 'single')
            
            try:
                x_offset = float(via.get('x_offset', 0))
                y_offset = float(via.get('y_offset', 0))
            except (ValueError, TypeError):
                x_offset, y_offset = 0, 0

            # Handle offset_from (simplified)
            offset_from = via.get('offset_from', 'origin')
            if offset_from != 'origin':
                # Add logic to resolve reference positions if needed
                pass

            if via_type == 'single':
                try:
                    via_diameter = float(via.get('via_diameter', 0.2))
                    drill_diameter = float(via.get('drill_diameter', 0.1))
                except (ValueError, TypeError):
                    via_diameter, drill_diameter = 0.2, 0.1

                lines.append(f"Via (Location {x_offset*SCALE:.2f}, {y_offset*SCALE:.2f}) (Size {via_diameter*SCALE:.2f}) (DrillSize {drill_diameter*SCALE:.2f})")

            elif via_type == 'grid_array':
                try:
                    rows = int(via.get('rows', 2))
                    columns = int(via.get('columns', 2))
                    row_spacing = float(via.get('row_spacing', 1.0))
                    col_spacing = float(via.get('col_spacing', 1.0))
                    via_diameter = float(via.get('via_diameter', 0.2))
                    drill_diameter = float(via.get('drill_diameter', 0.1))
                except (ValueError, TypeError):
                    rows, columns = 2, 2
                    row_spacing, col_spacing = 1.0, 1.0
                    via_diameter, drill_diameter = 0.2, 0.1

                start_x = x_offset - (columns - 1) * col_spacing / 2
                start_y = y_offset - (rows - 1) * row_spacing / 2

                for row in range(rows):
                    for col in range(columns):
                        via_x = (start_x + col * col_spacing) * SCALE
                        via_y = (start_y + row * row_spacing) * SCALE
                        lines.append(f"Via (Location {via_x:.2f}, {via_y:.2f}) (Size {via_diameter*SCALE:.2f}) (DrillSize {drill_diameter*SCALE:.2f})")

        # Add unique padstack name texts below footprint
        for i, pad_name in enumerate(unique_names):
            text_x = 0  # Center at origin
            text_y = base_y - (i * (text_height + 0.2 * SCALE))  # Stack vertically
            lines.append(f'Text (Location {text_x:.1f}, {text_y:.1f}) (Line Width {text_line_width}) (Height {text_height:.1f}) (Width {text_width:.1f}) (Rotation 0) (Layer Mechanical13) (Value "{pad_name}")')

        lines.append("EndFootprint\nEndFootprints")

        # Join lines and save
        script = '\n'.join(lines)
        output_path = settings.get('altium_output_path', os.path.expanduser("~/Documents/Altium"))
        os.makedirs(output_path, exist_ok=True)
        footprint_name = data.get('footprint_name', 'Unnamed')
        file_name = os.path.join(output_path, f"{footprint_name}_footprint.txt")

        try:
            with open(file_name, "w") as f:
                f.write(script)
            self.show_script_dialog("Altium Script Generated", file_name, script)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save script file:\n{str(e)}")


    # Add this helper method to the FootprintDesigner class
    def generate_pad_name_for_script(self, pad):
        """Generate pad name for script - same logic as renderer"""
        return self.renderer.generate_pad_name(pad)


    def generate_pad_name(self, pad):
        """Generate padstack name based on pad type and expansions"""
        pad_type = pad['type']
        
        try:
            mask_exp = float(pad.get('mask_expansion', 0)) if pad.get('mask_enabled', True) else 0
            paste_exp = float(pad.get('paste_expansion', 0)) if pad.get('paste_enabled', True) else 0
        except (ValueError, TypeError):
            mask_exp = paste_exp = 0
        
        name = ""
        
        if pad_type == 'square':
            try:
                size = float(pad.get('size', 1))
                name = f"S{int(size * 100)}"
                if mask_exp > 0:
                    mask_size = int((size + 2 * mask_exp) * 100)
                    name += f"_M{mask_size}"
                if paste_exp > 0:           
                    paste_size = int((size + 2 * paste_exp) * 100)
                    name += f"_P{paste_size}"
            except (ValueError, TypeError):
                name = "S100"
                
        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong', 'PTH_rectangle']:
            try:
                length = float(pad.get('length', 1))
                width = float(pad.get('width', 1))
                name = f"R{int(length * 100)}x{int(width * 100)}"
                if mask_exp > 0:
                    mask_l = int((length + 2 * mask_exp) * 100)
                    mask_w = int((width + 2 * mask_exp) * 100)
                    name += f"_M{mask_l}x{mask_w}"
                if paste_exp > 0:
                    paste_l = int((length + 2 * paste_exp) * 100)
                    paste_w = int((width + 2 * paste_exp) * 100)
                    name += f"_P{paste_l}x{paste_w}"
            except (ValueError, TypeError):
                name = "R100x100"
                
        elif pad_type == 'round':
            try:
                diameter = float(pad.get('diameter', 1))
                name = f"C{int(diameter * 100)}"  # C for circular
                if mask_exp > 0:
                    mask_dia = int((diameter + 2 * mask_exp) * 100)
                    name += f"_M{mask_dia}"
                if paste_exp > 0:
                    paste_dia = int((diameter + 2 * paste_exp) * 100)
                    name += f"_P{paste_dia}"
            except (ValueError, TypeError):
                name = "C100"
                
        elif pad_type in ['PTH', 'NPTH']:
            hole_dia = float(pad.get('hole_diameter', 0.8))
            if pad_type == 'PTH':
                pad_dia = float(pad.get('pad_diameter', 1.2))
                name = f"PTH{int(hole_dia * 100)}_P{int(pad_dia * 100)}"
            else:
                name = f"NPTH{int(hole_dia * 100)}"
                
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            hole_l = float(pad.get('hole_length', 1.5))
            hole_w = float(pad.get('hole_width', 0.8))
            if pad_type == 'PTH_oblong':
                pad_l = float(pad.get('pad_length', 2.0))
                pad_w = float(pad.get('pad_width', 1.2))
                name = f"PTHO{int(hole_l * 100)}x{int(hole_w * 100)}_P{int(pad_l * 100)}x{int(pad_w * 100)}"
            else:
                name = f"NPTHO{int(hole_l * 100)}x{int(hole_w * 100)}"
        else:
            name = f"{pad_type.upper()}"
            
        return name
  
    def generate_allegro_script(self):
        """Generate Allegro PCB Editor script"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        
        lines = []
        footprint_name = data.get('footprint_name', 'Unnamed')
        
        # Allegro script header
        lines.append("# Allegro PCB Editor Script")
        lines.append(f"# Footprint: {footprint_name}")
        lines.append("")
        
        # Package creation
        lines.append("package")
        lines.append(f"create_package {footprint_name}")
        
        # Body outline
        try:
            body_length = float(data.get('body_length', 0))
            body_width = float(data.get('body_width', 0))
        except (ValueError, TypeError):
            body_length = body_width = 0
            
        if body_length > 0 and body_width > 0:
            lines.append("# Package outline")
            lines.append(f"line package_geometry 0 0 {body_length} 0")
            lines.append(f"line package_geometry {body_length} 0 {body_length} {body_width}")
            lines.append(f"line package_geometry {body_length} {body_width} 0 {body_width}")
            lines.append(f"line package_geometry 0 {body_width} 0 0")
        
        # Generate pads
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        
        for pad in pads:
            pad_type = pad.get('type', 'square')
            name = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)
            
            if pad_type == 'square':
                size = float(pad.get('size', 1))
                lines.append(f"pad rect {name} {abs_x} {abs_y} {size} {size}")
            elif pad_type in ['rectangle', 'SMD-oblong']:
                length = float(pad.get('length', 1))
                width = float(pad.get('width', 1))
                lines.append(f"pad rect {name} {abs_x} {abs_y} {length} {width}")
            elif pad_type == 'round':
                diameter = float(pad.get('diameter', 1))
                lines.append(f"pad circle {name} {abs_x} {abs_y} {diameter}")
            elif pad_type in ['PTH', 'NPTH']:
                hole_dia = float(pad.get('hole_diameter', 0.8))
                pad_dia = float(pad.get('pad_diameter', 1.2)) if pad_type == 'PTH' else hole_dia
                lines.append(f"via {name} {abs_x} {abs_y} {hole_dia} {pad_dia}")
        
        lines.append("end")
        
        # Save script
        script = '\n'.join(lines)
        output_path = settings.get('allegro_output_path', os.path.expanduser("~/Documents/Allegro"))
        os.makedirs(output_path, exist_ok=True)
        file_name = os.path.join(output_path, f"{footprint_name}_allegro.scr")
        
        try:
            with open(file_name, "w") as f:
                f.write(script)
            self.show_script_dialog("Allegro Script Generated", file_name, script)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save Allegro script: {str(e)}")

    def generate_pads_script(self):
        """Generate PADS Layout script"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        
        lines = []
        footprint_name = data.get('footprint_name', 'Unnamed')
        
        # PADS script header
        lines.append("! PADS Layout Script")
        lines.append(f"! Footprint: {footprint_name}")
        lines.append("")
        
        # Start part definition
        lines.append("*PART*")
        lines.append(f"{footprint_name}")
        
        # Generate pads
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        
        for pad in pads:
            pad_type = pad.get('type', 'square')
            name = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)
            
            if pad_type == 'square':
                size = float(pad.get('size', 1)) * 1000  # Convert to mils
                lines.append(f"{name} {abs_x * 1000:.0f} {abs_y * 1000:.0f} S{size:.0f}")
            elif pad_type in ['rectangle', 'SMD-oblong']:
                length = float(pad.get('length', 1)) * 1000
                width = float(pad.get('width', 1)) * 1000
                lines.append(f"{name} {abs_x * 1000:.0f} {abs_y * 1000:.0f} R{length:.0f}X{width:.0f}")
            elif pad_type == 'round':
                diameter = float(pad.get('diameter', 1)) * 1000
                lines.append(f"{name} {abs_x * 1000:.0f} {abs_y * 1000:.0f} C{diameter:.0f}")
            elif pad_type in ['PTH', 'NPTH']:
                hole_dia = float(pad.get('hole_diameter', 0.8)) * 1000
                pad_dia = float(pad.get('pad_diameter', 1.2)) * 1000 if pad_type == 'PTH' else hole_dia
                lines.append(f"{name} {abs_x * 1000:.0f} {abs_y * 1000:.0f} T{hole_dia:.0f}P{pad_dia:.0f}")
        
        lines.append("*END*")
        
        # Save script
        script = '\n'.join(lines)
        output_path = settings.get('pads_output_path', os.path.expanduser("~/Documents/PADS"))
        os.makedirs(output_path, exist_ok=True)
        file_name = os.path.join(output_path, f"{footprint_name}_pads.pt")
        
        try:
            with open(file_name, "w") as f:
                f.write(script)
            self.show_script_dialog("PADS Script Generated", file_name, script)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save PADS script: {str(e)}")

    def generate_xpedition_script(self):
        """Generate Xpedition Layout script"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        
        lines = []
        footprint_name = data.get('footprint_name', 'Unnamed')
        
        # Xpedition script header
        lines.append("# Xpedition Layout Script")
        lines.append(f"# Footprint: {footprint_name}")
        lines.append("")
        
        lines.append("BeginPart")
        lines.append(f"PartName = {footprint_name}")
        
        # Generate pads
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        
        for pad in pads:
            pad_type = pad.get('type', 'square')
            name = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)
            
            lines.append(f"BeginPin")
            lines.append(f"PinName = {name}")
            lines.append(f"X = {abs_x}")
            lines.append(f"Y = {abs_y}")
            
            if pad_type == 'square':
                size = float(pad.get('size', 1))
                lines.append(f"PadShape = Rectangle")
                lines.append(f"PadWidth = {size}")
                lines.append(f"PadHeight = {size}")
            elif pad_type in ['rectangle', 'SMD-oblong']:
                length = float(pad.get('length', 1))
                width = float(pad.get('width', 1))
                lines.append(f"PadShape = Rectangle")
                lines.append(f"PadWidth = {length}")
                lines.append(f"PadHeight = {width}")
            elif pad_type == 'round':
                diameter = float(pad.get('diameter', 1))
                lines.append(f"PadShape = Circle")
                lines.append(f"PadDiameter = {diameter}")
            elif pad_type in ['PTH', 'NPTH']:
                hole_dia = float(pad.get('hole_diameter', 0.8))
                pad_dia = float(pad.get('pad_diameter', 1.2)) if pad_type == 'PTH' else hole_dia
                lines.append(f"PadShape = Circle")
                lines.append(f"PadDiameter = {pad_dia}")
                lines.append(f"HoleDiameter = {hole_dia}")
            
            lines.append("EndPin")
        
        lines.append("EndPart")
        
        # Save script
        script = '\n'.join(lines)
        output_path = settings.get('xpedition_output_path', os.path.expanduser("~/Documents/Xpedition"))
        os.makedirs(output_path, exist_ok=True)
        file_name = os.path.join(output_path, f"{footprint_name}_xpedition.txt")
        
        try:
            with open(file_name, "w") as f:
                f.write(script)
            self.show_script_dialog("Xpedition Script Generated", file_name, script)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save Xpedition script: {str(e)}")

    def show_script_dialog(self, title, filename, script):
        """Show script generation dialog"""
        dialog = QMessageBox(self)
        dialog.setWindowTitle(title)
        dialog.setText(f"Script saved to:\n{filename}")
        dialog.setDetailedText(script)
        dialog.setIcon(QMessageBox.Icon.Information)
        dialog.exec()

    def calculate_pad_bounds_for_script(self, pad, abs_x, abs_y):
        """Calculate pad bounds for script generation"""
        pad_type = pad.get('type', 'square')
        
        if pad_type == 'square':
            try:
                size = float(pad.get('size', 1))
                return (abs_x - size/2, abs_y - size/2, abs_x + size/2, abs_y + size/2)
            except (ValueError, TypeError):
                return (abs_x - 0.5, abs_y - 0.5, abs_x + 0.5, abs_y + 0.5)
        
        elif pad_type in ['rectangle', 'rounded_rectangle', 'SMD-oblong']:
            try:
                length = float(pad.get('length', 1))
                width = float(pad.get('width', 1))
                return (abs_x - length/2, abs_y - width/2, abs_x + length/2, abs_y + width/2)
            except (ValueError, TypeError):
                return (abs_x - 0.5, abs_y - 0.5, abs_x + 0.5, abs_y + 0.5)
            
        elif pad_type == 'PTH_rectangle':  # ADD THIS CASE
            try:
                pad_length = float(pad.get('pad_length', 2.0))
                pad_width = float(pad.get('pad_width', 1.2))
                return (abs_x - pad_length/2, abs_y - pad_width/2, abs_x + pad_length/2, abs_y + pad_width/2)
            except (ValueError, TypeError):
                return (abs_x - 1.0, abs_y - 0.6, abs_x + 1.0, abs_y + 0.6)
        
        elif pad_type in ['round', 'D-shape']:
            try:
                diameter = float(pad.get('diameter', 1))
                return (abs_x - diameter/2, abs_y - diameter/2, abs_x + diameter/2, abs_y + diameter/2)
            except (ValueError, TypeError):
                return (abs_x - 0.5, abs_y - 0.5, abs_x + 0.5, abs_y + 0.5)
        
        elif pad_type in ['PTH', 'NPTH']:
            try:
                if pad_type == 'PTH':
                    diameter = float(pad.get('pad_diameter', 1.2))
                else:
                    diameter = float(pad.get('hole_diameter', 0.8))
                return (abs_x - diameter/2, abs_y - diameter/2, abs_x + diameter/2, abs_y + diameter/2)
            except (ValueError, TypeError):
                return (abs_x - 0.6, abs_y - 0.6, abs_x + 0.6, abs_y + 0.6)
        
        # Add more pad types as needed
        return (abs_x - 0.5, abs_y - 0.5, abs_x + 0.5, abs_y + 0.5)


    def start_update_thread(self):
        self.update_thread = UpdateThread(self)
        self.update_thread.update_signal.connect(self.renderer.update_footprint)
        self.update_thread.start()

    def closeEvent(self, event):
        """Save settings on close"""
        self.save_app_settings()
        if hasattr(self, 'update_thread'):
            self.update_thread.stop()
            self.update_thread.wait()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)

    # Set application-wide dark theme
    app.setStyle('Fusion')
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(43, 43, 43))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Base, QColor(60, 60, 60))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(80, 80, 80))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Text, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Button, QColor(74, 74, 74))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 0, 0))
    palette.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(0, 0, 0))
    app.setPalette(palette)

    window = FootprintDesigner()
    window.show()

    sys.exit(app.exec())
