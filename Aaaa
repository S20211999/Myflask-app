def calculate_price(self):
    """Calculate PCB price based on database data with proper filtering"""
    try:
        # Validate inputs
        if not all([
            self.customer_input.text().strip(),
            self.job_input.text().strip(),
            self.pcb_part_input.text().strip(),
            self.length_input.text(),
            self.width_input.text()
        ]):
            QMessageBox.warning(self, "Input Error", "Please fill all required fields!")
            return

        # Get input values
        customer_name = self.customer_input.text().strip()
        job_number = self.job_input.text().strip()
        pcb_part_number = self.pcb_part_input.text().strip()
        unit = self.unit_combo.currentText()
        
        try:
            length = float(self.length_input.text())
            width = float(self.width_input.text())
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Length and Width must be numeric.")
            return

        # Build dynamic query with proper filtering
        query_conditions = []
        params = []
        
        # Base conditions to ensure valid data
        base_conditions = [
            "PricePerUnit IS NOT NULL",
            "PricePerUnit != ''", 
            "Length > 0", 
            "Width > 0",
            "TotalCostINR IS NOT NULL",
            "TotalCostINR > 0"
        ]
        
        # Add filter conditions based on user selections
        active_filters = []
        for field, combo in self.filter_combos.items():
            current_value = combo.currentText().strip()
            if current_value and current_value != "Any" and current_value != "":
                # Handle different data types properly
                if field in ["Layers", "BoardThickness"]:
                    # Integer fields - exact match
                    query_conditions.append(f"CAST({field} AS TEXT) = ?")
                    params.append(str(current_value))
                elif field in ["back_drill", "blind_via", "berried_via", "Impedance"]:
                    # Boolean-like fields - case insensitive
                    query_conditions.append(f"UPPER({field}) = UPPER(?)")
                    params.append(current_value)
                else:
                    # Text fields - case insensitive partial match
                    query_conditions.append(f"UPPER({field}) LIKE UPPER(?)")
                    params.append(f"%{current_value}%")
                
                active_filters.append(f"{field}: {current_value}")

        # Construct the complete query
        base_query = '''
            SELECT Quantity, Length, Width, PricePerUnit, TotalCostINR, FabricatorName, 
                   Layers, material, BoardThickness, CuInner, CuOuter, SurfaceFinish,
                   Impedance, Soldermask, Silkscreen, back_drill, blind_via, berried_via
            FROM pcb_data
            WHERE ''' + " AND ".join(base_conditions)
        
        if query_conditions:
            complete_query = base_query + " AND " + " AND ".join(query_conditions)
        else:
            complete_query = base_query
            
        # Add ordering - prioritize by price per unit (highest first)
        complete_query += " ORDER BY CAST(REPLACE(PricePerUnit, ',', '') AS REAL) DESC"

        print(f"Executing query: {complete_query}")
        print(f"With parameters: {params}")
        print(f"Active filters: {active_filters}")
        
        self.parent.cursor.execute(complete_query, params)
        matches = self.parent.cursor.fetchall()

        if not matches:
            filter_info = "\n".join(active_filters) if active_filters else "No filters applied"
            QMessageBox.information(self, "No Match", 
                                  f"No matching records found for the specified criteria:\n\n{filter_info}\n\nTry adjusting your filter selections.")
            return

        print(f"Found {len(matches)} matching records")

        # Use the record with highest price per unit (first result due to ordering)
        best_match = matches[0]
        (ref_qty, ref_length, ref_width, ref_price_per_unit_str, ref_total_cost, ref_fabricator,
         ref_layers, ref_material, ref_thickness, ref_cu_inner, ref_cu_outer, ref_surface_finish,
         ref_impedance, ref_soldermask, ref_silkscreen, ref_back_drill, ref_blind_via, ref_buried_via) = best_match
        
        # Convert price per unit to float with proper error handling
        try:
            ref_price_per_unit = float(str(ref_price_per_unit_str).replace(',', '').strip())
        except (ValueError, TypeError):
            ref_price_per_unit = 0.0

        if ref_price_per_unit <= 0:
            QMessageBox.warning(self, "Data Error", "Invalid reference price data found. Please check your database records.")
            return

        # Calculate price per square unit
        ref_area = float(ref_length) * float(ref_width)
        if ref_area <= 0:
            QMessageBox.warning(self, "Data Error", "Invalid reference PCB dimensions found.")
            return
            
        price_per_sq_unit = ref_price_per_unit / ref_area

        # Calculate prices for input PCB
        input_area = length * width
        per_unit_price = price_per_sq_unit * input_area

        # Create reference specs dictionary for display
        reference_specs = {
            'Fabricator': ref_fabricator,
            'Layers': ref_layers,
            'Material': ref_material,
            'Thickness': f"{ref_thickness} mil" if ref_thickness else "N/A",
            'Cu Inner': ref_cu_inner or "N/A",
            'Cu Outer': ref_cu_outer or "N/A",
            'Surface Finish': ref_surface_finish or "N/A",
            'Impedance': ref_impedance or "N/A",
            'Soldermask': ref_soldermask or "N/A",
            'Silkscreen': ref_silkscreen or "N/A",
            'Back Drill': ref_back_drill or "N/A",
            'Blind Via': ref_blind_via or "N/A",
            'Buried Via': ref_buried_via or "N/A"
        }

        # Populate results table with reference specs
        self.populate_results_table_with_specs(
            customer_name, job_number, pcb_part_number, unit, 
            length, width, input_area, ref_length, ref_width, 
            ref_price_per_unit, price_per_sq_unit, per_unit_price, 
            reference_specs, active_filters, len(matches)
        )

        print(f"Calculation completed successfully. Price per unit: ₹{per_unit_price:.2f}")
        
        # Show summary of applied filters
        if active_filters:
            filter_summary = "Applied Filters:\n" + "\n".join(f"• {f}" for f in active_filters)
            filter_summary += f"\n\nFound {len(matches)} matching records."
            print(filter_summary)

    except ValueError as ve:
        QMessageBox.warning(self, "Input Error", f"Please enter valid numeric values: {str(ve)}")
    except Exception as e:
        print(f"Calculation error: {e}")
        QMessageBox.critical(self, "Error", f"Calculation failed: {str(e)}")
