            self.hole_length_input.setMaximumWidth(100)
            self.hole_length_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_length_input)
            
            self.geometry_layout.addWidget(QLabel("Hole Width:"))
            self.hole_width_input = QDoubleSpinBox()
            self.hole_width_input.setRange(0.1, 10)
            self.hole_width_input.setSingleStep(0.1)
            self.hole_width_input.setValue(0.8)
            self.hole_width_input.setDecimals(5)
            self.hole_width_input.setMaximumWidth(100)
            self.hole_width_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_width_input)
            
            if pad_type == 'PTH_oblong':
                # PTH oblong needs pad dimensions
                self.geometry_layout.addWidget(QLabel("Pad Length:"))
                self.pad_length_input = QDoubleSpinBox()
                self.pad_length_input.setRange(0.1, 50)
                self.pad_length_input.setSingleStep(0.1)
                self.pad_length_input.setValue(2.0)
                self.pad_length_input.setDecimals(5)
                self.pad_length_input.setMaximumWidth(100)
                self.pad_length_input.valueChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_length_input)
                
                self.geometry_layout.addWidget(QLabel("Pad Width:"))
                self.pad_width_input = QDoubleSpinBox()
                self.pad_width_input.setRange(0.1, 50)
                self.pad_width_input.setSingleStep(0.1)
                self.pad_width_input.setValue(1.2)
                self.pad_width_input.setDecimals(5)
                self.pad_width_input.setMaximumWidth(100)
                self.pad_width_input.valueChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_width_input)
                
        elif pad_type == 'custom':
            # Custom polygon inputs handled by polygon_widget
            self.geometry_layout.addWidget(QLabel("Custom Polygon (see below)"))
        
        # Add stretch to push everything to the left
        self.geometry_layout.addStretch()
        
    def get_data(self):
        data = {
            'type': self.type_combo.currentText(),
            'x_offset': self.x_offset.value(),
            'y_offset': self.y_offset.value(),
            'offset_from': self.offset_from.currentText(),
            'mask_expansion': self.mask_expansion.value(),
            'paste_expansion': self.paste_expansion.value(),
            'pin_number': self.pin_number.text()
        }
        
        pad_type = self.type_combo.currentText()
        if pad_type == 'square' and hasattr(self, 'size_input'):
            data['size'] = self.size_input.value()
        elif pad_type in ['rectangle', 'rounded_rectangle']:
            if hasattr(self, 'length_input'):
                data['length'] = self.length_input.value()
            if hasattr(self, 'width_input'):
                data['width'] = self.width_input.value()
            if pad_type == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                data['corner_radius'] = self.corner_radius_input.value()
        elif pad_type == 'round' and hasattr(self, 'diameter_input'):
            data['diameter'] = self.diameter_input.value()
        elif pad_type in ['PTH', 'NPTH']:
            if hasattr(self, 'hole_diameter_input'):
                data['hole_diameter'] = self.hole_diameter_input.value()
            if pad_type == 'PTH' and hasattr(self, 'pad_diameter_input'):
                data['pad_diameter'] = self.pad_diameter_input.value()
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if hasattr(self, 'hole_length_input'):
                data['hole_length'] = self.hole_length_input.value()
            if hasattr(self, 'hole_width_input'):
                data['hole_width'] = self.hole_width_input.value()
            if pad_type == 'PTH_oblong':
                if hasattr(self, 'pad_length_input'):
                    data['pad_length'] = self.pad_length_input.value()
                if hasattr(self, 'pad_width_input'):
                    data['pad_width'] = self.pad_width_input.value()
        elif pad_type == 'custom':
            data['polygon_data'] = self.polygon_widget.get_data()
            
        return data
        

    
    def set_data(self, data):
        self.type_combo.setCurrentText(data.get('type', 'square'))
        self.x_offset.setValue(data.get('x_offset', 0))
        self.y_offset.setValue(data.get('y_offset', 0))
        self.mask_expansion.setValue(data.get('mask_expansion', 0))
        self.paste_expansion.setValue(data.get('paste_expansion', 0))
        self.pin_number.setText(data.get('pin_number', '1'))
        
        # Update options first, then set the selection
        self.update_offset_from_options()
        self.offset_from.setCurrentText(data.get('offset_from', 'origin'))

        # Set type-specific data
        pad_type = data.get('type', 'square')
        if pad_type == 'square' and hasattr(self, 'size_input'):
            self.size_input.setValue(data.get('size', 1.0))
        elif pad_type in ['rectangle', 'rounded_rectangle']:
            if hasattr(self, 'length_input'):
                self.length_input.setValue(data.get('length', 1.0))
            if hasattr(self, 'width_input'):
                self.width_input.setValue(data.get('width', 1.0))
            if pad_type == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                self.corner_radius_input.setValue(data.get('corner_radius', 0.2))
        elif pad_type == 'round' and hasattr(self, 'diameter_input'):
            self.diameter_input.setValue(data.get('diameter', 1.0))
        elif pad_type in ['PTH', 'NPTH']:
            if hasattr(self, 'hole_diameter_input'):
                self.hole_diameter_input.setValue(data.get('hole_diameter', 0.8))
            if pad_type == 'PTH' and hasattr(self, 'pad_diameter_input'):
                self.pad_diameter_input.setValue(data.get('pad_diameter', 1.2))
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if hasattr(self, 'hole_length_input'):
                self.hole_length_input.setValue(data.get('hole_length', 1.5))
            if hasattr(self, 'hole_width_input'):
                self.hole_width_input.setValue(data.get('hole_width', 0.8))
            if pad_type == 'PTH_oblong':
                if hasattr(self, 'pad_length_input'):
                    self.pad_length_input.setValue(data.get('pad_length', 2.0))
                if hasattr(self, 'pad_width_input'):
                    self.pad_width_input.setValue(data.get('pad_width', 1.2))
        elif pad_type == 'custom':
            self.polygon_widget.set_data(data.get('polygon_data', {}))

class SettingsPanel(QWidget):
    settings_changed = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_user = None
        self.setup_ui()
        self.setup_styling()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(15)
        
        # Title
        title = QLabel("Settings")
        title.setStyleSheet("font-size: 16px; font-weight: bold; color: #ffffff; margin-bottom: 10px;")
        layout.addWidget(title)
        
        # User Login Section
        self.setup_user_section(layout)
        
        # Separator
        separator1 = QFrame()
        separator1.setFrameShape(QFrame.Shape.HLine)
        separator1.setStyleSheet("color: #555;")
        layout.addWidget(separator1)
        
        # Body Settings
        self.setup_body_settings(layout)
        
        # Separator
        separator2 = QFrame()
        separator2.setFrameShape(QFrame.Shape.HLine)
        separator2.setStyleSheet("color: #555;")
        layout.addWidget(separator2)
        
        # Courtyard Settings
        self.setup_courtyard_settings(layout)
        
        # Separator
        separator3 = QFrame()
        separator3.setFrameShape(QFrame.Shape.HLine)
        separator3.setStyleSheet("color: #555;")
        layout.addWidget(separator3)
        
        # Silkscreen Settings
        self.setup_silkscreen_settings(layout)
        
        # Separator
        separator4 = QFrame()
        separator4.setFrameShape(QFrame.Shape.HLine)
        separator4.setStyleSheet("color: #555;")
        layout.addWidget(separator4)
        
        # Script Output Settings
        self.setup_script_settings(layout)
        
        layout.addStretch()
        
    def setup_user_section(self, layout):
        user_group = QGroupBox("User Account")
        user_layout = QVBoxLayout(user_group)
        
        # User display/login
        self.user_display = QLabel("Not logged in")
        self.user_display.setStyleSheet("color: #ffffff; margin: 5px;")
        user_layout.addWidget(self.user_display)
        
        # Login form (initially visible)
        self.login_frame = QFrame()
        login_layout = QGridLayout(self.login_frame)
        
        login_layout.addWidget(QLabel("Username:"), 0, 0)
        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter username")
        login_layout.addWidget(self.username_input, 0, 1)
        
        login_layout.addWidget(QLabel("Password:"), 1, 0)
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText("Enter password")
        login_layout.addWidget(self.password_input, 1, 1)
        
        self.login_btn = QPushButton("Login")
        self.login_btn.clicked.connect(self.handle_login)
        login_layout.addWidget(self.login_btn, 2, 0, 1, 2)
        
        user_layout.addWidget(self.login_frame)
        
        # Logout button (initially hidden)
        self.logout_btn = QPushButton("Logout")
        self.logout_btn.clicked.connect(self.handle_logout)
        self.logout_btn.setVisible(False)
        user_layout.addWidget(self.logout_btn)
        
        layout.addWidget(user_group)
        
    def setup_body_settings(self, layout):
        body_group = QGroupBox("Body Settings")
        body_layout = QGridLayout(body_group)
        
        body_layout.addWidget(QLabel("Body Line Width:"), 0, 0)
        self.body_line_width = QDoubleSpinBox()
        self.body_line_width.setRange(0.1, 10.0)
        self.body_line_width.setSingleStep(0.1)
        self.body_line_width.setValue(1.5)
        self.body_line_width.setDecimals(2)
        self.body_line_width.setSuffix(" mm")
        self.body_line_width.valueChanged.connect(self.settings_changed.emit)
        body_layout.addWidget(self.body_line_width, 0, 1)
        
        layout.addWidget(body_group)
        
    def setup_courtyard_settings(self, layout):
        courtyard_group = QGroupBox("Courtyard Settings")
        courtyard_layout = QGridLayout(courtyard_group)
        
        courtyard_layout.addWidget(QLabel("Courtyard Expansion:"), 0, 0)
        self.courtyard_expansion = QDoubleSpinBox()
        self.courtyard_expansion.setRange(0, 5)
        self.courtyard_expansion.setSingleStep(0.1)
        self.courtyard_expansion.setValue(0.25)
        self.courtyard_expansion.setDecimals(5)
        self.courtyard_expansion.setSuffix(" mm")
        self.courtyard_expansion.valueChanged.connect(self.settings_changed.emit)
        courtyard_layout.addWidget(self.courtyard_expansion, 0, 1)
        
        courtyard_layout.addWidget(QLabel("Courtyard Line Width:"), 1, 0)
        self.courtyard_line_width = QDoubleSpinBox()
        self.courtyard_line_width.setRange(0.1, 5.0)
        self.courtyard_line_width.setSingleStep(0.1)
        self.courtyard_line_width.setValue(0.1)
        self.courtyard_line_width.setDecimals(2)
        self.courtyard_line_width.setSuffix(" mm")
        self.courtyard_line_width.valueChanged.connect(self.settings_changed.emit)
        courtyard_layout.addWidget(self.courtyard_line_width, 1, 1)
        
        layout.addWidget(courtyard_group)
        
    def setup_silkscreen_settings(self, layout):
        silkscreen_group = QGroupBox("Silkscreen Settings")
        silkscreen_layout = QGridLayout(silkscreen_group)
        
        silkscreen_layout.addWidget(QLabel("Silkscreen Airgap:"), 0, 0)
        self.silkscreen_airgap = QDoubleSpinBox()
        self.silkscreen_airgap.setRange(0, 2)
        self.silkscreen_airgap.setSingleStep(0.01)
        self.silkscreen_airgap.setValue(0.15)
        self.silkscreen_airgap.setDecimals(5)
        self.silkscreen_airgap.setSuffix(" mm")
        self.silkscreen_airgap.valueChanged.connect(self.settings_changed.emit)
        silkscreen_layout.addWidget(self.silkscreen_airgap, 0, 1)
        
        silkscreen_layout.addWidget(QLabel("Silkscreen Line Width:"), 1, 0)
        self.silkscreen_line_width = QDoubleSpinBox()
        self.silkscreen_line_width.setRange(0.1, 5.0)
        self.silkscreen_line_width.setSingleStep(0.1)
        self.silkscreen_line_width.setValue(0.15)
        self.silkscreen_line_width.setDecimals(2)
        self.silkscreen_line_width.setSuffix(" mm")
        self.silkscreen_line_width.valueChanged.connect(self.settings_changed.emit)
        silkscreen_layout.addWidget(self.silkscreen_line_width, 1, 1)
        
        layout.addWidget(silkscreen_group)
        
    def setup_script_settings(self, layout):
        script_group = QGroupBox("Script Output Settings")
        script_layout = QGridLayout(script_group)
        
        script_layout.addWidget(QLabel("Altium Script Output Path:"), 0, 0)
        
        path_layout = QHBoxLayout()
        self.script_output_path = QLineEdit()
        self.script_output_path.setPlaceholderText("Select output directory...")
        self.script_output_path.setText(os.path.expanduser("~/Documents"))
        path_layout.addWidget(self.script_output_path)
        
        browse_btn = QPushButton("Browse...")
        browse_btn.clicked.connect(self.browse_output_path)
        browse_btn.setMaximumWidth(80)
        path_layout.addWidget(browse_btn)
        
        script_layout.addLayout(path_layout, 0, 1)
        
        layout.addWidget(script_group)
        
    def browse_output_path(self):
        path = QFileDialog.getExistingDirectory(
            self, 
            "Select Script Output Directory",
            self.script_output_path.text()
        )
        if path:
            self.script_output_path.setText(path)
            self.settings_changed.emit()
            
    def handle_login(self):
        username = self.username_input.text().strip()
        password = self.password_input.text().strip()
        
        if not username or not password:
            QMessageBox.warning(self, "Login", "Please enter both username and password")
            return
            
        # Simple mock authentication - replace with real authentication
        if username and password:  # Accept any non-empty credentials for demo
            self.current_user = username
            self.user_display.setText(f"Welcome, {username}")
            self.login_frame.setVisible(False)
            self.logout_btn.setVisible(True)
            
            # Clear password for security
            self.password_input.clear()
            
            QMessageBox.information(self, "Login", f"Successfully logged in as {username}")
        else:
            QMessageBox.warning(self, "Login", "Invalid credentials")
            
    def handle_logout(self):
        self.current_user = None
        self.user_display.setText("Not logged in")
        self.login_frame.setVisible(True)
        self.logout_btn.setVisible(False)
        self.username_input.clear()
        self.password_input.clear()
        
    def setup_styling(self):
        self.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLabel {
                color: #ffffff;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
                color: #ffffff;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
        """)
        
    def get_settings(self):
        return {
            'body_line_width': self.body_line_width.value(),
            'courtyard_expansion': self.courtyard_expansion.value(),
            'courtyard_line_width': self.courtyard_line_width.value(),
            'silkscreen_airgap': self.silkscreen_airgap.value(),
            'silkscreen_line_width': self.silkscreen_line_width.value(),
            'script_output_path': self.script_output_path.text(),
            'current_user': self.current_user
        }
        
    def set_settings(self, settings):
        self.body_line_width.setValue(settings.get('body_line_width', 1.5))
        self.courtyard_expansion.setValue(settings.get('courtyard_expansion', 0.25))
        self.courtyard_line_width.setValue(settings.get('courtyard_line_width', 0.1))
        self.silkscreen_airgap.setValue(settings.get('silkscreen_airgap', 0.15))
        self.silkscreen_line_width.setValue(settings.get('silkscreen_line_width', 0.15))
        self.script_output_path.setText(settings.get('script_output_path', os.path.expanduser("~/Documents")))
        
        user = settings.get('current_user')
        if user:
            self.current_user = user
            self.user_display.setText(f"Welcome, {user}")
            self.login_frame.setVisible(False)
            self.logout_btn.setVisible(True)


class UpdateThread(QThread):
    update_signal = pyqtSignal(dict)
    
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.running = True
    
    def run(self):
        while self.running:
            data = self.main_window.get_footprint_data()
            self.update_signal.emit(data)
            self.msleep(100)  # Update every 100ms
    
    def stop(self):
        self.running = False

class FootprintDesigner(QMainWindow):
    def __init__(self):
        super().__init__()
        self.padstack_rows = []
        self.current_save_file = None 
        self.setup_ui()
        self.setup_dark_theme()
        self.start_update_thread()
        

    def setup_dark_theme(self):
        self.setStyleSheet("""
            QMainWindow {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLineEdit, QDoubleSpinBox, QSpinBox, QComboBox {
                background-color: #3c3c3c;
                border: 1px solid #555;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
            QScrollArea {
                background-color: #2b2b2b;
                border: none;
            }
            QFrame {
                border: 1px solid #555;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
            }
        """)

    def setup_ui(self):
        self.setWindowTitle("Footprint Designer")
        self.setGeometry(100, 100, 1800, 900)  # Increased width for settings panel

        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main splitter (3 panels: left, center, right)
        main_splitter = QSplitter(Qt.Orientation.Horizontal)
        central_widget.setLayout(QHBoxLayout())
        central_widget.layout().addWidget(main_splitter)

        # Left panel
        left_panel = self.create_left_panel()
        main_splitter.addWidget(left_panel)

        # Center panel (renderer)
        self.renderer = FootprintRenderer()
        main_splitter.addWidget(self.renderer)
        self.renderer.footprint_designer_ref = self

        # Right panel (settings) - initially hidden
        self.settings_panel = SettingsPanel()
        self.settings_panel.settings_changed.connect(self.on_settings_changed)
        self.settings_panel.setVisible(False)
        self.settings_panel.setMaximumWidth(350)
        self.settings_panel.setMinimumWidth(300)
        main_splitter.addWidget(self.settings_panel)

        # Set initial splitter proportions
        main_splitter.setSizes([800, 700, 0])  # Left, Center, Right (hidden)

    def toggle_settings_panel(self):
        """Toggle the visibility of settings panel"""
        is_visible = self.settings_panel.isVisible()
        self.settings_panel.setVisible(not is_visible)
        
        # Adjust splitter sizes
        if not is_visible:
            # Show settings panel
            self.centralWidget().layout().itemAt(0).widget().setSizes([700, 600, 300])
        else:
            # Hide settings panel
            self.centralWidget().layout().itemAt(0).widget().setSizes([800, 700, 0])

    def on_settings_changed(self):
        """Handle settings changes"""
        # Update renderer with new settings
        self.renderer.update()

        
        


    def create_left_panel(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)
        

        # Create buttons (removed fit_btn)

        header1_frame = QFrame()
        header1_frame.setFrameStyle(QFrame.Shape.StyledPanel)
        button_layout = QGridLayout(header1_frame)
        self.new_btn = QPushButton("New")
        self.save_btn = QPushButton("Save")
        self.save_as_btn = QPushButton("Save As")
        self.open_btn = QPushButton("Open")
        self.generate_btn = QPushButton("Generate Script")

        # Add buttons to layout (removed fit_btn)
        button_layout.addWidget(self.new_btn, 0, 0)
        button_layout.addWidget(self.save_btn, 0, 1)
        button_layout.addWidget(self.save_as_btn, 0, 2)
        button_layout.addWidget(self.open_btn, 0, 3)
        button_layout.addWidget(self.generate_btn, 0, 4)
 # Push buttons to the left

        # Connect signals to methods (removed fit_btn connection)
        self.new_btn.clicked.connect(self.new_footprint)
        self.save_btn.clicked.connect(self.save_data)
        self.save_as_btn.clicked.connect(self.save_data_as)
        self.open_btn.clicked.connect(self.load_data)
        self.generate_btn.clicked.connect(self.generate_footprint_script)

        layout.addWidget(header1_frame)


        # Header section (existing code)
        header_frame = QFrame()
        header_frame.setFrameStyle(QFrame.Shape.StyledPanel)
        header_layout = QGridLayout(header_frame)

        # Header inputs (existing code remains the same)
        header_layout.addWidget(QLabel("Part Number:"), 0, 0)
        self.part_number = QLineEdit()
        header_layout.addWidget(self.part_number, 0, 1)
        header_layout.addWidget(QLabel("Footprint Name:"), 0, 2)
        self.footprint_name = QLineEdit()
        header_layout.addWidget(self.footprint_name, 0, 3)

        # Rest of header inputs (keep existing code)
        header_layout.addWidget(QLabel("Body Length:"), 1, 0)
        self.body_length = QDoubleSpinBox()
        self.body_length.setRange(0.1, 100)
        self.body_length.setValue(5.0)
        self.body_length.setDecimals(5)
        header_layout.addWidget(self.body_length, 1, 1)
        
        header_layout.addWidget(QLabel("Body Width:"), 1, 2)
        self.body_width = QDoubleSpinBox()
        self.body_width.setRange(0.1, 100)
        self.body_width.setValue(3.0)
        self.body_width.setDecimals(5)
        header_layout.addWidget(self.body_width, 1, 3)

        header_layout.addWidget(QLabel("Body Height:"), 2, 0)
        self.body_height = QDoubleSpinBox()
        self.body_height.setRange(0.1, 100)
        self.body_height.setValue(1.0)
        self.body_height.setDecimals(5)
        header_layout.addWidget(self.body_height, 2, 1)
        
        # Body Shape
        header_layout.addWidget(QLabel("Body Shape:"), 2, 2)
        self.body_shape_combobox = QComboBox()
        self.body_shape_combobox.addItems(["rectangle", "round"])
        self.body_shape_combobox.setCurrentIndex(0)
        header_layout.addWidget(self.body_shape_combobox, 2, 3)


        # Show Silkscreen checkbox
        self.silkscreen_enabled = QCheckBox("Show Silkscreen")
        self.silkscreen_enabled.setChecked(True)
        header_layout.addWidget(self.silkscreen_enabled, 3, 0, 1, 2)

        # Add Padstack button
        add_btn = QPushButton("+ Add Padstack")
        add_btn.clicked.connect(self.add_padstack_row)
        header_layout.addWidget(add_btn, 3, 2, 1, 2)

        
        layout.addWidget(header_frame)

        # Padstack scroll area (existing code)
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.padstack_container = QWidget()
        self.padstack_layout = QVBoxLayout(self.padstack_container)
        self.padstack_layout.addStretch()
        scroll_area.setWidget(self.padstack_container)
        layout.addWidget(scroll_area)

        # Add initial padstack
        self.add_padstack_row()
        
        return widget

    def new_footprint(self):
        """Create a new footprint (reset all fields)"""
        reply = QMessageBox.question(
            self,
            'New Footprint',
            'Are you sure you want to create a new footprint? All current data will be lost.',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Clear current file path
            self.current_save_file = None
            
            # Clear all input fields
            self.part_number.setText('')
            self.footprint_name.setText('')
            self.body_length.setValue(5.0)
            self.body_width.setValue(3.0)
            self.body_height.setValue(1.0)
            self.body_shape_combobox.setCurrentIndex(0)
            self.silkscreen_enabled.setChecked(True)
            
            # FIXED: Reset settings panel to defaults
            default_settings = {
                'body_line_width': 1.5,
                'courtyard_expansion': 0.25,
                'courtyard_line_width': 0.1,
                'silkscreen_airgap': 0.15,
                'silkscreen_line_width': 0.15,
                'script_output_path': os.path.expanduser("~/Documents"),
                'current_user': None
            }
            self.settings_panel.set_settings(default_settings)
            
            # Clear all padstacks
            for row in self.padstack_rows[:]:
                self.delete_padstack_row(row)
            
            # Add one default padstack
            self.add_padstack_row()


    def save_data_as(self):
        """Save footprint data with a new filename (always prompts)"""
        filename, _ = QFileDialog.getSaveFileName(
            self,
            "Save Footprint As",
            "",
            "LibSienna Footprint Files (*.LibSienna);;All Files (*)"
        )
        
        if filename:
            # Automatically add .LibSienna extension if not present
            if not filename.lower().endswith('.libsienna'):
                filename += '.LibSienna'
            
            # Update current file path
            self.current_save_file = filename
            
            # Save the data
            data = self.get_footprint_data()
            success = LibSiennaFileFormat.save_footprint(data, filename)
            
            if success:
                QMessageBox.information(
                    self, 
                    "Success", 
                    f"Footprint saved successfully as {os.path.basename(filename)}!"
                )
            else:
                QMessageBox.critical(self, "Error", "Failed to save footprint file!")

    def generate_footprint_script(self):
        """Generate footprint script from current data and save to a text file"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        lines = []
        
        # Scale factor for unit conversion (mm to mils)
        SCALE = 39.37
        
        # Footprint name
        footprint_name = data.get('footprint_name', 'Unnamed')
        lines.append(f"StartFootprints\n\nFootprint (Name \"{footprint_name}\"),")

        # Body dimensions
        body_length = data.get('body_length', 0)
        body_width = data.get('body_width', 0)
        half_length = body_length / 2
        half_width = body_width / 2

        # Define corners of body rectangle
        bl = (-half_length, -half_width)
        tl = (-half_length, half_width)
        tr = (half_length, half_width)
        br = (half_length, -half_width)

        # Body shape generation
        body_shape = data.get('body_shape', 'rectangle')
        if body_shape == 'rectangle':
            lines.append(f"Line (Width 1.7) (Start {tl[0]*SCALE:.2f}, {tl[1]*SCALE:.2f}) (End {tr[0]*SCALE:.2f}, {tr[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {bl[0]*SCALE:.2f}, {bl[1]*SCALE:.2f}) (End {tl[0]*SCALE:.2f}, {tl[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {tr[0]*SCALE:.2f}, {tr[1]*SCALE:.2f}) (End {br[0]*SCALE:.2f}, {br[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {br[0]*SCALE:.2f}, {br[1]*SCALE:.2f}) (End {bl[0]*SCALE:.2f}, {bl[1]*SCALE:.2f}) (Layer Mechanical13)")
        else:
            radius = max(half_length, half_width)
            lines.append(f"Line (Width 1.7) (Center (0, 0)) (Radius {radius*SCALE:.2f}) (Layer Mechanical13)")

        # FIXED: Calculate pad absolute bounds for silkscreen gap calculation
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        pad_bounds_list = []
        
        for i, pad in enumerate(pads):
            abs_x, abs_y = resolver.get_absolute_position(pad)
            pad_type = pad.get('type', 'square')
            
            if pad_type == 'square':
                size = pad.get('size', 1)
                pb = [abs_x - size/2, abs_y - size/2, abs_x + size/2, abs_y + size/2]
            elif pad_type in ['rectangle', 'rounded_rectangle']:
                length = pad.get('length', 1)
                width = pad.get('width', 1)
                pb = [abs_x - length/2, abs_y - width/2, abs_x + length/2, abs_y + width/2]
            elif pad_type == 'round':
                diameter = pad.get('diameter', 1)
                pb = [abs_x - diameter/2, abs_y - diameter/2, abs_x + diameter/2, abs_y + diameter/2]
            elif pad_type in ['PTH', 'NPTH']:
                if pad_type == 'PTH':
                    diameter = pad.get('pad_diameter', 1.2)
                else:
                    diameter = pad.get('hole_diameter', 0.8)
                pb = [abs_x - diameter/2, abs_y - diameter/2, abs_x + diameter/2, abs_y + diameter/2]
            elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
                if pad_type == 'PTH_oblong':
                    length = pad.get('pad_length', 2.0)
                    width = pad.get('pad_width', 1.2)
                else:
                    length = pad.get('hole_length', 1.5)
                    width = pad.get('hole_width', 0.8)
                pb = [abs_x - length/2, abs_y - width/2, abs_x + length/2, abs_y + width/2]
            elif pad_type == 'custom':
                # Simplified bounds for custom pads
                pb = [abs_x - 0.5, abs_y - 0.5, abs_x + 0.5, abs_y + 0.5]
            else:
                pb = [abs_x - 0.5, abs_y - 0.5, abs_x + 0.5, abs_y + 0.5]
                
            pad_bounds_list.append(pb)

        # Helper functions for silkscreen with gaps
        def merge_intervals(intervals):
            if not intervals:
                return []
            intervals = sorted(intervals, key=lambda x: x[0])
            merged = [intervals[0]]
            for current in intervals[1:]:
                last_start, last_end = merged[-1]
                current_start, current_end = current
                if current_start <= last_end:  # overlap
                    merged[-1] = (last_start, max(last_end, current_end))
                else:
                    merged.append(current)
            return merged


        def generate_silkscreen_lines_with_gaps(x1, y1, x2, y2, pad_bounds_list, gap, orientation):
            segments = []
            if orientation == 'horizontal':
                start_pos = min(x1, x2)
                end_pos = max(x1, x2)
                line_y = y1
                intersections = []
                
                for (px_min, py_min, px_max, py_max) in pad_bounds_list:
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if horizontal line intersects with expanded pad
                    if (pad_min_y <= line_y <= pad_max_y and 
                        pad_max_x >= start_pos and pad_min_x <= end_pos):
                        inter_start = max(start_pos, pad_min_x)
                        inter_end = min(end_pos, pad_max_x)
                        intersections.append((inter_start, inter_end))
                
                # Merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Generate line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        segments.append((current_pos, line_y, gap_start, line_y))
                    current_pos = gap_end
                if current_pos < end_pos:
                    segments.append((current_pos, line_y, end_pos, line_y))
                    
            else:  # vertical
                start_pos = min(y1, y2)
                end_pos = max(y1, y2)
                line_x = x1
                intersections = []
                
                for (px_min, py_min, px_max, py_max) in pad_bounds_list:
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if vertical line intersects with expanded pad
                    if (pad_min_x <= line_x <= pad_max_x and 
                        pad_max_y >= start_pos and pad_min_y <= end_pos):
                        inter_start = max(start_pos, pad_min_y)
                        inter_end = min(end_pos, pad_max_y)
                        intersections.append((inter_start, inter_end))
                
                # Merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Generate line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        segments.append((line_x, current_pos, line_x, gap_start))
                    current_pos = gap_end
                if current_pos < end_pos:
                    segments.append((line_x, current_pos, line_x, end_pos))
                    
            return segments

        # FIXED: Generate silkscreen with gaps (matching live view)
        silkscreen_gap = data.get('silkscreen_airgap', 0.15)
        
        # Generate silkscreen lines with gaps for each side of body rectangle
        silk_lines = []
        # Top line
        silk_lines += generate_silkscreen_lines_with_gaps(-half_length, half_width, half_length, half_width, pad_bounds_list, silkscreen_gap, 'horizontal')
        # Bottom line  
        silk_lines += generate_silkscreen_lines_with_gaps(-half_length, -half_width, half_length, -half_width, pad_bounds_list, silkscreen_gap, 'horizontal')
        # Left line
        silk_lines += generate_silkscreen_lines_with_gaps(-half_length, -half_width, -half_length, half_width, pad_bounds_list, silkscreen_gap, 'vertical')
        # Right line
        silk_lines += generate_silkscreen_lines_with_gaps(half_length, -half_width, half_length, half_width, pad_bounds_list, silkscreen_gap, 'vertical')
        
        # Add silkscreen segment lines to script
        for (x1_, y1_, x2_, y2_) in silk_lines:
            lines.append(f"Line (Width 6) (Start {x1_*SCALE:.2f}, {y1_*SCALE:.2f}) (End {x2_*SCALE:.2f}, {y2_*SCALE:.2f}) (Layer TopOverlay)")

        # Calculate pad bounds for courtyard (same logic as live view)
        pad_bounds = None
        if pad_bounds_list:
            min_x = min(pb[0] for pb in pad_bounds_list)
            min_y = min(pb[1] for pb in pad_bounds_list)
            max_x = max(pb[2] for pb in pad_bounds_list)
            max_y = max(pb[3] for pb in pad_bounds_list)
            pad_bounds = [min_x, min_y, max_x, max_y]

        # FIXED: Courtyard based on outermost bounds (matching live view)
        courtyard_expansion = data.get('courtyard_expansion', 0.25)
        body_bounds = [-half_length, -half_width, half_length, half_width]
        
        # Use outermost bounds logic (same as live view)
        if body_bounds and pad_bounds:
            outermost_bounds = [
                min(body_bounds[0], pad_bounds[0]),  # min_x
                min(body_bounds[1], pad_bounds[1]),  # min_y  
                max(body_bounds[2], pad_bounds[2]),  # max_x
                max(body_bounds[3], pad_bounds[3])   # max_y
            ]
        elif body_bounds:
            outermost_bounds = body_bounds
        elif pad_bounds:
            outermost_bounds = pad_bounds
        else:
            outermost_bounds = body_bounds

        if outermost_bounds:
            cy_tl = (outermost_bounds[0] - courtyard_expansion, outermost_bounds[3] + courtyard_expansion)
            cy_tr = (outermost_bounds[2] + courtyard_expansion, outermost_bounds[3] + courtyard_expansion)
            cy_br = (outermost_bounds[2] + courtyard_expansion, outermost_bounds[1] - courtyard_expansion)
            cy_bl = (outermost_bounds[0] - courtyard_expansion, outermost_bounds[1] - courtyard_expansion)

            lines.append(f"Line (Width 1.7) (Start {cy_tl[0]*SCALE:.2f}, {cy_tl[1]*SCALE:.2f}) (End {cy_tr[0]*SCALE:.2f}, {cy_tr[1]*SCALE:.2f}) (Layer Mechanical15)")
            lines.append(f"Line (Width 1.7) (Start {cy_tr[0]*SCALE:.2f}, {cy_tr[1]*SCALE:.2f}) (End {cy_br[0]*SCALE:.2f}, {cy_br[1]*SCALE:.2f}) (Layer Mechanical15)")
            lines.append(f"Line (Width 1.7) (Start {cy_br[0]*SCALE:.2f}, {cy_br[1]*SCALE:.2f}) (End {cy_bl[0]*SCALE:.2f}, {cy_bl[1]*SCALE:.2f}) (Layer Mechanical15)")
            lines.append(f"Line (Width 1.7) (Start {cy_bl[0]*SCALE:.2f}, {cy_bl[1]*SCALE:.2f}) (End {cy_tl[0]*SCALE:.2f}, {cy_tl[1]*SCALE:.2f}) (Layer Mechanical15)")

        # Generate pads (using absolute positions)
        for pad in pads:
            pad_type = pad.get('type', 'square')
            name = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)  # Use absolute position
            rotation = 0
            expand_mask = pad.get('mask_expansion', 0)
            expand_paste = pad.get('paste_expansion', 0)
            surface = 'True' if pad_type not in ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong'] else 'False'

            if pad_type == 'square':
                size = pad.get('size', 1)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {size*SCALE:.2f}, {size*SCALE:.2f}) (Shape Rectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'rectangle':
                length = pad.get('length', 1)
                width = pad.get('width', 1)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {length*SCALE:.2f}, {width*SCALE:.2f}) (Shape Rectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'rounded_rectangle':
                length = pad.get('length', 1)
                width = pad.get('width', 1)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {length*SCALE:.2f}, {width*SCALE:.2f}) (Shape RoundedRectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'round':
                diameter = pad.get('diameter', 1)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {diameter*SCALE:.2f}, {diameter*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'custom':
                polygon_data = pad.get('polygon_data', {})
                lines_data = polygon_data.get('lines', [])
                point_coords = [(abs_x, abs_y)]
                current_x, current_y = abs_x, abs_y
                
                for ld in lines_data:
                    direction = ld.get('direction', 'right')
                    line_size = ld.get('line_size', 0)
                    if direction == 'right':
                        current_x += line_size
                    elif direction == 'left':
                        current_x -= line_size
                    elif direction == 'up':
                        current_y += line_size
                    elif direction == 'down':
                        current_y -= line_size
                    point_coords.append((current_x, current_y))
                
                lines.append(f"Polygon (PointCount {len(point_coords)}) (Layer TopLayer)")
                for px, py in point_coords:
                    lines.append(f"Point ({px*SCALE:.2f}, {py*SCALE:.2f})")
                lines.append("EndPolygon")

            elif pad_type in ['PTH', 'NPTH']:
                hole_diameter = pad.get('hole_diameter', 0.8)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Slotted False) (HoleSize {hole_diameter*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                
                if pad_type == 'PTH':
                    pad_diameter = pad.get('pad_diameter', 1.2)
                    lines.append(f"PadShape (Size {pad_diameter*SCALE:.2f}, {pad_diameter*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                    lines.append(f"PadShape (Size {pad_diameter*SCALE:.2f}, {pad_diameter*SCALE:.2f}) (Shape Rounded) (Layer Bottom)")
                lines.append("EndPad")

            elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
                hole_length = pad.get('hole_length', 1.5)
                hole_width = pad.get('hole_width', 0.8)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Slotted True) (SlotWidth {hole_width*SCALE:.2f}) (SlotHeight {hole_length*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                
                if pad_type == 'PTH_oblong':
                    pad_length = pad.get('pad_length', 2.0)
                    pad_width = pad.get('pad_width', 1.2)
                    lines.append(f"PadShape (Size {pad_length*SCALE:.2f}, {pad_width*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                    lines.append(f"PadShape (Size {pad_length*SCALE:.2f}, {pad_width*SCALE:.2f}) (Shape Rounded) (Layer Bottom)")
                lines.append("EndPad")

        lines.append("EndFootprint\nEndFootprints")

        # Join lines and save
        script = '\n'.join(lines)

        output_path = settings.get('script_output_path', os.path.expanduser("~/Documents"))
        footprint_name = data.get('footprint_name', 'Unnamed')
        file_name = os.path.join(output_path, f"{footprint_name}_footprint.txt")
        
        try:
            with open(file_name, "w") as f:
                f.write(script)
            
            # Show dialog
            dialog = QMessageBox(self)
            dialog.setWindowTitle("Generated Footprint Script")
            dialog.setText(f"Generated script saved to:\n{file_name}")
            dialog.setDetailedText(script)
            dialog.setIcon(QMessageBox.Icon.Information)
            dialog.exec()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save script file:\n{str(e)}")


    def add_padstack_row(self):
        row = PadStackRow()
        row.delete_requested.connect(self.delete_padstack_row)
        row.data_changed.connect(self.on_data_changed)
        row.duplicate_btn.clicked.connect(lambda: self.duplicate_padstack_row(row))
        
        self.padstack_rows.append(row)
        self.padstack_layout.insertWidget(len(self.padstack_rows) - 1, row)
        
        # Set pin number automatically
        row.pin_number.setText(str(len(self.padstack_rows)))
        
        # Update all offset_from dropdowns
        self.update_all_offset_dropdowns()

    def delete_padstack_row(self, row):
        if len(self.padstack_rows) > 0:
            self.padstack_rows.remove(row)
            row.setParent(None)
            # Update all remaining offset_from dropdowns
            self.update_all_offset_dropdowns()

    def update_all_offset_dropdowns(self):
        """Update all offset_from dropdowns when pads are added/removed"""
        for row in self.padstack_rows:
            row.update_offset_from_options()

    
    def duplicate_padstack_row(self, original_row):
        new_row = PadStackRow()
        new_row.delete_requested.connect(self.delete_padstack_row)
        new_row.data_changed.connect(self.on_data_changed)
        new_row.duplicate_btn.clicked.connect(lambda: self.duplicate_padstack_row(new_row))
        
        # Copy data from original
        data = original_row.get_data()
        data['pin_number'] = str(len(self.padstack_rows) + 1)
        
        # Add to layout FIRST so update_offset_from_options can find all rows
        self.padstack_rows.append(new_row)
        self.padstack_layout.insertWidget(len(self.padstack_rows) - 1, new_row)
        
        # Update all dropdowns to include the new pin numbers
        self.update_all_offset_dropdowns()
        
        # NOW set the data - the dropdown will have the correct options
        new_row.set_data(data)

    
    def on_data_changed(self):
        # This will be handled by the update thread
        pass
    
    def get_footprint_data(self):
        settings = self.settings_panel.get_settings()
        
        data = {
            'part_number': self.part_number.text(),
            'footprint_name': self.footprint_name.text(),
            'body_length': self.body_length.value(),
            'body_width': self.body_width.value(),
            'body_height': self.body_height.value(),
            'body_shape': self.body_shape_combobox.currentText(),
            'courtyard_expansion': settings['courtyard_expansion'],  # From settings panel
            'silkscreen_airgap': settings['silkscreen_airgap'],      # From settings panel
            'silkscreen_enabled': self.silkscreen_enabled.isChecked(),
            'padstacks': [row.get_data() for row in self.padstack_rows],
            # Add new settings
            'body_line_width': settings['body_line_width'],
            'courtyard_line_width': settings['courtyard_line_width'],
            'silkscreen_line_width': settings['silkscreen_line_width'],
            'script_output_path': settings['script_output_path']
        }
        return data



    def set_footprint_data(self, data):
        self.part_number.setText(data.get('part_number', ''))
        self.footprint_name.setText(data.get('footprint_name', ''))
        self.body_length.setValue(data.get('body_length', 5.0))
        self.body_width.setValue(data.get('body_width', 3.0))
        self.body_height.setValue(data.get('body_height', 1.0))
        self.body_shape_combobox.setCurrentText(data.get('body_shape', 'rectangle'))
        self.silkscreen_enabled.setChecked(data.get('silkscreen_enabled', True))

        # FIXED: Update settings panel instead of direct attributes
        settings = {
            'body_line_width': data.get('body_line_width', 1.5),
            'courtyard_expansion': data.get('courtyard_expansion', 0.25),
            'courtyard_line_width': data.get('courtyard_line_width', 0.1),
            'silkscreen_airgap': data.get('silkscreen_airgap', 0.15),
            'silkscreen_line_width': data.get('silkscreen_line_width', 0.15),
            'script_output_path': data.get('script_output_path', os.path.expanduser("~/Documents")),
            'current_user': data.get('current_user', None)
        }
        self.settings_panel.set_settings(settings)

        # Clear existing padstacks
        for row in self.padstack_rows[:]:
            self.delete_padstack_row(row)

        # Add padstacks from data
        for pad_data in data.get('padstacks', []):
            self.add_padstack_row()
            self.padstack_rows[-1].set_data(pad_data)


    
    def save_data(self):
        """Save footprint data - prompts for filename only if not previously saved"""
        if self.current_save_file is None:
            # No file currently open, act like "Save As"
            self.save_data_as() 
        else:
            # File already exists, just update it
            data = self.get_footprint_data()
            success = LibSiennaFileFormat.save_footprint(data, self.current_save_file)
            
            if success:
                QMessageBox.information(
                    self, 
                    "Success", 
                    f"Footprint updated successfully!\n{os.path.basename(self.current_save_file)}"
                )
            else:
                QMessageBox.critical(self, "Error", "Failed to save footprint file!")


    def load_data(self):
        """Load footprint data from custom LibSienna format"""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "Load Footprint",
            "",
            "LibSienna Footprint Files (*.LibSienna);;All Files (*)"
        )
        
        if filename:
            data = LibSiennaFileFormat.load_footprint(filename)
            if data:
                self.set_footprint_data(data)
                # IMPORTANT: Set current file path so Save will work
                self.current_save_file = filename
                QMessageBox.information(
                    self, 
                    "Success", 
                    f"Footprint loaded successfully from {os.path.basename(filename)}!"
                )
            else:
                QMessageBox.critical(self, "Error", "Failed to load footprint file!")
        
    def fit_to_view(self):
        self.renderer.auto_fit = True
        self.renderer.fit_to_view()
        self.renderer.update()
    
    def start_update_thread(self):
        self.update_thread = UpdateThread(self)
        self.update_thread.update_signal.connect(self.renderer.update_footprint)
        self.update_thread.start()
    
    def closeEvent(self, event):    
        if hasattr(self, 'update_thread'):
            self.update_thread.stop()
            self.update_thread.wait()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    
    # Set application-wide dark theme
    app.setStyle('Fusion')
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(43, 43, 43))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Base, QColor(60, 60, 60))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(80, 80, 80))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Text, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Button, QColor(74, 74, 74))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 0, 0))
    palette.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(0, 0, 0))
    app.setPalette(palette)
    
    window = FootprintDesigner()
    window.show()
    
    sys.exit(app.exec()) min_y, max_x, max_y = bounds
                if min_x <= world_x <= max_x and min_y <= world_y <= max_y:
                    clicked_pad = i
                    break
        
        if clicked_pad is not None:
            # Toggle pad selection
            if clicked_pad in self.selected_pads:
                self.selected_pads.remove(clicked_pad)
            else:
                # Limit to 2 pads maximum
                if len(self.selected_pads) >= 2:
                    # Remove oldest selection (FIFO)
                    oldest_pad = next(iter(self.selected_pads))
                    self.selected_pads.remove(oldest_pad)
                self.selected_pads.add(clicked_pad)
        else:
            # Click outside pads - clear selection
            self.selected_pads.clear()
        
        self.update()  # Repaint to show selection changes


    def setup_dimension_controls(self):
        """Create overlay dimension control widgets"""
        # Air Gap Dimensions toggle
        self.show_airgap_checkbox = QCheckBox("Show Air Gap Dimensions", self)
        self.show_airgap_checkbox.setChecked(True)
        self.show_airgap_checkbox.move(10, 10)
        self.show_airgap_checkbox.setStyleSheet("""
            QCheckBox {
                color: #00FFFF;
                background-color: rgba(0,0,0,180);
                padding: 4px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
            }
            QCheckBox::indicator {
                width: 14px;
                height: 14px;
            }
            QCheckBox::indicator:checked {
                background-color: #00FFFF;
            }
        """)

        # Pitch Dimensions toggle
        self.show_pitch_checkbox = QCheckBox("Show Pitch Dimensions", self)
        self.show_pitch_checkbox.setChecked(False)
        self.show_pitch_checkbox.move(10, 40)
        self.show_pitch_checkbox.setStyleSheet("""
            QCheckBox {
                color: #FFA500;
                background-color: rgba(0,0,0,180);
                padding: 4px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
            }
            QCheckBox::indicator {
                width: 14px;
                height: 14px;
            }
            QCheckBox::indicator:checked {
                background-color: #FFA500;
            }
        """)

        # Clear All Dimensions button
        self.clear_dims_btn = QPushButton("Clear All Dimensions", self)
        self.clear_dims_btn.move(10, 70)
        self.clear_dims_btn.setMaximumWidth(160)
        self.clear_dims_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(68,68,68,200);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
                border: 1px solid #666;
            }
            QPushButton:hover {
                background-color: rgba(88,88,88,220);
            }
            QPushButton:pressed {
                background-color: rgba(48,48,48,200);
            }
        """)

        # NEW: Fit to View button
        self.fit_to_view_btn = QPushButton("Fit to View", self)
        self.fit_to_view_btn.move(10, 100)
        self.fit_to_view_btn.setMaximumWidth(160)

        self.fit_to_view_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(68,68,68,200);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
                border: 1px solid #666;
            }
            QPushButton:hover {
                background-color: rgba(88,88,88,220);
            }
            QPushButton:pressed {
                background-color: rgba(48,48,48,200);
            }
        """)

        # Connect signals
        # NEW: Settings button in top right
        self.settings_btn = QPushButton("Settings", self)
        self.settings_btn.setMaximumWidth(80)
        self.settings_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(68,68,68,200);
                color: white;
                padding: 6px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
                border: 1px solid #666;
            }
            QPushButton:hover {
                background-color: rgba(88,88,88,220);
            }
            QPushButton:pressed {
                background-color: rgba(48,48,48,200);
            }
        """)

        # Connect signals
        self.show_airgap_checkbox.stateChanged.connect(self.on_dimension_toggle)
        self.show_pitch_checkbox.stateChanged.connect(self.on_dimension_toggle)
        self.clear_dims_btn.clicked.connect(self.on_clear_dimensions)
        self.fit_to_view_btn.clicked.connect(self.on_fit_to_view)
        # NEW: Connect settings button
        self.settings_btn.clicked.connect(self.toggle_settings_panel)

    def resizeEvent(self, event):
        """Handle resize events to position settings button"""
        super().resizeEvent(event)
        # Position settings button in top right corner
        if hasattr(self, 'settings_btn'):
            self.settings_btn.move(self.width() - 90, 10)

    def toggle_settings_panel(self):
        """Toggle settings panel visibility"""
        if hasattr(self, 'footprint_designer_ref'):
            self.footprint_designer_ref.toggle_settings_panel()

    def on_dimension_toggle(self):
        """Handle dimension toggle changes"""
        self.update()  # Trigger repaint

    def on_clear_dimensions(self):
        """Clear all dimension displays and selections"""
        self.show_airgap_checkbox.setChecked(False)
        self.show_pitch_checkbox.setChecked(False)
        self.selected_pads.clear()  # Clear pad selections
        self.update()

        
    def update_footprint(self, data):
        self.footprint_data = data
        # Clear cached absolute positions when data changes
        self._absolute_positions = None
        if self.auto_fit:
            self.fit_to_view()
        self.update()

    def on_fit_to_view(self):
        """Handle fit to view button click"""
        self.auto_fit = True
        self.fit_to_view()
        self.update()

    def fit_to_view(self):
        if not self.footprint_data.get('padstacks') and not all(k in self.footprint_data for k in ['body_length', 'body_width']):
            return
        
        # Reset offsets for auto-fit
        self.offset_x = 0.0
        self.offset_y = 0.0
        
        # Calculate body bounds
        body_bounds = None
        if all(k in self.footprint_data for k in ['body_length', 'body_width']):
            length = self.footprint_data['body_length']
            width = self.footprint_data['body_width']
            body_bounds = [-length/2, -width/2, length/2, width/2]
        
        # Calculate pad bounds
        pad_bounds = self.calculate_all_pads_bounds()
        
        # Determine outermost bounds
        if body_bounds and pad_bounds:
            min_x = min(body_bounds[0], pad_bounds[0])
            min_y = min(body_bounds[1], pad_bounds[1])
            max_x = max(body_bounds[2], pad_bounds[2])
            max_y = max(body_bounds[3], pad_bounds[3])
        elif body_bounds:
            min_x, min_y, max_x, max_y = body_bounds
        elif pad_bounds:
            min_x, min_y, max_x, max_y = pad_bounds
        else:
            return
        
        # Add courtyard expansion
        courtyard = self.footprint_data.get('courtyard_expansion', 0.25)
        min_x -= courtyard
        max_x += courtyard
        min_y -= courtyard
        max_y += courtyard
        
        # Calculate zoom to fit
        if max_x > min_x and max_y > min_y:
            margin = 20
            zoom_x = (self.width() - 2 * margin) / (max_x - min_x)
            zoom_y = (self.height() - 2 * margin) / (max_y - min_y)
            self.zoom_factor = min(zoom_x, zoom_y, 110)  # Max zoom limit
        
        self.update()
    
    def calculate_pad_bounds(self, pad):
        """Calculate bounding box for a pad"""
        x = pad.get('x_offset', 0)
        y = pad.get('y_offset', 0)
        pad_type = pad['type']
        
        if pad_type == 'square':
            size = pad.get('size', 1)
            return [x - size/2, y - size/2, x + size/2, y + size/2]
        elif pad_type in ['rectangle', 'rounded_rectangle']:
            length = pad.get('length', 1)
            width = pad.get('width', 1)
            return [x - length/2, y - width/2, x + length/2, y + width/2]
        elif pad_type == 'round':
            diameter = pad.get('diameter', 1)
            return [x - diameter/2, y - diameter/2, x + diameter/2, y + diameter/2]
        elif pad_type == 'custom':
            # Calculate bounds for custom polygon
            polygon_points = self.calculate_polygon_points(pad)
            if polygon_points:
                xs = [p.x() for p in polygon_points]
                ys = [p.y() for p in polygon_points]
                return [min(xs), min(ys), max(xs), max(ys)]
        
        return None
    
    def calculate_polygon_points(self, pad):
        """Calculate polygon points from line definitions with proper corner handling"""
        lines_data = pad.get('polygon_data', {}).get('lines', [])
        if not lines_data:
            return []

        raw_points = []
        current_x = pad.get('x_offset', 0)
        current_y = pad.get('y_offset', 0)
        raw_points.append((current_x, current_y))

        for line_data in lines_data:
            line_size = line_data.get('line_size', 1.0)
            direction = line_data.get('direction', 'right')

            if direction == 'right':
                current_x += line_size
            elif direction == 'down':
                current_y -= line_size
            elif direction == 'left':
                current_x -= line_size
            elif direction == 'up':
                current_y += line_size

            raw_points.append((current_x, current_y))

        final_points = []
        final_points.append(QPointF(raw_points[0][0], raw_points[0][1]))


        for i in range(1, len(raw_points) - 1):
            prev_point = raw_points[i-1]
            curr_point = raw_points[i]
            next_point = raw_points[i+1]

            line_data = lines_data[i-1]
            corner_type = line_data.get('corner_type', '90-degree')
            corner_size = line_data.get('corner_size', 0)

            if corner_type == '90-degree' or corner_size == 0:
                final_points.append(QPointF(curr_point[0], curr_point[1]))  # FIXED
            elif corner_type == 'chamfer':
                chamfer_points = self.calculate_chamfer_points(
                    QPointF(prev_point[0], prev_point[1]),  # FIXED
                    QPointF(curr_point[0], curr_point[1]),   # FIXED
                    QPointF(next_point[0], next_point[1]),   # FIXED
                    corner_size
                )
                final_points.extend(chamfer_points)
            elif corner_type == 'fillet':
                fillet_points = self.calculate_fillet_points(
                    QPointF(prev_point[0], prev_point[1]),   # FIXED
                    QPointF(curr_point[0], curr_point[1]),   # FIXED
                    QPointF(next_point[0], next_point[1]),   # FIXED
                    corner_size
                )
                final_points.extend(fillet_points)

        final_points.append(QPointF(raw_points[-1][0], raw_points[-1][1]))  # FIXED
        return final_points

    def calculate_all_pad_pitches(self):
        """Calculate center-to-center pitch distances between all pad pairs"""
        pads = self.footprint_data.get('padstacks', [])
        if len(pads) < 2:
            return []
        
        pitches = []
        positions = self.calculate_pad_absolute_positions()
        
        # Calculate pitches between all pad pairs
        for i in range(len(pads)):
            for j in range(i + 1, len(pads)):
                if i not in positions or j not in positions:
                    continue
                    
                x1, y1 = positions[i]
                x2, y2 = positions[j]
                
                dx = abs(x2 - x1)
                dy = abs(y2 - y1)
                
                # Add horizontal pitch if significant
                if dx > 0.01:  # Minimum threshold to avoid noise
                    pitches.append({
                        'pad_pair': (i, j),
                        'direction': 'horizontal',
                        'pitch': dx,
                        'start_pos': QPointF(min(x1, x2), (y1 + y2) / 2),
                        'end_pos': QPointF(max(x1, x2), (y1 + y2) / 2)
                    })
                
                # Add vertical pitch if significant  
                if dy > 0.01:
                    pitches.append({
                        'pad_pair': (i, j),
                        'direction': 'vertical', 
                        'pitch': dy,
                        'start_pos': QPointF((x1 + x2) / 2, min(y1, y2)),
                        'end_pos': QPointF((x1 + x2) / 2, max(y1, y2))
                    })
        
        return pitches




    def calculate_min_pad_to_pad_airgap(self):
        """Calculate minimum edge-to-edge distance between all pads"""
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if len(pad_bounds_list) < 2:
            return None, None

        min_gap = float('inf')
        closest_pads = None

        for i in range(len(pad_bounds_list)):
            for j in range(i + 1, len(pad_bounds_list)):
                # Unpack bounds
                x1_min, y1_min, x1_max, y1_max = pad_bounds_list[i]
                x2_min, y2_min, x2_max, y2_max = pad_bounds_list[j]

                # Horizontal gap
                if x1_max < x2_min:  # b1 right edge < b2 left edge
                    x_gap = x2_min - x1_max
                elif x2_max < x1_min:  # b2 right edge < b1 left edge
                    x_gap = x1_min - x2_max
                else:
                    x_gap = 0  # Overlapping in X

                # Vertical gap
                if y1_max < y2_min:  # b1 top edge < b2 bottom edge
                    y_gap = y2_min - y1_max
                elif y2_max < y1_min:  # b2 top edge < b1 bottom edge
                    y_gap = y1_min - y2_max
                else:
                    y_gap = 0  # Overlapping in Y

                # Actual distance
                if x_gap == 0 and y_gap == 0:
                    dist = 0  # Overlapping pads
                elif x_gap == 0:
                    dist = y_gap  # Vertically separated
                elif y_gap == 0:
                    dist = x_gap  # Horizontally separated
                else:
                    dist = math.sqrt(x_gap**2 + y_gap**2)  # Corner-to-corner

                if dist < min_gap:
                    min_gap = dist
                    closest_pads = (i, j, x_gap, y_gap)

        return (min_gap if min_gap != float('inf') else None), closest_pads

    def calculate_all_pad_airgaps(self):
        """Calculate only X and Y edge-to-edge pad clearances."""
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if len(pad_bounds_list) < 2:
            return []
        
        airgaps = []
        
        for i in range(len(pad_bounds_list)):
            for j in range(i + 1, len(pad_bounds_list)):
                b1 = pad_bounds_list[i]  # [min_x, min_y, max_x, max_y]
                b2 = pad_bounds_list[j]

                h_start = h_end = v_start = v_end = None
                x_gap = y_gap = 0

                # --- Horizontal gap (edge-to-edge) ---
                if b1[2] < b2[0]:  # pad1 right to pad2 left
                    x_gap = b2[0] - b1[2]
                    h_start = QPointF(b1[2], (b1[1] + b1[3]) / 2)
                    h_end   = QPointF(b2[0], (b2[1] + b2[3]) / 2)
                elif b2[2] < b1[0]:  # pad2 right to pad1 left
                    x_gap = b1[0] - b2[2]
                    h_start = QPointF(b2[2], (b2[1] + b2[3]) / 2)
                    h_end   = QPointF(b1[0], (b1[1] + b1[3]) / 2)

                # --- Vertical gap (edge-to-edge) ---
                if b1[3] < b2[1]:  # pad1 top to pad2 bottom
                    y_gap = b2[1] - b1[3]
                    v_start = QPointF((b1[0] + b1[2]) / 2, b1[3])
                    v_end   = QPointF((b2[0] + b2[2]) / 2, b2[1])
                elif b2[3] < b1[1]:  # pad2 top to pad1 bottom
                    y_gap = b1[1] - b2[3]
                    v_start = QPointF((b2[0] + b2[2]) / 2, b2[3])
                    v_end   = QPointF((b1[0] + b1[2]) / 2, b1[1])

                airgaps.append({
                    'pads': (i, j),
                    'x_gap': x_gap,
                    'y_gap': y_gap,
                    'h_line': (h_start, h_end) if h_start and h_end else None,
                    'v_line': (v_start, v_end) if v_start and v_end else None,
                })
        
        return airgaps


    def draw_dimension_line_with_label(self, painter, start_point, end_point, value_mm, label_prefix, color, label_offset=QPointF(0,0)):
        """Draw a dimension line with colored 'pill' label in mm with optional offset."""
        if not start_point or not end_point or value_mm <= 0:
            return

        # 1) Dimension line
        painter.setPen(QPen(color, 1.5/self.zoom_factor))
        painter.drawLine(start_point, end_point)

        # 2) End ticks
        ext = 3/self.zoom_factor
        v = QPointF(end_point.x() - start_point.x(), end_point.y() - start_point.y())
        L = math.hypot(v.x(), v.y())
        if L > 0:
            n = QPointF(v.x()/L, v.y()/L)
            p = QPointF(-n.y(), n.x())
            painter.drawLine(QPointF(start_point.x()+p.x()*ext, start_point.y()+p.y()*ext),
                            QPointF(start_point.x()-p.x()*ext, start_point.y()-p.y()*ext))
            painter.drawLine(QPointF(end_point.x()+p.x()*ext, end_point.y()+p.y()*ext),
                            QPointF(end_point.x()-p.x()*ext, end_point.y()-p.y()*ext))

        # 3) Label (world midpoint -> screen) with offset
        mid = QPointF((start_point.x()+end_point.x())/2, (start_point.y()+end_point.y())/2)
        screen_mid = painter.worldTransform().map(mid)
        
        # Apply offset to prevent label overlap
        screen_mid += label_offset

        label_text = f"{label_prefix}:{value_mm:.1f}mm"

        painter.save()
        painter.resetTransform()
        font = QFont("Arial", 9)
        font.setBold(True)
        painter.setFont(font)
        fm = painter.fontMetrics()
        rect = fm.boundingRect(label_text)
        rect.moveCenter(screen_mid.toPoint())
        rect.adjust(-4, -2, 4, 2)

        bg = QColor(color)
        bg.setAlpha(200)
        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush(bg))
        painter.drawRoundedRect(rect, 4, 4)

        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush())
        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, label_text)
        painter.restore()

    def draw_all_airgap_dimensions(self, painter):
        """Draw air gap dimensions only between selected pads (if exactly 2 selected)"""
        if len(self.selected_pads) != 2:
            return

        pad_indices = list(self.selected_pads)
        i, j = pad_indices[0], pad_indices[1]

        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if i >= len(pad_bounds_list) or j >= len(pad_bounds_list):
            return

        b1 = pad_bounds_list[i]  # (x_min, y_min, x_max, y_max)
        b2 = pad_bounds_list[j]

        # Calculate horizontal gap (X)
        h_start = h_end = None
        x_gap = 0

        if b1[2] < b2[0]:  # pad1 right edge < pad2 left edge
            x_gap = b2[0] - b1[2]
            h_start = QPointF(b1[2], (b1[1] + b1[3]) / 2)
            h_end   = QPointF(b2[0], (b2[1] + b2[3]) / 2)

        elif b2[2] < b1[0]:  # pad2 right edge < pad1 left edge
            x_gap = b1[0] - b2[2]
            h_start = QPointF(b2[2], (b2[1] + b2[3]) / 2)
            h_end   = QPointF(b1[0], (b1[1] + b1[3]) / 2)

        # Calculate vertical gap (Y)
        v_start = v_end = None
        y_gap = 0

        if b1[3] < b2[1]:  # pad1 top < pad2 bottom
            y_gap = b2[1] - b1[3]
            v_start = QPointF((b1[0] + b1[2]) / 2, b1[3])
            v_end   = QPointF((b2[0] + b2[2]) / 2, b2[1])

        elif b2[3] < b1[1]:  # pad2 top < pad1 bottom
            y_gap = b1[1] - b2[3]
            v_start = QPointF((b2[0] + b2[2]) / 2, b2[3])
            v_end   = QPointF((b1[0] + b1[2]) / 2, b1[1])

        # Draw dimension lines
        if h_start and h_end and x_gap > 0:
            label_offset = QPointF(0, -15)
            self.draw_dimension_line_with_label(
                painter, h_start, h_end, x_gap, "X Gap", QColor("#00FFFF"), label_offset
            )

        if v_start and v_end and y_gap > 0:
            label_offset = QPointF(15, 0)
            self.draw_dimension_line_with_label(
                painter, v_start, v_end, y_gap, "Y Gap", QColor("#FFFF00"), label_offset
            )

    def draw_all_pitch_dimensions(self, painter):
        """Draw pitch dimensions only between selected pads (if exactly 2 selected)"""
        if len(self.selected_pads) != 2:
            return
        
        pad_indices = list(self.selected_pads)
        i, j = pad_indices[0], pad_indices[1]
        
        positions = self.calculate_pad_absolute_positions()
        if i not in positions or j not in positions:
            return
        
        x1, y1 = positions[i]
        x2, y2 = positions[j]
        
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        
        # Draw horizontal pitch if significant
        if dx > 0.01:
            start = QPointF(min(x1, x2), (y1 + y2) / 2)
            end = QPointF(max(x1, x2), (y1 + y2) / 2)
            label_offset = QPointF(0, -25)  # Offset to avoid overlap
            self.draw_dimension_line_with_label(
                painter, start, end, dx, "Pitch X", QColor("#FFA500"), label_offset
            )
        
        # Draw vertical pitch if significant
        if dy > 0.01:
            start = QPointF((x1 + x2) / 2, min(y1, y2))
            end = QPointF((x1 + x2) / 2, max(y1, y2))
            label_offset = QPointF(25, 0)  # Offset to avoid overlap
            self.draw_dimension_line_with_label(
                painter, start, end, dy, "Pitch Y", QColor("#FFA500"), label_offset
            )


    def draw_minimum_airgap_summary(self, painter):
        """Draw minimum airgap summary in top-left corner"""
        airgaps = self.calculate_all_pad_airgaps()
        if not airgaps:
            return
        
        # Find minimum values
        min_x = min((a['x_gap'] for a in airgaps if a['x_gap'] > 0), default=None)
        min_y = min((a['y_gap'] for a in airgaps if a['y_gap'] > 0), default=None)
        min_overall = min((min(a['x_gap'], a['y_gap']) for a in airgaps 
                        if a['x_gap'] > 0 or a['y_gap'] > 0), default=None)
        
        if min_overall is None:
            return
        
        painter.save()
        painter.resetTransform()
        
        # Create summary text
        summary_lines = []
        if min_overall is not None:
            summary_lines.append(f"Min Airgap: {min_overall:.3f}mm")
        if min_x is not None:
            summary_lines.append(f"Min X Gap: {min_x:.3f}mm")
        if min_y is not None:
            summary_lines.append(f"Min Y Gap: {min_y:.3f}mm")
        
        # Set font
        font = QFont("Arial", 10)
        font.setBold(True)
        painter.setFont(font)
        
        # Calculate text area
        fm = painter.fontMetrics()
        max_width = max(fm.horizontalAdvance(line) for line in summary_lines)
        line_height = fm.height()
        total_height = len(summary_lines) * line_height + 10
        
        # Draw background
        bg_rect = QRectF(10, 10, max_width + 20, total_height)
        painter.setPen(QPen(QColor("#000000"), 1))
        painter.setBrush(QBrush(QColor("#000000", 180)))
        painter.drawRect(bg_rect)
        
        # Draw text lines
        y_offset = 10
        painter.setPen(QPen(QColor("#00FF00"), 1))
        for line in summary_lines:
            painter.drawText(20, y_offset + line_height, line)
            y_offset += line_height
        
        painter.restore()


    def calculate_chamfer_points(self, p1, p2, p3, chamfer_size):
        """Calculate chamfer points for corner at p2"""
        def point_along_line(p_start, p_end, dist):
            vx = p_end.x() - p_start.x()
            vy = p_end.y() - p_start.y()
            length = math.sqrt(vx*vx + vy*vy)
            if length == 0:
                return p_start
            scale = dist / length
            return QPointF(p_start.x() + vx*scale, p_start.y() + vy*scale)

        cp1 = point_along_line(p2, p1, chamfer_size)
        cp2 = point_along_line(p2, p3, chamfer_size)
        return [cp1, cp2]

    def calculate_fillet_points(self, p1, p2, p3, radius, segments=8):
        """Calculate arc points for fillet at corner p2"""
        def normalize(v):
            length = math.sqrt(v[0]**2 + v[1]**2)
            if length == 0:
                return (0.0, 0.0)
            return (v[0] / length, v[1] / length)

        v1 = (p1.x() - p2.x(), p1.y() - p2.y())
        v2 = (p3.x() - p2.x(), p3.y() - p2.y())

        n1 = normalize(v1)
        n2 = normalize(v2)

        # Dot product
        dot = max(min(n1[0] * n2[0] + n1[1] * n2[1], 1), -1)
        angle = math.acos(dot)

        if angle < 0.01:
            return [p2]

        tangent_length = radius / math.tan(angle / 2)

        tp1 = QPointF(p2.x() + n1[0] * tangent_length, p2.y() + n1[1] * tangent_length)
        tp2 = QPointF(p2.x() + n2[0] * tangent_length, p2.y() + n2[1] * tangent_length)

        # Bisector
        bisector = normalize(((n1[0] + n2[0]) / 2, (n1[1] + n2[1]) / 2))
        dist_to_center = radius / math.sin(angle / 2)
        center = QPointF(p2.x() + bisector[0] * dist_to_center,
                        p2.y() + bisector[1] * dist_to_center)

        start_angle = math.atan2(tp1.y() - center.y(), tp1.x() - center.x())
        end_angle = math.atan2(tp2.y() - center.y(), tp2.x() - center.x())

        cross = (tp1.x() - center.x()) * (tp2.y() - center.y()) - (tp1.y() - center.y()) * (tp2.x() - center.x())

        points = []
        for i in range(segments + 1):
            t = i / segments
            if cross > 0:
                angle_t = start_angle + t * (end_angle - start_angle)
            else:
                if end_angle > start_angle:
                    end_angle -= 2 * math.pi
                angle_t = start_angle + t * (end_angle - start_angle)

            x = center.x() + radius * math.cos(angle_t)
            y = center.y() + radius * math.sin(angle_t)
            points.append(QPointF(x, y))

        return points

    def draw_selected_pads_highlight(self, painter):
        """Draw selection highlights on selected pads"""
        if not self.selected_pads:
            return
        
        # Draw selection highlights
        painter.setPen(QPen(QColor("#FF00FF"), 3/self.zoom_factor))  # Magenta highlight
        painter.setBrush(QBrush())  # No fill
        
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        
        for pad_index in self.selected_pads:
            if pad_index < len(pad_bounds_list):
                bounds = pad_bounds_list[pad_index]
                if bounds:
                    min_x, min_y, max_x, max_y = bounds
                    # Draw highlight rectangle slightly larger than pad
                    margin = 0.1  # mm
                    painter.drawRect(QRectF(
                        min_x - margin, min_y - margin,
                        max_x - min_x + 2*margin, max_y - min_y + 2*margin
                    ))

            
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Get center point and apply offset
        center_x = self.width() // 2
        center_y = self.height() // 2
        
        # Apply translation with offset for cursor-centered zoom
        painter.translate(center_x + self.offset_x, center_y + self.offset_y)
        painter.scale(self.zoom_factor, -self.zoom_factor)  # Flip Y axis
        
        # Clear cached positions when data changes
        self._absolute_positions = None
        
        # Draw origin first
        self.draw_origin(painter)
        
        # Draw body outline with shape support
        body_bounds = None
        if all(k in self.footprint_data for k in ['body_length', 'body_width']):
            length = self.footprint_data['body_length']
            width = self.footprint_data['body_width']
            body_shape = self.footprint_data.get('body_shape', 'rectangle')
            
            painter.setPen(QPen(QColor("#FF69B4"), 2/self.zoom_factor))  # Pink
            painter.setBrush(QBrush())  # No fill
            
            if body_shape == 'rectangle':
                painter.drawRect(QRectF(-length/2, -width/2, length, width))
                body_bounds = [-length/2, -width/2, length/2, width/2]
            elif body_shape == 'round':
                # Use the larger dimension as diameter for round body
                diameter = max(length, width)
                painter.drawEllipse(QRectF(-diameter/2, -diameter/2, diameter, diameter))
                body_bounds = [-diameter/2, -diameter/2, diameter/2, diameter/2]
        
        # Get individual pad bounds for silkscreen calculation
        individual_pad_bounds = self.get_individual_pad_bounds_absolute()
        
        # Calculate overall pad bounds for courtyard
        pad_bounds = self.calculate_all_pads_bounds_absolute()
        
        # Draw silkscreen layer with gaps where pads overlap
        if body_bounds and self.footprint_data.get('silkscreen_enabled', True):
            airgap = self.footprint_data.get('silkscreen_airgap', 0.15)
            self.draw_silkscreen(painter, body_bounds, individual_pad_bounds, airgap)
        
        # Draw courtyard based on outermost bounds
        self.draw_courtyard(painter, body_bounds, pad_bounds)
        
        # Draw pads with absolute positioning
        for i, pad in enumerate(self.footprint_data.get('padstacks', [])):
            self.draw_pad(painter, pad, i)
        
        # NEW: Draw selection highlights
        self.draw_selected_pads_highlight(painter)

        # Draw dimensions based on overlay control states and selections
        if self.show_airgap_checkbox.isChecked():
            self.draw_all_airgap_dimensions(painter)
        
        if self.show_pitch_checkbox.isChecked():
            self.draw_all_pitch_dimensions(painter)

        # NEW: Draw instruction text
        self.draw_selection_instructions(painter)


    def calculate_all_pads_bounds(self):
        """Calculate bounding box for all copper pads"""
        if not self.footprint_data.get('padstacks'):
            return None
        
        min_x = min_y = float('inf')
        max_x = max_y = float('-inf')
        
        for pad in self.footprint_data['padstacks']:
            pad_bounds = self.calculate_pad_bounds(pad)
            if pad_bounds:
                min_x = min(min_x, pad_bounds[0])
                min_y = min(min_y, pad_bounds[1])
                max_x = max(max_x, pad_bounds[2])
                max_y = max(max_y, pad_bounds[3])
        
        if min_x == float('inf'):
            return None
        
        return [min_x, min_y, max_x, max_y]
    
    def draw_selection_instructions(self, painter):
        """Draw instruction text for pad selection"""
        painter.save()
        painter.resetTransform()  # Switch to screen coordinates
        
        instructions = []
        
        if self.show_airgap_checkbox.isChecked() or self.show_pitch_checkbox.isChecked():
            if len(self.selected_pads) == 0:
                instructions.append("Click on 2 pads to measure dimensions")
            elif len(self.selected_pads) == 1:
                instructions.append("Click on 1 more pad to measure")
            elif len(self.selected_pads) == 2:
                instructions.append("Dimensions shown between selected pads")
                instructions.append("Click elsewhere to clear selection")
        
        if instructions:
            # Position at bottom-left
            y_start = self.height() - 60
            
            painter.setPen(QPen(QColor("#FFFFFF"), 1))
            font = QFont("Arial", 10)
            painter.setFont(font)
            
            for i, instruction in enumerate(instructions):
                # Draw background for better visibility
                text_rect = painter.fontMetrics().boundingRect(instruction)
                text_rect.moveTo(10, y_start + i * 20)
                text_rect.adjust(-3, -1, 3, 1)
                
                painter.setBrush(QBrush(QColor(0, 0, 0, 150)))
                painter.drawRect(text_rect)
                
                painter.setBrush(QBrush())
                painter.drawText(10, y_start + i * 20 + 15, instruction)
        
        painter.restore()



    def draw_pad_airgap_dimension(self, painter):
        """Draw pad-to-pad airgap dimension in screen space"""
        min_airgap, closest_pads = self.calculate_min_pad_to_pad_airgap()
        if min_airgap is None:
            return
        
        # Draw airgap text in screen space
        painter.save()
        painter.resetTransform()  # Switch to screen coordinates
        
        # Set text properties
        painter.setPen(QPen(QColor("#00FF00"), 2))  # Bright green
        font = QFont("Arial", 12)
        font.setBold(True)
        painter.setFont(font)
        
        # Format the airgap value
        airgap_text = f"Min Pad-to-Pad Airgap: {min_airgap:.3f} mm"
        
        # Draw text with background for better visibility
        text_rect = painter.fontMetrics().boundingRect(airgap_text)
        text_rect.adjust(-5, -2, 5, 2)
        text_rect.moveTo(10, 10)
        
        # Draw background rectangle
        painter.setPen(QPen(QColor("#000000"), 1))
        color = QColor("#000000")
        color.setAlpha(180)
        painter.setBrush(QBrush(color))
 # Semi-transparent black
        painter.drawRect(text_rect)
        
        # Draw the text
        painter.setPen(QPen(QColor("#00FF00"), 2))
        painter.setBrush(QBrush())
        painter.drawText(text_rect.adjusted(5, 2, -5, -2), Qt.AlignmentFlag.AlignLeft, airgap_text)
        
        painter.restore()

    def draw_airgap_dimension_lines(self, painter):
        """Draw dimension lines between closest pads"""
        min_airgap, closest_pads = self.calculate_min_pad_to_pad_airgap()
        if min_airgap is None or closest_pads is None:
            return
        
        if min_airgap == 0:  # Skip if pads are overlapping
            return
            
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        i, j, x_gap, y_gap = closest_pads
        
        b1 = pad_bounds_list[i]
        b2 = pad_bounds_list[j]
        
        # Set dimension line properties
        painter.setPen(QPen(QColor("#FFFF00"), 1.5/self.zoom_factor))  # Yellow dimension lines
        
        if x_gap > 0 and y_gap == 0:  # Horizontally separated
            # Draw horizontal dimension line
            y_center = (max(b1[1], b2[1]) + min(b1[3], b2[3])) / 2
            line_start = QPointF(b1[2], y_center)
            line_end = QPointF(b2[0], y_center)
            
            painter.drawLine(line_start, line_end)
            
            # Draw extension lines
            # Draw extension lines (horizontal gap case)
            painter.drawLine(QPointF(b1[2], b1[1]), QPointF(b1[2], b1[3]))  # right edge of pad 1
            painter.drawLine(QPointF(b2[0], b2[1]), QPointF(b2[0], b2[3]))  # left edge of pad 2

        elif y_gap > 0 and x_gap == 0:  # Vertically separated
            # Draw vertical dimension line
            x_center = (max(b1[0], b2[0]) + min(b1[2], b2[2])) / 2
            line_start = QPointF(x_center, b1[3])  # top edge of pad 1
            line_end   = QPointF(x_center, b2[1])  # bottom edge of pad 2
            painter.drawLine(line_start, line_end)

            # Draw extension lines (vertical gap case)
            painter.drawLine(QPointF(b1[0], b1[3]), QPointF(b1[2], b1[3]))  # top edge of pad 1
            painter.drawLine(QPointF(b2[0], b2[1]), QPointF(b2[2], b2[1]))  # bottom edge of pad 2



    def draw_courtyard(self, painter, body_bounds, pad_bounds):
        """Draw courtyard based on outermost bounds of body or pads"""
        expansion = self.footprint_data.get('courtyard_expansion', 0.25)
        
        # Determine outermost bounds
        outermost_bounds = None
        
        if body_bounds and pad_bounds:
            # Use whichever is outermost
            outermost_bounds = [
                min(body_bounds[0], pad_bounds[0]),  # min_x
                min(body_bounds[1], pad_bounds[1]),  # min_y
                max(body_bounds[2], pad_bounds[2]),  # max_x
                max(body_bounds[3], pad_bounds[3])   # max_y
            ]
        elif body_bounds:
            outermost_bounds = body_bounds
        elif pad_bounds:
            outermost_bounds = pad_bounds
        
        if outermost_bounds:
            # Apply courtyard expansion
            courtyard_bounds = [
                outermost_bounds[0] - expansion,  # min_x
                outermost_bounds[1] - expansion,  # min_y
                outermost_bounds[2] + expansion,  # max_x
                outermost_bounds[3] + expansion   # max_y
            ]
            
            # Draw courtyard rectangle
            painter.setPen(QPen(QColor("#00FF00"), 1/self.zoom_factor))  # Green
            painter.setBrush(QBrush())  # No fill
            
            courtyard_width = courtyard_bounds[2] - courtyard_bounds[0]
            courtyard_height = courtyard_bounds[3] - courtyard_bounds[1]
            
            painter.drawRect(QRectF(courtyard_bounds[0], courtyard_bounds[1], 
                                courtyard_width, courtyard_height))

    def draw_silkscreen(self, painter, body_bounds, individual_pad_bounds, airgap=0.15):
        """Draw silkscreen exactly along body outline with gaps only where pads overlap with airgap"""
        if not body_bounds:
            return
        
        min_x, min_y, max_x, max_y = body_bounds
        body_shape = self.footprint_data.get('body_shape', 'rectangle')
        
        # Set silkscreen line properties
        line_width = 1.5/self.zoom_factor
        painter.setPen(QPen(QColor("#FFFFFF"), line_width))
        
        if body_shape == 'rectangle':
            self.draw_rectangle_silkscreen(painter, body_bounds, individual_pad_bounds, airgap)
        elif body_shape == 'round':
            self.draw_round_silkscreen(painter, body_bounds, individual_pad_bounds, airgap)

    def draw_rectangle_silkscreen(self, painter, body_bounds, individual_pad_bounds, airgap):
        """Draw rectangular silkscreen with gaps where pads overlap"""
        min_x, min_y, max_x, max_y = body_bounds
        
        # Helper function to merge overlapping intervals

        def merge_intervals(intervals):
            """Merge overlapping intervals in the form [(start, end), ...]"""
            if not intervals:
                return []

            # Sort intervals by start coordinate
            intervals = sorted(intervals, key=lambda x: x[0])
            merged = [intervals[0]]

            for current in intervals[1:]:
                last = merged[-1]

                if current[0] <= last[1]:  #  compare start of current with end of last
                    merged[-1] = (last[0], max(last[1], current[1]))
                else:
                    merged.append(current)

            return merged


        
        # Helper function to draw line segments with gaps where pads interfere
        def draw_line_with_pad_gaps(x1, y1, x2, y2, pad_bounds_list, gap, orientation):
            """Draw line segment with gaps where pads (+ airgap) would overlap"""
            
            if orientation == 'horizontal':
                start_pos = min(x1, x2)
                end_pos = max(x1, x2)
                line_y = y1
                
                # Find all pad intersections with this horizontal line
                intersections = []
                for pad_bounds in pad_bounds_list:
                    if not pad_bounds:
                        continue
                    px_min, py_min, px_max, py_max = pad_bounds
                    
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if this horizontal line intersects with expanded pad
                    if (line_y >= pad_min_y and line_y <= pad_max_y and
                        pad_max_x >= start_pos and pad_min_x <= end_pos):
                        
                        # Calculate intersection range
                        inter_start = max(start_pos, pad_min_x)
                        inter_end = min(end_pos, pad_max_x)
                        intersections.append((inter_start, inter_end))
                
                # Sort and merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Draw line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        painter.drawLine(QPointF(current_pos, line_y), QPointF(gap_start, line_y))
                    current_pos = gap_end
                
                # Draw final segment if needed
                if current_pos < end_pos:
                    painter.drawLine(QPointF(current_pos, line_y), QPointF(end_pos, line_y))
                    
            else:  # vertical
                start_pos = min(y1, y2)
                end_pos = max(y1, y2)
                line_x = x1
                
                # Find all pad intersections with this vertical line
                intersections = []
                for pad_bounds in pad_bounds_list:
                    if not pad_bounds:
                        continue
                    px_min, py_min, px_max, py_max = pad_bounds
                    
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if this vertical line intersects with expanded pad
                    if (line_x >= pad_min_x and line_x <= pad_max_x and
                        pad_max_y >= start_pos and pad_min_y <= end_pos):
                        
                        # Calculate intersection range
                        inter_start = max(start_pos, pad_min_y)
                        inter_end = min(end_pos, pad_max_y)
                        intersections.append((inter_start, inter_end))
                
                # Sort and merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Draw line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        painter.drawLine(QPointF(line_x, current_pos), QPointF(line_x, gap_start))
                    current_pos = gap_end
                
                # Draw final segment if needed
                if current_pos < end_pos:
                    painter.drawLine(QPointF(line_x, current_pos), QPointF(line_x, end_pos))
        
        # Draw all four sides of rectangular body outline with gaps where pads interfere
        # Top line
        draw_line_with_pad_gaps(min_x, max_y, max_x, max_y, individual_pad_bounds, airgap, 'horizontal')
        
        # Bottom line  
        draw_line_with_pad_gaps(min_x, min_y, max_x, min_y, individual_pad_bounds, airgap, 'horizontal')
        
        # Left line
        draw_line_with_pad_gaps(min_x, min_y, min_x, max_y, individual_pad_bounds, airgap, 'vertical')
        
        # Right line
        draw_line_with_pad_gaps(max_x, min_y, max_x, max_y, individual_pad_bounds, airgap, 'vertical')

    def draw_round_silkscreen(self, painter, body_bounds, individual_pad_bounds, airgap):
        """Draw round silkscreen with gaps where pads overlap"""
        import math
        
        min_x, min_y, max_x, max_y = body_bounds
        
        # Calculate circle parameters
        center_x = (min_x + max_x) / 2
        center_y = (min_y + max_y) / 2
        radius = (max_x - min_x) / 2
        
        # Check if any pads overlap with the circle outline
        has_pad_overlaps = False
        for pad_bounds in individual_pad_bounds:
            if not pad_bounds:
                continue
            px_min, py_min, px_max, py_max = pad_bounds
            
            # Expand pad bounds by airgap
            pad_min_x = px_min - airgap
            pad_max_x = px_max + airgap
            pad_min_y = py_min - airgap
            pad_max_y = py_max + airgap
            
            # Simple check: if pad rectangle intersects with circle bounds
            circle_left = center_x - radius
            circle_right = center_x + radius
            circle_top = center_y + radius
            circle_bottom = center_y - radius
            
            if (pad_max_x >= circle_left and pad_min_x <= circle_right and
                pad_max_y >= circle_bottom and pad_min_y <= circle_top):
                has_pad_overlaps = True
                break
        
        if not has_pad_overlaps:
            # No pad overlaps, draw complete circle
            painter.drawEllipse(QRectF(min_x, min_y, max_x - min_x, max_y - min_y))
        else:
            # Draw circle with gaps - simplified approach using small arc segments
            num_segments = 72  # 5-degree segments
            angle_step = 360.0 / num_segments
            
            for i in range(num_segments):
                start_angle = i * angle_step
                end_angle = (i + 1) * angle_step
                
                # Calculate midpoint of this arc segment
                mid_angle = math.radians((start_angle + end_angle) / 2)
                mid_x = center_x + radius * math.cos(mid_angle)
                mid_y = center_y + radius * math.sin(mid_angle)
                
                # Check if this segment overlaps with any expanded pad
                segment_overlaps = False
                for pad_bounds in individual_pad_bounds:
                    if not pad_bounds:
                        continue
                    px_min, py_min, px_max, py_max = pad_bounds
                    
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - airgap
                    pad_max_x = px_max + airgap
                    pad_min_y = py_min - airgap
                    pad_max_y = py_max + airgap
                    
                    # Check if segment midpoint is inside expanded pad rectangle
                    if (mid_x >= pad_min_x and mid_x <= pad_max_x and
                        mid_y >= pad_min_y and mid_y <= pad_max_y):
                        segment_overlaps = True
                        break
                
                # Draw this segment if it doesn't overlap with pads
                if not segment_overlaps:
                    # Use drawArc for precise arc drawing
                    # drawArc takes (rect, startAngle*16, spanAngle*16) in 1/16th degrees
                    arc_rect = QRectF(min_x, min_y, max_x - min_x, max_y - min_y)
                    start_angle_16 = int(start_angle * 16)
                    span_angle_16 = int(angle_step * 16)
                    painter.drawArc(arc_rect, start_angle_16, span_angle_16)


    def draw_silkscreen_line(self, painter, x1, y1, x2, y2, pad_bounds_list, airgap, direction):
        """Draw a silkscreen line with gaps where pads overlap"""
        from PyQt6.QtCore import QPointF
        
        # Determine line segments that don't overlap with pads
        segments = []
        
        if direction == 'horizontal':
            # Horizontal line - check for pad overlaps along X axis
            start_x = min(x1, x2)
            end_x = max(x1, x2)
            line_y = y1
            
            current_x = start_x
            
            # Sort pad intersections along this line
            intersections = []
            for pad_bounds in pad_bounds_list:
                if not pad_bounds:
                    continue
                px_min, py_min, px_max, py_max = pad_bounds
                
                # Expand pad bounds by airgap
                pad_min_x = px_min - airgap
                pad_max_x = px_max + airgap
                pad_min_y = py_min - airgap
                pad_max_y = py_max + airgap
                
                # Check if this horizontal line intersects with pad
                if (line_y >= pad_min_y and line_y <= pad_max_y and
                    pad_max_x >= start_x and pad_min_x <= end_x):
                    
                    # Calculate intersection range
                    int_start = max(start_x, pad_min_x)
                    int_end = min(end_x, pad_max_x)
                    intersections.append((int_start, int_end))
            
            # Sort intersections by start position
            intersections.sort()
            
            # Merge overlapping intersections
            merged = []
            for start, end in intersections:
                if merged and start <= merged[-1][1]:
                    merged[-1] = (merged[-1][0], max(merged[-1][1], end))
                else:
                    merged.append((start, end))
            
            # Draw line segments between gaps
            current_x = start_x
            for gap_start, gap_end in merged:
                if current_x < gap_start:
                    painter.drawLine(QPointF(current_x, line_y), QPointF(gap_start, line_y))
                current_x = gap_end
            
            # Draw final segment if needed
            if current_x < end_x:
                painter.drawLine(QPointF(current_x, line_y), QPointF(end_x, line_y))
                
        else:  # vertical
            # Vertical line - check for pad overlaps along Y axis
            start_y = min(y1, y2)
            end_y = max(y1, y2)
            line_x = x1
            
            # Sort pad intersections along this line
            intersections = []
            for pad_bounds in pad_bounds_list:
                if not pad_bounds:
                    continue
                px_min, py_min, px_max, py_max = pad_bounds
                
                # Expand pad bounds by airgap
                pad_min_x = px_min - airgap
                pad_max_x = px_max + airgap
                pad_min_y = py_min - airgap
                pad_max_y = py_max + airgap
                
                # Check if this vertical line intersects with pad
                if (line_x >= pad_min_x and line_x <= pad_max_x and
                    pad_max_y >= start_y and pad_min_y <= end_y):
                    
                    # Calculate intersection range
                    int_start = max(start_y, pad_min_y)
                    int_end = min(end_y, pad_max_y)
                    intersections.append((int_start, int_end))
            
            # Sort and merge intersections
            intersections.sort()
            merged = []
            for start, end in intersections:
                if merged and start <= merged[-1][1]:
                    merged[-1] = (merged[-1][0], max(merged[-1][1], end))
                else:
                    merged.append((start, end))
            
            # Draw line segments between gaps
            current_y = start_y
            for gap_start, gap_end in merged:
                if current_y < gap_start:
                    painter.drawLine(QPointF(line_x, current_y), QPointF(line_x, gap_start))
                current_y = gap_end
            
            # Draw final segment if needed
            if current_y < end_y:
                painter.drawLine(QPointF(line_x, current_y), QPointF(line_x, end_y))

    def get_individual_pad_bounds(self):
        """Get bounding box for each individual pad (copper layer only)"""
        if not self.footprint_data.get('padstacks'):
            return []
        
        pad_bounds_list = []
        
        for pad in self.footprint_data['padstacks']:
            pad_bounds = self.calculate_pad_bounds(pad)
            if pad_bounds:
                pad_bounds_list.append(pad_bounds)
        
        return pad_bounds_list

    def calculate_pad_bounds_absolute(self, pad, pad_index):
        """Calculate bounding box for a pad using absolute position"""
        absolute_positions = getattr(self, '_absolute_positions', None)
        if absolute_positions is None:
            absolute_positions = self.calculate_pad_absolute_positions()
            self._absolute_positions = absolute_positions
        
        if pad_index in absolute_positions:
            x, y = absolute_positions[pad_index]
        else:
            x = pad.get('x_offset', 0)
            y = pad.get('y_offset', 0)
        
        pad_type = pad['type']
        
        if pad_type == 'square':
            size = pad.get('size', 1)
            return [x - size/2, y - size/2, x + size/2, y + size/2]
        elif pad_type in ['rectangle', 'rounded_rectangle']:
            length = pad.get('length', 1)
            width = pad.get('width', 1)
            return [x - length/2, y - width/2, x + length/2, y + width/2]
        elif pad_type == 'round':
            diameter = pad.get('diameter', 1)
            return [x - diameter/2, y - diameter/2, x + diameter/2, y + diameter/2]
        elif pad_type in ['PTH', 'NPTH']:
            if pad_type == 'PTH':
                diameter = pad.get('pad_diameter', 1.2)
            else:
                diameter = pad.get('hole_diameter', 0.8)
            return [x - diameter/2, y - diameter/2, x + diameter/2, y + diameter/2]
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if pad_type == 'PTH_oblong':
                length = pad.get('pad_length', 2.0)
                width = pad.get('pad_width', 1.2)
            else:
                length = pad.get('hole_length', 1.5)
                width = pad.get('hole_width', 0.8)
            return [x - length/2, y - width/2, x + length/2, y + width/2]
        elif pad_type == 'custom':
            # Handle custom polygon pads with absolute positioning
            polygon_points = self.calculate_polygon_points_absolute(pad, x, y)
            if polygon_points:
                xs = [p.x() for p in polygon_points]
                ys = [p.y() for p in polygon_points]
                return [min(xs), min(ys), max(xs), max(ys)]
        
        return None

    def get_individual_pad_bounds_absolute(self):
        """Get bounding box for each individual pad using absolute positions"""
        if not self.footprint_data.get('padstacks'):
            return []
        
        pad_bounds_list = []
        
        for i, pad in enumerate(self.footprint_data['padstacks']):
            pad_bounds = self.calculate_pad_bounds_absolute(pad, i)
            if pad_bounds:
                pad_bounds_list.append(pad_bounds)
        
        return pad_bounds_list


    def calculate_pad_bounds(self, pad):
        """Calculate bounding box for a single pad (copper layer only)"""
        x = pad.get('x_offset', 0)
        y = pad.get('y_offset', 0)
        pad_type = pad['type']
        
        if pad_type == 'square':
            size = pad.get('size', 1)
            return [x - size/2, y - size/2, x + size/2, y + size/2]
        elif pad_type in ['rectangle', 'rounded_rectangle']:
            length = pad.get('length', 1)
            width = pad.get('width', 1)
            return [x - length/2, y - width/2, x + length/2, y + width/2]
        elif pad_type == 'round':
            diameter = pad.get('diameter', 1)
            return [x - diameter/2, y - diameter/2, x + diameter/2, y + diameter/2]
        elif pad_type == 'custom':
            # Calculate bounds for custom polygon
            polygon_points = self.calculate_polygon_points(pad)
            if polygon_points:
                xs = [p.x() for p in polygon_points]
                ys = [p.y() for p in polygon_points]
                return [min(xs), min(ys), max(xs), max(ys)]
        
        return None

    def calculate_all_pads_bounds_absolute(self):
        """Calculate the outer bounding box of all pads using absolute pad bounds"""
        pad_bounds_list = self.get_individual_pad_bounds_absolute()
        if not pad_bounds_list:
            return None
        
        min_x = min(pb[0] for pb in pad_bounds_list)
        min_y = min(pb[1] for pb in pad_bounds_list)
        max_x = max(pb[2] for pb in pad_bounds_list)
        max_y = max(pb[3] for pb in pad_bounds_list)
        
        return [min_x, min_y, max_x, max_y]

    def calculate_polygon_points_absolute(self, pad, abs_x, abs_y):
        """Calculate polygon points using absolute position"""
        lines_data = pad.get('polygon_data', {}).get('lines', [])
        if not lines_data:
            return []

        raw_points = []
        current_x = abs_x
        current_y = abs_y
        raw_points.append((current_x, current_y))

        for line_data in lines_data:
            line_size = line_data.get('line_size', 1.0)
            direction = line_data.get('direction', 'right')

            if direction == 'right':
                current_x += line_size
            elif direction == 'down':
                current_y -= line_size
            elif direction == 'left':
                current_x -= line_size
            elif direction == 'up':
                current_y += line_size

            raw_points.append((current_x, current_y))

        final_points = []
        final_points.append(QPointF(raw_points[0][0], raw_points[0][1]))


        for i in range(1, len(raw_points) - 1):
            prev_point = raw_points[i-1]
            curr_point = raw_points[i]
            next_point = raw_points[i+1]

            line_data = lines_data[i-1]
            corner_type = line_data.get('corner_type', '90-degree')
            corner_size = line_data.get('corner_size', 0)

            if corner_type == '90-degree' or corner_size == 0:
                final_points.append(QPointF(curr_point[0], curr_point[1]))  # FIXED
            elif corner_type == 'chamfer':
                chamfer_points = self.calculate_chamfer_points(
                    QPointF(prev_point[0], prev_point[1]),  # FIXED
                    QPointF(curr_point[0], curr_point[1]),  # FIXED
                    QPointF(next_point[0], next_point[1]),  # FIXED
                    corner_size
                )
                final_points.extend(chamfer_points)
            elif corner_type == 'fillet':
                fillet_points = self.calculate_fillet_points(
                    QPointF(prev_point[0], prev_point[1]),  # FIXED
                    QPointF(curr_point[0], curr_point[1]),  # FIXED
                    QPointF(next_point[0], next_point[1]),  # FIXED
                    corner_size
                )
                final_points.extend(fillet_points)

        final_points.append(QPointF(raw_points[-1][0], raw_points[-1][1]))  # FIXED

        return final_points

    def calculate_pad_absolute_positions(self):
        """Calculate absolute positions for all pads considering offset_from"""
        if not self.footprint_data.get('padstacks'):
            return {}

        pads = self.footprint_data['padstacks']
        
        # IMPORTANT: Create a new resolver instance to avoid stale cache
        resolver = PadPositionResolver(pads)
        
        positions = {}
        for i, pad in enumerate(pads):
            abs_x, abs_y = resolver.get_absolute_position(pad)
            positions[i] = (abs_x, abs_y)

        return positions


    def draw_pad(self, painter, pad, pad_index=None):
        """Draw pad using absolute position with proper layer handling for TH pads"""
        # Get absolute positions
        absolute_positions = getattr(self, '_absolute_positions', None)
        if absolute_positions is None:
            absolute_positions = self.calculate_pad_absolute_positions()
            self._absolute_positions = absolute_positions
        
        # Use absolute position if available, otherwise fall back to direct offsets
        if pad_index is not None and pad_index in absolute_positions:
            x, y = absolute_positions[pad_index]
        else:
            x = pad.get('x_offset', 0)
            y = pad.get('y_offset', 0)
        
        pin_num = pad.get('pin_number', '1')
        
        # Define through hole pad types (no paste layer)
        through_hole_types = ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong']
        
        # Draw paste layer (silver) - SKIP FOR THROUGH HOLE PADS
        paste_exp = pad.get('paste_expansion', 0)
        if pad['type'] not in through_hole_types and paste_exp != 0:
            painter.setPen(QPen(QColor("#C0C0C0"), 1/self.zoom_factor))
            painter.setBrush(QBrush())  # No fill - outline only
            self.draw_pad_shape(painter, pad, x, y, paste_exp)
        
        # Draw mask layer (purple #8A2BE2) - outline only
        mask_exp = pad.get('mask_expansion', 0)
        if mask_exp != 0:
            painter.setPen(QPen(QColor("#8A2BE2"), 1/self.zoom_factor))  # Updated purple color
            painter.setBrush(QBrush())  # No fill - outline only
            self.draw_pad_shape(painter, pad, x, y, mask_exp)
        
        # Draw copper pad (red) - outline only
        painter.setPen(QPen(QColor("#FF0000"), 2/self.zoom_factor))
        painter.setBrush(QBrush())  # No fill - outline only
        self.draw_pad_shape(painter, pad, x, y, 0)
        
        # Draw pin number with correct orientation
        self.draw_pin_number(painter, pad, x, y, pin_num)


    def draw_pin_number(self, painter, pad, x, y, pin_num):
        """Draw pin number in screen space with correct orientation and ultra-small size"""
        
        # Save current state
        painter.save()
        
        # Get current transform matrix
        transform = painter.worldTransform()
        
        # Map pad center to screen coordinates
        screen_pos = transform.map(QPointF(x, y))
        
        # Reset transform to draw in screen space (ensures upright text)
        painter.resetTransform()
        
        # Calculate font size based on pad size and zoom for ultra-small text
        pad_type = pad['type']
        if pad_type == 'square':
            pad_size = pad.get('size', 1)
            base_font_size = max(6, min(pad_size * self.zoom_factor * 0.12, 12))
        elif pad_type in ['rectangle', 'rounded_rectangle']:
            min_dim = min(pad.get('length', 1), pad.get('width', 1))
            base_font_size = max(6, min(min_dim * self.zoom_factor * 0.1, 12))
        elif pad_type == 'round':
            diameter = pad.get('diameter', 1)
            base_font_size = max(6, min(diameter * self.zoom_factor * 0.12, 12))
        else:
            base_font_size = max(6, min(8, 12))
        
        # Set text properties for screen space
        painter.setPen(QPen(QColor("#FFFFFF"), 1))
        font = QFont("Arial", int(base_font_size))
        font.setBold(True)  # Make bold for better visibility at small sizes
        painter.setFont(font)
        
        # Calculate text area based on font size
        text_width = base_font_size * 1.5
        text_height = base_font_size * 1.2
        
        # Draw text in screen coordinates (always upright)
        text_rect = QRectF(screen_pos.x() - text_width/2, screen_pos.y() - text_height/2, 
                        text_width, text_height)
        painter.drawText(text_rect, Qt.AlignmentFlag.AlignCenter, pin_num)
        
        # Restore transform
        painter.restore()

    def draw_pad_shape(self, painter, pad, x, y, expansion):
        """Draw pad shape as outline only (no fill) - PRESERVES CALLER'S PEN COLOR"""
        pad_type = pad['type']
        
        # Ensure no fill - outline only
        painter.setBrush(QBrush())
        
        if pad_type == 'square':
            size = pad.get('size', 1) + 2*expansion
            painter.drawRect(QRectF(x-size/2, y-size/2, size, size))
            
        elif pad_type == 'rectangle':
            length = pad.get('length', 1) + 2*expansion
            width = pad.get('width', 1) + 2*expansion
            painter.drawRect(QRectF(x-length/2, y-width/2, length, width))
            
        elif pad_type == 'rounded_rectangle':
            length = pad.get('length', 1) + 2*expansion
            width = pad.get('width', 1) + 2*expansion
            radius = pad.get('corner_radius', 0.2)
            painter.drawRoundedRect(QRectF(x-length/2, y-width/2, length, width), radius, radius)
            
        elif pad_type == 'round':
            diameter = pad.get('diameter', 1) + 2*expansion
            painter.drawEllipse(QRectF(x-diameter/2, y-diameter/2, diameter, diameter))
            
        elif pad_type in ['PTH', 'NPTH']:
            if expansion == 0:  # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                # Draw hole (black circle)
                hole_diameter = pad.get('hole_diameter', 0.8)
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                painter.drawEllipse(QRectF(x-hole_diameter/2, y-hole_diameter/2, hole_diameter, hole_diameter))
                
                # Draw pad for PTH only
                if pad_type == 'PTH':
                    painter.setPen(QPen(QColor("#FF0000"), 2/self.zoom_factor))  # Red for copper
                    painter.setBrush(QBrush())  # No fill for pad outline
                    pad_diameter = pad.get('pad_diameter', 1.2)
                    painter.drawEllipse(QRectF(x-pad_diameter/2, y-pad_diameter/2, pad_diameter, pad_diameter))
                
                # Restore original pen (not needed for copper layer, but good practice)
                painter.setPen(saved_pen)
            else:  # Drawing mask/paste expansion - PRESERVE CALLER'S PEN COLOR
                if pad_type == 'PTH':
                    pad_diameter = pad.get('pad_diameter', 1.2) + 2*expansion
                    painter.drawEllipse(QRectF(x-pad_diameter/2, y-pad_diameter/2, pad_diameter, pad_diameter))
                else:  # NPTH
                    hole_diameter = pad.get('hole_diameter', 0.8) + 2*expansion
                    painter.drawEllipse(QRectF(x-hole_diameter/2, y-hole_diameter/2, hole_diameter, hole_diameter))
                
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if expansion == 0:  # Drawing the actual copper pad/hole
                # Save current pen color
                saved_pen = painter.pen()
                
                # Draw oblong hole (black)
                hole_length = pad.get('hole_length', 1.5)
                hole_width = pad.get('hole_width', 0.8)
                painter.setPen(QPen(QColor("#FF6600"), 2/self.zoom_factor))
                painter.setBrush(QBrush(QColor("#000000")))
                
                # Draw oblong as rounded rectangle
                radius = hole_width / 2
                painter.drawRoundedRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width), radius, radius)
                
                # Draw pad for PTH oblong only
                if pad_type == 'PTH_oblong':
                    painter.setPen(QPen(QColor("#FF0000"), 2/self.zoom_factor))  # Red for copper
                    painter.setBrush(QBrush())  # No fill for pad outline
                    pad_length = pad.get('pad_length', 2.0)
                    pad_width = pad.get('pad_width', 1.2)
                    pad_radius = pad_width / 2
                    painter.drawRoundedRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width), pad_radius, pad_radius)
                
                # Restore original pen
                painter.setPen(saved_pen)
            else:  # Drawing mask/paste expansion - PRESERVE CALLER'S PEN COLOR
                if pad_type == 'PTH_oblong':
                    pad_length = pad.get('pad_length', 2.0) + 2*expansion
                    pad_width = pad.get('pad_width', 1.2) + 2*expansion
                    pad_radius = pad_width / 2
                    painter.drawRoundedRect(QRectF(x-pad_length/2, y-pad_width/2, pad_length, pad_width), pad_radius, pad_radius)
                else:  # NPTH_oblong
                    hole_length = pad.get('hole_length', 1.5) + 2*expansion
                    hole_width = pad.get('hole_width', 0.8) + 2*expansion
                    radius = hole_width / 2
                    painter.drawRoundedRect(QRectF(x-hole_length/2, y-hole_width/2, hole_length, hole_width), radius, radius)
            
        elif pad_type == 'custom':
            # Draw custom polygon using absolute position
            polygon_points = self.calculate_polygon_points_absolute(pad, x, y)
            if polygon_points:
                # Apply expansion to polygon (simplified - just scale from center)
                if expansion != 0:
                    center_x = sum(p.x() for p in polygon_points) / len(polygon_points)
                    center_y = sum(p.y() for p in polygon_points) / len(polygon_points)
                    scale_factor = 1 + expansion / 1.0  # Approximate scaling
                    
                    expanded_points = []
                    for point in polygon_points:
                        dx = point.x() - center_x
                        dy = point.y() - center_y
                        new_x = center_x + dx * scale_factor
                        new_y = center_y + dy * scale_factor
                        expanded_points.append(QPointF(new_x, new_y))
                    
                    polygon_points = expanded_points
                
                polygon = QPolygonF(polygon_points)
                painter.drawPolygon(polygon)


    def draw_origin(self, painter):
        """Draw origin crosshair"""
        # Draw origin crosshair
        painter.setPen(QPen(QColor("#FFFF00"), 2/self.zoom_factor))  # Yellow crosshair
        
        # Crosshair size
        cross_size = 10 / self.zoom_factor
        
        # Horizontal line
        painter.drawLine(QPointF(-cross_size, 0), QPointF(cross_size, 0))
        # Vertical line  
        painter.drawLine(QPointF(0, -cross_size), QPointF(0, cross_size))
        
        # Origin circle
        painter.setPen(QPen(QColor("#FFFF00"), 1/self.zoom_factor))
        painter.setBrush(QBrush())  # No fill
        painter.drawEllipse(QPointF(0, 0), 3/self.zoom_factor, 3/self.zoom_factor)
    
    def wheelEvent(self, event):
        """Handle mouse wheel events with cursor-centered zoom - FIXED VERSION"""
        zoom_in_factor = 1.2
        zoom_out_factor = 1 / zoom_in_factor
        
        # Get mouse position
        mouse_pos = event.position()
        
        # Store old zoom factor
        old_zoom = self.zoom_factor
        
        # Determine zoom direction
        if event.angleDelta().y() > 0:
            zoom_factor = zoom_in_factor
        else:
            zoom_factor = zoom_out_factor
        
        # Update zoom factor with limits
        new_zoom = self.zoom_factor * zoom_factor
        new_zoom = max(0.1, min(new_zoom, 1000))  # Clamp zoom
        self.zoom_factor = new_zoom
        
        # Calculate widget center
        center_x = self.width() / 2
        center_y = self.height() / 2
        
        # Mouse position relative to center (in widget coordinates)
        mouse_rel_x = mouse_pos.x() - center_x
        mouse_rel_y = mouse_pos.y() - center_y
        
        # FIXED: Calculate scene coordinates more accurately  
        # Convert mouse position to scene coordinates BEFORE zoom change
        scene_x = (mouse_rel_x - self.offset_x) / old_zoom
        scene_y = (mouse_rel_y - self.offset_y) / (-old_zoom)  # Note: negative for Y-flip
        
        # FIXED: Calculate new offsets to keep the scene point under the mouse
        self.offset_x = mouse_rel_x - scene_x * self.zoom_factor
        self.offset_y = mouse_rel_y - scene_y * (-self.zoom_factor)  # Note: negative for Y-flip
        
        # Disable auto fit when manually zooming
        self.auto_fit = False
        self.update()

class PadPositionResolver:
    def __init__(self, pads):
        self.pads = pads
        self.cache = {}
        self.resolved_positions = {}

    def clear_cache(self):
        self.cache.clear()
        self.resolved_positions.clear()

    def get_pad_by_pin(self, pin_number):
        for pad in self.pads:
            if pad.get('pin_number', None) == pin_number:
                return pad
        return None

    def get_absolute_position(self, pad):
        pad_pin = pad.get('pin_number', '')
        if pad_pin in self.cache:
            return self.cache[pad_pin]

        offset_from = pad.get('offset_from', 'origin')
        x_offset = pad.get('x_offset', 0)
        y_offset = pad.get('y_offset', 0)

        if offset_from == 'origin':
            abs_x, abs_y = x_offset, y_offset
            self.resolved_positions[pad_pin] = (abs_x, abs_y)
        else:
            # Direct pin reference - much simpler!
            ref_pad = self.get_pad_by_pin(offset_from)
            if ref_pad and ref_pad != pad:
                ref_x, ref_y = self.get_absolute_position(ref_pad)
                abs_x = ref_x + x_offset
                abs_y = ref_y + y_offset
                self.resolved_positions[pad_pin] = (abs_x, abs_y)
            else:
                # Fallback to origin if reference not found
                abs_x, abs_y = x_offset, y_offset
                self.resolved_positions[pad_pin] = (abs_x, abs_y)

        self.cache[pad_pin] = (abs_x, abs_y)
        return abs_x, abs_y

    def resolve_all_positions(self):
        self.clear_cache()
        
        # Resolve origin-based pads first
        for pad in self.pads:
            if pad.get('offset_from', 'origin') == 'origin':
                self.get_absolute_position(pad)
        
        # Iteratively resolve referenced pads
        max_iterations = len(self.pads) * 2
        for _ in range(max_iterations):
            resolved_any = False
            for pad in self.pads:
                pad_pin = pad.get('pin_number', '')
                if pad_pin not in self.resolved_positions:
                    try:
                        self.get_absolute_position(pad)
                        resolved_any = True
                    except:
                        continue
            if not resolved_any:
                break
        
        return self.resolved_positions


class PadStackRow(QWidget):
    delete_requested = pyqtSignal(object)
    data_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self):
        # Main container with grouped sections
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)

        # Create group box for this padstack
        self.group_box = QGroupBox("Padstack Configuration")
        group_layout = QVBoxLayout(self.group_box)
        group_layout.setSpacing(5)

        # ===== ROW 1: Pad Type and Geometry =====
        row1_layout = QHBoxLayout()
        row1_layout.setSpacing(10)

        # Pad Type Group
        type_group = QGroupBox("Pad Type")
        type_layout = QHBoxLayout(type_group)
        type_layout.setContentsMargins(5, 5, 5, 5)
        self.type_combo = QComboBox()
        self.type_combo.addItems([
            'square', 'rectangle', 'rounded_rectangle', 'round', 'custom',
            'PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong'
        ])
        type_layout.addWidget(self.type_combo)
        row1_layout.addWidget(type_group)

        # Geometry Group (Dynamic based on pad type)
        self.geometry_group = QGroupBox("Geometry")
        self.geometry_layout = QHBoxLayout(self.geometry_group)
        self.geometry_layout.setContentsMargins(5, 5, 5, 5)
        row1_layout.addWidget(self.geometry_group)

        # Action Buttons Group
        actions_group = QGroupBox("Actions")
        actions_layout = QHBoxLayout(actions_group)
        actions_layout.setContentsMargins(5, 5, 5, 5)
        self.duplicate_btn = QPushButton("Duplicate")
        self.duplicate_btn.setMaximumWidth(80)
        self.delete_btn = QPushButton("Delete")
        self.delete_btn.setMaximumWidth(60)
        actions_layout.addWidget(self.duplicate_btn)
        actions_layout.addWidget(self.delete_btn)
        row1_layout.addWidget(actions_group)

        group_layout.addLayout(row1_layout)

        # ===== ROW 2: Position and Layer Properties =====
        row2_layout = QHBoxLayout()
        row2_layout.setSpacing(10)

        # Position Group
        position_group = QGroupBox("Position")
        position_layout = QGridLayout(position_group)
        position_layout.setContentsMargins(5, 5, 5, 5)

        position_layout.addWidget(QLabel("X Offset:"), 0, 0)
        self.x_offset = QDoubleSpinBox()
        self.x_offset.setRange(-100, 100)
        self.x_offset.setSingleStep(0.1)
        self.x_offset.setDecimals(5)
        self.x_offset.setMaximumWidth(100)
        position_layout.addWidget(self.x_offset, 0, 1)

        position_layout.addWidget(QLabel("Y Offset:"), 0, 2)
        self.y_offset = QDoubleSpinBox()
        self.y_offset.setRange(-100, 100)
        self.y_offset.setSingleStep(0.1)
        self.y_offset.setDecimals(5)
        self.y_offset.setMaximumWidth(100)
        position_layout.addWidget(self.y_offset, 0, 3)

        position_layout.addWidget(QLabel("Offset From:"), 1, 0)
        # CHANGED: Dynamic dropdown instead of fixed directional options
        self.offset_from = QComboBox()
        self.offset_from.setMaximumWidth(100)
        position_layout.addWidget(self.offset_from, 1, 1, 1, 2)

        position_layout.addWidget(QLabel("Pin:"), 1, 2)
        self.pin_number = QLineEdit()
        self.pin_number.setMaximumWidth(50)
        position_layout.addWidget(self.pin_number, 1, 3)

        row2_layout.addWidget(position_group)

        # Layer Properties Group
        layers_group = QGroupBox("Layer Properties")
        layers_layout = QGridLayout(layers_group)
        layers_layout.setContentsMargins(5, 5, 5, 5)

        layers_layout.addWidget(QLabel("Mask Expansion:"), 0, 0)
        self.mask_expansion = QDoubleSpinBox()
        self.mask_expansion.setRange(-1, 1)
        self.mask_expansion.setSingleStep(0.01)
        self.mask_expansion.setDecimals(5)
        self.mask_expansion.setMaximumWidth(100)
        layers_layout.addWidget(self.mask_expansion, 0, 1)

        layers_layout.addWidget(QLabel("Paste Expansion:"), 1, 0)
        self.paste_expansion = QDoubleSpinBox()
        self.paste_expansion.setRange(-1, 1)
        self.paste_expansion.setSingleStep(0.01)
        self.paste_expansion.setDecimals(5)
        self.paste_expansion.setMaximumWidth(100)
        layers_layout.addWidget(self.paste_expansion, 1, 1)

        row2_layout.addWidget(layers_group)
        group_layout.addLayout(row2_layout)

        # Custom polygon widget (initially hidden)
        self.polygon_widget = CustomPolygonWidget()
        self.polygon_widget.data_changed.connect(self.data_changed.emit)
        self.polygon_widget.setVisible(False)
        group_layout.addWidget(self.polygon_widget)

        main_layout.addWidget(self.group_box)
        self.setLayout(main_layout)

        # Initialize geometry inputs
        self.update_geometry_inputs()

    def connect_signals(self):
        self.type_combo.currentTextChanged.connect(self.update_geometry_inputs)
        self.type_combo.currentTextChanged.connect(self.data_changed.emit)
        self.delete_btn.clicked.connect(lambda: self.delete_requested.emit(self))

        # Connect all input signals
        for widget in [self.x_offset, self.y_offset, self.mask_expansion, self.paste_expansion]:
            widget.valueChanged.connect(self.data_changed.emit)

        self.offset_from.currentTextChanged.connect(self.data_changed.emit)
        
        # CHANGED: Update dropdown when pin numbers change
        self.pin_number.textChanged.connect(self.update_offset_from_options)
        self.pin_number.textChanged.connect(self.data_changed.emit)

    def update_offset_from_options(self):
        """Update the offset_from dropdown with all available pin numbers"""
        # Get the parent FootprintDesigner to access all padstack rows
        parent_designer = self.get_parent_designer()
        if not parent_designer:
            return

        # Collect all pin numbers except the current one
        available_pins = []
        current_pin = self.pin_number.text().strip()
        
        for row in parent_designer.padstack_rows:
            if row != self:  # Don't include self
                pin_text = row.pin_number.text().strip()
                if pin_text and pin_text != current_pin:
                    available_pins.append(pin_text)

        # Update the dropdown
        current_selection = self.offset_from.currentText()
        self.offset_from.blockSignals(True)
        self.offset_from.clear()
        self.offset_from.addItem('origin')  # Always include origin
        
        # Sort pin numbers numerically if possible, otherwise alphabetically
        try:
            available_pins.sort(key=lambda x: int(x) if x.isdigit() else float('inf'))
        except:
            available_pins.sort()
            
        self.offset_from.addItems(available_pins)
        
        # Restore previous selection if still valid
        index = self.offset_from.findText(current_selection)
        if index >= 0:
            self.offset_from.setCurrentIndex(index)
        else:
            self.offset_from.setCurrentText('origin')
            
        self.offset_from.blockSignals(False)

    def get_parent_designer(self):
        """Find the parent FootprintDesigner instance"""
        parent = self.parent()
        while parent:
            if hasattr(parent, 'padstack_rows'):
                return parent
            parent = parent.parent()
        return None

    def update_geometry_inputs(self):
        # Clear existing geometry inputs
        for i in reversed(range(self.geometry_layout.count())):
            item = self.geometry_layout.itemAt(i)
            if item:
                widget = item.widget()
                if widget:
                    widget.setParent(None)
        
        pad_type = self.type_combo.currentText()
        
        # Show/hide polygon widget
        self.polygon_widget.setVisible(pad_type == 'custom')
        
        if pad_type == 'square':
            self.geometry_layout.addWidget(QLabel("Size:"))
            self.size_input = QDoubleSpinBox()
            self.size_input.setRange(0.1, 50)
            self.size_input.setSingleStep(0.1)
            self.size_input.setValue(1.0)
            self.size_input.setDecimals(5)
            self.size_input.setMaximumWidth(100)
            self.size_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.size_input)
            
        elif pad_type == 'rectangle':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QDoubleSpinBox()
            self.length_input.setRange(0.1, 50)
            self.length_input.setSingleStep(0.1)
            self.length_input.setValue(1.0)
            self.length_input.setDecimals(5)
            self.length_input.setMaximumWidth(100)
            self.length_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)
            
            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QDoubleSpinBox()
            self.width_input.setRange(0.1, 50)
            self.width_input.setSingleStep(0.1)
            self.width_input.setValue(1.0)
            self.width_input.setDecimals(5)
            self.width_input.setMaximumWidth(100)
            self.width_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)
            
        elif pad_type == 'rounded_rectangle':
            self.geometry_layout.addWidget(QLabel("Length:"))
            self.length_input = QDoubleSpinBox()
            self.length_input.setRange(0.1, 50)
            self.length_input.setSingleStep(0.1)
            self.length_input.setValue(1.0)
            self.length_input.setDecimals(5)
            self.length_input.setMaximumWidth(100)
            self.length_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.length_input)
            
            self.geometry_layout.addWidget(QLabel("Width:"))
            self.width_input = QDoubleSpinBox()
            self.width_input.setRange(0.1, 50)
            self.width_input.setSingleStep(0.1)
            self.width_input.setValue(1.0)
            self.width_input.setDecimals(5)
            self.width_input.setMaximumWidth(100)
            self.width_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.width_input)
            
            self.geometry_layout.addWidget(QLabel("Corner Radius:"))
            self.corner_radius_input = QDoubleSpinBox()
            self.corner_radius_input.setRange(0, 5)
            self.corner_radius_input.setSingleStep(0.1)
            self.corner_radius_input.setValue(0.2)
            self.corner_radius_input.setDecimals(5)
            self.corner_radius_input.setMaximumWidth(100)
            self.corner_radius_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.corner_radius_input)
            
        elif pad_type == 'round':
            self.geometry_layout.addWidget(QLabel("Diameter:"))
            self.diameter_input = QDoubleSpinBox()
            self.diameter_input.setRange(0.1, 50)
            self.diameter_input.setSingleStep(0.1)
            self.diameter_input.setValue(1.0)
            self.diameter_input.setDecimals(5)
            self.diameter_input.setMaximumWidth(100)
            self.diameter_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.diameter_input)
            
        elif pad_type in ['PTH', 'NPTH']:
            # Round through hole
            self.geometry_layout.addWidget(QLabel("Hole Diameter:"))
            self.hole_diameter_input = QDoubleSpinBox()
            self.hole_diameter_input.setRange(0.1, 10)
            self.hole_diameter_input.setSingleStep(0.1)
            self.hole_diameter_input.setValue(0.8)
            self.hole_diameter_input.setDecimals(5)
            self.hole_diameter_input.setMaximumWidth(100)
            self.hole_diameter_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_diameter_input)
            
            if pad_type == 'PTH':
                # PTH needs pad diameter
                self.geometry_layout.addWidget(QLabel("Pad Diameter:"))
                self.pad_diameter_input = QDoubleSpinBox()
                self.pad_diameter_input.setRange(0.1, 50)
                self.pad_diameter_input.setSingleStep(0.1)
                self.pad_diameter_input.setValue(1.2)
                self.pad_diameter_input.setDecimals(5)
                self.pad_diameter_input.setMaximumWidth(100)
                self.pad_diameter_input.valueChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_diameter_input)
            
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            # Oblong through hole
            self.geometry_layout.addWidget(QLabel("Hole Length:"))
            self.hole_length_input = QDoubleSpinBox()
            self.hole_length_input.setRange(0.1, 10)
            self.hole_length_input.setSingleStep(0.1)
            self.hole_length_input.setValue(1.5)
            self.hole_length_input.setDecimals(5)
            self.hole_length_input.setMaximumWidth(100)
            self.hole_length_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_length_input)
            
            self.geometry_layout.addWidget(QLabel("Hole Width:"))
            self.hole_width_input = QDoubleSpinBox()
            self.hole_width_input.setRange(0.1, 10)
            self.hole_width_input.setSingleStep(0.1)
            self.hole_width_input.setValue(0.8)
            self.hole_width_input.setDecimals(5)
            self.hole_width_input.setMaximumWidth(100)
            self.hole_width_input.valueChanged.connect(self.data_changed.emit)
            self.geometry_layout.addWidget(self.hole_width_input)
            
            if pad_type == 'PTH_oblong':
                # PTH oblong needs pad dimensions
                self.geometry_layout.addWidget(QLabel("Pad Length:"))
                self.pad_length_input = QDoubleSpinBox()
                self.pad_length_input.setRange(0.1, 50)
                self.pad_length_input.setSingleStep(0.1)
                self.pad_length_input.setValue(2.0)
                self.pad_length_input.setDecimals(5)
                self.pad_length_input.setMaximumWidth(100)
                self.pad_length_input.valueChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_length_input)
                
                self.geometry_layout.addWidget(QLabel("Pad Width:"))
                self.pad_width_input = QDoubleSpinBox()
                self.pad_width_input.setRange(0.1, 50)
                self.pad_width_input.setSingleStep(0.1)
                self.pad_width_input.setValue(1.2)
                self.pad_width_input.setDecimals(5)
                self.pad_width_input.setMaximumWidth(100)
                self.pad_width_input.valueChanged.connect(self.data_changed.emit)
                self.geometry_layout.addWidget(self.pad_width_input)
                
        elif pad_type == 'custom':
            # Custom polygon inputs handled by polygon_widget
            self.geometry_layout.addWidget(QLabel("Custom Polygon (see below)"))
        
        # Add stretch to push everything to the left
        self.geometry_layout.addStretch()
        
    def get_data(self):
        data = {
            'type': self.type_combo.currentText(),
            'x_offset': self.x_offset.value(),
            'y_offset': self.y_offset.value(),
            'offset_from': self.offset_from.currentText(),
            'mask_expansion': self.mask_expansion.value(),
            'paste_expansion': self.paste_expansion.value(),
            'pin_number': self.pin_number.text()
        }
        
        pad_type = self.type_combo.currentText()
        if pad_type == 'square' and hasattr(self, 'size_input'):
            data['size'] = self.size_input.value()
        elif pad_type in ['rectangle', 'rounded_rectangle']:
            if hasattr(self, 'length_input'):
                data['length'] = self.length_input.value()
            if hasattr(self, 'width_input'):
                data['width'] = self.width_input.value()
            if pad_type == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                data['corner_radius'] = self.corner_radius_input.value()
        elif pad_type == 'round' and hasattr(self, 'diameter_input'):
            data['diameter'] = self.diameter_input.value()
        elif pad_type in ['PTH', 'NPTH']:
            if hasattr(self, 'hole_diameter_input'):
                data['hole_diameter'] = self.hole_diameter_input.value()
            if pad_type == 'PTH' and hasattr(self, 'pad_diameter_input'):
                data['pad_diameter'] = self.pad_diameter_input.value()
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if hasattr(self, 'hole_length_input'):
                data['hole_length'] = self.hole_length_input.value()
            if hasattr(self, 'hole_width_input'):
                data['hole_width'] = self.hole_width_input.value()
            if pad_type == 'PTH_oblong':
                if hasattr(self, 'pad_length_input'):
                    data['pad_length'] = self.pad_length_input.value()
                if hasattr(self, 'pad_width_input'):
                    data['pad_width'] = self.pad_width_input.value()
        elif pad_type == 'custom':
            data['polygon_data'] = self.polygon_widget.get_data()
            
        return data
        

    
    def set_data(self, data):
        self.type_combo.setCurrentText(data.get('type', 'square'))
        self.x_offset.setValue(data.get('x_offset', 0))
        self.y_offset.setValue(data.get('y_offset', 0))
        self.mask_expansion.setValue(data.get('mask_expansion', 0))
        self.paste_expansion.setValue(data.get('paste_expansion', 0))
        self.pin_number.setText(data.get('pin_number', '1'))
        
        # Update options first, then set the selection
        self.update_offset_from_options()
        self.offset_from.setCurrentText(data.get('offset_from', 'origin'))

        # Set type-specific data
        pad_type = data.get('type', 'square')
        if pad_type == 'square' and hasattr(self, 'size_input'):
            self.size_input.setValue(data.get('size', 1.0))
        elif pad_type in ['rectangle', 'rounded_rectangle']:
            if hasattr(self, 'length_input'):
                self.length_input.setValue(data.get('length', 1.0))
            if hasattr(self, 'width_input'):
                self.width_input.setValue(data.get('width', 1.0))
            if pad_type == 'rounded_rectangle' and hasattr(self, 'corner_radius_input'):
                self.corner_radius_input.setValue(data.get('corner_radius', 0.2))
        elif pad_type == 'round' and hasattr(self, 'diameter_input'):
            self.diameter_input.setValue(data.get('diameter', 1.0))
        elif pad_type in ['PTH', 'NPTH']:
            if hasattr(self, 'hole_diameter_input'):
                self.hole_diameter_input.setValue(data.get('hole_diameter', 0.8))
            if pad_type == 'PTH' and hasattr(self, 'pad_diameter_input'):
                self.pad_diameter_input.setValue(data.get('pad_diameter', 1.2))
        elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
            if hasattr(self, 'hole_length_input'):
                self.hole_length_input.setValue(data.get('hole_length', 1.5))
            if hasattr(self, 'hole_width_input'):
                self.hole_width_input.setValue(data.get('hole_width', 0.8))
            if pad_type == 'PTH_oblong':
                if hasattr(self, 'pad_length_input'):
                    self.pad_length_input.setValue(data.get('pad_length', 2.0))
                if hasattr(self, 'pad_width_input'):
                    self.pad_width_input.setValue(data.get('pad_width', 1.2))
        elif pad_type == 'custom':
            self.polygon_widget.set_data(data.get('polygon_data', {}))

class SettingsPanel(QWidget):
    settings_changed = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_user = None
        self.setup_ui()
        self.setup_styling()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(15)
        
        # Title
        title = QLabel("Settings")
        title.setStyleSheet("font-size: 16px; font-weight: bold; color: #ffffff; margin-bottom: 10px;")
        layout.addWidget(title)
        
        # User Login Section
        self.setup_user_section(layout)
        
        # Separator
        separator1 = QFrame()
        separator1.setFrameShape(QFrame.Shape.HLine)
        separator1.setStyleSheet("color: #555;")
        layout.addWidget(separator1)
        
        # Body Settings
        self.setup_body_settings(layout)
        
        # Separator
        separator2 = QFrame()
        separator2.setFrameShape(QFrame.Shape.HLine)
        separator2.setStyleSheet("color: #555;")
        layout.addWidget(separator2)
        
        # Courtyard Settings
        self.setup_courtyard_settings(layout)
        
        # Separator
        separator3 = QFrame()
        separator3.setFrameShape(QFrame.Shape.HLine)
        separator3.setStyleSheet("color: #555;")
        layout.addWidget(separator3)
        
        # Silkscreen Settings
        self.setup_silkscreen_settings(layout)
        
        # Separator
        separator4 = QFrame()
        separator4.setFrameShape(QFrame.Shape.HLine)
        separator4.setStyleSheet("color: #555;")
        layout.addWidget(separator4)
        
        # Script Output Settings
        self.setup_script_settings(layout)
        
        layout.addStretch()
        
    def setup_user_section(self, layout):
        user_group = QGroupBox("User Account")
        user_layout = QVBoxLayout(user_group)
        
        # User display/login
        self.user_display = QLabel("Not logged in")
        self.user_display.setStyleSheet("color: #ffffff; margin: 5px;")
        user_layout.addWidget(self.user_display)
        
        # Login form (initially visible)
        self.login_frame = QFrame()
        login_layout = QGridLayout(self.login_frame)
        
        login_layout.addWidget(QLabel("Username:"), 0, 0)
        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter username")
        login_layout.addWidget(self.username_input, 0, 1)
        
        login_layout.addWidget(QLabel("Password:"), 1, 0)
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText("Enter password")
        login_layout.addWidget(self.password_input, 1, 1)
        
        self.login_btn = QPushButton("Login")
        self.login_btn.clicked.connect(self.handle_login)
        login_layout.addWidget(self.login_btn, 2, 0, 1, 2)
        
        user_layout.addWidget(self.login_frame)
        
        # Logout button (initially hidden)
        self.logout_btn = QPushButton("Logout")
        self.logout_btn.clicked.connect(self.handle_logout)
        self.logout_btn.setVisible(False)
        user_layout.addWidget(self.logout_btn)
        
        layout.addWidget(user_group)
        
    def setup_body_settings(self, layout):
        body_group = QGroupBox("Body Settings")
        body_layout = QGridLayout(body_group)
        
        body_layout.addWidget(QLabel("Body Line Width:"), 0, 0)
        self.body_line_width = QDoubleSpinBox()
        self.body_line_width.setRange(0.1, 10.0)
        self.body_line_width.setSingleStep(0.1)
        self.body_line_width.setValue(1.5)
        self.body_line_width.setDecimals(2)
        self.body_line_width.setSuffix(" mm")
        self.body_line_width.valueChanged.connect(self.settings_changed.emit)
        body_layout.addWidget(self.body_line_width, 0, 1)
        
        layout.addWidget(body_group)
        
    def setup_courtyard_settings(self, layout):
        courtyard_group = QGroupBox("Courtyard Settings")
        courtyard_layout = QGridLayout(courtyard_group)
        
        courtyard_layout.addWidget(QLabel("Courtyard Expansion:"), 0, 0)
        self.courtyard_expansion = QDoubleSpinBox()
        self.courtyard_expansion.setRange(0, 5)
        self.courtyard_expansion.setSingleStep(0.1)
        self.courtyard_expansion.setValue(0.25)
        self.courtyard_expansion.setDecimals(5)
        self.courtyard_expansion.setSuffix(" mm")
        self.courtyard_expansion.valueChanged.connect(self.settings_changed.emit)
        courtyard_layout.addWidget(self.courtyard_expansion, 0, 1)
        
        courtyard_layout.addWidget(QLabel("Courtyard Line Width:"), 1, 0)
        self.courtyard_line_width = QDoubleSpinBox()
        self.courtyard_line_width.setRange(0.1, 5.0)
        self.courtyard_line_width.setSingleStep(0.1)
        self.courtyard_line_width.setValue(0.1)
        self.courtyard_line_width.setDecimals(2)
        self.courtyard_line_width.setSuffix(" mm")
        self.courtyard_line_width.valueChanged.connect(self.settings_changed.emit)
        courtyard_layout.addWidget(self.courtyard_line_width, 1, 1)
        
        layout.addWidget(courtyard_group)
        
    def setup_silkscreen_settings(self, layout):
        silkscreen_group = QGroupBox("Silkscreen Settings")
        silkscreen_layout = QGridLayout(silkscreen_group)
        
        silkscreen_layout.addWidget(QLabel("Silkscreen Airgap:"), 0, 0)
        self.silkscreen_airgap = QDoubleSpinBox()
        self.silkscreen_airgap.setRange(0, 2)
        self.silkscreen_airgap.setSingleStep(0.01)
        self.silkscreen_airgap.setValue(0.15)
        self.silkscreen_airgap.setDecimals(5)
        self.silkscreen_airgap.setSuffix(" mm")
        self.silkscreen_airgap.valueChanged.connect(self.settings_changed.emit)
        silkscreen_layout.addWidget(self.silkscreen_airgap, 0, 1)
        
        silkscreen_layout.addWidget(QLabel("Silkscreen Line Width:"), 1, 0)
        self.silkscreen_line_width = QDoubleSpinBox()
        self.silkscreen_line_width.setRange(0.1, 5.0)
        self.silkscreen_line_width.setSingleStep(0.1)
        self.silkscreen_line_width.setValue(0.15)
        self.silkscreen_line_width.setDecimals(2)
        self.silkscreen_line_width.setSuffix(" mm")
        self.silkscreen_line_width.valueChanged.connect(self.settings_changed.emit)
        silkscreen_layout.addWidget(self.silkscreen_line_width, 1, 1)
        
        layout.addWidget(silkscreen_group)
        
    def setup_script_settings(self, layout):
        script_group = QGroupBox("Script Output Settings")
        script_layout = QGridLayout(script_group)
        
        script_layout.addWidget(QLabel("Altium Script Output Path:"), 0, 0)
        
        path_layout = QHBoxLayout()
        self.script_output_path = QLineEdit()
        self.script_output_path.setPlaceholderText("Select output directory...")
        self.script_output_path.setText(os.path.expanduser("~/Documents"))
        path_layout.addWidget(self.script_output_path)
        
        browse_btn = QPushButton("Browse...")
        browse_btn.clicked.connect(self.browse_output_path)
        browse_btn.setMaximumWidth(80)
        path_layout.addWidget(browse_btn)
        
        script_layout.addLayout(path_layout, 0, 1)
        
        layout.addWidget(script_group)
        
    def browse_output_path(self):
        path = QFileDialog.getExistingDirectory(
            self, 
            "Select Script Output Directory",
            self.script_output_path.text()
        )
        if path:
            self.script_output_path.setText(path)
            self.settings_changed.emit()
            
    def handle_login(self):
        username = self.username_input.text().strip()
        password = self.password_input.text().strip()
        
        if not username or not password:
            QMessageBox.warning(self, "Login", "Please enter both username and password")
            return
            
        # Simple mock authentication - replace with real authentication
        if username and password:  # Accept any non-empty credentials for demo
            self.current_user = username
            self.user_display.setText(f"Welcome, {username}")
            self.login_frame.setVisible(False)
            self.logout_btn.setVisible(True)
            
            # Clear password for security
            self.password_input.clear()
            
            QMessageBox.information(self, "Login", f"Successfully logged in as {username}")
        else:
            QMessageBox.warning(self, "Login", "Invalid credentials")
            
    def handle_logout(self):
        self.current_user = None
        self.user_display.setText("Not logged in")
        self.login_frame.setVisible(True)
        self.logout_btn.setVisible(False)
        self.username_input.clear()
        self.password_input.clear()
        
    def setup_styling(self):
        self.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLabel {
                color: #ffffff;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
                color: #ffffff;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
        """)
        
    def get_settings(self):
        return {
            'body_line_width': self.body_line_width.value(),
            'courtyard_expansion': self.courtyard_expansion.value(),
            'courtyard_line_width': self.courtyard_line_width.value(),
            'silkscreen_airgap': self.silkscreen_airgap.value(),
            'silkscreen_line_width': self.silkscreen_line_width.value(),
            'script_output_path': self.script_output_path.text(),
            'current_user': self.current_user
        }
        
    def set_settings(self, settings):
        self.body_line_width.setValue(settings.get('body_line_width', 1.5))
        self.courtyard_expansion.setValue(settings.get('courtyard_expansion', 0.25))
        self.courtyard_line_width.setValue(settings.get('courtyard_line_width', 0.1))
        self.silkscreen_airgap.setValue(settings.get('silkscreen_airgap', 0.15))
        self.silkscreen_line_width.setValue(settings.get('silkscreen_line_width', 0.15))
        self.script_output_path.setText(settings.get('script_output_path', os.path.expanduser("~/Documents")))
        
        user = settings.get('current_user')
        if user:
            self.current_user = user
            self.user_display.setText(f"Welcome, {user}")
            self.login_frame.setVisible(False)
            self.logout_btn.setVisible(True)


class UpdateThread(QThread):
    update_signal = pyqtSignal(dict)
    
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.running = True
    
    def run(self):
        while self.running:
            data = self.main_window.get_footprint_data()
            self.update_signal.emit(data)
            self.msleep(100)  # Update every 100ms
    
    def stop(self):
        self.running = False

class FootprintDesigner(QMainWindow):
    def __init__(self):
        super().__init__()
        self.padstack_rows = []
        self.current_save_file = None 
        self.setup_ui()
        self.setup_dark_theme()
        self.start_update_thread()
        

    def setup_dark_theme(self):
        self.setStyleSheet("""
            QMainWindow {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QLineEdit, QDoubleSpinBox, QSpinBox, QComboBox {
                background-color: #3c3c3c;
                border: 1px solid #555;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton {
                background-color: #4a4a4a;
                border: 1px solid #666;
                padding: 5px 10px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
            QScrollArea {
                background-color: #2b2b2b;
                border: none;
            }
            QFrame {
                border: 1px solid #555;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                background-color: #2b2b2b;
            }
        """)

    def setup_ui(self):
        self.setWindowTitle("Footprint Designer")
        self.setGeometry(100, 100, 1800, 900)  # Increased width for settings panel

        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main splitter (3 panels: left, center, right)
        main_splitter = QSplitter(Qt.Orientation.Horizontal)
        central_widget.setLayout(QHBoxLayout())
        central_widget.layout().addWidget(main_splitter)

        # Left panel
        left_panel = self.create_left_panel()
        main_splitter.addWidget(left_panel)

        # Center panel (renderer)
        self.renderer = FootprintRenderer()
        main_splitter.addWidget(self.renderer)
        self.renderer.footprint_designer_ref = self

        # Right panel (settings) - initially hidden
        self.settings_panel = SettingsPanel()
        self.settings_panel.settings_changed.connect(self.on_settings_changed)
        self.settings_panel.setVisible(False)
        self.settings_panel.setMaximumWidth(350)
        self.settings_panel.setMinimumWidth(300)
        main_splitter.addWidget(self.settings_panel)

        # Set initial splitter proportions
        main_splitter.setSizes([800, 700, 0])  # Left, Center, Right (hidden)

    def toggle_settings_panel(self):
        """Toggle the visibility of settings panel"""
        is_visible = self.settings_panel.isVisible()
        self.settings_panel.setVisible(not is_visible)
        
        # Adjust splitter sizes
        if not is_visible:
            # Show settings panel
            self.centralWidget().layout().itemAt(0).widget().setSizes([700, 600, 300])
        else:
            # Hide settings panel
            self.centralWidget().layout().itemAt(0).widget().setSizes([800, 700, 0])

    def on_settings_changed(self):
        """Handle settings changes"""
        # Update renderer with new settings
        self.renderer.update()

        
        


    def create_left_panel(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)
        

        # Create buttons (removed fit_btn)

        header1_frame = QFrame()
        header1_frame.setFrameStyle(QFrame.Shape.StyledPanel)
        button_layout = QGridLayout(header1_frame)
        self.new_btn = QPushButton("New")
        self.save_btn = QPushButton("Save")
        self.save_as_btn = QPushButton("Save As")
        self.open_btn = QPushButton("Open")
        self.generate_btn = QPushButton("Generate Script")

        # Add buttons to layout (removed fit_btn)
        button_layout.addWidget(self.new_btn, 0, 0)
        button_layout.addWidget(self.save_btn, 0, 1)
        button_layout.addWidget(self.save_as_btn, 0, 2)
        button_layout.addWidget(self.open_btn, 0, 3)
        button_layout.addWidget(self.generate_btn, 0, 4)
 # Push buttons to the left

        # Connect signals to methods (removed fit_btn connection)
        self.new_btn.clicked.connect(self.new_footprint)
        self.save_btn.clicked.connect(self.save_data)
        self.save_as_btn.clicked.connect(self.save_data_as)
        self.open_btn.clicked.connect(self.load_data)
        self.generate_btn.clicked.connect(self.generate_footprint_script)

        layout.addWidget(header1_frame)


        # Header section (existing code)
        header_frame = QFrame()
        header_frame.setFrameStyle(QFrame.Shape.StyledPanel)
        header_layout = QGridLayout(header_frame)

        # Header inputs (existing code remains the same)
        header_layout.addWidget(QLabel("Part Number:"), 0, 0)
        self.part_number = QLineEdit()
        header_layout.addWidget(self.part_number, 0, 1)
        header_layout.addWidget(QLabel("Footprint Name:"), 0, 2)
        self.footprint_name = QLineEdit()
        header_layout.addWidget(self.footprint_name, 0, 3)

        # Rest of header inputs (keep existing code)
        header_layout.addWidget(QLabel("Body Length:"), 1, 0)
        self.body_length = QDoubleSpinBox()
        self.body_length.setRange(0.1, 100)
        self.body_length.setValue(5.0)
        self.body_length.setDecimals(5)
        header_layout.addWidget(self.body_length, 1, 1)
        
        header_layout.addWidget(QLabel("Body Width:"), 1, 2)
        self.body_width = QDoubleSpinBox()
        self.body_width.setRange(0.1, 100)
        self.body_width.setValue(3.0)
        self.body_width.setDecimals(5)
        header_layout.addWidget(self.body_width, 1, 3)

        header_layout.addWidget(QLabel("Body Height:"), 2, 0)
        self.body_height = QDoubleSpinBox()
        self.body_height.setRange(0.1, 100)
        self.body_height.setValue(1.0)
        self.body_height.setDecimals(5)
        header_layout.addWidget(self.body_height, 2, 1)
        
        # Body Shape
        header_layout.addWidget(QLabel("Body Shape:"), 2, 2)
        self.body_shape_combobox = QComboBox()
        self.body_shape_combobox.addItems(["rectangle", "round"])
        self.body_shape_combobox.setCurrentIndex(0)
        header_layout.addWidget(self.body_shape_combobox, 2, 3)


        # Show Silkscreen checkbox
        self.silkscreen_enabled = QCheckBox("Show Silkscreen")
        self.silkscreen_enabled.setChecked(True)
        header_layout.addWidget(self.silkscreen_enabled, 3, 0, 1, 2)

        # Add Padstack button
        add_btn = QPushButton("+ Add Padstack")
        add_btn.clicked.connect(self.add_padstack_row)
        header_layout.addWidget(add_btn, 3, 2, 1, 2)

        
        layout.addWidget(header_frame)

        # Padstack scroll area (existing code)
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.padstack_container = QWidget()
        self.padstack_layout = QVBoxLayout(self.padstack_container)
        self.padstack_layout.addStretch()
        scroll_area.setWidget(self.padstack_container)
        layout.addWidget(scroll_area)

        # Add initial padstack
        self.add_padstack_row()
        
        return widget

    def new_footprint(self):
        """Create a new footprint (reset all fields)"""
        reply = QMessageBox.question(
            self,
            'New Footprint',
            'Are you sure you want to create a new footprint? All current data will be lost.',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Clear current file path
            self.current_save_file = None
            
            # Clear all input fields
            self.part_number.setText('')
            self.footprint_name.setText('')
            self.body_length.setValue(5.0)
            self.body_width.setValue(3.0)
            self.body_height.setValue(1.0)
            self.body_shape_combobox.setCurrentIndex(0)
            self.silkscreen_enabled.setChecked(True)
            
            # FIXED: Reset settings panel to defaults
            default_settings = {
                'body_line_width': 1.5,
                'courtyard_expansion': 0.25,
                'courtyard_line_width': 0.1,
                'silkscreen_airgap': 0.15,
                'silkscreen_line_width': 0.15,
                'script_output_path': os.path.expanduser("~/Documents"),
                'current_user': None
            }
            self.settings_panel.set_settings(default_settings)
            
            # Clear all padstacks
            for row in self.padstack_rows[:]:
                self.delete_padstack_row(row)
            
            # Add one default padstack
            self.add_padstack_row()


    def save_data_as(self):
        """Save footprint data with a new filename (always prompts)"""
        filename, _ = QFileDialog.getSaveFileName(
            self,
            "Save Footprint As",
            "",
            "LibSienna Footprint Files (*.LibSienna);;All Files (*)"
        )
        
        if filename:
            # Automatically add .LibSienna extension if not present
            if not filename.lower().endswith('.libsienna'):
                filename += '.LibSienna'
            
            # Update current file path
            self.current_save_file = filename
            
            # Save the data
            data = self.get_footprint_data()
            success = LibSiennaFileFormat.save_footprint(data, filename)
            
            if success:
                QMessageBox.information(
                    self, 
                    "Success", 
                    f"Footprint saved successfully as {os.path.basename(filename)}!"
                )
            else:
                QMessageBox.critical(self, "Error", "Failed to save footprint file!")

    def generate_footprint_script(self):
        """Generate footprint script from current data and save to a text file"""
        data = self.get_footprint_data()
        settings = self.settings_panel.get_settings()
        lines = []
        
        # Scale factor for unit conversion (mm to mils)
        SCALE = 39.37
        
        # Footprint name
        footprint_name = data.get('footprint_name', 'Unnamed')
        lines.append(f"StartFootprints\n\nFootprint (Name \"{footprint_name}\"),")

        # Body dimensions
        body_length = data.get('body_length', 0)
        body_width = data.get('body_width', 0)
        half_length = body_length / 2
        half_width = body_width / 2

        # Define corners of body rectangle
        bl = (-half_length, -half_width)
        tl = (-half_length, half_width)
        tr = (half_length, half_width)
        br = (half_length, -half_width)

        # Body shape generation
        body_shape = data.get('body_shape', 'rectangle')
        if body_shape == 'rectangle':
            lines.append(f"Line (Width 1.7) (Start {tl[0]*SCALE:.2f}, {tl[1]*SCALE:.2f}) (End {tr[0]*SCALE:.2f}, {tr[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {bl[0]*SCALE:.2f}, {bl[1]*SCALE:.2f}) (End {tl[0]*SCALE:.2f}, {tl[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {tr[0]*SCALE:.2f}, {tr[1]*SCALE:.2f}) (End {br[0]*SCALE:.2f}, {br[1]*SCALE:.2f}) (Layer Mechanical13)")
            lines.append(f"Line (Width 1.7) (Start {br[0]*SCALE:.2f}, {br[1]*SCALE:.2f}) (End {bl[0]*SCALE:.2f}, {bl[1]*SCALE:.2f}) (Layer Mechanical13)")
        else:
            radius = max(half_length, half_width)
            lines.append(f"Line (Width 1.7) (Center (0, 0)) (Radius {radius*SCALE:.2f}) (Layer Mechanical13)")

        # FIXED: Calculate pad absolute bounds for silkscreen gap calculation
        pads = data.get('padstacks', [])
        resolver = PadPositionResolver(pads)
        pad_bounds_list = []
        
        for i, pad in enumerate(pads):
            abs_x, abs_y = resolver.get_absolute_position(pad)
            pad_type = pad.get('type', 'square')
            
            if pad_type == 'square':
                size = pad.get('size', 1)
                pb = [abs_x - size/2, abs_y - size/2, abs_x + size/2, abs_y + size/2]
            elif pad_type in ['rectangle', 'rounded_rectangle']:
                length = pad.get('length', 1)
                width = pad.get('width', 1)
                pb = [abs_x - length/2, abs_y - width/2, abs_x + length/2, abs_y + width/2]
            elif pad_type == 'round':
                diameter = pad.get('diameter', 1)
                pb = [abs_x - diameter/2, abs_y - diameter/2, abs_x + diameter/2, abs_y + diameter/2]
            elif pad_type in ['PTH', 'NPTH']:
                if pad_type == 'PTH':
                    diameter = pad.get('pad_diameter', 1.2)
                else:
                    diameter = pad.get('hole_diameter', 0.8)
                pb = [abs_x - diameter/2, abs_y - diameter/2, abs_x + diameter/2, abs_y + diameter/2]
            elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
                if pad_type == 'PTH_oblong':
                    length = pad.get('pad_length', 2.0)
                    width = pad.get('pad_width', 1.2)
                else:
                    length = pad.get('hole_length', 1.5)
                    width = pad.get('hole_width', 0.8)
                pb = [abs_x - length/2, abs_y - width/2, abs_x + length/2, abs_y + width/2]
            elif pad_type == 'custom':
                # Simplified bounds for custom pads
                pb = [abs_x - 0.5, abs_y - 0.5, abs_x + 0.5, abs_y + 0.5]
            else:
                pb = [abs_x - 0.5, abs_y - 0.5, abs_x + 0.5, abs_y + 0.5]
                
            pad_bounds_list.append(pb)

        # Helper functions for silkscreen with gaps
        def merge_intervals(intervals):
            if not intervals:
                return []
            intervals = sorted(intervals, key=lambda x: x[0])
            merged = [intervals[0]]
            for current in intervals[1:]:
                last_start, last_end = merged[-1]
                current_start, current_end = current
                if current_start <= last_end:  # overlap
                    merged[-1] = (last_start, max(last_end, current_end))
                else:
                    merged.append(current)
            return merged


        def generate_silkscreen_lines_with_gaps(x1, y1, x2, y2, pad_bounds_list, gap, orientation):
            segments = []
            if orientation == 'horizontal':
                start_pos = min(x1, x2)
                end_pos = max(x1, x2)
                line_y = y1
                intersections = []
                
                for (px_min, py_min, px_max, py_max) in pad_bounds_list:
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if horizontal line intersects with expanded pad
                    if (pad_min_y <= line_y <= pad_max_y and 
                        pad_max_x >= start_pos and pad_min_x <= end_pos):
                        inter_start = max(start_pos, pad_min_x)
                        inter_end = min(end_pos, pad_max_x)
                        intersections.append((inter_start, inter_end))
                
                # Merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Generate line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        segments.append((current_pos, line_y, gap_start, line_y))
                    current_pos = gap_end
                if current_pos < end_pos:
                    segments.append((current_pos, line_y, end_pos, line_y))
                    
            else:  # vertical
                start_pos = min(y1, y2)
                end_pos = max(y1, y2)
                line_x = x1
                intersections = []
                
                for (px_min, py_min, px_max, py_max) in pad_bounds_list:
                    # Expand pad bounds by airgap
                    pad_min_x = px_min - gap
                    pad_max_x = px_max + gap
                    pad_min_y = py_min - gap
                    pad_max_y = py_max + gap
                    
                    # Check if vertical line intersects with expanded pad
                    if (pad_min_x <= line_x <= pad_max_x and 
                        pad_max_y >= start_pos and pad_min_y <= end_pos):
                        inter_start = max(start_pos, pad_min_y)
                        inter_end = min(end_pos, pad_max_y)
                        intersections.append((inter_start, inter_end))
                
                # Merge overlapping intersections
                merged = merge_intervals(intersections)
                
                # Generate line segments between gaps
                current_pos = start_pos
                for gap_start, gap_end in merged:
                    if current_pos < gap_start:
                        segments.append((line_x, current_pos, line_x, gap_start))
                    current_pos = gap_end
                if current_pos < end_pos:
                    segments.append((line_x, current_pos, line_x, end_pos))
                    
            return segments

        # FIXED: Generate silkscreen with gaps (matching live view)
        silkscreen_gap = data.get('silkscreen_airgap', 0.15)
        
        # Generate silkscreen lines with gaps for each side of body rectangle
        silk_lines = []
        # Top line
        silk_lines += generate_silkscreen_lines_with_gaps(-half_length, half_width, half_length, half_width, pad_bounds_list, silkscreen_gap, 'horizontal')
        # Bottom line  
        silk_lines += generate_silkscreen_lines_with_gaps(-half_length, -half_width, half_length, -half_width, pad_bounds_list, silkscreen_gap, 'horizontal')
        # Left line
        silk_lines += generate_silkscreen_lines_with_gaps(-half_length, -half_width, -half_length, half_width, pad_bounds_list, silkscreen_gap, 'vertical')
        # Right line
        silk_lines += generate_silkscreen_lines_with_gaps(half_length, -half_width, half_length, half_width, pad_bounds_list, silkscreen_gap, 'vertical')
        
        # Add silkscreen segment lines to script
        for (x1_, y1_, x2_, y2_) in silk_lines:
            lines.append(f"Line (Width 6) (Start {x1_*SCALE:.2f}, {y1_*SCALE:.2f}) (End {x2_*SCALE:.2f}, {y2_*SCALE:.2f}) (Layer TopOverlay)")

        # Calculate pad bounds for courtyard (same logic as live view)
        pad_bounds = None
        if pad_bounds_list:
            min_x = min(pb[0] for pb in pad_bounds_list)
            min_y = min(pb[1] for pb in pad_bounds_list)
            max_x = max(pb[2] for pb in pad_bounds_list)
            max_y = max(pb[3] for pb in pad_bounds_list)
            pad_bounds = [min_x, min_y, max_x, max_y]

        # FIXED: Courtyard based on outermost bounds (matching live view)
        courtyard_expansion = data.get('courtyard_expansion', 0.25)
        body_bounds = [-half_length, -half_width, half_length, half_width]
        
        # Use outermost bounds logic (same as live view)
        if body_bounds and pad_bounds:
            outermost_bounds = [
                min(body_bounds[0], pad_bounds[0]),  # min_x
                min(body_bounds[1], pad_bounds[1]),  # min_y  
                max(body_bounds[2], pad_bounds[2]),  # max_x
                max(body_bounds[3], pad_bounds[3])   # max_y
            ]
        elif body_bounds:
            outermost_bounds = body_bounds
        elif pad_bounds:
            outermost_bounds = pad_bounds
        else:
            outermost_bounds = body_bounds

        if outermost_bounds:
            cy_tl = (outermost_bounds[0] - courtyard_expansion, outermost_bounds[3] + courtyard_expansion)
            cy_tr = (outermost_bounds[2] + courtyard_expansion, outermost_bounds[3] + courtyard_expansion)
            cy_br = (outermost_bounds[2] + courtyard_expansion, outermost_bounds[1] - courtyard_expansion)
            cy_bl = (outermost_bounds[0] - courtyard_expansion, outermost_bounds[1] - courtyard_expansion)

            lines.append(f"Line (Width 1.7) (Start {cy_tl[0]*SCALE:.2f}, {cy_tl[1]*SCALE:.2f}) (End {cy_tr[0]*SCALE:.2f}, {cy_tr[1]*SCALE:.2f}) (Layer Mechanical15)")
            lines.append(f"Line (Width 1.7) (Start {cy_tr[0]*SCALE:.2f}, {cy_tr[1]*SCALE:.2f}) (End {cy_br[0]*SCALE:.2f}, {cy_br[1]*SCALE:.2f}) (Layer Mechanical15)")
            lines.append(f"Line (Width 1.7) (Start {cy_br[0]*SCALE:.2f}, {cy_br[1]*SCALE:.2f}) (End {cy_bl[0]*SCALE:.2f}, {cy_bl[1]*SCALE:.2f}) (Layer Mechanical15)")
            lines.append(f"Line (Width 1.7) (Start {cy_bl[0]*SCALE:.2f}, {cy_bl[1]*SCALE:.2f}) (End {cy_tl[0]*SCALE:.2f}, {cy_tl[1]*SCALE:.2f}) (Layer Mechanical15)")

        # Generate pads (using absolute positions)
        for pad in pads:
            pad_type = pad.get('type', 'square')
            name = pad.get('pin_number', '1')
            abs_x, abs_y = resolver.get_absolute_position(pad)  # Use absolute position
            rotation = 0
            expand_mask = pad.get('mask_expansion', 0)
            expand_paste = pad.get('paste_expansion', 0)
            surface = 'True' if pad_type not in ['PTH', 'NPTH', 'PTH_oblong', 'NPTH_oblong'] else 'False'

            if pad_type == 'square':
                size = pad.get('size', 1)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {size*SCALE:.2f}, {size*SCALE:.2f}) (Shape Rectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'rectangle':
                length = pad.get('length', 1)
                width = pad.get('width', 1)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {length*SCALE:.2f}, {width*SCALE:.2f}) (Shape Rectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'rounded_rectangle':
                length = pad.get('length', 1)
                width = pad.get('width', 1)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {length*SCALE:.2f}, {width*SCALE:.2f}) (Shape RoundedRectangular) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'round':
                diameter = pad.get('diameter', 1)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                lines.append(f"PadShape (Size {diameter*SCALE:.2f}, {diameter*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                lines.append("EndPad")

            elif pad_type == 'custom':
                polygon_data = pad.get('polygon_data', {})
                lines_data = polygon_data.get('lines', [])
                point_coords = [(abs_x, abs_y)]
                current_x, current_y = abs_x, abs_y
                
                for ld in lines_data:
                    direction = ld.get('direction', 'right')
                    line_size = ld.get('line_size', 0)
                    if direction == 'right':
                        current_x += line_size
                    elif direction == 'left':
                        current_x -= line_size
                    elif direction == 'up':
                        current_y += line_size
                    elif direction == 'down':
                        current_y -= line_size
                    point_coords.append((current_x, current_y))
                
                lines.append(f"Polygon (PointCount {len(point_coords)}) (Layer TopLayer)")
                for px, py in point_coords:
                    lines.append(f"Point ({px*SCALE:.2f}, {py*SCALE:.2f})")
                lines.append("EndPolygon")

            elif pad_type in ['PTH', 'NPTH']:
                hole_diameter = pad.get('hole_diameter', 0.8)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Slotted False) (HoleSize {hole_diameter*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                
                if pad_type == 'PTH':
                    pad_diameter = pad.get('pad_diameter', 1.2)
                    lines.append(f"PadShape (Size {pad_diameter*SCALE:.2f}, {pad_diameter*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                    lines.append(f"PadShape (Size {pad_diameter*SCALE:.2f}, {pad_diameter*SCALE:.2f}) (Shape Rounded) (Layer Bottom)")
                lines.append("EndPad")

            elif pad_type in ['PTH_oblong', 'NPTH_oblong']:
                hole_length = pad.get('hole_length', 1.5)
                hole_width = pad.get('hole_width', 0.8)
                lines.append(f"Pad (Name \"{name}\") (Location {abs_x*SCALE:.2f}, {abs_y*SCALE:.2f}) (Slotted True) (SlotWidth {hole_width*SCALE:.2f}) (SlotHeight {hole_length*SCALE:.2f}) (Surface {surface}) (Rotation {rotation}) (ExpandMask {expand_mask*SCALE:.2f}) (ExpandPaste {expand_paste*SCALE:.2f})")
                
                if pad_type == 'PTH_oblong':
                    pad_length = pad.get('pad_length', 2.0)
                    pad_width = pad.get('pad_width', 1.2)
                    lines.append(f"PadShape (Size {pad_length*SCALE:.2f}, {pad_width*SCALE:.2f}) (Shape Rounded) (Layer Top)")
                    lines.append(f"PadShape (Size {pad_length*SCALE:.2f}, {pad_width*SCALE:.2f}) (Shape Rounded) (Layer Bottom)")
                lines.append("EndPad")

        lines.append("EndFootprint\nEndFootprints")

        # Join lines and save
        script = '\n'.join(lines)

        output_path = settings.get('script_output_path', os.path.expanduser("~/Documents"))
        footprint_name = data.get('footprint_name', 'Unnamed')
        file_name = os.path.join(output_path, f"{footprint_name}_footprint.txt")
        
        try:
            with open(file_name, "w") as f:
                f.write(script)
            
            # Show dialog
            dialog = QMessageBox(self)
            dialog.setWindowTitle("Generated Footprint Script")
            dialog.setText(f"Generated script saved to:\n{file_name}")
            dialog.setDetailedText(script)
            dialog.setIcon(QMessageBox.Icon.Information)
            dialog.exec()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save script file:\n{str(e)}")


    def add_padstack_row(self):
        row = PadStackRow()
        row.delete_requested.connect(self.delete_padstack_row)
        row.data_changed.connect(self.on_data_changed)
        row.duplicate_btn.clicked.connect(lambda: self.duplicate_padstack_row(row))
        
        self.padstack_rows.append(row)
        self.padstack_layout.insertWidget(len(self.padstack_rows) - 1, row)
        
        # Set pin number automatically
        row.pin_number.setText(str(len(self.padstack_rows)))
        
        # Update all offset_from dropdowns
        self.update_all_offset_dropdowns()

    def delete_padstack_row(self, row):
        if len(self.padstack_rows) > 0:
            self.padstack_rows.remove(row)
            row.setParent(None)
            # Update all remaining offset_from dropdowns
            self.update_all_offset_dropdowns()

    def update_all_offset_dropdowns(self):
        """Update all offset_from dropdowns when pads are added/removed"""
        for row in self.padstack_rows:
            row.update_offset_from_options()

    
    def duplicate_padstack_row(self, original_row):
        new_row = PadStackRow()
        new_row.delete_requested.connect(self.delete_padstack_row)
        new_row.data_changed.connect(self.on_data_changed)
        new_row.duplicate_btn.clicked.connect(lambda: self.duplicate_padstack_row(new_row))
        
        # Copy data from original
        data = original_row.get_data()
        data['pin_number'] = str(len(self.padstack_rows) + 1)
        
        # Add to layout FIRST so update_offset_from_options can find all rows
        self.padstack_rows.append(new_row)
        self.padstack_layout.insertWidget(len(self.padstack_rows) - 1, new_row)
        
        # Update all dropdowns to include the new pin numbers
        self.update_all_offset_dropdowns()
        
        # NOW set the data - the dropdown will have the correct options
        new_row.set_data(data)

    
    def on_data_changed(self):
        # This will be handled by the update thread
        pass
    
    def get_footprint_data(self):
        settings = self.settings_panel.get_settings()
        
        data = {
            'part_number': self.part_number.text(),
            'footprint_name': self.footprint_name.text(),
            'body_length': self.body_length.value(),
            'body_width': self.body_width.value(),
            'body_height': self.body_height.value(),
            'body_shape': self.body_shape_combobox.currentText(),
            'courtyard_expansion': settings['courtyard_expansion'],  # From settings panel
            'silkscreen_airgap': settings['silkscreen_airgap'],      # From settings panel
            'silkscreen_enabled': self.silkscreen_enabled.isChecked(),
            'padstacks': [row.get_data() for row in self.padstack_rows],
            # Add new settings
            'body_line_width': settings['body_line_width'],
            'courtyard_line_width': settings['courtyard_line_width'],
            'silkscreen_line_width': settings['silkscreen_line_width'],
            'script_output_path': settings['script_output_path']
        }
        return data



    def set_footprint_data(self, data):
        self.part_number.setText(data.get('part_number', ''))
        self.footprint_name.setText(data.get('footprint_name', ''))
        self.body_length.setValue(data.get('body_length', 5.0))
        self.body_width.setValue(data.get('body_width', 3.0))
        self.body_height.setValue(data.get('body_height', 1.0))
        self.body_shape_combobox.setCurrentText(data.get('body_shape', 'rectangle'))
        self.silkscreen_enabled.setChecked(data.get('silkscreen_enabled', True))

        # FIXED: Update settings panel instead of direct attributes
        settings = {
            'body_line_width': data.get('body_line_width', 1.5),
            'courtyard_expansion': data.get('courtyard_expansion', 0.25),
            'courtyard_line_width': data.get('courtyard_line_width', 0.1),
            'silkscreen_airgap': data.get('silkscreen_airgap', 0.15),
            'silkscreen_line_width': data.get('silkscreen_line_width', 0.15),
            'script_output_path': data.get('script_output_path', os.path.expanduser("~/Documents")),
            'current_user': data.get('current_user', None)
        }
        self.settings_panel.set_settings(settings)

        # Clear existing padstacks
        for row in self.padstack_rows[:]:
            self.delete_padstack_row(row)

        # Add padstacks from data
        for pad_data in data.get('padstacks', []):
            self.add_padstack_row()
            self.padstack_rows[-1].set_data(pad_data)


    
    def save_data(self):
        """Save footprint data - prompts for filename only if not previously saved"""
        if self.current_save_file is None:
            # No file currently open, act like "Save As"
            self.save_data_as() 
        else:
            # File already exists, just update it
            data = self.get_footprint_data()
            success = LibSiennaFileFormat.save_footprint(data, self.current_save_file)
            
            if success:
                QMessageBox.information(
                    self, 
                    "Success", 
                    f"Footprint updated successfully!\n{os.path.basename(self.current_save_file)}"
                )
            else:
                QMessageBox.critical(self, "Error", "Failed to save footprint file!")


    def load_data(self):
        """Load footprint data from custom LibSienna format"""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "Load Footprint",
            "",
            "LibSienna Footprint Files (*.LibSienna);;All Files (*)"
        )
        
        if filename:
            data = LibSiennaFileFormat.load_footprint(filename)
            if data:
                self.set_footprint_data(data)
                # IMPORTANT: Set current file path so Save will work
                self.current_save_file = filename
                QMessageBox.information(
                    self, 
                    "Success", 
                    f"Footprint loaded successfully from {os.path.basename(filename)}!"
                )
            else:
                QMessageBox.critical(self, "Error", "Failed to load footprint file!")
        
    def fit_to_view(self):
        self.renderer.auto_fit = True
        self.renderer.fit_to_view()
        self.renderer.update()
    
    def start_update_thread(self):
        self.update_thread = UpdateThread(self)
        self.update_thread.update_signal.connect(self.renderer.update_footprint)
        self.update_thread.start()
    
    def closeEvent(self, event):    
        if hasattr(self, 'update_thread'):
            self.update_thread.stop()
            self.update_thread.wait()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    
    # Set application-wide dark theme
    app.setStyle('Fusion')
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(43, 43, 43))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Base, QColor(60, 60, 60))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(80, 80, 80))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Text, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Button, QColor(74, 74, 74))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 0, 0))
    palette.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(0, 0, 0))
    app.setPalette(palette)
    
    window = FootprintDesigner()
    window.show()
    
    sys.exit(app.exec())
