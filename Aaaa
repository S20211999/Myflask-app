def calculate_price(self):
    """Calculate total project price with quantity"""
    try:
        # Validate inputs including quantity
        if not all([
            self.customer_input.text().strip(),
            self.job_input.text().strip(),
            self.pcb_part_input.text().strip(),
            self.quantity_input.text().strip(),
            self.length_input.text(),
            self.width_input.text()
        ]):
            QMessageBox.warning(self, "Input Error", "Please fill all required fields including quantity!")
            return

        # Get input values
        customer_name = self.customer_input.text().strip()
        job_number = self.job_input.text().strip()
        pcb_part_number = self.pcb_part_input.text().strip()
        unit = self.unit_combo.currentText()
        
        try:
            quantity = int(self.quantity_input.text())
            length = float(self.length_input.text())
            width = float(self.width_input.text())
            
            if quantity <= 0:
                QMessageBox.warning(self, "Input Error", "Quantity must be greater than 0!")
                return
                
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Please enter valid numbers for quantity, length, and width.")
            return

        # Sequential filtering logic (same as before)
        print("=== SEQUENTIAL FILTERING WITH QUANTITY ===")
        
        base_query = '''
            SELECT Quantity, Length, Width, PricePerUnit, TotalCostINR, FabricatorName, 
                   Layers, material, BoardThickness, CuInner, CuOuter, SurfaceFinish,
                   Impedance, Soldermask, Silkscreen, back_drill, blind_via, berried_via
            FROM pcb_data
            WHERE PricePerUnit IS NOT NULL 
            AND PricePerUnit != '' 
            AND Length > 0 
            AND Width > 0
        '''
        
        self.parent.cursor.execute(base_query)
        current_records = self.parent.cursor.fetchall()
        print(f"Step 0 - Initial records: {len(current_records)}")
        
        # Apply sequential filters (same logic as before)
        filter_sequence = [
            "Layers", "material", "BoardThickness", "CuInner", "CuOuter",
            "SurfaceFinish", "Impedance", "Soldermask", "Silkscreen", 
            "back_drill", "blind_via", "berried_via"
        ]
        
        applied_filters = []
        step = 1
        
        for field in filter_sequence:
            if field in self.filter_combos:
                selected_value = self.filter_combos[field].currentText().strip()
                
                if selected_value and selected_value != "Any":
                    print(f"Step {step} - Applying {field} = '{selected_value}'")
                    
                    filtered_records = []
                    field_index = self.get_field_index(field)
                    
                    for record in current_records:
                        if str(record[field_index]).strip() == selected_value:
                            filtered_records.append(record)
                    
                    current_records = filtered_records
                    applied_filters.append(f"{field}: {selected_value}")
                    
                    print(f"   After {field} filter: {len(current_records)} records remaining")
                    
                    if not current_records:
                        print(f"   No records match {field} = '{selected_value}'. Stopping filter sequence.")
                        break
                    
                    step += 1
        
        print(f"=== FINAL RESULTS: {len(current_records)} records ===")
        
        if not current_records:
            filter_msg = "Sequential Filters Applied:\n" + "\n".join(f"{i+1}. {f}" for i, f in enumerate(applied_filters))
            QMessageBox.information(self, "No Records Found", 
                                  f"No records found after sequential filtering:\n\n{filter_msg}\n\nTry relaxing some filter criteria.")
            return

        # Sort by price (highest first)
        try:
            current_records.sort(key=lambda x: float(str(x[3]).replace('$', '').replace('₹', '').replace(',', '').strip()), reverse=True)
        except:
            pass
        
        # Use the best record
        best_match = current_records[0]
        (ref_qty, ref_length, ref_width, ref_price_per_unit_str, ref_total_cost, ref_fabricator,
         ref_layers, ref_material, ref_thickness, ref_cu_inner, ref_cu_outer, ref_surface_finish,
         ref_impedance, ref_soldermask, ref_silkscreen, ref_back_drill, ref_blind_via, ref_buried_via) = best_match
        
        # Convert price to number
        try:
            clean_price = str(ref_price_per_unit_str).replace('$', '').replace('₹', '').replace(',', '').strip()
            ref_price_per_unit = float(clean_price)
        except (ValueError, TypeError):
            QMessageBox.warning(self, "Data Error", f"Invalid price format: {ref_price_per_unit_str}")
            return

        # Calculate pricing WITH QUANTITY
        ref_area = float(ref_length) * float(ref_width)
        if ref_area <= 0:
            QMessageBox.warning(self, "Data Error", "Invalid PCB dimensions in reference data.")
            return
            
        price_per_sq_unit = ref_price_per_unit / ref_area
        input_area = length * width
        per_unit_price = price_per_sq_unit * input_area
        
        # CALCULATE TOTAL PROJECT PRICE
        total_project_price = per_unit_price * quantity

        # Create reference specs
        reference_specs = {
            'Fabricator': ref_fabricator,
            'Layers': ref_layers,
            'Material': ref_material,
            'Board Thickness': f"{ref_thickness} mil" if ref_thickness else "N/A",
            'Cu Inner': ref_cu_inner or "N/A",
            'Cu Outer': ref_cu_outer or "N/A",
            'Surface Finish': ref_surface_finish or "N/A",
            'Impedance': ref_impedance or "N/A",
            'Soldermask': ref_soldermask or "N/A",
            'Silkscreen': ref_silkscreen or "N/A",
            'Back Drill': ref_back_drill or "N/A",
            'Blind Via': ref_blind_via or "N/A",
            'Buried Via': ref_buried_via or "N/A"
        }

        # Display results with quantity
        self.populate_project_results(
            customer_name, job_number, pcb_part_number, unit, quantity,
            length, width, input_area, ref_length, ref_width,
            ref_price_per_unit, price_per_sq_unit, per_unit_price, total_project_price,
            reference_specs, applied_filters, len(current_records)
        )

        print(f"SUCCESS: Per unit price: ₹{per_unit_price:.2f}, Total project price: ₹{total_project_price:.2f}")

    except Exception as e:
        print(f"ERROR: {e}")
        QMessageBox.critical(self, "Error", f"Calculation failed: {str(e)}")
