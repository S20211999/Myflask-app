def calculate_price(self):
    """Calculate PCB price with sequential cascading filters"""
    try:
        # Validate inputs
        if not all([
            self.customer_input.text().strip(),
            self.job_input.text().strip(),
            self.pcb_part_input.text().strip(),
            self.length_input.text(),
            self.width_input.text()
        ]):
            QMessageBox.warning(self, "Input Error", "Please fill all required fields!")
            return

        # Get input values
        customer_name = self.customer_input.text().strip()
        job_number = self.job_input.text().strip()
        pcb_part_number = self.pcb_part_input.text().strip()
        unit = self.unit_combo.currentText()
        
        try:
            length = float(self.length_input.text())
            width = float(self.width_input.text())
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Length and Width must be numeric.")
            return

        # SEQUENTIAL FILTERING - Apply filters in order, each one shortlisting from previous results
        
        # Start with all valid records
        print("=== SEQUENTIAL FILTERING START ===")
        
        base_query = '''
            SELECT Quantity, Length, Width, PricePerUnit, TotalCostINR, FabricatorName, 
                   Layers, material, BoardThickness, CuInner, CuOuter, SurfaceFinish,
                   Impedance, Soldermask, Silkscreen, back_drill, blind_via, berried_via
            FROM pcb_data
            WHERE PricePerUnit IS NOT NULL 
            AND PricePerUnit != '' 
            AND Length > 0 
            AND Width > 0
        '''
        
        self.parent.cursor.execute(base_query)
        current_records = self.parent.cursor.fetchall()
        print(f"Step 0 - Initial records: {len(current_records)}")
        
        # Define filter sequence - EXACT ORDER as you specified
        filter_sequence = [
            "Layers", "material", "BoardThickness", "CuInner", "CuOuter",
            "SurfaceFinish", "Impedance", "Soldermask", "Silkscreen", 
            "back_drill", "blind_via", "berried_via"
        ]
        
        applied_filters = []
        step = 1
        
        # Apply each filter sequentially
        for field in filter_sequence:
            if field in self.filter_combos:
                selected_value = self.filter_combos[field].currentText().strip()
                
                if selected_value and selected_value != "Any":
                    print(f"Step {step} - Applying {field} = '{selected_value}'")
                    
                    # Filter current records by this field
                    filtered_records = []
                    field_index = self.get_field_index(field)
                    
                    for record in current_records:
                        if str(record[field_index]).strip() == selected_value:
                            filtered_records.append(record)
                    
                    current_records = filtered_records
                    applied_filters.append(f"{field}: {selected_value}")
                    
                    print(f"   After {field} filter: {len(current_records)} records remaining")
                    
                    # If no records left, stop filtering
                    if not current_records:
                        print(f"   No records match {field} = '{selected_value}'. Stopping filter sequence.")
                        break
                    
                    step += 1
        
        print(f"=== FINAL RESULTS: {len(current_records)} records ===")
        
        if not current_records:
            filter_msg = "Sequential Filters Applied:\n" + "\n".join(f"{i+1}. {f}" for i, f in enumerate(applied_filters))
            QMessageBox.information(self, "No Records Found", 
                                  f"No records found after sequential filtering:\n\n{filter_msg}\n\nTry relaxing some filter criteria.")
            return

        # Sort remaining records by price (highest first)
        try:
            current_records.sort(key=lambda x: float(str(x[3]).replace('$', '').replace('₹', '').replace(',', '').strip()), reverse=True)
        except:
            pass  # Keep original order if sorting fails
        
        # Use the best record
        best_match = current_records[0]
        (ref_qty, ref_length, ref_width, ref_price_per_unit_str, ref_total_cost, ref_fabricator,
         ref_layers, ref_material, ref_thickness, ref_cu_inner, ref_cu_outer, ref_surface_finish,
         ref_impedance, ref_soldermask, ref_silkscreen, ref_back_drill, ref_blind_via, ref_buried_via) = best_match
        
        # Convert price to number
        try:
            clean_price = str(ref_price_per_unit_str).replace('$', '').replace('₹', '').replace(',', '').strip()
            ref_price_per_unit = float(clean_price)
        except (ValueError, TypeError):
            QMessageBox.warning(self, "Data Error", f"Invalid price format: {ref_price_per_unit_str}")
            return

        # Calculate pricing
        ref_area = float(ref_length) * float(ref_width)
        if ref_area <= 0:
            QMessageBox.warning(self, "Data Error", "Invalid PCB dimensions in reference data.")
            return
            
        price_per_sq_unit = ref_price_per_unit / ref_area
        input_area = length * width
        per_unit_price = price_per_sq_unit * input_area

        # Create reference specs
        reference_specs = {
            'Fabricator': ref_fabricator,
            'Layers': ref_layers,
            'Material': ref_material,
            'Board Thickness': f"{ref_thickness} mil" if ref_thickness else "N/A",
            'Cu Inner': ref_cu_inner or "N/A",
            'Cu Outer': ref_cu_outer or "N/A",
            'Surface Finish': ref_surface_finish or "N/A",
            'Impedance': ref_impedance or "N/A",
            'Soldermask': ref_soldermask or "N/A",
            'Silkscreen': ref_silkscreen or "N/A",
            'Back Drill': ref_back_drill or "N/A",
            'Blind Via': ref_blind_via or "N/A",
            'Buried Via': ref_buried_via or "N/A"
        }

        # Display results
        self.populate_sequential_results(
            customer_name, job_number, pcb_part_number, unit,
            length, width, input_area, ref_length, ref_width,
            ref_price_per_unit, price_per_sq_unit, per_unit_price,
            reference_specs, applied_filters, len(current_records)
        )

        print(f"SUCCESS: Sequential filtering complete. Final price: ₹{per_unit_price:.2f}")

    except Exception as e:
        print(f"ERROR: {e}")
        QMessageBox.critical(self, "Error", f"Sequential filtering failed: {str(e)}")

def get_field_index(self, field_name):
    """Get the index position of field in the query results"""
    # Based on the SELECT query order:
    # 0=Quantity, 1=Length, 2=Width, 3=PricePerUnit, 4=TotalCostINR, 5=FabricatorName, 
    # 6=Layers, 7=material, 8=BoardThickness, 9=CuInner, 10=CuOuter, 11=SurfaceFinish,
    # 12=Impedance, 13=Soldermask, 14=Silkscreen, 15=back_drill, 16=blind_via, 17=berried_via
    
    field_indices = {
        "Layers": 6,
        "material": 7,
        "BoardThickness": 8,
        "CuInner": 9,
        "CuOuter": 10,
        "SurfaceFinish": 11,
        "Impedance": 12,
        "Soldermask": 13,
        "Silkscreen": 14,
        "back_drill": 15,
        "blind_via": 16,
        "berried_via": 17
    }
    
    return field_indices.get(field_name, 0)

def populate_sequential_results(self, customer_name, job_number, pcb_part_number, unit,
                               length, width, input_area, ref_length, ref_width,
                               ref_price_per_unit, price_per_sq_unit, per_unit_price,
                               reference_specs, applied_filters, final_count):
    """Display results from sequential filtering"""
    
    rows = [
        ("PCB Fabrication Cost Tool", "", "header"),
        ("", "", "spacer"),
        ("Customer Information", "", "section"),
        ("Customer Name", customer_name, "data"),
        ("Job Number", job_number, "data"),
        ("PCB Part Number", pcb_part_number, "data"),
        ("", "", "spacer"),
        ("Your PCB Specifications", "", "section"),
        ("Unit", unit, "data"),
        ("Length", f"{length} {unit}", "data"),
        ("Width", f"{width} {unit}", "data"),
        ("Area", f"{input_area:.2f} {unit}²", "data"),
    ]
    
    # Show sequential filter steps
    if applied_filters:
        rows.extend([
            ("", "", "spacer"),
            ("SEQUENTIAL FILTERS APPLIED", "", "section"),
            ("Final Records Found", f"{final_count} matches", "data"),
            ("", "", "spacer"),
            ("Filter Sequence Applied:", "", "section")
        ])
        
        for i, filter_info in enumerate(applied_filters, 1):
            rows.append((f"Step {i}", filter_info, "data"))
    else:
        rows.extend([
            ("", "", "spacer"),
            ("No Filters Applied", "All records considered", "section")
        ])
    
    # Show best match details
    rows.extend([
        ("", "", "spacer"),
        ("BEST MATCH FROM SHORTLIST", "", "section")
    ])
    
    for spec_name, spec_value in reference_specs.items():
        rows.append((spec_name, str(spec_value), "data"))
        
    rows.extend([
        ("Reference Size", f"{ref_length} × {ref_width} {unit}", "data"),
        ("Reference Price/Unit", f"₹{ref_price_per_unit:.2f}", "data"),
        ("", "", "spacer"),
        ("CALCULATED PRICING", "", "section"),
        ("Price per Sq Unit", f"₹{price_per_sq_unit:.4f}", "calculation"),
        ("Your PCB Price", f"₹{per_unit_price:.2f}", "calculation"),
        ("Final Cost per Piece", f"₹{per_unit_price:.2f}", "calculation")
    ])

    # Populate table
    self.results_table.setRowCount(len(rows))
    
    for row_idx, (param, value, row_type) in enumerate(rows):
        param_item = QTableWidgetItem(param)
        value_item = QTableWidgetItem(value)
        
        if row_type == "header":
            param_item.setBackground(QColor(68, 114, 196))
            param_item.setForeground(QColor(255, 255, 255))
            value_item.setBackground(QColor(68, 114, 196))
            value_item.setForeground(QColor(255, 255, 255))
            font = QFont()
            font.setBold(True)
            font.setPointSize(14)
            param_item.setFont(font)
            
        elif row_type == "section":
            param_item.setBackground(QColor(213, 228, 247))
            value_item.setBackground(QColor(213, 228, 247))
            font = QFont()
            font.setBold(True)
            param_item.setFont(font)
            value_item.setFont(font)
            
        elif row_type == "calculation":
            param_item.setBackground(QColor(226, 239, 218))
            value_item.setBackground(QColor(226, 239, 218))
            font = QFont()
            font.setBold(True)
            param_item.setFont(font)
            value_item.setFont(font)
            
        elif row_type == "data":
            param_item.setBackground(QColor(242, 242, 242))
            value_item.setBackground(QColor(255, 255, 255))

        self.results_table.setItem(row_idx, 0, param_item)
        self.results_table.setItem(row_idx, 1, value_item)

    self.results_table.resizeColumnsToContents()
    self.results_table.resizeRowsToContents()
