package main

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"database/sql"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"io"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"
	
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"golang.org/x/crypto/bcrypt"
	"gopkg.in/gomail.v2"
)

// ============================================
// DATABASE CONNECTION
// ============================================
var (
	db     *pgxpool.Pool
	dbOnce sync.Once
	dbMux  sync.RWMutex
)

type DBConfig struct {
	Host     string `json:"host"`
	Port     int    `json:"port"`
	User     string `json:"user"`
	Password string `json:"password"`
	DBName   string `json:"dbname"`
	MaxConns int32  `json:"max_conns"`
	MinConns int32  `json:"min_conns"`
}

// User levels
const (
	LevelEngineer = "engineer"
	LevelManager  = "manager"
	LevelGM       = "gm"
	LevelAdmin    = "admin"
)

// ============================================
// MODELS
// ============================================

type User struct {
	ID           string    `json:"id"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	Password     string    `json:"-"`
	PasswordHash string    `json:"-"`
	Level        string    `json:"level"`
	AssignedApps []string  `json:"assigned_apps"`
	CreatedAt    time.Time `json:"created_at"`
}

type App struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	URL         string    `json:"url"`
	Icon        string    `json:"icon"`
	Description string    `json:"description"`
	Password    string    `json:"-"`
	CreatedAt   time.Time `json:"created_at"`
}

type Session struct {
	Token      string    `json:"token"`
	Username   string    `json:"username"`
	ExpiresAt  time.Time `json:"expires_at"`
	RememberMe bool      `json:"remember_me"`
}

// Component - Shared table accessible by all apps
type Component struct {
	ID          int64                  `json:"id"`
	Name        string                 `json:"name"`
	Category    string                 `json:"category"`
	Description string                 `json:"description"`
	Datasheet   string                 `json:"datasheet"`
	Metadata    map[string]interface{} `json:"metadata"`
	CreatedBy   string                 `json:"created_by"`
	CreatedAt   time.Time              `json:"created_at"`
	UpdatedAt   time.Time              `json:"updated_at"`
}

// AppData - Data sent by external apps
type AppData struct {
	AppName   string                 `json:"app_name"`
	TableName string                 `json:"table_name"`
	Data      map[string]interface{} `json:"data"`
	Timestamp time.Time              `json:"timestamp"`
}

type EmailConfig struct {
	SMTPHost string
	SMTPPort int
	From     string
	Password string
}

type SMTPSettings struct {
	ID           int       `json:"id"`
	SMTPHost     string    `json:"smtp_host"`
	SMTPPort     int       `json:"smtp_port"`
	SMTPFrom     string    `json:"smtp_from"`
	SMTPPassword string    `json:"smtp_password"`
	SMTPEncryption string  `json:"smtp_encryption"`
	SMTPEnabled  bool      `json:"smtp_enabled"`
	UpdatedAt    time.Time `json:"updated_at"`
}

var emailConfig = EmailConfig{
	SMTPHost: os.Getenv("SMTP_HOST"),
	SMTPPort: 587,
	From:     os.Getenv("SMTP_FROM"),
	Password: os.Getenv("SMTP_PASSWORD"),
}

// ============================================
// DATABASE INITIALIZATION
// ============================================

func initDB(config DBConfig) error {
	var err error

	connString := fmt.Sprintf(
		"postgres://%s:%s@%s:%d/%s?sslmode=disable",
		config.User, config.Password, config.Host, config.Port, config.DBName,
	)

	poolConfig, err := pgxpool.ParseConfig(connString)
	if err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}

	poolConfig.MaxConns = config.MaxConns
	poolConfig.MinConns = config.MinConns
	poolConfig.MaxConnLifetime = time.Hour
	poolConfig.MaxConnIdleTime = 30 * time.Minute

	dbMux.Lock()
	defer dbMux.Unlock()

	if db != nil {
		db.Close()
	}

	db, err = pgxpool.NewWithConfig(context.Background(), poolConfig)
	if err != nil {
		return fmt.Errorf("failed to create pool: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err = db.Ping(ctx); err != nil {
		return fmt.Errorf("failed to ping database: %w", err)
	}

	// Create tables
	if err := createTables(ctx); err != nil {
		return fmt.Errorf("failed to create tables: %w", err)
	}

	log.Println("PostgreSQL connected successfully")
	return nil
}

func createTables(ctx context.Context) error {
	schema := `
	-- Users table
	CREATE TABLE IF NOT EXISTS users (
		id VARCHAR(50) PRIMARY KEY,
		username VARCHAR(100) UNIQUE NOT NULL,
		email VARCHAR(255) NOT NULL,
		password_hash VARCHAR(255) NOT NULL,
		level VARCHAR(20) NOT NULL,
		assigned_apps TEXT[],
		created_at TIMESTAMP DEFAULT NOW()
	);

	-- Apps table
	CREATE TABLE IF NOT EXISTS apps (
		id VARCHAR(50) PRIMARY KEY,
		name VARCHAR(255) NOT NULL,
		url VARCHAR(500) NOT NULL,
		icon TEXT,
		description TEXT,
		password_hash VARCHAR(255) NOT NULL,
		created_at TIMESTAMP DEFAULT NOW()
	);

	-- SMTP Settings table
	CREATE TABLE IF NOT EXISTS smtp_settings (
		id SERIAL PRIMARY KEY,
		smtp_host VARCHAR(255) NOT NULL,
		smtp_port INTEGER NOT NULL DEFAULT 587,
		smtp_from VARCHAR(255) NOT NULL,
		smtp_password VARCHAR(255) NOT NULL,
		smtp_encryption VARCHAR(20) DEFAULT 'tls',
		smtp_enabled BOOLEAN DEFAULT TRUE,
		updated_at TIMESTAMP DEFAULT NOW()
	);

	-- Sessions table
	CREATE TABLE IF NOT EXISTS sessions (
		token VARCHAR(255) PRIMARY KEY,
		username VARCHAR(100) NOT NULL,
		expires_at TIMESTAMP NOT NULL,
		remember_me BOOLEAN DEFAULT FALSE,
		created_at TIMESTAMP DEFAULT NOW()
	);

	-- Components table (shared across all apps)
    -- =====================================================
    -- COMPREHENSIVE COMPONENTS TABLE
    -- =====================================================
    CREATE TABLE IF NOT EXISTS components (
        -- Identification & Classification
        component_id SERIAL PRIMARY KEY,
        component_name VARCHAR(255) NOT NULL,
        component_code VARCHAR(100) UNIQUE,
        component_type VARCHAR(50),
        component_subtype VARCHAR(50),
        manufacturer VARCHAR(100),
        manufacturer_part_number VARCHAR(100),
        description TEXT,
        tags VARCHAR(500),
        
        -- Physical Specifications
        package_type VARCHAR(50),
        dimensions_length DECIMAL(10,3),
        dimensions_width DECIMAL(10,3),
        dimensions_height DECIMAL(10,3),
        weight DECIMAL(10,4),
        mounting_type VARCHAR(30),
        pin_count INT,
        footprint VARCHAR(100),
        
        -- Electrical Specifications
        voltage_rating VARCHAR(50),
        current_rating VARCHAR(50),
        power_rating VARCHAR(50),
        tolerance VARCHAR(20),
        temperature_coefficient VARCHAR(50),
        operating_temp_min DECIMAL(6,2),
        operating_temp_max DECIMAL(6,2),
        
        -- Component-Specific Values
        resistance_value VARCHAR(50),
        capacitance_value VARCHAR(50),
        inductance_value VARCHAR(50),
        frequency VARCHAR(50),
        data_value VARCHAR(255),
        
        -- Inventory
        quantity_in_stock INT DEFAULT 0,
        
        -- Lifecycle & Status
        lifecycle_status VARCHAR(30) DEFAULT 'active',
        is_active BOOLEAN DEFAULT TRUE,
        is_rohs_compliant BOOLEAN DEFAULT FALSE,
        is_reach_compliant BOOLEAN DEFAULT FALSE,
        eol_date DATE,
        replacement_component_id INT,
        
        -- Documentation & Links
        datasheet_url VARCHAR(500),
        specification_url VARCHAR(500),
        cad_model_url VARCHAR(500),
        image_url VARCHAR(500),
        notes TEXT,
        
        -- Quality & Testing
        quality_grade VARCHAR(30),
        test_required BOOLEAN DEFAULT FALSE,
        inspection_level VARCHAR(20),
        failure_rate DECIMAL(8,4),
        mtbf INT,
        
        -- Timestamps & Audit
        created_at TIMESTAMP DEFAULT NOW(),
        created_by VARCHAR(100),
        updated_at TIMESTAMP DEFAULT NOW(),
        updated_by VARCHAR(100),
        deleted_at TIMESTAMP NULL,
        
        FOREIGN KEY (replacement_component_id) REFERENCES components(component_id)
    );
    
    -- =====================================================
    -- SUPPLIER PRICING TABLES
    -- =====================================================
    
    -- Digikey Pricing
    CREATE TABLE IF NOT EXISTS supplier_digikey (
        pricing_id SERIAL PRIMARY KEY,
        component_id INT NOT NULL,
        supplier_part_number VARCHAR(100),
        
        price_tier_1_qty INT,
        price_tier_1_price DECIMAL(10,4),
        price_tier_2_qty INT,
        price_tier_2_price DECIMAL(10,4),
        price_tier_3_qty INT,
        price_tier_3_price DECIMAL(10,4),
        price_tier_4_qty INT,
        price_tier_4_price DECIMAL(10,4),
        price_tier_5_qty INT,
        price_tier_5_price DECIMAL(10,4),
        price_tier_6_qty INT,
        price_tier_6_price DECIMAL(10,4),
        price_tier_7_qty INT,
        price_tier_7_price DECIMAL(10,4),
        price_tier_8_qty INT,
        price_tier_8_price DECIMAL(10,4),
        
        currency VARCHAR(3) DEFAULT 'USD',
        stock_available INT,
        lead_time_days INT,
        moq INT DEFAULT 1,
        product_url VARCHAR(500),
        last_updated TIMESTAMP DEFAULT NOW(),
        is_active BOOLEAN DEFAULT TRUE,
        
        FOREIGN KEY (component_id) REFERENCES components(component_id) ON DELETE CASCADE
    );
    
    -- Mouser Electronics Pricing
    CREATE TABLE IF NOT EXISTS supplier_mouser (
        pricing_id SERIAL PRIMARY KEY,
        component_id INT NOT NULL,
        supplier_part_number VARCHAR(100),
        
        price_tier_1_qty INT,
        price_tier_1_price DECIMAL(10,4),
        price_tier_2_qty INT,
        price_tier_2_price DECIMAL(10,4),
        price_tier_3_qty INT,
        price_tier_3_price DECIMAL(10,4),
        price_tier_4_qty INT,
        price_tier_4_price DECIMAL(10,4),
        price_tier_5_qty INT,
        price_tier_5_price DECIMAL(10,4),
        price_tier_6_qty INT,
        price_tier_6_price DECIMAL(10,4),
        price_tier_7_qty INT,
        price_tier_7_price DECIMAL(10,4),
        price_tier_8_qty INT,
        price_tier_8_price DECIMAL(10,4),
        
        currency VARCHAR(3) DEFAULT 'USD',
        stock_available INT,
        lead_time_days INT,
        moq INT DEFAULT 1,
        product_url VARCHAR(500),
        last_updated TIMESTAMP DEFAULT NOW(),
        is_active BOOLEAN DEFAULT TRUE,
        
        FOREIGN KEY (component_id) REFERENCES components(component_id) ON DELETE CASCADE
    );
    
    -- Arrow Electronics Pricing
    CREATE TABLE IF NOT EXISTS supplier_arrow (
        pricing_id SERIAL PRIMARY KEY,
        component_id INT NOT NULL,
        supplier_part_number VARCHAR(100),
        
        price_tier_1_qty INT,
        price_tier_1_price DECIMAL(10,4),
        price_tier_2_qty INT,
        price_tier_2_price DECIMAL(10,4),
        price_tier_3_qty INT,
        price_tier_3_price DECIMAL(10,4),
        price_tier_4_qty INT,
        price_tier_4_price DECIMAL(10,4),
        price_tier_5_qty INT,
        price_tier_5_price DECIMAL(10,4),
        price_tier_6_qty INT,
        price_tier_6_price DECIMAL(10,4),
        price_tier_7_qty INT,
        price_tier_7_price DECIMAL(10,4),
        price_tier_8_qty INT,
        price_tier_8_price DECIMAL(10,4),
        
        currency VARCHAR(3) DEFAULT 'USD',
        stock_available INT,
        lead_time_days INT,
        moq INT DEFAULT 1,
        product_url VARCHAR(500),
        last_updated TIMESTAMP DEFAULT NOW(),
        is_active BOOLEAN DEFAULT TRUE,
        
        FOREIGN KEY (component_id) REFERENCES components(component_id) ON DELETE CASCADE
    );
    
    -- Avnet Pricing
    CREATE TABLE IF NOT EXISTS supplier_avnet (
        pricing_id SERIAL PRIMARY KEY,
        component_id INT NOT NULL,
        supplier_part_number VARCHAR(100),
        
        price_tier_1_qty INT,
        price_tier_1_price DECIMAL(10,4),
        price_tier_2_qty INT,
        price_tier_2_price DECIMAL(10,4),
        price_tier_3_qty INT,
        price_tier_3_price DECIMAL(10,4),
        price_tier_4_qty INT,
        price_tier_4_price DECIMAL(10,4),
        price_tier_5_qty INT,
        price_tier_5_price DECIMAL(10,4),
        price_tier_6_qty INT,
        price_tier_6_price DECIMAL(10,4),
        price_tier_7_qty INT,
        price_tier_7_price DECIMAL(10,4),
        price_tier_8_qty INT,
        price_tier_8_price DECIMAL(10,4),
        
        currency VARCHAR(3) DEFAULT 'USD',
        stock_available INT,
        lead_time_days INT,
        moq INT DEFAULT 1,
        product_url VARCHAR(500),
        last_updated TIMESTAMP DEFAULT NOW(),
        is_active BOOLEAN DEFAULT TRUE,
        
        FOREIGN KEY (component_id) REFERENCES components(component_id) ON DELETE CASCADE
    );
    
    -- element14 Pricing
    CREATE TABLE IF NOT EXISTS supplier_element14 (
        pricing_id SERIAL PRIMARY KEY,
        component_id INT NOT NULL,
        supplier_part_number VARCHAR(100),
        
        price_tier_1_qty INT,
        price_tier_1_price DECIMAL(10,4),
        price_tier_2_qty INT,
        price_tier_2_price DECIMAL(10,4),
        price_tier_3_qty INT,
        price_tier_3_price DECIMAL(10,4),
        price_tier_4_qty INT,
        price_tier_4_price DECIMAL(10,4),
        price_tier_5_qty INT,
        price_tier_5_price DECIMAL(10,4),
        price_tier_6_qty INT,
        price_tier_6_price DECIMAL(10,4),
        price_tier_7_qty INT,
        price_tier_7_price DECIMAL(10,4),
        price_tier_8_qty INT,
        price_tier_8_price DECIMAL(10,4),
        
        currency VARCHAR(3) DEFAULT 'USD',
        stock_available INT,
        lead_time_days INT,
        moq INT DEFAULT 1,
        product_url VARCHAR(500),
        last_updated TIMESTAMP DEFAULT NOW(),
        is_active BOOLEAN DEFAULT TRUE,
        
        FOREIGN KEY (component_id) REFERENCES components(component_id) ON DELETE CASCADE
    );
    
    -- =====================================================
    -- REVISION CONTROL TABLE
    -- =====================================================
    CREATE TABLE IF NOT EXISTS component_revisions (
        revision_id SERIAL PRIMARY KEY,
        component_id INT NOT NULL,
        revision_number INT NOT NULL,
        data_value VARCHAR(255),
        revision_reason TEXT,
        change_summary TEXT,
        revised_by VARCHAR(100),
        is_current_revision BOOLEAN DEFAULT FALSE,
        is_deleted BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT NOW(),
        
        FOREIGN KEY (component_id) REFERENCES components(component_id) ON DELETE CASCADE,
        UNIQUE (component_id, revision_number)
    );


	-- Database settings table
	CREATE TABLE IF NOT EXISTS db_settings (
		id SERIAL PRIMARY KEY,
		host VARCHAR(255) NOT NULL,
		port INTEGER NOT NULL DEFAULT 5432,
		username VARCHAR(100) NOT NULL,
		password VARCHAR(255) NOT NULL,
		dbname VARCHAR(100) NOT NULL,
		max_conns INTEGER DEFAULT 25,
		min_conns INTEGER DEFAULT 5,
		is_active BOOLEAN DEFAULT TRUE,
		updated_at TIMESTAMP DEFAULT NOW()
	);

	-- Table registry (tracks dynamically created tables)
	CREATE TABLE IF NOT EXISTS table_registry (
		id SERIAL PRIMARY KEY,
		app_name VARCHAR(100) NOT NULL,
		table_name VARCHAR(100) NOT NULL,
		full_table_name VARCHAR(200) NOT NULL,
		column_schema JSONB,
		created_at TIMESTAMP DEFAULT NOW(),
		UNIQUE(app_name, table_name)
	);

	-- =====================================================
	-- SHARED DATABASE CONFIGURATION (No dependencies)
	-- =====================================================
	
	CREATE TABLE IF NOT EXISTS shared_database_config (
		config_id SERIAL PRIMARY KEY,
		is_shared_mode_enabled BOOLEAN DEFAULT TRUE,
		master_database_host VARCHAR(255),
		master_database_port INT DEFAULT 5432,
		master_database_name VARCHAR(255),
		master_database_user VARCHAR(255),
		master_database_password_encrypted TEXT,
		default_isolation_level VARCHAR(50) DEFAULT 'READ COMMITTED',
		enable_row_level_security BOOLEAN DEFAULT FALSE,
		enable_audit_logging BOOLEAN DEFAULT TRUE,
		max_total_connections INT DEFAULT 100,
		connection_pool_mode VARCHAR(50) DEFAULT 'transaction',
		description TEXT,
		created_at TIMESTAMP DEFAULT NOW(),
		updated_at TIMESTAMP DEFAULT NOW()
	);

	-- =====================================================
	-- APP DATABASE ACCESS (Depends on apps table)
	-- =====================================================
	
	CREATE TABLE IF NOT EXISTS app_database_access (
		access_id SERIAL PRIMARY KEY,
		app_id VARCHAR(50) NOT NULL,
		database_host VARCHAR(255),
		database_port INT,
		database_name VARCHAR(255),
		database_user VARCHAR(255),
		database_password_encrypted TEXT,
		connection_string TEXT,
		max_connections INT DEFAULT 25,
		min_connections INT DEFAULT 5,
		connection_timeout INT DEFAULT 30,
		isolation_level VARCHAR(50) DEFAULT 'READ COMMITTED',
		enable_shared_mode BOOLEAN DEFAULT TRUE,
		has_read_access BOOLEAN DEFAULT TRUE,
		has_write_access BOOLEAN DEFAULT FALSE,
		has_delete_access BOOLEAN DEFAULT FALSE,
		allowed_tables TEXT[],
		restricted_tables TEXT[],
		is_active BOOLEAN DEFAULT TRUE,
		created_at TIMESTAMP DEFAULT NOW(),
		created_by VARCHAR(100),
		updated_at TIMESTAMP DEFAULT NOW(),
		updated_by VARCHAR(100),
		FOREIGN KEY (app_id) REFERENCES apps(id) ON DELETE CASCADE
	);

	-- Database Access Audit Log (Depends on apps table)
	CREATE TABLE IF NOT EXISTS database_access_log (
		log_id SERIAL PRIMARY KEY,
		app_id VARCHAR(50),
		app_name VARCHAR(255),
		operation_type VARCHAR(50),
		table_name VARCHAR(255),
		query_text TEXT,
		rows_affected INT,
		execution_time_ms INT,
		success BOOLEAN,
		error_message TEXT,
		user_name VARCHAR(100),
		ip_address VARCHAR(50),
		timestamp TIMESTAMP DEFAULT NOW(),
		FOREIGN KEY (app_id) REFERENCES apps(id) ON DELETE SET NULL
	);

    -- =====================================================
    -- INDEXES
    -- =====================================================
    CREATE INDEX IF NOT EXISTS idx_component_code ON components(component_code);
    CREATE INDEX IF NOT EXISTS idx_component_type ON components(component_type);
    CREATE INDEX IF NOT EXISTS idx_manufacturer ON components(manufacturer);
    CREATE INDEX IF NOT EXISTS idx_lifecycle_status ON components(lifecycle_status);
    CREATE INDEX IF NOT EXISTS idx_is_active ON components(is_active);

    CREATE INDEX IF NOT EXISTS idx_app_db_access_app ON app_database_access(app_id);
    CREATE INDEX IF NOT EXISTS idx_app_db_access_active ON app_database_access(is_active);
    CREATE INDEX IF NOT EXISTS idx_db_access_log_app ON database_access_log(app_id);
    CREATE INDEX IF NOT EXISTS idx_db_access_log_timestamp ON database_access_log(timestamp);	
    
    CREATE INDEX IF NOT EXISTS idx_digikey_component ON supplier_digikey(component_id);
    CREATE INDEX IF NOT EXISTS idx_mouser_component ON supplier_mouser(component_id);
    CREATE INDEX IF NOT EXISTS idx_arrow_component ON supplier_arrow(component_id);
    CREATE INDEX IF NOT EXISTS idx_avnet_component ON supplier_avnet(component_id);
    CREATE INDEX IF NOT EXISTS idx_element14_component ON supplier_element14(component_id);
    
    CREATE INDEX IF NOT EXISTS idx_revision_component ON component_revisions(component_id);
    CREATE INDEX IF NOT EXISTS idx_revision_current ON component_revisions(is_current_revision);
	CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at);
	CREATE INDEX IF NOT EXISTS idx_table_registry_app ON table_registry(app_name);
	`

	_, err := db.Exec(ctx, schema)
	return err
}

// ============================================
// DATABASE OPERATIONS
// ============================================

// User operations
func saveUser(ctx context.Context, user *User) error {
	query := `
		INSERT INTO users (id, username, email, password_hash, level, assigned_apps, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		ON CONFLICT (username) 
		DO UPDATE SET email = $3, password_hash = $4, level = $5, assigned_apps = $6
	`
	_, err := db.Exec(ctx, query,
		user.ID, user.Username, user.Email, user.PasswordHash,
		user.Level, user.AssignedApps, user.CreatedAt)
	return err
}

func getUser(ctx context.Context, username string) (*User, error) {
	query := `SELECT id, username, email, password_hash, level, assigned_apps, created_at 
	          FROM users WHERE username = $1`

	var user User
	err := db.QueryRow(ctx, query, username).Scan(
		&user.ID, &user.Username, &user.Email, &user.PasswordHash,
		&user.Level, &user.AssignedApps, &user.CreatedAt)

	if err != nil {
		return nil, err
	}
	return &user, nil
}

func listUsers(ctx context.Context) ([]*User, error) {
	query := `SELECT id, username, email, password_hash, level, assigned_apps, created_at FROM users`
	rows, err := db.Query(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var users []*User
	for rows.Next() {
		var user User
		err := rows.Scan(&user.ID, &user.Username, &user.Email, &user.PasswordHash,
			&user.Level, &user.AssignedApps, &user.CreatedAt)
		if err != nil {
			continue
		}
		users = append(users, &user)
	}
	return users, nil
}

func deleteUser(ctx context.Context, username string) error {
	_, err := db.Exec(ctx, "DELETE FROM users WHERE username = $1", username)
	return err
}

// App operations
func saveApp(ctx context.Context, app *App) error {
	query := `
		INSERT INTO apps (id, name, url, icon, description, password_hash, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		ON CONFLICT (id) 
		DO UPDATE SET name = $2, url = $3, icon = $4, description = $5
	`
	_, err := db.Exec(ctx, query,
		app.ID, app.Name, app.URL, app.Icon, app.Description, app.Password, app.CreatedAt)
	return err
}

func getApp(ctx context.Context, id string) (*App, error) {
	query := `SELECT id, name, url, icon, description, password_hash, created_at 
	          FROM apps WHERE id = $1`

	var app App
	err := db.QueryRow(ctx, query, id).Scan(
		&app.ID, &app.Name, &app.URL, &app.Icon,
		&app.Description, &app.Password, &app.CreatedAt)

	if err != nil {
		return nil, err
	}
	return &app, nil
}

func listApps(ctx context.Context) ([]*App, error) {
	query := `SELECT id, name, url, icon, description, password_hash, created_at FROM apps`
	rows, err := db.Query(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var apps []*App
	for rows.Next() {
		var app App
		err := rows.Scan(&app.ID, &app.Name, &app.URL, &app.Icon,
			&app.Description, &app.Password, &app.CreatedAt)
		if err != nil {
			continue
		}
		apps = append(apps, &app)
	}
	return apps, nil
}

func deleteApp(ctx context.Context, id string) error {
	_, err := db.Exec(ctx, "DELETE FROM apps WHERE id = $1", id)
	return err
}

// Session operations
func saveSession(ctx context.Context, session *Session) error {
	query := `INSERT INTO sessions (token, username, expires_at, remember_me) 
	          VALUES ($1, $2, $3, $4)
			  ON CONFLICT (token) DO UPDATE SET expires_at = $3`
	_, err := db.Exec(ctx, query, session.Token, session.Username, session.ExpiresAt, session.RememberMe)
	return err
}

func getSession(r *http.Request) (*Session, error) {
	cookie, err := r.Cookie("session_token")
	if err != nil {
		return nil, err
	}

	ctx := r.Context()
	query := `SELECT token, username, expires_at, remember_me FROM sessions WHERE token = $1`

	var session Session
	err = db.QueryRow(ctx, query, cookie.Value).Scan(
		&session.Token, &session.Username, &session.ExpiresAt, &session.RememberMe)

	if err != nil {
		return nil, fmt.Errorf("invalid or expired session")
	}

	if time.Now().After(session.ExpiresAt) {
		deleteSession(ctx, session.Token)
		return nil, fmt.Errorf("session expired")
	}

	return &session, nil
}

func deleteSession(ctx context.Context, token string) error {
	_, err := db.Exec(ctx, "DELETE FROM sessions WHERE token = $1", token)
	return err
}


// ============================================
// GATEWAY DATA OPERATIONS
// ============================================

func createAppTable(ctx context.Context, appName, tableName string, columns map[string]interface{}) error {
	safeTableName := pgx.Identifier{appName + "_" + tableName}.Sanitize()

	var columnDefs []string
	columnDefs = append(columnDefs, "id BIGSERIAL PRIMARY KEY")
	columnDefs = append(columnDefs, "created_at TIMESTAMP DEFAULT NOW()")
	columnDefs = append(columnDefs, "updated_at TIMESTAMP DEFAULT NOW()")

	columnSchema := make(map[string]string)
	for colName, colValue := range columns {
		colType := inferColumnType(colValue)
		columnDefs = append(columnDefs, fmt.Sprintf("%s %s",
			pgx.Identifier{colName}.Sanitize(), colType))
		columnSchema[colName] = colType
	}

	query := fmt.Sprintf(`
		CREATE TABLE IF NOT EXISTS %s (
			%s
		)
	`, safeTableName, strings.Join(columnDefs, ",\n"))

	_, err := db.Exec(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	// Register table
	schemaJSON, _ := json.Marshal(columnSchema)
	regQuery := `
		INSERT INTO table_registry (app_name, table_name, full_table_name, column_schema)
		VALUES ($1, $2, $3, $4)
		ON CONFLICT (app_name, table_name) DO NOTHING
	`
	_, err = db.Exec(ctx, regQuery, appName, tableName, appName+"_"+tableName, schemaJSON)

	// Create index
	indexQuery := fmt.Sprintf(`
		CREATE INDEX IF NOT EXISTS idx_%s_created_at ON %s(created_at)
	`, appName+"_"+tableName, safeTableName)
	db.Exec(ctx, indexQuery)

	return err
}

func insertAppData(ctx context.Context, appName, tableName string, data map[string]interface{}) error {
	safeTableName := pgx.Identifier{appName + "_" + tableName}.Sanitize()

	var columns []string
	var placeholders []string
	var values []interface{}
	idx := 1

	for key, value := range data {
		columns = append(columns, pgx.Identifier{key}.Sanitize())
		placeholders = append(placeholders, fmt.Sprintf("$%d", idx))
		values = append(values, value)
		idx++
	}

	query := fmt.Sprintf(`
		INSERT INTO %s (%s) VALUES (%s)
	`, safeTableName,
		strings.Join(columns, ", "),
		strings.Join(placeholders, ", "))

	_, err := db.Exec(ctx, query, values...)
	return err
}

func getAppData(ctx context.Context, appName, tableName string, limit int) ([]map[string]interface{}, error) {
	safeTableName := pgx.Identifier{appName + "_" + tableName}.Sanitize()

	query := fmt.Sprintf(`
		SELECT * FROM %s ORDER BY created_at DESC LIMIT $1
	`, safeTableName)

	rows, err := db.Query(ctx, query, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []map[string]interface{}

	for rows.Next() {
		values, err := rows.Values()
		if err != nil {
			return nil, err
		}

		fieldDescriptions := rows.FieldDescriptions()
		rowMap := make(map[string]interface{})

		for i, fd := range fieldDescriptions {
			rowMap[string(fd.Name)] = values[i]
		}

		results = append(results, rowMap)
	}

	return results, nil
}

func listAppTables(ctx context.Context, appName string) ([]string, error) {
	query := `SELECT table_name FROM table_registry WHERE app_name = $1`

	rows, err := db.Query(ctx, query, appName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tables []string
	for rows.Next() {
		var tableName string
		if err := rows.Scan(&tableName); err != nil {
			return nil, err
		}
		tables = append(tables, tableName)
	}

	return tables, nil
}

func inferColumnType(value interface{}) string {
	switch value.(type) {
	case int, int32, int64:
		return "BIGINT"
	case float32, float64:
		return "DOUBLE PRECISION"
	case bool:
		return "BOOLEAN"
	case map[string]interface{}, []interface{}:
		return "JSONB"
	default:
		return "TEXT"
	}
}

// Component operations
func createComponent(ctx context.Context, comp *Component) error {
	query := `
		INSERT INTO components (name, category, description, datasheet, metadata, created_by)
		VALUES ($1, $2, $3, $4, $5, $6)
		RETURNING id, created_at, updated_at
	`
	metadataJSON, _ := json.Marshal(comp.Metadata)
	return db.QueryRow(ctx, query,
		comp.Name, comp.Category, comp.Description,
		comp.Datasheet, metadataJSON, comp.CreatedBy,
	).Scan(&comp.ID, &comp.CreatedAt, &comp.UpdatedAt)
}

func getComponents(ctx context.Context, category string) ([]Component, error) {
	var query string
	var rows pgx.Rows
	var err error

	if category != "" {
		query = `SELECT id, name, category, description, datasheet, metadata, created_by, created_at, updated_at 
		         FROM components WHERE category = $1 ORDER BY created_at DESC`
		rows, err = db.Query(ctx, query, category)
	} else {
		query = `SELECT id, name, category, description, datasheet, metadata, created_by, created_at, updated_at 
		         FROM components ORDER BY created_at DESC`
		rows, err = db.Query(ctx, query)
	}

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var components []Component
	for rows.Next() {
		var comp Component
		var metadataJSON []byte

		err := rows.Scan(&comp.ID, &comp.Name, &comp.Category, &comp.Description,
			&comp.Datasheet, &metadataJSON, &comp.CreatedBy,
			&comp.CreatedAt, &comp.UpdatedAt)
		if err != nil {
			continue
		}

		json.Unmarshal(metadataJSON, &comp.Metadata)
		components = append(components, comp)
	}

	return components, nil
}

func searchComponents(ctx context.Context, searchTerm string) ([]Component, error) {
	query := `
		SELECT id, name, category, description, datasheet, metadata, created_by, created_at, updated_at
		FROM components 
		WHERE name ILIKE $1 OR category ILIKE $1 OR description ILIKE $1
		ORDER BY created_at DESC
	`

	rows, err := db.Query(ctx, query, "%"+searchTerm+"%")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var components []Component
	for rows.Next() {
		var comp Component
		var metadataJSON []byte

		err := rows.Scan(&comp.ID, &comp.Name, &comp.Category, &comp.Description,
			&comp.Datasheet, &metadataJSON, &comp.CreatedBy,
			&comp.CreatedAt, &comp.UpdatedAt)
		if err != nil {
			continue
		}

		json.Unmarshal(metadataJSON, &comp.Metadata)
		components = append(components, comp)
	}

	return components, nil
}

// =====================================================
// SHARED DATABASE CONFIGURATION HANDLERS
// =====================================================

// Get shared database configuration
func handleGetSharedDatabaseConfig(w http.ResponseWriter, r *http.Request) {
	query := `
		SELECT config_id, is_shared_mode_enabled, master_database_host, 
		       master_database_port, master_database_name, master_database_user,
		       default_isolation_level, enable_row_level_security, enable_audit_logging,
		       max_total_connections, connection_pool_mode, description
		FROM shared_database_config
		ORDER BY config_id DESC
		LIMIT 1
	`

	var config map[string]interface{}
	var configID int
	var isShared, rowSecurity, auditLogging bool
	var host, dbName, dbUser, isolationLevel, poolMode, description string
	var port, maxConns int

	err := db.QueryRow(r.Context(), query).Scan(
		&configID, &isShared, &host, &port, &dbName, &dbUser,
		&isolationLevel, &rowSecurity, &auditLogging, &maxConns, &poolMode, &description,
	)

	if err != nil {
		// Return default config if none exists
		config = map[string]interface{}{
			"is_shared_mode_enabled":     true,
			"master_database_host":       "localhost",
			"master_database_port":       5432,
			"master_database_name":       "sienna_ecad_tools_db",
			"default_isolation_level":    "READ COMMITTED",
			"enable_row_level_security":  false,
			"enable_audit_logging":       true,
			"max_total_connections":      100,
			"connection_pool_mode":       "transaction",
			"description":                "Shared database for all applications",
		}
	} else {
		config = map[string]interface{}{
			"config_id":                  configID,
			"is_shared_mode_enabled":     isShared,
			"master_database_host":       host,
			"master_database_port":       port,
			"master_database_name":       dbName,
			"master_database_user":       dbUser,
			"default_isolation_level":    isolationLevel,
			"enable_row_level_security":  rowSecurity,
			"enable_audit_logging":       auditLogging,
			"max_total_connections":      maxConns,
			"connection_pool_mode":       poolMode,
			"description":                description,
		}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(config)
}

// Update shared database configuration
func handleUpdateSharedDatabaseConfig(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	// Check if config exists
	var exists bool
	err := db.QueryRow(r.Context(), "SELECT EXISTS(SELECT 1 FROM shared_database_config)").Scan(&exists)
	if err != nil {
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	var query string
	if exists {
		query = `
			UPDATE shared_database_config
			SET is_shared_mode_enabled = $1, master_database_host = $2, 
			    master_database_port = $3, master_database_name = $4,
			    master_database_user = $5, default_isolation_level = $6,
			    enable_row_level_security = $7, enable_audit_logging = $8,
			    max_total_connections = $9, connection_pool_mode = $10,
			    description = $11, updated_at = NOW()
		`
	} else {
		query = `
			INSERT INTO shared_database_config (
				is_shared_mode_enabled, master_database_host, master_database_port,
				master_database_name, master_database_user, default_isolation_level,
				enable_row_level_security, enable_audit_logging, max_total_connections,
				connection_pool_mode, description
			) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
		`
	}

	_, err = db.Exec(r.Context(), query,
		req["is_shared_mode_enabled"],
		req["master_database_host"],
		req["master_database_port"],
		req["master_database_name"],
		req["master_database_user"],
		req["default_isolation_level"],
		req["enable_row_level_security"],
		req["enable_audit_logging"],
		req["max_total_connections"],
		req["connection_pool_mode"],
		req["description"],
	)

	if err != nil {
		log.Printf("Failed to update shared database config: %v", err)
		http.Error(w, "Failed to update configuration", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": "Shared database configuration updated successfully",
	})
}

// Get apps with database access
func handleGetAppDatabaseAccess(w http.ResponseWriter, r *http.Request) {
	query := `
		SELECT ada.access_id, ada.app_id, a.name as app_name, ada.database_host,
		       ada.database_port, ada.database_name, ada.database_user,
		       ada.max_connections, ada.min_connections, ada.isolation_level,
		       ada.enable_shared_mode, ada.has_read_access, ada.has_write_access,
		       ada.has_delete_access, ada.allowed_tables, ada.restricted_tables,
		       ada.is_active, ada.created_at, ada.updated_at
		FROM app_database_access ada
		JOIN apps a ON ada.app_id = a.id
		ORDER BY a.name ASC
	`

	rows, err := db.Query(r.Context(), query)
	if err != nil {
		log.Printf("Failed to query app database access: %v", err)
		http.Error(w, "Failed to get app database access", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var accessList []map[string]interface{}
	for rows.Next() {
		var accessID, maxConns, minConns int
		var appID, appName, host, dbName, dbUser, isolationLevel string
		var port sql.NullInt32
		var enableShared, readAccess, writeAccess, deleteAccess, isActive bool
		var allowedTables, restrictedTables []string
		var createdAt, updatedAt time.Time

		err := rows.Scan(
			&accessID, &appID, &appName, &host, &port, &dbName, &dbUser,
			&maxConns, &minConns, &isolationLevel, &enableShared,
			&readAccess, &writeAccess, &deleteAccess,
			&allowedTables, &restrictedTables, &isActive, &createdAt, &updatedAt,
		)

		if err != nil {
			log.Printf("Failed to scan row: %v", err)
			continue
		}

		portVal := 5432
		if port.Valid {
			portVal = int(port.Int32)
		}

		access := map[string]interface{}{
			"access_id":          accessID,
			"app_id":             appID,
			"app_name":           appName,
			"database_host":      host,
			"database_port":      portVal,
			"database_name":      dbName,
			"database_user":      dbUser,
			"max_connections":    maxConns,
			"min_connections":    minConns,
			"isolation_level":    isolationLevel,
			"enable_shared_mode": enableShared,
			"has_read_access":    readAccess,
			"has_write_access":   writeAccess,
			"has_delete_access":  deleteAccess,
			"allowed_tables":     allowedTables,
			"restricted_tables":  restrictedTables,
			"is_active":          isActive,
			"created_at":         createdAt,
			"updated_at":         updatedAt,
		}

		accessList = append(accessList, access)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(accessList)
}

// Grant database access to an app
func handleGrantAppDatabaseAccess(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	// Get shared database config
	var host, dbName, dbUser string
	var port int
	err = db.QueryRow(r.Context(), `
		SELECT master_database_host, master_database_port, 
		       master_database_name, master_database_user
		FROM shared_database_config
		ORDER BY config_id DESC LIMIT 1
	`).Scan(&host, &port, &dbName, &dbUser)

	if err != nil {
		// Use default values
		host = "localhost"
		port = 5432
		dbName = "sienna_ecad_tools_db"
		dbUser = "postgres"
	}

	// Generate connection string
	connString := fmt.Sprintf(
		"postgresql://%s@%s:%d/%s?sslmode=disable&pool_max_conns=%v",
		dbUser, host, port, dbName, req["max_connections"],
	)

	query := `
		INSERT INTO app_database_access (
			app_id, database_host, database_port, database_name, database_user,
			connection_string, max_connections, min_connections, isolation_level,
			enable_shared_mode, has_read_access, has_write_access, has_delete_access,
			allowed_tables, restricted_tables, created_by, updated_by
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $16)
		ON CONFLICT (app_id) DO UPDATE
		SET database_host = $2, database_port = $3, database_name = $4,
		    database_user = $5, connection_string = $6, max_connections = $7,
		    min_connections = $8, isolation_level = $9, enable_shared_mode = $10,
		    has_read_access = $11, has_write_access = $12, has_delete_access = $13,
		    allowed_tables = $14, restricted_tables = $15, updated_by = $16,
		    updated_at = NOW()
		RETURNING access_id
	`

	var accessID int
	err = db.QueryRow(r.Context(), query,
		req["app_id"], host, port, dbName, dbUser, connString,
		req["max_connections"], req["min_connections"], req["isolation_level"],
		req["enable_shared_mode"], req["has_read_access"], req["has_write_access"],
		req["has_delete_access"], req["allowed_tables"], req["restricted_tables"],
		session.Username,
	).Scan(&accessID)

	if err != nil {
		log.Printf("Failed to grant database access: %v", err)
		http.Error(w, "Failed to grant access", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":         true,
		"access_id":       accessID,
		"connection_string": connString,
		"message":         "Database access granted successfully",
	})
}

// Handler: Verify session for external apps
// Add this handler function anywhere in app.go
func handleVerifySession(w http.ResponseWriter, r *http.Request) {
	// Get session from cookie
	session, err := getSession(r)
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// Get user details
	user, err := getUser(r.Context(), session.Username)
	if err != nil {
		http.Error(w, "User not found", http.StatusUnauthorized)
		return
	}

	// Return session info
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"username": user.Username,
		"email":    user.Email,
		"level":    user.Level,
	})
}





// Get connection string for an app
func handleGetAppConnectionString(w http.ResponseWriter, r *http.Request) {
	appID := r.URL.Query().Get("app_id")
	if appID == "" {
		http.Error(w, "App ID required", http.StatusBadRequest)
		return
	}

	query := `
		SELECT connection_string, database_host, database_port, 
		       database_name, database_user, max_connections, isolation_level
		FROM app_database_access
		WHERE app_id = $1 AND is_active = TRUE
	`

	var connStr, host, dbName, dbUser, isolationLevel string
	var port, maxConns int

	err := db.QueryRow(r.Context(), query, appID).Scan(
		&connStr, &host, &port, &dbName, &dbUser, &maxConns, &isolationLevel,
	)

	if err != nil {
		http.Error(w, "No database access configured for this app", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":           true,
		"connection_string": connStr,
		"host":              host,
		"port":              port,
		"database":          dbName,
		"user":              dbUser,
		"max_connections":   maxConns,
		"isolation_level":   isolationLevel,
	})
}

// Revoke database access from an app
func handleRevokeAppDatabaseAccess(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	query := `UPDATE app_database_access SET is_active = FALSE WHERE app_id = $1`
	_, err := db.Exec(r.Context(), query, req["app_id"])

	if err != nil {
		http.Error(w, "Failed to revoke access", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": "Database access revoked successfully",
	})
}


// ============================================
// HTTP HANDLERS - GATEWAY API
// ============================================

func handleIngestData(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var appData AppData
	if err := json.NewDecoder(r.Body).Decode(&appData); err != nil {
		http.Error(w, "Invalid request format", http.StatusBadRequest)
		return
	}

	if appData.AppName == "" || appData.TableName == "" || appData.Data == nil {
		http.Error(w, "app_name, table_name, and data are required", http.StatusBadRequest)
		return
	}

	appData.Timestamp = time.Now()
	ctx := r.Context()

	// Create table if not exists
	err := createAppTable(ctx, appData.AppName, appData.TableName, appData.Data)
	if err != nil {
		log.Printf("Failed to create table: %v", err)
		http.Error(w, "Failed to create/verify table", http.StatusInternalServerError)
		return
	}

	// Insert data
	err = insertAppData(ctx, appData.AppName, appData.TableName, appData.Data)
	if err != nil {
		log.Printf("Failed to insert data: %v", err)
		http.Error(w, "Failed to insert data", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"message":    "Data saved successfully",
		"app_name":   appData.AppName,
		"table_name": appData.TableName,
		"timestamp":  appData.Timestamp,
	})
}

func handleGetAppData(w http.ResponseWriter, r *http.Request) {
	// Parse URL: /api/gateway/apps/{app_name}/tables/{table_name}/data
	parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/gateway/apps/"), "/")
	if len(parts) < 3 {
		http.Error(w, "Invalid path", http.StatusBadRequest)
		return
	}

	appName := parts[0]
	tableName := parts[2]
	limit := 100

	data, err := getAppData(r.Context(), appName, tableName, limit)
	if err != nil {
		http.Error(w, "Failed to retrieve data", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"app_name":   appName,
		"table_name": tableName,
		"count":      len(data),
		"data":       data,
	})
}

func handleListAppTables(w http.ResponseWriter, r *http.Request) {
	// Parse URL: /api/gateway/apps/{app_name}/tables
	appName := strings.TrimPrefix(r.URL.Path, "/api/gateway/apps/")
	appName = strings.TrimSuffix(appName, "/tables")

	tables, err := listAppTables(r.Context(), appName)
	if err != nil {
		http.Error(w, "Failed to list tables", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"app_name": appName,
		"tables":   tables,
	})
}

// Component handlers
// Component API Handlers
// Get component with supplier pricing
func handleGetComponents(w http.ResponseWriter, r *http.Request) {
	query := `
		SELECT 
			c.component_id, c.component_name, c.component_code, c.component_type, c.component_subtype,
			c.manufacturer, c.manufacturer_part_number, c.description, c.tags,
			c.package_type, c.mounting_type, c.pin_count, c.footprint,
			c.dimensions_length, c.dimensions_width, c.dimensions_height, c.weight,
			c.voltage_rating, c.current_rating, c.power_rating, c.tolerance,
			c.temperature_coefficient, c.operating_temp_min, c.operating_temp_max,
			c.resistance_value, c.capacitance_value, c.inductance_value, c.frequency, c.data_value,
			c.quantity_in_stock, c.lifecycle_status, c.is_active, c.is_rohs_compliant, c.is_reach_compliant, c.eol_date,
			c.datasheet_url, c.specification_url, c.cad_model_url, c.image_url, c.notes,
			c.quality_grade, c.test_required, c.inspection_level, c.failure_rate, c.mtbf,
			c.created_at, c.created_by, c.updated_at, c.updated_by,
			COALESCE(cr.revision_number, 0) as current_revision,
			CASE WHEN cr.is_deleted THEN 'DELETED' ELSE 'OK' END as revision_status
		FROM components c
		LEFT JOIN component_revisions cr ON c.component_id = cr.component_id AND cr.is_current_revision = TRUE
		WHERE c.deleted_at IS NULL
		ORDER BY c.component_id DESC
	`

	rows, err := db.Query(r.Context(), query)
	if err != nil {
		log.Printf("Failed to get components: %v", err)
		http.Error(w, "Failed to get components", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	var components []map[string]interface{}

	for rows.Next() {
		var comp map[string]interface{}
		// Scan component data...
		// (Add all your scan logic here)
		
		componentID := comp["component_id"].(int)
			
		// Fetch supplier pricing for each component
		comp["digikey"] = getSupplierPricing(r.Context(), "digikey", componentID)
		comp["mouser"] = getSupplierPricing(r.Context(), "mouser", componentID)
		comp["arrow"] = getSupplierPricing(r.Context(), "arrow", componentID)
		comp["avnet"] = getSupplierPricing(r.Context(), "avnet", componentID)
		comp["element14"] = getSupplierPricing(r.Context(), "element14", componentID)
		
		components = append(components, comp)
	}

	json.NewEncoder(w).Encode(components)
}

// Helper function to get supplier pricing
func getSupplierPricing(ctx context.Context, supplier string, componentID int) map[string]interface{} {
	query := fmt.Sprintf(`
		SELECT 
			supplier_part_number,
			price_tier_1_qty, price_tier_1_price,
			price_tier_2_qty, price_tier_2_price,
			price_tier_3_qty, price_tier_3_price,
			price_tier_4_qty, price_tier_4_price,
			price_tier_5_qty, price_tier_5_price,
			price_tier_6_qty, price_tier_6_price,
			price_tier_7_qty, price_tier_7_price,
			price_tier_8_qty, price_tier_8_price,
			currency, stock_available, lead_time_days, moq, product_url
		FROM supplier_%s
		WHERE component_id = $1 AND is_active = TRUE
		LIMIT 1
	`, supplier)

	var (
		partNum, currency, url                     string
		t1q, t2q, t3q, t4q, t5q, t6q, t7q, t8q    *int
		t1p, t2p, t3p, t4p, t5p, t6p, t7p, t8p    *float64
		stock, leadTime, moq                       *int
	)

	err := db.QueryRow(ctx, query, componentID).Scan(
		&partNum,
		&t1q, &t1p, &t2q, &t2p, &t3q, &t3p, &t4q, &t4p,
		&t5q, &t5p, &t6q, &t6p, &t7q, &t7p, &t8q, &t8p,
		&currency, &stock, &leadTime, &moq, &url,
	)

	if err != nil {
		return nil
	}

	tiers := []map[string]interface{}{}
	if t1q != nil && t1p != nil && *t1q > 0 {
		tiers = append(tiers, map[string]interface{}{"qty": *t1q, "price": *t1p})
	}
	if t2q != nil && t2p != nil && *t2q > 0 {
		tiers = append(tiers, map[string]interface{}{"qty": *t2q, "price": *t2p})
	}
	if t3q != nil && t3p != nil && *t3q > 0 {
		tiers = append(tiers, map[string]interface{}{"qty": *t3q, "price": *t3p})
	}
	if t4q != nil && t4p != nil && *t4q > 0 {
		tiers = append(tiers, map[string]interface{}{"qty": *t4q, "price": *t4p})
	}
	if t5q != nil && t5p != nil && *t5q > 0 {
		tiers = append(tiers, map[string]interface{}{"qty": *t5q, "price": *t5p})
	}
	if t6q != nil && t6p != nil && *t6q > 0 {
		tiers = append(tiers, map[string]interface{}{"qty": *t6q, "price": *t6p})
	}
	if t7q != nil && t7p != nil && *t7q > 0 {
		tiers = append(tiers, map[string]interface{}{"qty": *t7q, "price": *t7p})
	}
	if t8q != nil && t8p != nil && *t8q > 0 {
		tiers = append(tiers, map[string]interface{}{"qty": *t8q, "price": *t8p})
	}

	stockVal := 0
	if stock != nil {
		stockVal = *stock
	}

	return map[string]interface{}{
		"part_number": partNum,
		"tiers":       tiers,
		"currency":    currency,
		"stock":       stockVal,
		"url":         url,
	}
}


// Enhanced Component Create Handler
func handleCreateComponent(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	session, _ := getSession(r)
	username := "system"
	if session != nil {
		username = session.Username
	}

	query := `
		INSERT INTO components (
			component_name, component_code, component_type, component_subtype,
			manufacturer, manufacturer_part_number, description, tags,
			package_type, dimensions_length, dimensions_width, dimensions_height,
			weight, mounting_type, pin_count, footprint,
			voltage_rating, current_rating, power_rating, tolerance,
			temperature_coefficient, operating_temp_min, operating_temp_max,
			resistance_value, capacitance_value, inductance_value, frequency, data_value,
			quantity_in_stock, lifecycle_status, is_active, is_rohs_compliant, is_reach_compliant,
			datasheet_url, specification_url, cad_model_url, image_url, notes,
			quality_grade, test_required, inspection_level, failure_rate, mtbf,
			created_by
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16,
			$17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30,
			$31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44
		)
		RETURNING component_id
	`

	var componentID int
	err := db.QueryRow(r.Context(), query,
		req["component_name"], req["component_code"], req["component_type"], req["component_subtype"],
		req["manufacturer"], req["manufacturer_part_number"], req["description"], req["tags"],
		req["package_type"], req["dimensions_length"], req["dimensions_width"], req["dimensions_height"],
		req["weight"], req["mounting_type"], req["pin_count"], req["footprint"],
		req["voltage_rating"], req["current_rating"], req["power_rating"], req["tolerance"],
		req["temperature_coefficient"], req["operating_temp_min"], req["operating_temp_max"],
		req["resistance_value"], req["capacitance_value"], req["inductance_value"], req["frequency"], req["data_value"],
		req["quantity_in_stock"], req["lifecycle_status"], req["is_active"], req["is_rohs_compliant"], req["is_reach_compliant"],
		req["datasheet_url"], req["specification_url"], req["cad_model_url"], req["image_url"], req["notes"],
		req["quality_grade"], req["test_required"], req["inspection_level"], req["failure_rate"], req["mtbf"],
		username,
	).Scan(&componentID)

	if err != nil {
		log.Printf("Failed to create component: %v", err)
		http.Error(w, "Failed to create component", http.StatusInternalServerError)
		return
	}

	// Insert supplier pricing data
	suppliers := []string{"digikey", "mouser", "arrow", "avnet", "element14"}
	for _, supplier := range suppliers {
		if supplierData, ok := req[supplier].(map[string]interface{}); ok && supplierData != nil {
			insertSupplierPricing(r.Context(), supplier, componentID, supplierData)
		}
	}

	// Create initial revision (Revision 0)
	revisionQuery := `
		INSERT INTO component_revisions (component_id, revision_number, data_value, revised_by, is_current_revision)
		VALUES ($1, 0, $2, $3, TRUE)
	`
	db.Exec(r.Context(), revisionQuery, componentID, req["data_value"], username)

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":      true,
		"component_id": componentID,
		"message":      "Component created successfully with Revision 0",
	})
}


// ============================================
// FOOTPRINT FILE UPLOAD HANDLER
// ============================================

// Create/Update component with .siennalib file
func handleCreateComponentFootprint(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    session, err := getSession(r)
    if err != nil {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    // Parse multipart form (max 10MB)
    if err := r.ParseMultipartForm(10 << 20); err != nil {
        http.Error(w, "Failed to parse form", http.StatusBadRequest)
        return
    }

    // Get .siennalib file
    file, header, err := r.FormFile("footprint_file")
    if err != nil {
        http.Error(w, "No file uploaded", http.StatusBadRequest)
        return
    }
    defer file.Close()

    // Validate file extension
    if !strings.HasSuffix(header.Filename, ".siennalib") {
        http.Error(w, "Only .siennalib files allowed", http.StatusBadRequest)
        return
    }

    // Read file content
    fileBytes, err := io.ReadAll(file)
    if err != nil {
        http.Error(w, "Failed to read file", http.StatusInternalServerError)
        return
    }

    footprintData := string(fileBytes)

    // Get form fields
    partNumber := r.FormValue("part_number")          // Required - becomes component_code
    componentName := r.FormValue("component_name")    // Optional
    packageType := r.FormValue("package_type")        // Optional
    manufacturer := r.FormValue("manufacturer")       // Optional
    componentType := r.FormValue("component_type")    // Optional
    pinCount := r.FormValue("pin_count")              // Optional
    dimensionsLength := r.FormValue("dimensions_length")   // Optional
    dimensionsWidth := r.FormValue("dimensions_width")     // Optional
    dimensionsHeight := r.FormValue("dimensions_height")   // Optional
    description := r.FormValue("description")         // Optional
    datasheetURL := r.FormValue("datasheet_url")      // Optional

    // Validate required field
    if partNumber == "" {
        http.Error(w, "part_number is required", http.StatusBadRequest)
        return
    }

    // Insert or update component in existing components table
    query := `
        INSERT INTO components (
            component_code, 
            manufacturer_part_number,
            component_name,
            component_type,
            package_type,
            manufacturer,
            footprint,
            pin_count,
            dimensions_length,
            dimensions_width,
            dimensions_height,
            description,
            datasheet_url,
            created_by,
            updated_by,
            lifecycle_status,
            is_active
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $14, 'active', TRUE)
        ON CONFLICT (component_code) 
        DO UPDATE SET 
            footprint = $7,
            component_name = COALESCE(NULLIF($3, ''), components.component_name),
            component_type = COALESCE(NULLIF($4, ''), components.component_type),
            package_type = COALESCE(NULLIF($5, ''), components.package_type),
            manufacturer = COALESCE(NULLIF($6, ''), components.manufacturer),
            pin_count = CASE 
                WHEN $8 != '' THEN CAST($8 AS INT)
                ELSE components.pin_count
            END,
            dimensions_length = CASE 
                WHEN $9 != '' THEN CAST($9 AS DECIMAL(10,3))
                ELSE components.dimensions_length
            END,
            dimensions_width = CASE 
                WHEN $10 != '' THEN CAST($10 AS DECIMAL(10,3))
                ELSE components.dimensions_width
            END,
            dimensions_height = CASE 
                WHEN $11 != '' THEN CAST($11 AS DECIMAL(10,3))
                ELSE components.dimensions_height
            END,
            description = COALESCE(NULLIF($12, ''), components.description),
            datasheet_url = COALESCE(NULLIF($13, ''), components.datasheet_url),
            updated_at = NOW(),
            updated_by = $14
        RETURNING component_id
    `

    var componentID int
    err = db.QueryRow(r.Context(), query,
        partNumber,         // $1 - component_code (unique identifier)
        partNumber,         // $2 - manufacturer_part_number
        componentName,      // $3
        componentType,      // $4
        packageType,        // $5
        manufacturer,       // $6
        footprintData,      // $7  Store .siennalib content here
        pinCount,           // $8
        dimensionsLength,   // $9
        dimensionsWidth,    // $10
        dimensionsHeight,   // $11
        description,        // $12
        datasheetURL,       // $13
        session.Username,   // $14
    ).Scan(&componentID)

    if err != nil {
        log.Printf("Failed to save footprint: %v", err)
        http.Error(w, fmt.Sprintf("Failed to save footprint: %v", err), http.StatusInternalServerError)
        return
    }

    // Create initial revision if new component
    revisionQuery := `
        INSERT INTO component_revisions (
            component_id, 
            revision_number, 
            data_value, 
            revision_reason,
            revised_by, 
            is_current_revision
        )
        VALUES ($1, 0, 'Initial footprint upload', 'Created from desktop app', $2, TRUE)
        ON CONFLICT (component_id, revision_number) DO NOTHING
    `
    db.Exec(r.Context(), revisionQuery, componentID, session.Username)

    log.Printf(" User %s saved footprint for %s (Component ID: %d, Size: %d bytes)",
        session.Username, partNumber, componentID, len(footprintData))

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success":      true,
        "component_id": componentID,
        "part_number":  partNumber,
        "file_size":    len(footprintData),
        "filename":     header.Filename,
        "message":      "Footprint saved successfully to components.footprint column",
    })
}

// Download .siennalib file from components.footprint column
func handleGetComponentFootprint(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    session, err := getSession(r)
    if err != nil {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    // Get part number from query parameter
    partNumber := r.URL.Query().Get("part_number")
    if partNumber == "" {
        http.Error(w, "part_number parameter required", http.StatusBadRequest)
        return
    }

    // Query existing components table
    query := `
        SELECT footprint, component_name, package_type, manufacturer
        FROM components 
        WHERE component_code = $1 AND footprint IS NOT NULL AND footprint != ''
    `

    var footprintData, componentName, packageType, manufacturer string
    err = db.QueryRow(r.Context(), query, partNumber).Scan(
        &footprintData, &componentName, &packageType, &manufacturer,
    )

    if err != nil {
        log.Printf("Footprint not found for %s: %v", partNumber, err)
        http.Error(w, "Footprint not found", http.StatusNotFound)
        return
    }

    log.Printf(" User %s retrieved footprint for %s (Size: %d bytes)",
        session.Username, partNumber, len(footprintData))

    // Return as downloadable .siennalib file
    filename := fmt.Sprintf("%s_%s.siennalib", partNumber, packageType)
    
    w.Header().Set("Content-Type", "application/octet-stream")
    w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))
    w.Header().Set("Content-Length", fmt.Sprintf("%d", len(footprintData)))
    w.Write([]byte(footprintData))
}


// Helper function to insert supplier pricing
func insertSupplierPricing(ctx context.Context, supplier string, componentID int, data map[string]interface{}) error {
	query := fmt.Sprintf(`
		INSERT INTO supplier_%s (
			component_id, supplier_part_number,
			price_tier_1_qty, price_tier_1_price,
			price_tier_2_qty, price_tier_2_price,
			price_tier_3_qty, price_tier_3_price,
			price_tier_4_qty, price_tier_4_price,
			price_tier_5_qty, price_tier_5_price,
			price_tier_6_qty, price_tier_6_price,
			price_tier_7_qty, price_tier_7_price,
			price_tier_8_qty, price_tier_8_price,
			currency, stock_available, lead_time_days, moq, product_url
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
		)
	`, supplier)

	_, err := db.Exec(ctx, query,
		componentID, data["part_number"],
		data["tier1_qty"], data["tier1_price"],
		data["tier2_qty"], data["tier2_price"],
		data["tier3_qty"], data["tier3_price"],
		data["tier4_qty"], data["tier4_price"],	
		data["tier5_qty"], data["tier5_price"],
		data["tier6_qty"], data["tier6_price"],
		data["tier7_qty"], data["tier7_price"],
		data["tier8_qty"], data["tier8_price"],
		data["currency"], data["stock"], data["lead_time"], data["moq"], data["url"],
	)

	return err
}

// Get Component with all details including supplier pricing
func handleGetComponentDetails(w http.ResponseWriter, r *http.Request) {
	componentID := r.URL.Query().Get("id")
	if componentID == "" {
		http.Error(w, "Component ID required", http.StatusBadRequest)
		return
	}

	// Get component details
	query := `
		SELECT component_id, component_name, component_code, component_type, component_subtype,
		       manufacturer, manufacturer_part_number, description, tags,
		       package_type, dimensions_length, dimensions_width, dimensions_height,
		       weight, mounting_type, pin_count, footprint,
		       voltage_rating, current_rating, power_rating, tolerance,
		       temperature_coefficient, operating_temp_min, operating_temp_max,
		       resistance_value, capacitance_value, inductance_value, frequency, data_value,
		       quantity_in_stock, lifecycle_status, is_active, is_rohs_compliant, is_reach_compliant,
		       datasheet_url, specification_url, cad_model_url, image_url, notes,
		       quality_grade, test_required, inspection_level, failure_rate, mtbf,
		       created_at, created_by, updated_at, updated_by
		FROM components 
		WHERE component_id = $1 AND deleted_at IS NULL
	`

	var component map[string]interface{}
	row := db.QueryRow(r.Context(), query, componentID)
	
	var (
		id, name, code, compType, subtype, mfg, mpn, desc, tags string
		pkg, dimL, dimW, dimH, weight, mount string
		pinCount int
		footprint, vRating, cRating, pRating, tol, tempCoef string
		tempMin, tempMax float64
		resVal, capVal, indVal, freq, dataVal string
		qtyStock int
		lifecycle string
		active, rohs, reach, testReq bool
		datasheet, spec, cad, img, notes, grade, inspect string
		failRate float64
		mtbf int
		createdAt, updatedAt time.Time
		createdBy, updatedBy string
	)

	err := row.Scan(
		&id, &name, &code, &compType, &subtype, &mfg, &mpn, &desc, &tags,
		&pkg, &dimL, &dimW, &dimH, &weight, &mount, &pinCount, &footprint,
		&vRating, &cRating, &pRating, &tol, &tempCoef, &tempMin, &tempMax,
		&resVal, &capVal, &indVal, &freq, &dataVal,
		&qtyStock, &lifecycle, &active, &rohs, &reach,
		&datasheet, &spec, &cad, &img, &notes,
		&grade, &testReq, &inspect, &failRate, &mtbf,
		&createdAt, &createdBy, &updatedAt, &updatedBy,
	)

	if err != nil {
		http.Error(w, "Component not found", http.StatusNotFound)
		return
	}

	component = map[string]interface{}{
		"component_id": id,
		"component_name": name,
		"component_code": code,
		"component_type": compType,
		"manufacturer": mfg,
		"quantity_in_stock": qtyStock,
		"lifecycle_status": lifecycle,
		"is_active": active,
	}

	// Get supplier pricing
	suppliers := []string{"digikey", "mouser", "arrow", "avnet", "element14"}
	supplierData := make(map[string]interface{})

	for _, supplier := range suppliers {
		pricingQuery := fmt.Sprintf(`
			SELECT supplier_part_number,
			       price_tier_1_qty, price_tier_1_price,
			       price_tier_2_qty, price_tier_2_price,
			       price_tier_3_qty, price_tier_3_price,
			       price_tier_4_qty, price_tier_4_price,
			       price_tier_5_qty, price_tier_5_price,
			       price_tier_6_qty, price_tier_6_price,
			       price_tier_7_qty, price_tier_7_price,
			       price_tier_8_qty, price_tier_8_price,
			       currency, stock_available, lead_time_days, moq, product_url
			FROM supplier_%s 
			WHERE component_id = $1 AND is_active = TRUE
		`, supplier)

		var pricing map[string]interface{}
		pricingRow := db.QueryRow(r.Context(), pricingQuery, componentID)
		
		var partNum, currency, url string
		var t1q, t2q, t3q, t4q, t5q, t6q, t7q, t8q int
		var t1p, t2p, t3p, t4p, t5p, t6p, t7p, t8p float64
		var stock, leadTime, moq int

		err := pricingRow.Scan(
			&partNum,
			&t1q, &t1p, &t2q, &t2p, &t3q, &t3p, &t4q, &t4p,
			&t5q, &t5p, &t6q, &t6p, &t7q, &t7p, &t8q, &t8p,
			&currency, &stock, &leadTime, &moq, &url,
		)

		if err == nil {
			pricing = map[string]interface{}{
				"part_number": partNum,
				"tiers": []map[string]interface{}{
					{"qty": t1q, "price": t1p},
					{"qty": t2q, "price": t2p},
					{"qty": t3q, "price": t3p},
					{"qty": t4q, "price": t4p},
					{"qty": t5q, "price": t5p},
					{"qty": t6q, "price": t6p},
					{"qty": t7q, "price": t7p},
					{"qty": t8q, "price": t8p},
				},
				"currency": currency,
				"stock": stock,
				"lead_time": leadTime,
				"moq": moq,
				"url": url,
			}
			supplierData[supplier] = pricing
		} else {
			supplierData[supplier] = nil
		}
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":   true,
		"component": component,
		"suppliers": supplierData,
	})
}


func handleGetRevisions(w http.ResponseWriter, r *http.Request) {
    componentID := r.URL.Query().Get("component_id")
    
    query := `
        SELECT revision_id, revision_number, data_value, revision_reason,
               change_summary, revised_by, is_current_revision, is_deleted, created_at
        FROM component_revisions
        WHERE component_id = $1
        ORDER BY revision_number ASC
    `
    
    rows, err := db.Query(r.Context(), query, componentID)
    if err != nil {
        http.Error(w, "Failed to fetch revisions", http.StatusInternalServerError)
        return
    }
    defer rows.Close()
    
    var revisions []map[string]interface{}
    for rows.Next() {
        var rev map[string]interface{}
        // Scan and format revision data
        revisions = append(revisions, rev)
    }
    
    json.NewEncoder(w).Encode(revisions)
}

func handleCreateRevision(w http.ResponseWriter, r *http.Request) {
    var req struct {
        ComponentID   int    `json:"component_id"`
        DataValue     string `json:"data_value"`
        RevisionReason string `json:"revision_reason"`
        ChangeSummary string `json:"change_summary"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid input", http.StatusBadRequest)
        return
    }
    
    session, _ := getSession(r)
    
    // Get next revision number
    var nextRevision int
    db.QueryRow(r.Context(), 
        `SELECT COALESCE(MAX(revision_number), -1) + 1 FROM component_revisions WHERE component_id = $1`,
        req.ComponentID).Scan(&nextRevision)
    
    // Mark all revisions as non-current
    db.Exec(r.Context(), 
        `UPDATE component_revisions SET is_current_revision = FALSE WHERE component_id = $1`,
        req.ComponentID)
    
    // Insert new revision
    query := `
        INSERT INTO component_revisions (component_id, revision_number, data_value,
                                          revision_reason, change_summary, revised_by, 
                                          is_current_revision)
        VALUES ($1, $2, $3, $4, $5, $6, TRUE)
        RETURNING revision_id
    `
    
    var revisionID int
    err := db.QueryRow(r.Context(), query,
        req.ComponentID, nextRevision, req.DataValue, req.RevisionReason,
        req.ChangeSummary, session.Username).Scan(&revisionID)
    
    if err != nil {
        http.Error(w, "Failed to create revision", http.StatusInternalServerError)
        return
    }
    
    // Update component data_value
    db.Exec(r.Context(),
        `UPDATE components SET data_value = $1, updated_by = $2, updated_at = NOW() WHERE component_id = $3`,
        req.DataValue, session.Username, req.ComponentID)
    
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "revision_id": revisionID,
        "revision_number": nextRevision,
        "message": fmt.Sprintf("Revision %d created successfully", nextRevision),
    })
}

func handleDeleteRevision(w http.ResponseWriter, r *http.Request) {
    var req struct {
        RevisionID int `json:"revision_id"`
        ComponentID int `json:"component_id"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid input", http.StatusBadRequest)
        return
    }
    
    // Mark revision as deleted and update subsequent revisions
    tx, _ := db.Begin(r.Context())
    defer tx.Rollback(r.Context())
    
    // Mark as deleted
    tx.Exec(r.Context(),
        `UPDATE component_revisions SET is_deleted = TRUE WHERE revision_id = $1`,
        req.RevisionID)
    
    // Decrement subsequent revision numbers
    tx.Exec(r.Context(),
        `UPDATE component_revisions 
         SET revision_number = revision_number - 1 
         WHERE component_id = $1 AND revision_number > (
             SELECT revision_number FROM component_revisions WHERE revision_id = $2
         )`,
        req.ComponentID, req.RevisionID)
    
    tx.Commit(r.Context())
    
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "message": "Revision deleted and numbers updated",
    })
}

func handleSearchComponents(w http.ResponseWriter, r *http.Request) {
	searchTerm := r.URL.Query().Get("q")

	if searchTerm == "" {
		http.Error(w, "Search term required", http.StatusBadRequest)
		return
	}

	components, err := searchComponents(r.Context(), searchTerm)
	if err != nil {
		http.Error(w, "Failed to search components", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(components)
}

// ============================================
// HTTP HANDLERS - ADMIN DATABASE SETTINGS
// ============================================

func handleGetDBSettings(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	query := `SELECT host, port, username, dbname, max_conns, min_conns FROM db_settings WHERE is_active = true LIMIT 1`

	var config DBConfig
	err = db.QueryRow(r.Context(), query).Scan(
		&config.Host, &config.Port, &config.User, &config.DBName, &config.MaxConns, &config.MinConns)

	if err == sql.ErrNoRows {
		// Return default config
		config = DBConfig{
			Host:     "localhost",
			Port:     5432,
			User:     "postgres",
			DBName:   "sienna_ecad_tools_db",
			MaxConns: 25,
			MinConns: 5,
		}
	}

	config.Password = "******" // Mask password
	json.NewEncoder(w).Encode(config)
}

func handleUpdateDBSettings(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var config DBConfig
	if err := json.NewDecoder(r.Body).Decode(&config); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	// Test connection first
	testConfig := DBConfig{
		Host:     config.Host,
		Port:     config.Port,
		User:     config.User,
		Password: config.Password,
		DBName:   config.DBName,
		MaxConns: config.MaxConns,
		MinConns: config.MinConns,
	}

	if err := initDB(testConfig); err != nil {
		http.Error(w, "Connection failed: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Save settings
	query := `
		INSERT INTO db_settings (host, port, username, password, dbname, max_conns, min_conns, is_active)
		VALUES ($1, $2, $3, $4, $5, $6, $7, true)
		ON CONFLICT (id) DO UPDATE 
		SET host = $1, port = $2, username = $3, password = $4, dbname = $5, 
		    max_conns = $6, min_conns = $7, updated_at = NOW()
	`

	_, err = db.Exec(r.Context(), query,
		config.Host, config.Port, config.User, config.Password,
		config.DBName, config.MaxConns, config.MinConns)

	if err != nil {
		http.Error(w, "Failed to save settings", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]string{"message": "Database settings updated successfully"})
}

func handleTestDBConnection(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var config DBConfig
	if err := json.NewDecoder(r.Body).Decode(&config); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	// Test connection
	connString := fmt.Sprintf(
		"postgres://%s:%s@%s:%d/%s?sslmode=disable",
		config.User, config.Password, config.Host, config.Port, config.DBName,
	)

	testPool, err := pgxpool.New(r.Context(), connString)
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"message": "Failed to connect: " + err.Error(),
		})
		return
	}
	defer testPool.Close()

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	if err := testPool.Ping(ctx); err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"message": "Connection failed: " + err.Error(),
		})
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": "Connection successful",
	})
}

func handleGetSMTPSettings(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	query := `SELECT smtp_host, smtp_port, smtp_from, smtp_encryption, smtp_enabled 
	          FROM smtp_settings ORDER BY id DESC LIMIT 1`

	var settings SMTPSettings
	err = db.QueryRow(r.Context(), query).Scan(
		&settings.SMTPHost, &settings.SMTPPort, &settings.SMTPFrom,
		&settings.SMTPEncryption, &settings.SMTPEnabled)

	if err == sql.ErrNoRows || err != nil {
		// Return default empty config
		settings = SMTPSettings{
			SMTPHost:       "",
			SMTPPort:       587,
			SMTPFrom:       "",
			SMTPEncryption: "tls",
			SMTPEnabled:    true,
		}
	}

	// Don't send password to frontend
	json.NewEncoder(w).Encode(settings)
}

func handleUpdateSMTPSettings(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var settings SMTPSettings
	if err := json.NewDecoder(r.Body).Decode(&settings); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	// Delete old settings and insert new
	_, err = db.Exec(r.Context(), "DELETE FROM smtp_settings")
	if err != nil {
		log.Printf("Failed to delete old SMTP settings: %v", err)
	}

	query := `
		INSERT INTO smtp_settings (smtp_host, smtp_port, smtp_from, smtp_password, smtp_encryption, smtp_enabled)
		VALUES ($1, $2, $3, $4, $5, $6)
	`

	_, err = db.Exec(r.Context(), query,
		settings.SMTPHost, settings.SMTPPort, settings.SMTPFrom,
		settings.SMTPPassword, settings.SMTPEncryption, settings.SMTPEnabled)

	if err != nil {
		http.Error(w, "Failed to save settings", http.StatusInternalServerError)
		return
	}

	// Update the global email config
	emailConfig.SMTPHost = settings.SMTPHost
	emailConfig.SMTPPort = settings.SMTPPort
	emailConfig.From = settings.SMTPFrom
	emailConfig.Password = settings.SMTPPassword

	json.NewEncoder(w).Encode(map[string]string{
		"message": "SMTP settings updated successfully",
	})
}

func handleTestSMTPConnection(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req struct {
		SMTPHost       string `json:"smtp_host"`
		SMTPPort       int    `json:"smtp_port"`
		SMTPFrom       string `json:"smtp_from"`
		SMTPPassword   string `json:"smtp_password"`
		SMTPEncryption string `json:"smtp_encryption"`
		TestEmail      string `json:"test_email"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	// Send test email
	m := gomail.NewMessage()
	m.SetHeader("From", req.SMTPFrom)
	m.SetHeader("To", req.TestEmail)
	m.SetHeader("Subject", "SMTP Test - App Gateway")
	m.SetBody("text/html", `
		<h2> SMTP Configuration Test</h2>
		<p>This is a test email from your App Gateway SMTP configuration.</p>
		<p>If you received this email, your SMTP settings are working correctly!</p>
		<hr>
		<p style="color: #666; font-size: 12px;">
			<strong>Configuration Details:</strong><br>
			SMTP Host: `+req.SMTPHost+`<br>
			SMTP Port: `+fmt.Sprintf("%d", req.SMTPPort)+`<br>
			Encryption: `+req.SMTPEncryption+`
		</p>
	`)

	d := gomail.NewDialer(req.SMTPHost, req.SMTPPort, req.SMTPFrom, req.SMTPPassword)

	// Set encryption based on selection
	if req.SMTPEncryption == "ssl" {
		d.SSL = true
	} else if req.SMTPEncryption == "none" {
		d.SSL = false
		d.TLSConfig = nil
	}

	if err := d.DialAndSend(m); err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"message": "Failed to send test email: " + err.Error(),
		})
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": "Test email sent successfully to " + req.TestEmail,
	})
}

// ============================================
// HTTP HANDLERS - AUTHENTICATION
// ============================================

func handleLogin(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Username   string `json:"username"`
		Password   string `json:"password"`
		RememberMe bool   `json:"remember_me"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	user, err := getUser(r.Context(), req.Username)
	if err != nil {
		log.Printf("User not found: %v", err)
		http.Error(w, "Invalid credentials", http.StatusUnauthorized)
		return
	}

	if bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)) != nil {
		log.Println("Password mismatch")
		http.Error(w, "Invalid credentials", http.StatusUnauthorized)
		return
	}

	token := generateToken()
	expiresAt := time.Now().Add(24 * time.Hour)
	if req.RememberMe {
		expiresAt = time.Now().Add(30 * 24 * time.Hour)
	}

    // Create session
    session := Session{
        Token:      token,
        Username:   req.Username,
        ExpiresAt:  expiresAt,
        RememberMe: req.RememberMe,
    }
    saveSession(r.Context(), &session)
    
    // ===== SET COOKIE WITH CORRECT DOMAIN =====
    cookie := &http.Cookie{
        Name:     "session_token",  // Use session_token not sessiontoken
        Value:    token,
        Path:     "/",
        Domain:   "localhost",      //  Important: works across all ports
        Expires:  expiresAt,
        HttpOnly: true,
        SameSite: http.SameSiteLaxMode,
    }	
    http.SetCookie(w, cookie)
    // ==========================================
    
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "user": map[string]interface{}{
            "username": user.Username,
            "level":    user.Level,
            "email":    user.Email,
        },
    })
}

func handleLogout(w http.ResponseWriter, r *http.Request) {
	cookie, err := r.Cookie("session_token")
	if err == nil {
		deleteSession(r.Context(), cookie.Value)
	}

	http.SetCookie(w, &http.Cookie{
		Name:     "session_token",
		Value:    "",
		Expires:  time.Now().Add(-1 * time.Hour),
		HttpOnly: true,
		Path:     "/",
	})

	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func handleForgotPassword(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Email string `json:"email"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	users, _ := listUsers(r.Context())
	var user *User
	for _, u := range users {
		if u.Email == req.Email {
			user = u
			break
		}
	}

	if user == nil {
		json.NewEncoder(w).Encode(map[string]string{
			"message": "If the email exists, a password reset link has been sent",
		})
		return
	}

	tempPassword := generateToken()[:12]
	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(tempPassword), bcrypt.DefaultCost)
	user.PasswordHash = string(hashedPassword)
	saveUser(r.Context(), user)

	go sendPasswordResetEmail(user.Email, tempPassword)

	json.NewEncoder(w).Encode(map[string]string{
		"message": "If the email exists, a password reset link has been sent",
	})
}

func handleChangePassword(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req struct {
		OldPassword string `json:"old_password"`
		NewPassword string `json:"new_password"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	user, err := getUser(r.Context(), session.Username)
	if err != nil {
		http.Error(w, "User not found", http.StatusNotFound)
		return
	}

	if bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.OldPassword)) != nil {
		http.Error(w, "Invalid old password", http.StatusUnauthorized)
		return
	}

	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)
	user.PasswordHash = string(hashedPassword)
	saveUser(r.Context(), user)

	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func handleUserInfo(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	user, err := getUser(r.Context(), session.Username)
	if err != nil {
		http.Error(w, "User not found", http.StatusNotFound)
		return
	}

	json.NewEncoder(w).Encode(user)
}

func handleUserApps(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	user, err := getUser(r.Context(), session.Username)
	if err != nil {
		http.Error(w, "User not found", http.StatusNotFound)
		return
	}

	var userApps []*App
	for _, appID := range user.AssignedApps {
		if app, err := getApp(r.Context(), appID); err == nil {
			userApps = append(userApps, app)
		}
	}

	json.NewEncoder(w).Encode(userApps)
}

// ============================================
// USER MANAGEMENT - For Central Server
// ============================================
// ============================================
// USER LIST FOR CENTRAL SERVER
// ============================================

func handleListAllUsers(w http.ResponseWriter, r *http.Request) {
	// Add CORS
	w.Header().Set("Access-Control-Allow-Origin", "http://localhost:8082")
	w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Cookie")
	w.Header().Set("Access-Control-Allow-Credentials", "true")
	w.Header().Set("Content-Type", "application/json")

	if r.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	// Check session
	session, err := getSession(r)
	if err != nil {
		log.Printf(" Session check failed: %v", err)
		http.Error(w, `{"error":"Unauthorized - Please login first"}`, http.StatusUnauthorized)
		return
	}

	// Get user
	user, err := getUser(r.Context(), session.Username)
	if err != nil {
		log.Printf(" User not found: %v", err)
		http.Error(w, `{"error":"User not found"}`, http.StatusUnauthorized)
		return
	}

	// Only admin can list users
	if user.Level != "admin" {
		log.Printf("  Non-admin %s tried to list users", session.Username)
		http.Error(w, `{"error":"Forbidden - Admin access required"}`, http.StatusForbidden)
		return
	}

	// Get all users
	users, err := listUsers(r.Context())
	if err != nil {
		log.Printf(" Failed to list users: %v", err)
		http.Error(w, `{"error":"Failed to retrieve users"}`, http.StatusInternalServerError)
		return
	}

	// Return user list
	var userList []map[string]interface{}
	for _, u := range users {
		userList = append(userList, map[string]interface{}{
			"username":   u.Username,
			"email":      u.Email,
			"level":      u.Level,
			"created_at": u.CreatedAt,
		})
	}

	log.Printf(" Returning %d users to Central Server", len(userList))
	json.NewEncoder(w).Encode(userList)
}


// ============================================
// HTTP HANDLERS - ADMIN
// ============================================

func handleAdminUsers(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	users, err := listUsers(r.Context())
	if err != nil {
		http.Error(w, "Failed to list users", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(users)
}

func handleCreateUser(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req User
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	req.PasswordHash = string(hashedPassword)
	req.ID = generateToken()[:8]
	req.CreatedAt = time.Now()

	if err := saveUser(r.Context(), &req); err != nil {
		http.Error(w, "Failed to create user", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func handleUpdateUser(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req User
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	user, err := getUser(r.Context(), req.Username)
	if err != nil {
		http.Error(w, "User not found", http.StatusNotFound)
		return
	}

	user.Email = req.Email
	user.Level = req.Level
	user.AssignedApps = req.AssignedApps
	saveUser(r.Context(), user)

	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func handleDeleteUser(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	username := r.URL.Query().Get("username")
	if username == "admin" {
		http.Error(w, "Cannot delete admin user", http.StatusBadRequest)
		return
	}

	deleteUser(r.Context(), username)
	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func handleAdminApps(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	apps, err := listApps(r.Context())
	if err != nil {
		http.Error(w, "Failed to list apps", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(apps)
}

func handleCreateApp(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req App
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("Failed to decode app request: %v", err)
		http.Error(w, "Invalid request: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Log icon size for debugging
	if req.Icon != "" {
		log.Printf(" Received app icon of size: %d bytes", len(req.Icon))
	}

	req.ID = generateToken()[:8]
	req.CreatedAt = time.Now()

	apiPassword := generateToken()[:16]
	req.Password = hashPassword(apiPassword)

	if err := saveApp(r.Context(), &req); err != nil {
		log.Printf("Failed to create app: %v", err)
		http.Error(w, "Failed to create app: "+err.Error(), http.StatusInternalServerError)
		return
	}

	log.Printf(" App created successfully: %s (ID: %s)", req.Name, req.ID)

	response := map[string]interface{}{
		"id":           req.ID,
		"name":         req.Name,
		"url":          req.URL,
		"icon":         req.Icon,
		"description":  req.Description,
		"created_at":   req.CreatedAt,
		"api_password": apiPassword,
	}

	json.NewEncoder(w).Encode(response)
}

func handleUpdateApp(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req App
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	app, err := getApp(r.Context(), req.ID)
	if err != nil {
		http.Error(w, "App not found", http.StatusNotFound)
		return
	}

	app.Name = req.Name
	app.URL = req.URL
	app.Icon = req.Icon
	app.Description = req.Description
	saveApp(r.Context(), app)

	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func handleDeleteApp(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	appID := r.URL.Query().Get("id")

	users, _ := listUsers(r.Context())
	for _, user := range users {
		for i, id := range user.AssignedApps {
			if id == appID {
				user.AssignedApps = append(user.AssignedApps[:i], user.AssignedApps[i+1:]...)
				saveUser(r.Context(), user)
				break
			}
		}
	}

	deleteApp(r.Context(), appID)
	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func handleAssignApp(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil || !isAdmin(r.Context(), session.Username) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var req struct {
		Username string `json:"username"`
		AppID    string `json:"app_id"`
		Assign   bool   `json:"assign"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	user, err := getUser(r.Context(), req.Username)
	if err != nil {
		http.Error(w, "User not found", http.StatusNotFound)
		return
	}

	if req.Assign {
		found := false
		for _, id := range user.AssignedApps {
			if id == req.AppID {
				found = true
				break
			}
		}
		if !found {
			user.AssignedApps = append(user.AssignedApps, req.AppID)
		}
	} else {
		for i, id := range user.AssignedApps {
			if id == req.AppID {
				user.AssignedApps = append(user.AssignedApps[:i], user.AssignedApps[i+1:]...)
				break
			}
		}
	}

	saveUser(r.Context(), user)
	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

// ============================================
// PROXY HANDLER
// ============================================

func handleProxy(w http.ResponseWriter, r *http.Request) {
	session, err := getSession(r)
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	pathParts := strings.SplitN(strings.TrimPrefix(r.URL.Path, "/proxy/"), "/", 2)
	if len(pathParts) == 0 || pathParts[0] == "" {
		http.Error(w, "Invalid proxy path", http.StatusBadRequest)
		return
	}

	appID := pathParts[0]
	targetPath := "/"
	if len(pathParts) > 1 {
		targetPath = "/" + pathParts[1]
	}

	app, err := getApp(r.Context(), appID)
	if err != nil {
		log.Printf("App not found: %v", err)
		http.Error(w, "App not found", http.StatusNotFound)
		return
	}

	user, err := getUser(r.Context(), session.Username)
	if err != nil {
		http.Error(w, "User not found", http.StatusUnauthorized)
		return
	}

	hasAccess := false
	for _, id := range user.AssignedApps {
		if id == appID {
			hasAccess = true
			break
		}
	}

	if !hasAccess {
		log.Printf("User %s does not have access to app %s", user.Username, appID)
		http.Error(w, "Access denied", http.StatusForbidden)
		return
	}

	target, err := url.Parse(app.URL)
	if err != nil {
		log.Printf("Invalid app URL: %v", err)
		http.Error(w, "Invalid app URL", http.StatusInternalServerError)
		return
	}

	log.Printf("Proxying: appID=%s target=%s path=%s", appID, target.String(), targetPath)

	proxy := &httputil.ReverseProxy{
		Director: func(req *http.Request) {
			req.URL.Scheme = target.Scheme
			req.URL.Host = target.Host
			req.URL.Path = targetPath
			req.URL.RawQuery = r.URL.RawQuery
			req.Host = target.Host

			req.Header.Set("X-Forwarded-Host", r.Header.Get("Host"))
			req.Header.Set("X-Forwarded-Proto", "http")
			req.Header.Set("X-Real-IP", r.RemoteAddr)
			req.Header.Set("X-Forwarded-For", r.RemoteAddr)
		},
		ModifyResponse: func(resp *http.Response) error {
			resp.Header.Del("X-Frame-Options")
			resp.Header.Del("Content-Security-Policy")
			resp.Header.Set("X-Frame-Options", "ALLOWALL")

			if location := resp.Header.Get("Location"); location != "" {
				if strings.HasPrefix(location, "/") {
					resp.Header.Set("Location", "/proxy/"+appID+location)
				}
			}
			return nil
		},
		ErrorHandler: func(w http.ResponseWriter, r *http.Request, err error) {
			log.Printf("Proxy error: %v", err)
			http.Error(w, "Proxy error: "+err.Error(), http.StatusBadGateway)
		},
	}

	proxy.ServeHTTP(w, r)
}

// ============================================
// HELPER FUNCTIONS
// ============================================

func initializeDefaultAdmin(ctx context.Context) {
	log.Println("Checking for default admin user...")

	_, err := getUser(ctx, "admin")
	if err == nil {
		log.Println(" Admin user already exists")
		return
	}

	log.Println("Creating default admin user...")

	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
	admin := &User{
		ID:           "1",
		Username:     "admin",
		Email:        "admin@example.com",
		PasswordHash: string(hashedPassword),
		Level:        LevelAdmin,
		AssignedApps: []string{},
		CreatedAt:    time.Now(),
	}

	if err := saveUser(ctx, admin); err != nil {
		log.Printf("WARNING: Could not create default admin: %v", err)
		return
	}

	log.Println(" Default admin user created")
	log.Println("  Username: admin")
	log.Println("  Password: admin123")
}

// Check if user is admin
func isAdmin(ctx context.Context, username string) bool {
	var level string
	err := db.QueryRow(ctx, 
		"SELECT level FROM users WHERE username = $1", 
		username,
	).Scan(&level)
	
	if err != nil {
		return false
	}
	
	return level == "admin"
}


func generateToken() string {
	b := make([]byte, 32)
	rand.Read(b)
	return base64.URLEncoding.EncodeToString(b)
}

func hashPassword(password string) string {
	hash := sha256.Sum256([]byte(password))
	return hex.EncodeToString(hash[:])
}


func sendPasswordResetEmail(to, tempPassword string) {
	// Check if SMTP is configured and enabled
	query := `SELECT smtp_host, smtp_port, smtp_from, smtp_password, smtp_enabled 
	          FROM smtp_settings ORDER BY id DESC LIMIT 1`

	var settings SMTPSettings
	err := db.QueryRow(context.Background(), query).Scan(
		&settings.SMTPHost, &settings.SMTPPort, &settings.SMTPFrom,
		&settings.SMTPPassword, &settings.SMTPEnabled)

	if err != nil || settings.SMTPHost == "" || !settings.SMTPEnabled {
		log.Println("SMTP not configured or disabled. Temporary password:", tempPassword)
		return
	}

	m := gomail.NewMessage()
	m.SetHeader("From", settings.SMTPFrom)
	m.SetHeader("To", to)
	m.SetHeader("Subject", "Password Reset - App Gateway")
	m.SetBody("text/html", fmt.Sprintf(`
		<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
			<h2 style="color: #C9313D;">Password Reset Request</h2>
			<p>You have requested to reset your password for the App Gateway system.</p>
			<p>Your temporary password is:</p>
			<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
				<p style="font-size: 24px; font-weight: bold; color: #1B365D; margin: 0; letter-spacing: 2px;">
					%s
				</p>
			</div>
			<p><strong>Important Security Notice:</strong></p>
			<ul>
				<li>Please login and change your password immediately</li>
				<li>This temporary password will work until you change it</li>
				<li>Do not share this password with anyone</li>
			</ul>
			<hr style="border: none; border-top: 1px solid #e0e0e0; margin: 30px 0;">
			<p style="color: #666; font-size: 12px;">
				If you did not request this password reset, please contact your administrator immediately.
			</p>
		</div>
	`, tempPassword))

	d := gomail.NewDialer(settings.SMTPHost, settings.SMTPPort, settings.SMTPFrom, settings.SMTPPassword)

	if err := d.DialAndSend(m); err != nil {
		log.Printf("Failed to send email: %v", err)
		log.Printf("Temporary password for %s: %s", to, tempPassword)
	} else {
		log.Printf(" Password reset email sent to: %s", to)
	}
}
// ============================================
// MAIN
// ============================================

// MAIN
func main() {
	// Initialize database with default config
	defaultConfig := DBConfig{
		Host:     "localhost",
		Port:     5432,
		User:     "postgres",
		Password: "5842",
		DBName:   "sienna_ecad_tools_db",
		MaxConns: 25,
		MinConns: 5,
	}

	if err := initDB(defaultConfig); err != nil {
		log.Fatal("Failed to connect to database:", err)
	}
	defer db.Close()

	// Initialize admin after a short delay
	go func() {
		time.Sleep(2 * time.Second)
		initializeDefaultAdmin(context.Background())
	}()

	// ============================================
	// AUTHENTICATION ENDPOINTS
	// ============================================
	http.HandleFunc("/api/login", handleLogin)
	http.HandleFunc("/api/logout", handleLogout)
	http.HandleFunc("/api/verify-session", handleVerifySession) 
	http.HandleFunc("/api/forgot-password", handleForgotPassword)
	http.HandleFunc("/api/change-password", handleChangePassword)
	http.HandleFunc("/api/user/info", handleUserInfo)
	http.HandleFunc("/api/user/apps", handleUserApps)
	// User management (admin only)
	http.HandleFunc("/api/users/list", handleListAllUsers)


	// ============================================
	// ADMIN USER MANAGEMENT ENDPOINTS
	// ============================================
	http.HandleFunc("/api/admin/users", handleAdminUsers)
	http.HandleFunc("/api/admin/users/create", handleCreateUser)
	http.HandleFunc("/api/admin/users/update", handleUpdateUser)
	http.HandleFunc("/api/admin/users/delete", handleDeleteUser)

	// ============================================
	// ADMIN APP MANAGEMENT ENDPOINTS
	// ============================================
	http.HandleFunc("/api/admin/apps", handleAdminApps)
	http.HandleFunc("/api/admin/apps/create", handleCreateApp)
	http.HandleFunc("/api/admin/apps/update", handleUpdateApp)
	http.HandleFunc("/api/admin/apps/delete", handleDeleteApp)
	http.HandleFunc("/api/admin/assign-app", handleAssignApp)

	// ============================================
	// COMPONENT MANAGEMENT ENDPOINTS
	// ============================================
	http.HandleFunc("/api/components", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == http.MethodPost {
			handleCreateComponent(w, r)
		} else {
			handleGetComponents(w, r)
		}
	})
	http.HandleFunc("/api/components/create", handleCreateComponent)
	http.HandleFunc("/api/components/search", handleSearchComponents)
	http.HandleFunc("/api/components/revisions", handleGetRevisions)
	http.HandleFunc("/api/components/revisions/create", handleCreateRevision)
	http.HandleFunc("/api/components/revisions/delete", handleDeleteRevision)
	http.HandleFunc("/api/components/details", handleGetComponentDetails)
	    //  FOOTPRINT-SPECIFIC ENDPOINTS (NEW)
    http.HandleFunc("/api/components/footprint/create", handleCreateComponentFootprint)
    http.HandleFunc("/api/components/footprint/get", handleGetComponentFootprint)

	// ============================================
	// ADMIN SMTP SETTINGS ENDPOINTS
	// ============================================
	http.HandleFunc("/api/admin/smtp/settings", handleGetSMTPSettings)
	http.HandleFunc("/api/admin/smtp/update", handleUpdateSMTPSettings)
	http.HandleFunc("/api/admin/smtp/test", handleTestSMTPConnection)

	// ============================================
	// ADMIN DATABASE SETTINGS ENDPOINTS
	// ============================================
	http.HandleFunc("/api/admin/db/settings", handleGetDBSettings)
	http.HandleFunc("/api/admin/db/update", handleUpdateDBSettings)
	http.HandleFunc("/api/admin/db/test", handleTestDBConnection)

    // Shared Database Configuration Routes
    http.HandleFunc("/api/admin/shared-db/config", handleGetSharedDatabaseConfig)
    http.HandleFunc("/api/admin/shared-db/update", handleUpdateSharedDatabaseConfig)
    http.HandleFunc("/api/admin/shared-db/apps", handleGetAppDatabaseAccess)
    http.HandleFunc("/api/admin/shared-db/grant", handleGrantAppDatabaseAccess)
    http.HandleFunc("/api/admin/shared-db/revoke", handleRevokeAppDatabaseAccess)
    http.HandleFunc("/api/admin/shared-db/connection-string", handleGetAppConnectionString)

	// ============================================
	// GATEWAY API ENDPOINTS (for external apps)
	// ============================================
	http.HandleFunc("/api/gateway/ingest", handleIngestData)
	http.HandleFunc("/api/gateway/apps/", func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "/data") {
			handleGetAppData(w, r)
		} else if strings.HasSuffix(r.URL.Path, "/tables") {
			handleListAppTables(w, r)
		}
	})

	// Load SMTP settings from database
	go func() {
		time.Sleep(3 * time.Second) // Wait for DB to be ready
		query := `SELECT smtp_host, smtp_port, smtp_from, smtp_password 
		          FROM smtp_settings WHERE smtp_enabled = true 
		          ORDER BY id DESC LIMIT 1`
		var settings SMTPSettings
		err := db.QueryRow(context.Background(), query).Scan(
			&settings.SMTPHost,
			&settings.SMTPPort,
			&settings.SMTPFrom,
			&settings.SMTPPassword,
		)
		if err == nil {
			emailConfig.SMTPHost = settings.SMTPHost
			emailConfig.SMTPPort = settings.SMTPPort
			emailConfig.From = settings.SMTPFrom
			emailConfig.Password = settings.SMTPPassword
			log.Println(" SMTP settings loaded from database")
		}
	}()

	// ============================================
	// APP PROXY ENDPOINT
	// ============================================
	http.HandleFunc("/proxy/", handleProxy)

	// ============================================
	// STATIC FILES
	// ============================================
	// Static files served from ./static directory
	fs := http.FileServer(http.Dir("./static"))
	http.Handle("/", fs)  // Root path  serves static files


	// ============================================
	// START SERVER
	// ============================================
	log.Println("---------------------------------------")
	log.Println(" App Gateway with PostgreSQL")
	log.Println("---------------------------------------")
	log.Println(" Server started on :8081")
	log.Println(" Database: PostgreSQL")
	log.Println(" Gateway API: /api/gateway/ingest")
	log.Println(" Components API: /api/components")
	log.Println("---------------------------------------")
	log.Fatal(http.ListenAndServe(":8081", nil))
}
