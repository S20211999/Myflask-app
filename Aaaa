def init_ui(self):
    """Initialize calculation page UI with cascading dropdowns"""
    layout = QHBoxLayout()
    layout.setSpacing(20)
    
    # Left side - Scrollable Input form
    left_frame = QGroupBox("Price Calculation Input")
    left_frame_layout = QVBoxLayout(left_frame)
    
    # Create scroll area for the input form
    self.input_scroll_area = QScrollArea()
    self.input_scroll_area.setWidgetResizable(True)
    self.input_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
    self.input_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
    
    # Create container widget for the form
    input_container = QWidget()
    input_layout = QVBoxLayout(input_container)
    
    form_layout = QGridLayout()
    form_layout.setSpacing(12)
    row = 0

    # Customer Information (same as before)
    customer_label = QLabel("Customer Information")
    customer_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
    customer_label.setStyleSheet("color: #0078d4; margin: 10px 0 5px 0;")
    form_layout.addWidget(customer_label, row, 0, 1, 2)
    row += 1

    form_layout.addWidget(QLabel("Customer Name:"), row, 0)
    self.customer_input = QLineEdit()
    self.customer_input.setPlaceholderText("Enter customer name...")
    form_layout.addWidget(self.customer_input, row, 1)
    row += 1

    form_layout.addWidget(QLabel("Job Number:"), row, 0)
    self.job_input = QLineEdit()
    self.job_input.setPlaceholderText("Enter job number...")
    form_layout.addWidget(self.job_input, row, 1)
    row += 1
    
    form_layout.addWidget(QLabel("PCB Part Number:"), row, 0)
    self.pcb_part_input = QLineEdit()
    self.pcb_part_input.setPlaceholderText("Enter PCB part number...")
    form_layout.addWidget(self.pcb_part_input, row, 1)
    row += 1

    # PCB Specifications
    pcb_label = QLabel("PCB Specifications")
    pcb_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
    pcb_label.setStyleSheet("color: #0078d4; margin: 15px 0 5px 0;")
    form_layout.addWidget(pcb_label, row, 0, 1, 2)
    row += 1

    form_layout.addWidget(QLabel("Unit:"), row, 0)
    self.unit_combo = QComboBox()
    self.unit_combo.addItems(["mm", "inch"])
    form_layout.addWidget(self.unit_combo, row, 1)
    row += 1

    # PCB Size
    form_layout.addWidget(QLabel("PCB Size (L Ã— W):"), row, 0)
    size_widget = QWidget()
    size_layout = QHBoxLayout(size_widget)
    size_layout.setContentsMargins(0, 0, 0, 0)
    
    self.length_input = QLineEdit()
    self.length_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
    self.length_input.setPlaceholderText("Length")
    
    self.width_input = QLineEdit()
    self.width_input.setValidator(QDoubleValidator(0.1, 9999.0, 2))
    self.width_input.setPlaceholderText("Width")
    
    size_layout.addWidget(QLabel("L:"))
    size_layout.addWidget(self.length_input)
    size_layout.addWidget(QLabel("Ã—"))
    size_layout.addWidget(QLabel("W:"))
    size_layout.addWidget(self.width_input)
    
    form_layout.addWidget(size_widget, row, 1)
    row += 1

    # Create cascading filter fields in sequence
    self.filter_combos = {}
    self.filter_sequence = [
        ("Layers", "Layers"),
        ("Material", "material"),
        ("Board Thickness", "BoardThickness"),
        ("Cu Inner", "CuInner"),
        ("Cu Outer", "CuOuter"),
        ("Surface Finish", "SurfaceFinish"),
        ("Impedance", "Impedance"),
        ("Soldermask", "Soldermask"),
        ("Silkscreen", "Silkscreen"),
        ("Back Drill", "back_drill"),
        ("Blind Via", "blind_via"),
        ("Buried Via", "berried_via")
    ]
    
    for display_name, field_name in self.filter_sequence:
        form_layout.addWidget(QLabel(f"{display_name}:"), row, 0)
        combo = QComboBox()
        combo.setMinimumWidth(200)
        combo.addItem("Any")
        
        # Connect each combo to update subsequent combos
        combo.currentTextChanged.connect(lambda text, field=field_name: self.on_filter_changed(field))
        
        self.filter_combos[field_name] = combo
        form_layout.addWidget(combo, row, 1)
        row += 1

    input_layout.addLayout(form_layout)
    
    # Calculate button
    self.calculate_btn = QPushButton("ðŸ§® Calculate Price")
    self.calculate_btn.setMinimumHeight(50)
    self.calculate_btn.setFont(QFont("Arial", 14, QFont.Weight.Bold))
    self.calculate_btn.clicked.connect(self.calculate_price)
    input_layout.addWidget(self.calculate_btn)
    
    # Set the container widget to the scroll area
    self.input_scroll_area.setWidget(input_container)
    left_frame_layout.addWidget(self.input_scroll_area)
    
    # Right side - Results (same as before)
    right_frame = QGroupBox("Calculation Results")
    right_layout = QVBoxLayout(right_frame)

    self.results_table = QTableWidget()
    self.results_table.setColumnCount(2)
    self.results_table.setHorizontalHeaderLabels(['Parameter', 'Value'])
    self.results_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
    self.results_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
    self.results_table.verticalHeader().setVisible(False)
    self.results_table.setAlternatingRowColors(True)
    self.results_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
    self.results_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
    right_layout.addWidget(self.results_table)

    self.export_btn = QPushButton("ðŸ“Š Export to Excel")
    self.export_btn.setMinimumHeight(45)
    self.export_btn.setFont(QFont("Arial", 12, QFont.Weight.Bold))
    self.export_btn.clicked.connect(self.export_to_excel)
    right_layout.addWidget(self.export_btn)
    
    layout.addWidget(left_frame, 1)
    layout.addWidget(right_frame, 1)
    self.setLayout(layout)

def refresh_data(self):
    """Initial load of all filter options"""
    print("Loading initial filter data...")
    self.load_filter_options()

def on_filter_changed(self, changed_field):
    """Handle when a filter dropdown changes - update subsequent dropdowns"""
    print(f"Filter changed: {changed_field}")
    
    # Find the position of the changed field
    field_names = [field[1] for field in self.filter_sequence]
    try:
        changed_index = field_names.index(changed_field)
    except ValueError:
        return
    
    # Clear and reset all subsequent filters
    for i in range(changed_index + 1, len(field_names)):
        subsequent_field = field_names[i]
        if subsequent_field in self.filter_combos:
            combo = self.filter_combos[subsequent_field]
            combo.blockSignals(True)  # Prevent recursive calls
            combo.clear()
            combo.addItem("Any")
            combo.blockSignals(False)
    
    # Update options for subsequent filters based on current selections
    self.update_subsequent_filters(changed_index)

def update_subsequent_filters(self, from_index):
    """Update dropdown options for filters after the changed one"""
    field_names = [field[1] for field in self.filter_sequence]
    
    # Get currently applied filters up to the changed point
    current_filters = {}
    for i in range(from_index + 1):
        field = field_names[i]
        if field in self.filter_combos:
            value = self.filter_combos[field].currentText()
            if value and value != "Any":
                current_filters[field] = value
    
    print(f"Current filters for cascading: {current_filters}")
    
    # Update each subsequent filter with available options
    for i in range(from_index + 1, len(field_names)):
        field = field_names[i]
        if field in self.filter_combos:
            available_values = self.get_available_values(field, current_filters)
            
            combo = self.filter_combos[field]
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Any")
            if available_values:
                combo.addItems(sorted(set(available_values)))
            combo.blockSignals(False)
            
            print(f"Updated {field} with {len(available_values)} options")

def get_available_values(self, field, current_filters):
    """Get available values for a field based on current filter selections"""
    try:
        # Build query with current filters
        conditions = ["PricePerUnit IS NOT NULL", "PricePerUnit != ''", "Length > 0", "Width > 0"]
        params = []
        
        for filter_field, filter_value in current_filters.items():
            conditions.append(f"{filter_field} = ?")
            params.append(filter_value)
        
        query = f"""
            SELECT DISTINCT {field}
            FROM pcb_data
            WHERE {' AND '.join(conditions)}
            AND {field} IS NOT NULL 
            AND {field} != ''
            ORDER BY {field}
        """
        
        print(f"Query for {field}: {query}")
        print(f"Params: {params}")
        
        self.parent.cursor.execute(query, params)
        results = self.parent.cursor.fetchall()
        values = [str(row[0]) for row in results if row[0]]
        
        print(f"Found {len(values)} values for {field}: {values[:5]}...")  # Show first 5
        return values
        
    except Exception as e:
        print(f"Error getting values for {field}: {e}")
        return []

def load_filter_options(self):
    """Load initial options for the first filter (Layers)"""
    try:
        # Load only the first filter initially
        first_field = self.filter_sequence[0][1]  # "Layers"
        values = self.get_available_values(first_field, {})
        
        if first_field in self.filter_combos and values:
            combo = self.filter_combos[first_field]
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Any")
            combo.addItems(sorted(set(values)))
            combo.blockSignals(False)
            print(f"Loaded {len(values)} options for {first_field}")
            
    except Exception as e:
        print(f"Error loading initial filter options: {e}")
