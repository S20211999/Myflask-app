
import sys
import re
import csv
import json
import math
import statistics
import threading
import sqlite3
import os
from typing import Dict, Any, Optional, Tuple, List, Union
from datetime import datetime, date
from decimal import Decimal
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QTableWidget, QTableWidgetItem, 
    QVBoxLayout, QHBoxLayout, QPushButton, QFileDialog, QLineEdit, QLabel, 
    QMessageBox, QTabWidget, QComboBox, QSpinBox, QColorDialog, QFontDialog,
    QMenuBar, QMenu, QToolBar, QStatusBar, QSplitter, QTextEdit, QCheckBox,
    QProgressBar, QDialog, QDialogButtonBox, QFormLayout, QListWidget,
    QGroupBox, QRadioButton, QSlider, QFrame, QTreeWidget, QTreeWidgetItem,
    QScrollArea, QGridLayout, QButtonGroup, QDoubleSpinBox, QDateEdit,
    QTimeEdit, QCalendarWidget, QInputDialog, QTextBrowser, QPlainTextEdit,
    QToolButton, QWidgetAction, QHeaderView, QAbstractItemView, QSizePolicy
)
from PyQt6.QtCore import (
    Qt, QThread, pyqtSignal, QTimer, QMutex, QMutexLocker, QRect, QDate, QTime,
    QPropertyAnimation, QEasingCurve, QParallelAnimationGroup, QSize, QPoint,
    QSettings, QStandardPaths, QUrl, QMimeData, QIODevice, QTextStream
)
from PyQt6.QtGui import (
    QFont, QColor, QPalette, QIcon, QPixmap, QPainter, QBrush, QPen,
    QAction, QKeySequence, QClipboard, QFontMetrics, QTextCharFormat,
    QTextCursor, QTextDocument, QCursor, QDrag, QValidator, QIntValidator,
    QDoubleValidator, QRegularExpressionValidator, QStandardItemModel
)
from PyQt6.QtCharts import QChart, QChartView, QLineSeries, QBarSeries, QBarSet, QPieSeries

class ExcelFunctions:
    """Comprehensive Excel function library"""
    
    @staticmethod
    def SUM(*args):
        """Excel SUM function"""
        total = 0
        for arg in args:
            if isinstance(arg, (int, float)):
                total += arg
            elif isinstance(arg, str):
                try:
                    total += float(arg)
                except ValueError:
                    pass
        return total
    
    @staticmethod
    def AVERAGE(*args):
        """Excel AVERAGE function"""
        values = []
        for arg in args:
            if isinstance(arg, (int, float)):
                values.append(arg)
            elif isinstance(arg, str):
                try:
                    values.append(float(arg))
                except ValueError:
                    pass
        return sum(values) / len(values) if values else 0
    
    @staticmethod
    def COUNT(*args):
        """Excel COUNT function"""
        count = 0
        for arg in args:
            if isinstance(arg, (int, float)):
                count += 1
            elif isinstance(arg, str):
                try:
                    float(arg)
                    count += 1
                except ValueError:
                    pass
        return count
    
    @staticmethod
    def MAX(*args):
        """Excel MAX function"""
        values = []
        for arg in args:
            if isinstance(arg, (int, float)):
                values.append(arg)
            elif isinstance(arg, str):
                try:
                    values.append(float(arg))
                except ValueError:
                    pass
        return max(values) if values else 0
    
    @staticmethod
    def MIN(*args):
        """Excel MIN function"""
        values = []
        for arg in args:
            if isinstance(arg, (int, float)):
                values.append(arg)
            elif isinstance(arg, str):
                try:
                    values.append(float(arg))
                except ValueError:
                    pass
        return min(values) if values else 0
    
    @staticmethod
    def IF(condition, true_value, false_value):
        """Excel IF function"""
        return true_value if condition else false_value
    
    @staticmethod
    def VLOOKUP(lookup_value, table_array, col_index_num, range_lookup=False):
        """Excel VLOOKUP function (simplified)"""
        # Implementation would require table data structure
        return lookup_value
    
    @staticmethod
    def CONCATENATE(*args):
        """Excel CONCATENATE function"""
        return ''.join(str(arg) for arg in args)
    
    @staticmethod
    def LEFT(text, num_chars):
        """Excel LEFT function"""
        return str(text)[:num_chars]
    
    @staticmethod
    def RIGHT(text, num_chars):
        """Excel RIGHT function"""
        return str(text)[-num_chars:]
    
    @staticmethod
    def MID(text, start_num, num_chars):
        """Excel MID function"""
        return str(text)[start_num-1:start_num-1+num_chars]
    
    @staticmethod
    def ROUND(number, num_digits):
        """Excel ROUND function"""
        return round(float(number), int(num_digits))
    
    @staticmethod
    def TODAY():
        """Excel TODAY function"""
        return date.today()
    
    @staticmethod
    def NOW():
        """Excel NOW function"""
        return datetime.now()

class FormulaEvaluator:
    """Advanced formula evaluation engine"""
    
    def __init__(self, worksheet_data):
        self.worksheet_data = worksheet_data
        self.functions = ExcelFunctions()
        
    def evaluate(self, formula, row, col):
        """Evaluate Excel formula"""
        if not formula.startswith('='):
            return formula
            
        try:
            expr = formula[1:].upper()
            
            # Handle cell references
            expr = re.sub(r'([A-Z]+)([0-9]+)', self._replace_cell_ref, expr)
            
            # Handle ranges
            expr = re.sub(r'([A-Z]+[0-9]+):([A-Z]+[0-9]+)', self._handle_range, expr)
            
            # Handle functions
            expr = self._handle_functions(expr)
            
            # Evaluate safely
            allowed_names = {
                "__builtins__": {},
                "SUM": self.functions.SUM,
                "AVERAGE": self.functions.AVERAGE,
                "COUNT": self.functions.COUNT,
                "MAX": self.functions.MAX,
                "MIN": self.functions.MIN,
                "IF": self.functions.IF,
                "CONCATENATE": self.functions.CONCATENATE,
                "LEFT": self.functions.LEFT,
                "RIGHT": self.functions.RIGHT,
                "MID": self.functions.MID,
                "ROUND": self.functions.ROUND,
                "TODAY": self.functions.TODAY,
                "NOW": self.functions.NOW,
                "abs": abs, "round": round, "min": min, "max": max,
                "sum": sum, "len": len, "int": int, "float": float,
                "pow": pow, "sqrt": math.sqrt, "sin": math.sin, "cos": math.cos,
                "tan": math.tan, "log": math.log, "exp": math.exp
            }
            
            result = eval(expr, allowed_names, {})
            return result
            
        except Exception as e:
            return f"#ERROR: {str(e)}"
    
    def _replace_cell_ref(self, match):
        """Replace cell reference with value"""
        col_str = match.group(1)
        row_str = match.group(2)
        
        col = self._col_str_to_num(col_str)
        row = int(row_str) - 1
        
        key = (row, col)
        if key in self.worksheet_data:
            value = self.worksheet_data[key]
            try:
                return str(float(value))
            except ValueError:
                return f'"{value}"'
        return '0'
    
    def _col_str_to_num(self, col_str):
        """Convert column string to number"""
        col = 0
        for i, char in enumerate(reversed(col_str)):
            col += (ord(char) - ord('A') + 1) * (26 ** i)
        return col - 1
    
    def _handle_range(self, match):
        """Handle range references"""
        # Simplified range handling
        return "0"
    
    def _handle_functions(self, expr):
        """Handle Excel function calls"""
        # This would handle more complex function parsing
        return expr

class RibbonTab(QWidget):
    """Ribbon tab widget"""
    
    def __init__(self, title, parent=None):
        super().__init__(parent)
        self.title = title
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(5, 5, 5, 5)
        self.groups = []
        
    def add_group(self, group):
        """Add group to ribbon tab"""
        self.groups.append(group)
        self.layout.addWidget(group)
        
    def add_separator(self):
        """Add separator to ribbon"""
        separator = QFrame()
        separator.setFrameStyle(QFrame.Shape.VLine | QFrame.Shadow.Sunken)
        separator.setLineWidth(1)
        self.layout.addWidget(separator)

class RibbonGroup(QGroupBox):
    """Ribbon group widget"""
    
    def __init__(self, title, parent=None):
        super().__init__(title, parent)
        self.layout = QGridLayout(self)
        self.layout.setSpacing(2)
        self.row = 0
        self.col = 0
        
    def add_widget(self, widget, row_span=1, col_span=1):
        """Add widget to group"""
        self.layout.addWidget(widget, self.row, self.col, row_span, col_span)
        self.col += col_span
        if self.col >= 3:  # Max 3 columns
            self.col = 0
            self.row += row_span
            
    def add_large_button(self, button):
        """Add large button spanning full height"""
        self.layout.addWidget(button, 0, self.col, 2, 1)
        self.col += 1

class ConditionalFormattingDialog(QDialog):
    """Dialog for conditional formatting"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Conditional Formatting")
        self.setModal(True)
        self.resize(500, 400)
        
        layout = QVBoxLayout(self)
        
        # Rule type
        rule_group = QGroupBox("Rule Type")
        rule_layout = QVBoxLayout(rule_group)
        
        self.rule_types = QComboBox()
        self.rule_types.addItems([
            "Highlight Cells Rules",
            "Top/Bottom Rules", 
            "Data Bars",
            "Color Scales",
            "Icon Sets"
        ])
        rule_layout.addWidget(self.rule_types)
        
        layout.addWidget(rule_group)
        
        # Condition
        condition_group = QGroupBox("Condition")
        condition_layout = QFormLayout(condition_group)
        
        self.condition_type = QComboBox()
        self.condition_type.addItems([
            "Greater than", "Less than", "Between", "Equal to",
            "Text containing", "Date occurring", "Duplicate values"
        ])
        condition_layout.addRow("Type:", self.condition_type)
        
        self.condition_value = QLineEdit()
        condition_layout.addRow("Value:", self.condition_value)
        
        layout.addWidget(condition_group)
        
        # Format
        format_group = QGroupBox("Format")
        format_layout = QHBoxLayout(format_group)
        
        self.font_color_btn = QPushButton("Font Color")
        self.bg_color_btn = QPushButton("Background")
        self.border_btn = QPushButton("Border")
        
        format_layout.addWidget(self.font_color_btn)
        format_layout.addWidget(self.bg_color_btn)
        format_layout.addWidget(self.border_btn)
        
        layout.addWidget(format_group)
        
        # Buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

class ChartDialog(QDialog):
    """Enhanced chart creation dialog"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Insert Chart")
        self.setModal(True)
        self.resize(600, 500)
        
        layout = QVBoxLayout(self)
        
        # Chart types with icons
        type_group = QGroupBox("Chart Type")
        type_layout = QGridLayout(type_group)
        
        chart_types = [
            ("Column", "Clustered Column"),
            ("Line", "Line with Markers"), 
            ("Pie", "Pie Chart"),
            ("Bar", "Clustered Bar"),
            ("Area", "Area Chart"),
            ("Scatter", "Scatter Plot"),
            ("Combo", "Column-Line Combo")
        ]
        
        self.chart_buttons = QButtonGroup()
        for i, (category, name) in enumerate(chart_types):
            btn = QRadioButton(f"{category}\n{name}")
            btn.setObjectName(category.lower())
            self.chart_buttons.addButton(btn, i)
            type_layout.addWidget(btn, i//3, i%3)
            
        chart_types[0][1]  # Select first by default
        self.chart_buttons.button(0).setChecked(True)
        
        layout.addWidget(type_group)
        
        # Data source
        data_group = QGroupBox("Data Source")
        data_layout = QFormLayout(data_group)
        
        self.data_range = QLineEdit()
        self.data_range.setPlaceholderText("A1:D10")
        data_layout.addRow("Data Range:", self.data_range)
        
        self.series_in_rows = QCheckBox("Series in rows")
        self.has_headers = QCheckBox("Headers in first row")
        self.has_headers.setChecked(True)
        
        data_layout.addWidget(self.series_in_rows)
        data_layout.addWidget(self.has_headers)
        
        layout.addWidget(data_group)
        
        # Chart options
        options_group = QGroupBox("Chart Options")
        options_layout = QFormLayout(options_group)
        
        self.chart_title = QLineEdit()
        self.x_axis_title = QLineEdit()
        self.y_axis_title = QLineEdit()
        
        options_layout.addRow("Chart Title:", self.chart_title)
        options_layout.addRow("X-Axis Title:", self.x_axis_title)
        options_layout.addRow("Y-Axis Title:", self.y_axis_title)
        
        layout.addWidget(options_group)
        
        # Buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

class FindReplaceDialog(QDialog):
    """Find and Replace dialog"""
    
    findNext = pyqtSignal(str, bool, bool, bool)  # text, match_case, whole_cell, regex
    replaceNext = pyqtSignal(str, str, bool, bool, bool)  # find, replace, match_case, whole_cell, regex
    replaceAll = pyqtSignal(str, str, bool, bool, bool)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Find & Replace")
        self.setModal(True)
        self.resize(400, 300)
        
        layout = QVBoxLayout(self)
        
        # Tab widget
        tabs = QTabWidget()
        
        # Find tab
        find_tab = QWidget()
        find_layout = QFormLayout(find_tab)
        
        self.find_text = QLineEdit()
        find_layout.addRow("Find what:", self.find_text)
        
        find_options = QGroupBox("Options")
        find_options_layout = QVBoxLayout(find_options)
        
        self.match_case = QCheckBox("Match case")
        self.match_entire_cell = QCheckBox("Match entire cell contents")
        self.use_regex = QCheckBox("Use regular expressions")
        
        find_options_layout.addWidget(self.match_case)
        find_options_layout.addWidget(self.match_entire_cell)
        find_options_layout.addWidget(self.use_regex)
        
        find_layout.addWidget(find_options)
        
        find_buttons = QHBoxLayout()
        self.find_next_btn = QPushButton("Find Next")
        self.find_all_btn = QPushButton("Find All")
        find_buttons.addWidget(self.find_next_btn)
        find_buttons.addWidget(self.find_all_btn)
        find_layout.addRow(find_buttons)
        
        tabs.addTab(find_tab, "Find")
        
        # Replace tab
        replace_tab = QWidget()
        replace_layout = QFormLayout(replace_tab)
        
        self.replace_find_text = QLineEdit()
        self.replace_with_text = QLineEdit()
        
        replace_layout.addRow("Find what:", self.replace_find_text)
        replace_layout.addRow("Replace with:", self.replace_with_text)
        
        replace_options = QGroupBox("Options")
        replace_options_layout = QVBoxLayout(replace_options)
        
        self.replace_match_case = QCheckBox("Match case")
        self.replace_match_entire_cell = QCheckBox("Match entire cell contents")
        self.replace_use_regex = QCheckBox("Use regular expressions")
        
        replace_options_layout.addWidget(self.replace_match_case)
        replace_options_layout.addWidget(self.replace_match_entire_cell)
        replace_options_layout.addWidget(self.replace_use_regex)
        
        replace_layout.addWidget(replace_options)
        
        replace_buttons = QHBoxLayout()
        self.replace_next_btn = QPushButton("Replace")
        self.replace_all_btn = QPushButton("Replace All")
        replace_buttons.addWidget(self.replace_next_btn)
        replace_buttons.addWidget(self.replace_all_btn)
        replace_layout.addRow(replace_buttons)
        
        tabs.addTab(replace_tab, "Replace")
        
        layout.addWidget(tabs)
        
        # Connect signals
        self.find_next_btn.clicked.connect(self.on_find_next)
        self.replace_next_btn.clicked.connect(self.on_replace_next)
        self.replace_all_btn.clicked.connect(self.on_replace_all)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        
    def on_find_next(self):
        self.findNext.emit(
            self.find_text.text(),
            self.match_case.isChecked(),
            self.match_entire_cell.isChecked(),
            self.use_regex.isChecked()
        )
        
    def on_replace_next(self):
        self.replaceNext.emit(
            self.replace_find_text.text(),
            self.replace_with_text.text(),
            self.replace_match_case.isChecked(),
            self.replace_match_entire_cell.isChecked(),
            self.replace_use_regex.isChecked()
        )
        
    def on_replace_all(self):
        self.replaceAll.emit(
            self.replace_find_text.text(),
            self.replace_with_text.text(),
            self.replace_match_case.isChecked(),
            self.replace_match_entire_cell.isChecked(),
            self.replace_use_regex.isChecked()
        )

class FormulaThread(QThread):
    """Multi-threaded formula evaluation"""
    
    resultReady = pyqtSignal(int, int, object)
    errorOccurred = pyqtSignal(int, int, str)
    
    def __init__(self, row, col, formula, worksheet_data, parent=None):
        super().__init__(parent)
        self.row = row
        self.col = col
        self.formula = formula
        self.worksheet_data = worksheet_data
        self.evaluator = FormulaEvaluator(worksheet_data)
        
    def run(self):
        """Execute formula calculation"""
        try:
            result = self.evaluator.evaluate(self.formula, self.row, self.col)
            self.resultReady.emit(self.row, self.col, result)
        except Exception as e:
            self.errorOccurred.emit(self.row, self.col, str(e))

class ExcelWorksheet(QTableWidget):
    """Enhanced Excel worksheet"""
    
    cellChanged = pyqtSignal(int, int, str)
    selectionChanged = pyqtSignal()
    
    def __init__(self, rows=1000, cols=50, parent=None):
        super().__init__(rows, cols, parent)
        self.setup_worksheet()
        self.formulas = {}
        self.formatting = {}
        self.conditional_formats = {}
        self.comments = {}
        self.data_validation = {}
        self.frozen_rows = 0
        self.frozen_cols = 0
        
    def setup_worksheet(self):
        """Setup worksheet appearance and behavior"""
        # Column headers (A, B, C, ..., AA, AB, etc.)
        col_headers = []
        for i in range(self.columnCount()):
            col_headers.append(self._num_to_col_str(i))
        self.setHorizontalHeaderLabels(col_headers)
        
        # Row headers (1, 2, 3, ...)
        row_headers = [str(i + 1) for i in range(self.rowCount())]
        self.setVerticalHeaderLabels(row_headers)
        
        # Set default sizes
        self.setDefaultSectionSize(75)
        self.verticalHeader().setDefaultSectionSize(20)
        
        # Enable selection and editing
        self.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectItems)
        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        
        # Allow resizing
        self.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        self.verticalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        
        # Connect signals
        self.itemChanged.connect(self._on_item_changed)
        self.itemSelectionChanged.connect(self.selectionChanged.emit)
        
    def _num_to_col_str(self, num):
        """Convert column number to Excel-style letter"""
        result = ""
        while num >= 0:
            result = chr(num % 26 + ord('A')) + result
            num = num // 26 - 1
            if num < 0:
                break
        return result
        
    def _on_item_changed(self, item):
        """Handle cell changes"""
        row, col = item.row(), item.column()
        self.cellChanged.emit(row, col, item.text())
        
    def set_cell_formula(self, row, col, formula):
        """Set formula for cell"""
        self.formulas[(row, col)] = formula
        
    def get_cell_formula(self, row, col):
        """Get formula for cell"""
        return self.formulas.get((row, col))
        
    def apply_conditional_formatting(self, ranges, rule_type, condition, format_data):
        """Apply conditional formatting"""
        for cell_range in ranges:
            key = (cell_range, rule_type, condition)
            self.conditional_formats[key] = format_data
            
    def add_comment(self, row, col, comment):
        """Add comment to cell"""
        self.comments[(row, col)] = comment
        
    def set_data_validation(self, row, col, validation_rule):
        """Set data validation for cell"""
        self.data_validation[(row, col)] = validation_rule
        
    def freeze_panes(self, row, col):
        """Freeze panes at specified position"""
        self.frozen_rows = row
        self.frozen_cols = col
        # Implementation for visual freezing would go here

class ExcelClone(QMainWindow):
    """Full-featured Excel clone"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("PyQt6 Excel Clone - Professional Edition")
        self.setGeometry(100, 100, 1400, 900)
        
        # Application data
        self.worksheets = []
        self.current_worksheet_index = 0
        self.clipboard_data = []
        self.undo_stack = []
        self.redo_stack = []
        self.recent_files = []
        self.auto_save_timer = QTimer()
        self.formula_threads = []
        
        # Setup UI components
        self.setup_ui()
        self.setup_ribbon()
        self.setup_status_bar()
        self.setup_shortcuts()
        
        # Create initial worksheet
        self.add_worksheet("Sheet1")
        
        # Load settings
        self.load_settings()
        
        # Setup auto-save
        self.auto_save_timer.timeout.connect(self.auto_save)
        self.auto_save_timer.start(300000)  # 5 minutes
        
    def setup_ui(self):
        """Setup main user interface"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Quick Access Toolbar (simplified)
        qa_toolbar = QToolBar("Quick Access")
        qa_toolbar.setMovable(False)
        qa_toolbar.setFloatable(False)
        qa_toolbar.addAction("💾", self.save_file)
        qa_toolbar.addAction("↶", self.undo)
        qa_toolbar.addAction("↷", self.redo)
        main_layout.addWidget(qa_toolbar)
        
        # Name box and formula bar container
        formula_container = QWidget()
        formula_layout = QHBoxLayout(formula_container)
        formula_layout.setContentsMargins(5, 2, 5, 2)
        
        # Name box
        name_label = QLabel("Name Box")
        self.name_box = QLineEdit()
        self.name_box.setFixedWidth(100)
        self.name_box.setText("A1")
        self.name_box.returnPressed.connect(self.navigate_to_cell)
        
        # Function button
        self.function_btn = QPushButton("fx")
        self.function_btn.setFixedWidth(30)
        self.function_btn.clicked.connect(self.open_function_wizard)
        
        # Formula bar
        self.formula_bar = QLineEdit()
        self.formula_bar.returnPressed.connect(self.apply_formula)
        
        formula_layout.addWidget(name_label)
        formula_layout.addWidget(self.name_box)
        formula_layout.addWidget(self.function_btn)
        formula_layout.addWidget(self.formula_bar)
        
        main_layout.addWidget(formula_container)
        
        # Worksheet container
        self.worksheet_container = QWidget()
        container_layout = QVBoxLayout(self.worksheet_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        
        # Tab widget for worksheets
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.setMovable(True)
        self.tab_widget.currentChanged.connect(self.on_worksheet_changed)
        self.tab_widget.tabCloseRequested.connect(self.close_worksheet)
        
        container_layout.addWidget(self.tab_widget)
        
        # Sheet navigation
        sheet_nav = QWidget()
        sheet_nav_layout = QHBoxLayout(sheet_nav)
        sheet_nav_layout.setContentsMargins(5, 2, 5, 2)
        
        self.sheet_nav_left = QPushButton("◀")
        self.sheet_nav_right = QPushButton("▶")
        self.add_sheet_btn = QPushButton("➕")
        
        self.sheet_nav_left.setFixedSize(25, 20)
        self.sheet_nav_right.setFixedSize(25, 20)
        self.add_sheet_btn.setFixedSize(25, 20)
        
        self.add_sheet_btn.clicked.connect(lambda: self.add_worksheet(f"Sheet{len(self.worksheets) + 1}"))
        
        sheet_nav_layout.addWidget(self.sheet_nav_left)
        sheet_nav_layout.addWidget(self.sheet_nav_right)
        sheet_nav_layout.addWidget(self.add_sheet_btn)
        sheet_nav_layout.addStretch()
        
        # Zoom controls
        zoom_label = QLabel("Zoom:")
        self.zoom_slider = QSlider(Qt.Orientation.Horizontal)
        self.zoom_slider.setRange(50, 200)
        self.zoom_slider.setValue(100)
        self.zoom_slider.setFixedWidth(100)
        self.zoom_label = QLabel("100%")
        self.zoom_slider.valueChanged.connect(self.on_zoom_changed)
        
        sheet_nav_layout.addWidget(zoom_label)
        sheet_nav_layout.addWidget(self.zoom_slider)
        sheet_nav_layout.addWidget(self.zoom_label)
        
        container_layout.addWidget(sheet_nav)
        main_layout.addWidget(self.worksheet_container)
        
    def setup_ribbon(self):
        """Setup ribbon interface"""
        # Create ribbon container
        ribbon_container = QWidget()
        ribbon_layout = QVBoxLayout(ribbon_container)
        ribbon_layout.setContentsMargins(0, 0, 0, 0)
        ribbon_layout.setSpacing(0)
        
        # Tab bar for ribbon
        self.ribbon_tabs = QTabWidget()
        self.ribbon_tabs.setFixedHeight(120)
        
        # Home tab
        home_tab = RibbonTab("Home")
        
        # Clipboard group
        clipboard_group = RibbonGroup("Clipboard")
        
        paste_btn = QPushButton("Paste")
        paste_btn.clicked.connect(self.paste_selection)
        clipboard_group.add_large_button(paste_btn)
        
        cut_btn = QPushButton("Cut")
        copy_btn = QPushButton("Copy")
        format_painter_btn = QPushButton("Format Painter")
        
        cut_btn.clicked.connect(self.cut_selection)
        copy_btn.clicked.connect(self.copy_selection)
        
        clipboard_group.add_widget(cut_btn)
        clipboard_group.add_widget(copy_btn)
        clipboard_group.add_widget(format_painter_btn)
        
        home_tab.add_group(clipboard_group)
        home_tab.add_separator()
        
        # Font group
        font_group = RibbonGroup("Font")
        
        self.font_combo = QComboBox()
        self.font_combo.addItems(["Calibri", "Arial", "Times New Roman", "Helvetica", "Verdana"])
        self.font_combo.currentTextChanged.connect(self.change_font_family)
        
        self.font_size_combo = QComboBox()
        self.font_size_combo.addItems([str(i) for i in [8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 28, 36, 48, 72]])
        self.font_size_combo.setCurrentText("11")
        self.font_size_combo.currentTextChanged.connect(self.change_font_size)
        
        font_group.add_widget(self.font_combo, 1, 2)
        font_group.add_widget(self.font_size_combo)
        
        # Font style buttons
        self.bold_btn = QPushButton("B")
        self.italic_btn = QPushButton("I")
        self.underline_btn = QPushButton("U")
        
        self.bold_btn.setCheckable(True)
        self.italic_btn.setCheckable(True)
        self.underline_btn.setCheckable(True)
        
        font_group.add_widget(self.bold_btn)
        font_group.add_widget(self.italic_btn)
        font_group.add_widget(self.underline_btn)
        
        # Font color buttons
        font_color_btn = QPushButton("A")
        fill_color_btn = QPushButton("🎨")
        
        font_color_btn.clicked.connect(self.change_font_color)
        fill_color_btn.clicked.connect(self.change_fill_color)
        
        font_group.add_widget(font_color_btn)
        font_group.add_widget(fill_color_btn)
        
        home_tab.add_group(font_group)
        home_tab.add_separator()
        
        # Alignment group
        alignment_group = RibbonGroup("Alignment")
        
        # Alignment buttons
        align_left_btn = QPushButton("⬅")
        align_center_btn = QPushButton("⬌")
        align_right_btn = QPushButton("➡")
        
        align_left_btn.clicked.connect(lambda: self.set_alignment(Qt.AlignmentFlag.AlignLeft))
        align_center_btn.clicked.connect(lambda: self.set_alignment(Qt.AlignmentFlag.AlignHCenter))
        align_right_btn.clicked.connect(lambda: self.set_alignment(Qt.AlignmentFlag.AlignRight))
        
        alignment_group.add_widget(align_left_btn)
        alignment_group.add_widget(align_center_btn)
        alignment_group.add_widget(align_right_btn)
        
        # Merge cells
        merge_cells_btn = QPushButton("Merge & Center")
        merge_cells_btn.clicked.connect(self.merge_cells)
        alignment_group.add_widget(merge_cells_btn, 1, 2)
        
        home_tab.add_group(alignment_group)
        home_tab.add_separator()
        
        # Number group
        number_group = RibbonGroup("Number")
        
        self.number_format_combo = QComboBox()
        self.number_format_combo.addItems([
            "General", "Number", "Currency", "Percentage", 
            "Date", "Time", "Text", "Fraction", "Scientific"
        ])
        number_group.add_widget(self.number_format_combo, 1, 2)
        
        percent_btn = QPushButton("%")
        comma_btn = QPushButton(",")
        increase_decimal_btn = QPushButton("00→")
        decrease_decimal_btn = QPushButton("←00")
        
        number_group.add_widget(percent_btn)
        number_group.add_widget(comma_btn)
        number_group.add_widget(increase_decimal_btn)
        number_group.add_widget(decrease_decimal_btn)
        
        home_tab.add_group(number_group)
        home_tab.add_separator()
        
        # Styles group
        styles_group = RibbonGroup("Styles")
        
        conditional_format_btn = QPushButton("Conditional\nFormatting")
        format_table_btn = QPushButton("Format as\nTable")
        cell_styles_btn = QPushButton("Cell\nStyles")
        
        conditional_format_btn.clicked.connect(self.open_conditional_formatting)
        
        styles_group.add_widget(conditional_format_btn)
        styles_group.add_widget(format_table_btn)
        styles_group.add_widget(cell_styles_btn)
        
        home_tab.add_group(styles_group)
        home_tab.add_separator()
        
        # Cells group
        cells_group = RibbonGroup("Cells")
        
        insert_btn = QPushButton("Insert")
        delete_btn = QPushButton("Delete")
        format_btn = QPushButton("Format")
        
        insert_btn.clicked.connect(self.insert_cells_rows_columns)
        delete_btn.clicked.connect(self.delete_cells_rows_columns)
        
        cells_group.add_widget(insert_btn)
        cells_group.add_widget(delete_btn)
        cells_group.add_widget(format_btn)
        
        home_tab.add_group(cells_group)
        home_tab.add_separator()
        
        # Editing group
        editing_group = RibbonGroup("Editing")
        
        autosum_btn = QPushButton("∑\nAutoSum")
        fill_btn = QPushButton("Fill")
        clear_btn = QPushButton("Clear")
        sort_filter_btn = QPushButton("Sort &\nFilter")
        find_select_btn = QPushButton("Find &\nSelect")
        
        autosum_btn.clicked.connect(self.auto_sum)
        find_select_btn.clicked.connect(self.open_find_replace)
        
        editing_group.add_widget(autosum_btn)
        editing_group.add_widget(fill_btn)
        editing_group.add_widget(clear_btn)
        editing_group.add_widget(sort_filter_btn)
        editing_group.add_widget(find_select_btn)
        
        home_tab.add_group(editing_group)
        
        self.ribbon_tabs.addTab(home_tab, "Home")
        
        # Insert tab
        insert_tab = RibbonTab("Insert")
        
        # Tables group
        tables_group = RibbonGroup("Tables")
        pivot_table_btn = QPushButton("PivotTable")
        table_btn = QPushButton("Table")
        tables_group.add_widget(pivot_table_btn)
        tables_group.add_widget(table_btn)
        insert_tab.add_group(tables_group)
        
        # Illustrations group
        illustrations_group = RibbonGroup("Illustrations")
        pictures_btn = QPushButton("Pictures")
        shapes_btn = QPushButton("Shapes")
        icons_btn = QPushButton("Icons")
        smartart_btn = QPushButton("SmartArt")
        screenshot_btn = QPushButton("Screenshot")
        
        illustrations_group.add_widget(pictures_btn)
        illustrations_group.add_widget(shapes_btn)
        illustrations_group.add_widget(icons_btn)
        illustrations_group.add_widget(smartart_btn)
        illustrations_group.add_widget(screenshot_btn)
        insert_tab.add_group(illustrations_group)
        
        # Charts group
        charts_group = RibbonGroup("Charts")
        charts_btn = QPushButton("Insert\nChart")
        charts_btn.clicked.connect(self.insert_chart)
        charts_group.add_large_button(charts_btn)
        insert_tab.add_group(charts_group)
        
        # Add-ins group
        addins_group = RibbonGroup("Add-ins")
        store_btn = QPushButton("Get Add-ins")
        my_addins_btn = QPushButton("My Add-ins")
        addins_group.add_widget(store_btn)
        addins_group.add_widget(my_addins_btn)
        insert_tab.add_group(addins_group)
        
        self.ribbon_tabs.addTab(insert_tab, "Insert")
        
        # Add more tabs...
        self.add_more_ribbon_tabs()
        
        # Insert ribbon into layout
        self.centralWidget().layout().insertWidget(1, self.ribbon_tabs)
        
    def add_more_ribbon_tabs(self):
        """Add remaining ribbon tabs"""
        
        # Page Layout tab
        page_layout_tab = RibbonTab("Page Layout")
        
        themes_group = RibbonGroup("Themes")
        themes_btn = QPushButton("Themes")
        colors_btn = QPushButton("Colors")
        fonts_btn = QPushButton("Fonts")
        effects_btn = QPushButton("Effects")
        themes_group.add_widget(themes_btn)
        themes_group.add_widget(colors_btn)
        themes_group.add_widget(fonts_btn)
        themes_group.add_widget(effects_btn)
        page_layout_tab.add_group(themes_group)
        
        page_setup_group = RibbonGroup("Page Setup")
        margins_btn = QPushButton("Margins")
        orientation_btn = QPushButton("Orientation")
        size_btn = QPushButton("Size")
        print_area_btn = QPushButton("Print Area")
        breaks_btn = QPushButton("Breaks")
        background_btn = QPushButton("Background")
        print_titles_btn = QPushButton("Print Titles")
        
        page_setup_group.add_widget(margins_btn)
        page_setup_group.add_widget(orientation_btn)
        page_setup_group.add_widget(size_btn)
        page_setup_group.add_widget(print_area_btn)
        page_setup_group.add_widget(breaks_btn)
        page_setup_group.add_widget(background_btn)
        page_setup_group.add_widget(print_titles_btn)
        page_layout_tab.add_group(page_setup_group)
        
        self.ribbon_tabs.addTab(page_layout_tab, "Page Layout")
        
        # Formulas tab
        formulas_tab = RibbonTab("Formulas")
        
        function_library_group = RibbonGroup("Function Library")
        insert_function_btn = QPushButton("Insert\nFunction")
        autosum_btn2 = QPushButton("AutoSum")
        recently_used_btn = QPushButton("Recently\nUsed")
        financial_btn = QPushButton("Financial")
        logical_btn = QPushButton("Logical")
        text_btn = QPushButton("Text")
        date_time_btn = QPushButton("Date &\nTime")
        lookup_btn = QPushButton("Lookup &\nReference")
        math_btn = QPushButton("Math &\nTrig")
        more_functions_btn = QPushButton("More\nFunctions")
        
        insert_function_btn.clicked.connect(self.open_function_wizard)
        
        function_library_group.add_widget(insert_function_btn)
        function_library_group.add_widget(autosum_btn2)
        function_library_group.add_widget(recently_used_btn)
        function_library_group.add_widget(financial_btn)
        function_library_group.add_widget(logical_btn)
        function_library_group.add_widget(text_btn)
        function_library_group.add_widget(date_time_btn)
        function_library_group.add_widget(lookup_btn)
        function_library_group.add_widget(math_btn)
        function_library_group.add_widget(more_functions_btn)
        formulas_tab.add_group(function_library_group)
        
        formula_auditing_group = RibbonGroup("Formula Auditing")
        trace_precedents_btn = QPushButton("Trace\nPrecedents")
        trace_dependents_btn = QPushButton("Trace\nDependents")
        remove_arrows_btn = QPushButton("Remove\nArrows")
        show_formulas_btn = QPushButton("Show\nFormulas")
        error_checking_btn = QPushButton("Error\nChecking")
        evaluate_formula_btn = QPushButton("Evaluate\nFormula")
        watch_window_btn = QPushButton("Watch\nWindow")
        
        formula_auditing_group.add_widget(trace_precedents_btn)
        formula_auditing_group.add_widget(trace_dependents_btn)
        formula_auditing_group.add_widget(remove_arrows_btn)
        formula_auditing_group.add_widget(show_formulas_btn)
        formula_auditing_group.add_widget(error_checking_btn)
        formula_auditing_group.add_widget(evaluate_formula_btn)
        formula_auditing_group.add_widget(watch_window_btn)
        formulas_tab.add_group(formula_auditing_group)
        
        self.ribbon_tabs.addTab(formulas_tab, "Formulas")
        
        # Data tab
        data_tab = RibbonTab("Data")
        
        get_external_data_group = RibbonGroup("Get External Data")
        from_access_btn = QPushButton("From\nAccess")
        from_web_btn = QPushButton("From\nWeb")
        from_text_btn = QPushButton("From\nText")
        from_other_btn = QPushButton("From\nOther Sources")
        existing_connections_btn = QPushButton("Existing\nConnections")
        
        get_external_data_group.add_widget(from_access_btn)
        get_external_data_group.add_widget(from_web_btn)
        get_external_data_group.add_widget(from_text_btn)
        get_external_data_group.add_widget(from_other_btn)
        get_external_data_group.add_widget(existing_connections_btn)
        data_tab.add_group(get_external_data_group)
        
        sort_filter_group = RibbonGroup("Sort & Filter")
        sort_btn = QPushButton("Sort")
        filter_btn = QPushButton("Filter")
        clear_btn2 = QPushButton("Clear")
        reapply_btn = QPushButton("Reapply")
        advanced_btn = QPushButton("Advanced")
        
        sort_btn.clicked.connect(self.sort_data)
        filter_btn.clicked.connect(self.filter_data)
        
        sort_filter_group.add_widget(sort_btn)
        sort_filter_group.add_widget(filter_btn)
        sort_filter_group.add_widget(clear_btn2)
        sort_filter_group.add_widget(reapply_btn)
        sort_filter_group.add_widget(advanced_btn)
        data_tab.add_group(sort_filter_group)
        
        data_tools_group = RibbonGroup("Data Tools")
        text_to_columns_btn = QPushButton("Text to\nColumns")
        remove_duplicates_btn = QPushButton("Remove\nDuplicates")
        data_validation_btn = QPushButton("Data\nValidation")
        consolidate_btn = QPushButton("Consolidate")
        what_if_analysis_btn = QPushButton("What-If\nAnalysis")
        
        data_validation_btn.clicked.connect(self.open_data_validation)
        
        data_tools_group.add_widget(text_to_columns_btn)
        data_tools_group.add_widget(remove_duplicates_btn)
        data_tools_group.add_widget(data_validation_btn)
        data_tools_group.add_widget(consolidate_btn)
        data_tools_group.add_widget(what_if_analysis_btn)
        data_tab.add_group(data_tools_group)
        
        self.ribbon_tabs.addTab(data_tab, "Data")
        
        # Review tab
        review_tab = RibbonTab("Review")
        
        proofing_group = RibbonGroup("Proofing")
        spelling_btn = QPushButton("Spelling")
        thesaurus_btn = QPushButton("Thesaurus")
        translate_btn = QPushButton("Translate")
        
        proofing_group.add_widget(spelling_btn)
        proofing_group.add_widget(thesaurus_btn)
        proofing_group.add_widget(translate_btn)
        review_tab.add_group(proofing_group)
        
        comments_group = RibbonGroup("Comments")
        new_comment_btn = QPushButton("New\nComment")
        delete_comment_btn = QPushButton("Delete")
        previous_btn = QPushButton("Previous")
        next_btn = QPushButton("Next")
        show_hide_btn = QPushButton("Show/Hide\nComments")
        
        new_comment_btn.clicked.connect(self.add_comment)
        
        comments_group.add_widget(new_comment_btn)
        comments_group.add_widget(delete_comment_btn)
        comments_group.add_widget(previous_btn)
        comments_group.add_widget(next_btn)
        comments_group.add_widget(show_hide_btn)
        review_tab.add_group(comments_group)
        
        changes_group = RibbonGroup("Changes")
        protect_sheet_btn = QPushButton("Protect\nSheet")
        protect_workbook_btn = QPushButton("Protect\nWorkbook")
        share_workbook_btn = QPushButton("Share\nWorkbook")
        track_changes_btn = QPushButton("Track\nChanges")
        
        changes_group.add_widget(protect_sheet_btn)
        changes_group.add_widget(protect_workbook_btn)
        changes_group.add_widget(share_workbook_btn)
        changes_group.add_widget(track_changes_btn)
        review_tab.add_group(changes_group)
        
        self.ribbon_tabs.addTab(review_tab, "Review")
        
        # View tab
        view_tab = RibbonTab("View")
        
        workbook_views_group = RibbonGroup("Workbook Views")
        normal_btn = QPushButton("Normal")
        page_break_btn = QPushButton("Page Break\nPreview")
        page_layout_btn = QPushButton("Page\nLayout")
        custom_views_btn = QPushButton("Custom\nViews")
        
        workbook_views_group.add_widget(normal_btn)
        workbook_views_group.add_widget(page_break_btn)
        workbook_views_group.add_widget(page_layout_btn)
        workbook_views_group.add_widget(custom_views_btn)
        view_tab.add_group(workbook_views_group)
        
        show_group = RibbonGroup("Show")
        ruler_cb = QCheckBox("Ruler")
        gridlines_cb = QCheckBox("Gridlines")
        formula_bar_cb = QCheckBox("Formula Bar")
        headings_cb = QCheckBox("Headings")
        
        gridlines_cb.setChecked(True)
        formula_bar_cb.setChecked(True)
        headings_cb.setChecked(True)
        
        show_group.add_widget(ruler_cb)
        show_group.add_widget(gridlines_cb)
        show_group.add_widget(formula_bar_cb)
        show_group.add_widget(headings_cb)
        view_tab.add_group(show_group)
        
        zoom_group = RibbonGroup("Zoom")
        zoom_btn = QPushButton("Zoom")
        zoom_100_btn = QPushButton("100%")
        zoom_to_selection_btn = QPushButton("Zoom to\nSelection")
        
        zoom_group.add_widget(zoom_btn)
        zoom_group.add_widget(zoom_100_btn)
        zoom_group.add_widget(zoom_to_selection_btn)
        view_tab.add_group(zoom_group)
        
        window_group = RibbonGroup("Window")
        new_window_btn = QPushButton("New\nWindow")
        arrange_all_btn = QPushButton("Arrange\nAll")
        freeze_panes_btn = QPushButton("Freeze\nPanes")
        split_btn = QPushButton("Split")
        hide_btn = QPushButton("Hide")
        unhide_btn = QPushButton("Unhide")
        view_side_by_side_btn = QPushButton("View Side\nby Side")
        synchronous_scrolling_btn = QPushButton("Synchronous\nScrolling")
        reset_window_position_btn = QPushButton("Reset Window\nPosition")
        
        freeze_panes_btn.clicked.connect(self.freeze_panes)
        
        window_group.add_widget(new_window_btn)
        window_group.add_widget(arrange_all_btn)
        window_group.add_widget(freeze_panes_btn)
        window_group.add_widget(split_btn)
        window_group.add_widget(hide_btn)
        window_group.add_widget(unhide_btn)
        window_group.add_widget(view_side_by_side_btn)
        window_group.add_widget(synchronous_scrolling_btn)
        window_group.add_widget(reset_window_position_btn)
        view_tab.add_group(window_group)
        
        macros_group = RibbonGroup("Macros")
        macros_btn = QPushButton("Macros")
        macros_group.add_widget(macros_btn)
        view_tab.add_group(macros_group)
        
        self.ribbon_tabs.addTab(view_tab, "View")
        
    def setup_status_bar(self):
        """Setup comprehensive status bar"""
        self.status_bar = self.statusBar()
        
        # Ready indicator
        self.ready_label = QLabel("Ready")
        self.status_bar.addWidget(self.ready_label)
        
        # Cell mode indicator
        self.cell_mode_label = QLabel("Ready")
        self.status_bar.addPermanentWidget(self.cell_mode_label)
        
        # Calculation status
        self.calc_label = QLabel("Calculate")
        self.status_bar.addPermanentWidget(self.calc_label)
        
        # Selection statistics
        self.selection_stats = QLabel("")
        self.status_bar.addPermanentWidget(self.selection_stats)
        
        # Zoom control (already added in setup_ui)
        
        # Macro recording indicator
        self.macro_indicator = QLabel("")
        self.status_bar.addPermanentWidget(self.macro_indicator)
        
    def setup_shortcuts(self):
        """Setup keyboard shortcuts"""
        # File operations
        QAction("New", self, shortcut=QKeySequence.StandardKey.New, triggered=self.new_workbook)
        QAction("Open", self, shortcut=QKeySequence.StandardKey.Open, triggered=self.open_file)
        QAction("Save", self, shortcut=QKeySequence.StandardKey.Save, triggered=self.save_file)
        QAction("Save As", self, shortcut=QKeySequence.StandardKey.SaveAs, triggered=self.save_file_as)
        QAction("Print", self, shortcut=QKeySequence.StandardKey.Print, triggered=self.print_worksheet)
        
        # Edit operations
        QAction("Undo", self, shortcut=QKeySequence.StandardKey.Undo, triggered=self.undo)
        QAction("Redo", self, shortcut=QKeySequence.StandardKey.Redo, triggered=self.redo)
        QAction("Cut", self, shortcut=QKeySequence.StandardKey.Cut, triggered=self.cut_selection)
        QAction("Copy", self, shortcut=QKeySequence.StandardKey.Copy, triggered=self.copy_selection)
        QAction("Paste", self, shortcut=QKeySequence.StandardKey.Paste, triggered=self.paste_selection)
        QAction("Select All", self, shortcut=QKeySequence.StandardKey.SelectAll, triggered=self.select_all)
        QAction("Find", self, shortcut=QKeySequence.StandardKey.Find, triggered=self.open_find_replace)
        QAction("Replace", self, shortcut=QKeySequence.StandardKey.Replace, triggered=self.open_find_replace)
        
        # Formatting shortcuts
        QAction("Bold", self, shortcut=QKeySequence("Ctrl+B"), triggered=self.toggle_bold)
        QAction("Italic", self, shortcut=QKeySequence("Ctrl+I"), triggered=self.toggle_italic)
        QAction("Underline", self, shortcut=QKeySequence("Ctrl+U"), triggered=self.toggle_underline)
        
        # Add shortcuts to main window
        for action in self.findChildren(QAction):
            self.addAction(action)
            
    # Worksheet management
    def add_worksheet(self, name):
        """Add new worksheet"""
        worksheet = ExcelWorksheet()
        worksheet.cellChanged.connect(self.on_cell_changed)
        worksheet.selectionChanged.connect(self.on_selection_changed)
        
        self.worksheets.append(worksheet)
        self.tab_widget.addTab(worksheet, name)
        self.tab_widget.setCurrentWidget(worksheet)
        
    def close_worksheet(self, index):
        """Close worksheet"""
        if len(self.worksheets) > 1:
            self.tab_widget.removeTab(index)
            del self.worksheets[index]
            
    def on_worksheet_changed(self, index):
        """Handle worksheet change"""
        self.current_worksheet_index = index
        self.on_selection_changed()
        
    def get_current_worksheet(self):
        """Get current worksheet"""
        if 0 <= self.current_worksheet_index < len(self.worksheets):
            return self.worksheets[self.current_worksheet_index]
        return None
        
    # Cell and selection handling
    def on_cell_changed(self, row, col, value):
        """Handle cell changes"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        if value.startswith('='):
            # Formula - evaluate in thread
            self.evaluate_formula_threaded(row, col, value)
        else:
            # Regular value
            self.update_cell_display(row, col, value)
            
    def on_selection_changed(self):
        """Handle selection changes"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if current:
            row, col = current.row(), current.column()
            
            # Update name box
            cell_ref = f"{worksheet._num_to_col_str(col)}{row + 1}"
            self.name_box.setText(cell_ref)
            
            # Update formula bar
            formula = worksheet.get_cell_formula(row, col)
            if formula:
                self.formula_bar.setText(formula)
            else:
                self.formula_bar.setText(current.text() if current.text() else "")
                
            # Update selection statistics
            self.update_selection_statistics()
            
    def update_selection_statistics(self):
        """Update selection statistics in status bar"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        selected_items = worksheet.selectedItems()
        if len(selected_items) > 1:
            # Calculate statistics for selection
            values = []
            for item in selected_items:
                try:
                    values.append(float(item.text()))
                except (ValueError, TypeError):
                    pass
                    
            if values:
                count = len(values)
                sum_val = sum(values)
                avg_val = sum_val / count
                min_val = min(values)
                max_val = max(values)
                
                stats_text = f"Count: {count} Sum: {sum_val:.2f} Average: {avg_val:.2f} Min: {min_val:.2f} Max: {max_val:.2f}"
                self.selection_stats.setText(stats_text)
            else:
                self.selection_stats.setText("")
        else:
            self.selection_stats.setText("")
            
    def evaluate_formula_threaded(self, row, col, formula):
        """Evaluate formula in separate thread"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        # Collect worksheet data
        worksheet_data = {}
        for r in range(worksheet.rowCount()):
            for c in range(worksheet.columnCount()):
                item = worksheet.item(r, c)
                if item and item.text():
                    worksheet_data[(r, c)] = item.text()
                    
        # Create and start thread
        thread = FormulaThread(row, col, formula, worksheet_data, self)
        thread.resultReady.connect(self.on_formula_result)
        thread.errorOccurred.connect(self.on_formula_error)
        thread.start()
        
        self.formula_threads.append(thread)
        
    def on_formula_result(self, row, col, result):
        """Handle formula result"""
        worksheet = self.get_current_worksheet()
        if worksheet:
            item = QTableWidgetItem(str(result))
            worksheet.setItem(row, col, item)
            
    def on_formula_error(self, row, col, error):
        """Handle formula error"""
        worksheet = self.get_current_worksheet()
        if worksheet:
            item = QTableWidgetItem(f"#ERROR: {error}")
            item.setForeground(QBrush(QColor("red")))
            worksheet.setItem(row, col, item)
            
    def update_cell_display(self, row, col, value):
        """Update cell display with proper formatting"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        item = worksheet.item(row, col)
        if not item:
            item = QTableWidgetItem()
            worksheet.setItem(row, col, item)
            
        # Apply number formatting based on format selection
        format_type = self.number_format_combo.currentText()
        formatted_value = self.format_cell_value(value, format_type)
        item.setText(formatted_value)
        
    def format_cell_value(self, value, format_type):
        """Format cell value according to format type"""
        try:
            if format_type == "Number":
                return f"{float(value):,.2f}"
            elif format_type == "Currency":
                return f"${float(value):,.2f}"
            elif format_type == "Percentage":
                return f"{float(value) * 100:.1f}%"
            elif format_type == "Date":
                # Simplified date formatting
                return str(value)
            elif format_type == "Time":
                # Simplified time formatting
                return str(value)
            elif format_type == "Scientific":
                return f"{float(value):.2e}"
            else:  # General or Text
                return str(value)
        except (ValueError, TypeError):
            return str(value)
            
    # Formula bar and navigation
    def apply_formula(self):
        """Apply formula from formula bar"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if not current:
            return
            
        formula = self.formula_bar.text()
        row, col = current.row(), current.column()
        
        if formula.startswith('='):
            worksheet.set_cell_formula(row, col, formula)
            self.evaluate_formula_threaded(row, col, formula)
        else:
            worksheet.set_cell_formula(row, col, None)
            current.setText(formula)
            
    def navigate_to_cell(self):
        """Navigate to cell specified in name box"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        cell_ref = self.name_box.text().upper()
        
        # Parse cell reference (e.g., "A1", "B5")
        match = re.match(r'([A-Z]+)([0-9]+)', cell_ref)
        if match:
            col_str = match.group(1)
            row_str = match.group(2)
            
            # Convert to indices
            col = worksheet._col_str_to_num(col_str)
            row = int(row_str) - 1
            
            if 0 <= row < worksheet.rowCount() and 0 <= col < worksheet.columnCount():
                worksheet.setCurrentCell(row, col)
                
    def auto_sum(self):
        """Auto sum selected range"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        selected_ranges = worksheet.selectedRanges()
        if not selected_ranges:
            return
            
        # Get first selected range
        range_item = selected_ranges[0]
        
        # Find next available cell for sum
        sum_row = range_item.bottomRow() + 1
        sum_col = range_item.rightColumn()
        
        if sum_row < worksheet.rowCount():
            # Create SUM formula
            start_cell = f"{worksheet._num_to_col_str(range_item.leftColumn())}{range_item.topRow() + 1}"
            end_cell = f"{worksheet._num_to_col_str(range_item.rightColumn())}{range_item.bottomRow() + 1}"
            formula = f"=SUM({start_cell}:{end_cell})"
            
            # Set formula
            item = QTableWidgetItem()
            worksheet.setItem(sum_row, sum_col, item)
            worksheet.set_cell_formula(sum_row, sum_col, formula)
            self.evaluate_formula_threaded(sum_row, sum_col, formula)
            
            # Select the sum cell
            worksheet.setCurrentCell(sum_row, sum_col)
            
    # File operations
    def new_workbook(self):
        """Create new workbook"""
        reply = QMessageBox.question(
            self, "New Workbook",
            "Create new workbook? Unsaved changes will be lost.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Clear all worksheets
            self.tab_widget.clear()
            self.worksheets.clear()
            
            # Add initial worksheet
            self.add_worksheet("Sheet1")
            self.ready_label.setText("Ready")
            
    def open_file(self):
        """Open file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open File", "",
            "Excel Files (*.xlsx *.xls);;CSV Files (*.csv);;All Files (*)"
        )
        
        if file_path:
            try:
                if file_path.endswith('.csv'):
                    self.load_csv_file(file_path)
                elif file_path.endswith(('.xlsx', '.xls')):
                    QMessageBox.information(self, "Info", "Excel file support requires openpyxl library")
                    
                self.add_to_recent_files(file_path)
                self.ready_label.setText(f"Opened {os.path.basename(file_path)}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to open file: {str(e)}")
                
    def save_file(self):
        """Save current file"""
        # For demo, save as CSV
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save File", "",
            "CSV Files (*.csv);;Excel Files (*.xlsx);;All Files (*)"
        )
        
        if file_path:
            try:
                if file_path.endswith('.csv'):
                    self.save_csv_file(file_path)
                else:
                    QMessageBox.information(self, "Info", "Only CSV export is supported in this demo")
                    
                self.ready_label.setText(f"Saved {os.path.basename(file_path)}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save file: {str(e)}")
                
    def save_file_as(self):
        """Save file as"""
        self.save_file()
        
    def load_csv_file(self, file_path):
        """Load CSV file into current worksheet"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        with open(file_path, 'r', newline='', encoding='utf-8') as file:
            csv_reader = csv.reader(file)
            
            worksheet.setRowCount(0)
            worksheet.setColumnCount(0)
            
            for row_idx, row_data in enumerate(csv_reader):
                if row_idx >= worksheet.rowCount():
                    worksheet.setRowCount(row_idx + 1)
                if len(row_data) > worksheet.columnCount():
                    worksheet.setColumnCount(len(row_data))
                    
                for col_idx, cell_data in enumerate(row_data):
                    item = QTableWidgetItem(str(cell_data))
                    worksheet.setItem(row_idx, col_idx, item)
                    
    def save_csv_file(self, file_path):
        """Save current worksheet as CSV"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        with open(file_path, 'w', newline='', encoding='utf-8') as file:
            csv_writer = csv.writer(file)
            
            for row in range(worksheet.rowCount()):
                row_data = []
                empty_row = True
                
                for col in range(worksheet.columnCount()):
                    item = worksheet.item(row, col)
                    cell_value = item.text() if item else ""
                    row_data.append(cell_value)
                    if cell_value:
                        empty_row = False
                        
                if not empty_row:
                    csv_writer.writerow(row_data)
                else:
                    break
                    
    def print_worksheet(self):
        """Print current worksheet"""
        QMessageBox.information(self, "Print", "Print functionality would be implemented here")
        
    def add_to_recent_files(self, file_path):
        """Add file to recent files list"""
        if file_path in self.recent_files:
            self.recent_files.remove(file_path)
        self.recent_files.insert(0, file_path)
        self.recent_files = self.recent_files[:10]  # Keep only 10 recent files
        
    def auto_save(self):
        """Auto-save current workbook"""
        # Implementation for auto-save
        pass
        
    # Edit operations
    def undo(self):
        """Undo last operation"""
        if self.undo_stack:
            operation = self.undo_stack.pop()
            self.redo_stack.append(operation)
            # Apply reverse operation
            self.ready_label.setText("Undo")
            
    def redo(self):
        """Redo last undone operation"""
        if self.redo_stack:
            operation = self.redo_stack.pop()
            self.undo_stack.append(operation)
            # Apply operation
            self.ready_label.setText("Redo")
            
    def cut_selection(self):
        """Cut selected cells"""
        self.copy_selection()
        self.clear_selection()
        
    def copy_selection(self):
        """Copy selected cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        selected_ranges = worksheet.selectedRanges()
        if not selected_ranges:
            return
            
        # Copy first selected range
        range_item = selected_ranges[0]
        self.clipboard_data = []
        
        for row in range(range_item.topRow(), range_item.bottomRow() + 1):
            row_data = []
            for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                item = worksheet.item(row, col)
                row_data.append(item.text() if item else "")
            self.clipboard_data.append(row_data)
            
        # Also copy to system clipboard
        clipboard_text = '\n'.join(['\t'.join(row) for row in self.clipboard_data])
        QApplication.clipboard().setText(clipboard_text)
        
        self.ready_label.setText("Copied")
        
    def paste_selection(self):
        """Paste copied cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if not current:
            return
            
        start_row, start_col = current.row(), current.column()
        
        # Try pasting from internal clipboard first
        if self.clipboard_data:
            data = self.clipboard_data
        else:
            # Try system clipboard
            clipboard_text = QApplication.clipboard().text()
            if not clipboard_text:
                return
                
            data = []
            for line in clipboard_text.split('\n'):
                if line:
                    data.append(line.split('\t'))
                    
        # Paste data
        for row_offset, row_data in enumerate(data):
            for col_offset, cell_data in enumerate(row_data):
                target_row = start_row + row_offset
                target_col = start_col + col_offset
                
                if (target_row < worksheet.rowCount() and 
                    target_col < worksheet.columnCount()):
                    item = QTableWidgetItem(str(cell_data))
                    worksheet.setItem(target_row, target_col, item)
                    
        self.ready_label.setText("Pasted")
        
    def clear_selection(self):
        """Clear selected cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        for item in worksheet.selectedItems():
            item.setText("")
            
    def select_all(self):
        """Select all cells"""
        worksheet = self.get_current_worksheet()
        if worksheet:
            worksheet.selectAll()
            
    # Formatting operations
    def change_font_family(self, family):
        """Change font family of selected cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        for item in worksheet.selectedItems():
            font = item.font()
            font.setFamily(family)
            item.setFont(font)
            
    def change_font_size(self, size_str):
        """Change font size of selected cells"""
        try:
            size = int(size_str)
            worksheet = self.get_current_worksheet()
            if not worksheet:
                return
                
            for item in worksheet.selectedItems():
                font = item.font()
                font.setPointSize(size)
                item.setFont(font)
        except ValueError:
            pass
            
    def toggle_bold(self):
        """Toggle bold formatting"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        items = worksheet.selectedItems()
        if not items:
            return
            
        # Check if any item is bold
        any_bold = any(item.font().bold() for item in items)
        
        for item in items:
            font = item.font()
            font.setBold(not any_bold)
            item.setFont(font)
            
        self.bold_btn.setChecked(not any_bold)
        
    def toggle_italic(self):
        """Toggle italic formatting"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        items = worksheet.selectedItems()
        if not items:
            return
            
        any_italic = any(item.font().italic() for item in items)
        
        for item in items:
            font = item.font()
            font.setItalic(not any_italic)
            item.setFont(font)
            
        self.italic_btn.setChecked(not any_italic)
        
    def toggle_underline(self):
        """Toggle underline formatting"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        items = worksheet.selectedItems()
        if not items:
            return
            
        any_underline = any(item.font().underline() for item in items)
        
        for item in items:
            font = item.font()
            font.setUnderline(not any_underline)
            item.setFont(font)
            
        self.underline_btn.setChecked(not any_underline)
        
    def change_font_color(self):
        """Change font color"""
        color = QColorDialog.getColor(Qt.GlobalColor.black, self)
        if color.isValid():
            worksheet = self.get_current_worksheet()
            if worksheet:
                for item in worksheet.selectedItems():
                    item.setForeground(QBrush(color))
                    
    def change_fill_color(self):
        """Change cell background color"""
        color = QColorDialog.getColor(Qt.GlobalColor.white, self)
        if color.isValid():
            worksheet = self.get_current_worksheet()
            if worksheet:
                for item in worksheet.selectedItems():
                    item.setBackground(QBrush(color))
                    
    def set_alignment(self, alignment):
        """Set text alignment"""
        worksheet = self.get_current_worksheet()
        if worksheet:
            for item in worksheet.selectedItems():
                item.setTextAlignment(alignment)
                
    def merge_cells(self):
        """Merge selected cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        selected_ranges = worksheet.selectedRanges()
        if not selected_ranges:
            return
            
        range_item = selected_ranges[0]
        
        # Get text from top-left cell
        top_left_item = worksheet.item(range_item.topRow(), range_item.leftColumn())
        merge_text = top_left_item.text() if top_left_item else ""
        
        # Clear all cells in range
        for row in range(range_item.topRow(), range_item.bottomRow() + 1):
            for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                item = worksheet.item(row, col)
                if item:
                    item.setText("")
                    
        # Set merged text in top-left cell
        if not top_left_item:
            top_left_item = QTableWidgetItem()
            worksheet.setItem(range_item.topRow(), range_item.leftColumn(), top_left_item)
        top_left_item.setText(merge_text)
        
        # Span the cell (simplified - Qt doesn't support true cell merging in QTableWidget)
        worksheet.setSpan(
            range_item.topRow(), range_item.leftColumn(),
            range_item.rowCount(), range_item.columnCount()
        )
        
    # Advanced features
    def open_conditional_formatting(self):
        """Open conditional formatting dialog"""
        dialog = ConditionalFormattingDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Apply conditional formatting
            QMessageBox.information(self, "Conditional Formatting", "Applied conditional formatting")
            
    def open_find_replace(self):
        """Open find and replace dialog"""
        dialog = FindReplaceDialog(self)
        dialog.findNext.connect(self.find_text)
        dialog.replaceNext.connect(self.replace_text)
        dialog.replaceAll.connect(self.replace_all_text)
        dialog.show()
        
    def find_text(self, text, match_case, whole_cell, use_regex):
        """Find text in worksheet"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        # Simple find implementation
        for row in range(worksheet.rowCount()):
            for col in range(worksheet.columnCount()):
                item = worksheet.item(row, col)
                if item and item.text():
                    cell_text = item.text()
                    search_text = text
                    
                    if not match_case:
                        cell_text = cell_text.lower()
                        search_text = search_text.lower()
                        
                    if whole_cell:
                        found = cell_text == search_text
                    elif use_regex:
                        found = re.search(search_text, cell_text) is not None
                    else:
                        found = search_text in cell_text
                        
                    if found:
                        worksheet.setCurrentCell(row, col)
                        return
                        
        QMessageBox.information(self, "Find", f"'{text}' not found")
        
    def replace_text(self, find_text, replace_text, match_case, whole_cell, use_regex):
        """Replace text in current cell"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if current and current.text():
            cell_text = current.text()
            
            if not match_case:
                # Case insensitive replacement
                if use_regex:
                    new_text = re.sub(find_text, replace_text, cell_text, flags=re.IGNORECASE)
                else:
                    new_text = cell_text.replace(find_text, replace_text)
            else:
                if use_regex:
                    new_text = re.sub(find_text, replace_text, cell_text)
                else:
                    new_text = cell_text.replace(find_text, replace_text)
                    
            current.setText(new_text)
            
    def replace_all_text(self, find_text, replace_text, match_case, whole_cell, use_regex):
        """Replace all occurrences of text"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        count = 0
        for row in range(worksheet.rowCount()):
            for col in range(worksheet.columnCount()):
                item = worksheet.item(row, col)
                if item and item.text():
                    old_text = item.text()
                    
                    if not match_case:
                        if use_regex:
                            new_text = re.sub(find_text, replace_text, old_text, flags=re.IGNORECASE)
                        else:
                            new_text = old_text.replace(find_text, replace_text)
                    else:
                        if use_regex:
                            new_text = re.sub(find_text, replace_text, old_text)
                        else:
                            new_text = old_text.replace(find_text, replace_text)
                            
                    if new_text != old_text:
                        item.setText(new_text)
                        count += 1
                        
        QMessageBox.information(self, "Replace All", f"Replaced {count} occurrences")
        
    def insert_chart(self):
        """Insert chart"""
        dialog = ChartDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Create chart based on selection
            chart_type = dialog.chart_buttons.checkedId()
            data_range = dialog.data_range.text()
            
            # For demo, just show message
            QMessageBox.information(self, "Chart", f"Would insert chart of type {chart_type} with range {data_range}")
            
    def open_function_wizard(self):
        """Open function wizard"""
        functions = [
            "SUM", "AVERAGE", "COUNT", "MAX", "MIN", "IF", "VLOOKUP",
            "CONCATENATE", "LEFT", "RIGHT", "MID", "ROUND", "TODAY", "NOW"
        ]
        
        function, ok = QInputDialog.getItem(
            self, "Insert Function", "Choose function:", functions, 0, False
        )
        
        if ok and function:
            self.formula_bar.setText(f"={function}(")
            self.formula_bar.setFocus()
            
    def sort_data(self):
        """Sort selected data"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        selected_ranges = worksheet.selectedRanges()
        if not selected_ranges:
            QMessageBox.warning(self, "Sort", "Please select a range to sort")
            return
            
        # Simple ascending sort implementation
        range_item = selected_ranges[0]
        
        # Collect data
        data = []
        for row in range(range_item.topRow(), range_item.bottomRow() + 1):
            row_data = []
            for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                item = worksheet.item(row, col)
                row_data.append(item.text() if item else "")
            data.append(row_data)
            
        # Sort by first column
        try:
            data.sort(key=lambda x: float(x[0]) if x[0].replace('.', '').replace('-', '').isdigit() else x[0])
        except (ValueError, IndexError):
            data.sort(key=lambda x: x[0] if x else "")
            
        # Write back sorted data
        for i, row_data in enumerate(data):
            row = range_item.topRow() + i
            for j, cell_data in enumerate(row_data):
                col = range_item.leftColumn() + j
                item = worksheet.item(row, col)
                if not item:
                    item = QTableWidgetItem()
                    worksheet.setItem(row, col, item)
                item.setText(cell_data)
                
    def filter_data(self):
        """Apply filter to data"""
        QMessageBox.information(self, "Filter", "Filter functionality would be implemented here")
        
    def add_comment(self):
        """Add comment to selected cell"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if not current:
            return
            
        comment, ok = QInputDialog.getMultiLineText(
            self, "Add Comment", "Comment:", ""
        )
        
        if ok and comment:
            row, col = current.row(), current.column()
            worksheet.add_comment(row, col, comment)
            
            # Visual indicator (simplified)
            current.setBackground(QBrush(QColor(255, 255, 200)))
            
    def open_data_validation(self):
        """Open data validation dialog"""
        QMessageBox.information(self, "Data Validation", "Data validation dialog would open here")
        
    def freeze_panes(self):
        """Freeze panes"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if current:
            row, col = current.row(), current.column()
            worksheet.freeze_panes(row, col)
            QMessageBox.information(self, "Freeze Panes", f"Frozen panes at row {row+1}, column {col+1}")
            
    def insert_cells_rows_columns(self):
        """Insert cells, rows, or columns"""
        options = ["Cells (Shift Right)", "Cells (Shift Down)", "Entire Row", "Entire Column"]
        choice, ok = QInputDialog.getItem(
            self, "Insert", "Insert:", options, 0, False
        )
        
        if ok:
            worksheet = self.get_current_worksheet()
            if worksheet:
                current = worksheet.currentItem()
                if current:
                    if "Row" in choice:
                        worksheet.insertRow(current.row())
                    elif "Column" in choice:
                        worksheet.insertColumn(current.column())
                        
    def delete_cells_rows_columns(self):
        """Delete cells, rows, or columns"""
        options = ["Cells (Shift Left)", "Cells (Shift Up)", "Entire Row", "Entire Column"]
        choice, ok = QInputDialog.getItem(
            self, "Delete", "Delete:", options, 0, False
        )
        
        if ok:
            worksheet = self.get_current_worksheet()
            if worksheet:
                current = worksheet.currentItem()
                if current:
                    if "Row" in choice:
                        worksheet.removeRow(current.row())
                    elif "Column" in choice:
                        worksheet.removeColumn(current.column())
                        
    # View operations
    def on_zoom_changed(self, value):
        """Handle zoom slider change"""
        self.zoom_label.setText(f"{value}%")
        
        # Apply zoom to current worksheet
        worksheet = self.get_current_worksheet()
        if worksheet:
            font = worksheet.font()
            base_size = 9
            new_size = int(base_size * value / 100)
            font.setPointSize(max(6, min(72, new_size)))
            worksheet.setFont(font)
            
    # Settings and cleanup
    def load_settings(self):
        """Load application settings"""
        settings = QSettings("PyQt6ExcelClone", "Settings")
        
        # Window geometry
        geometry = settings.value("geometry")
        if geometry:
            self.restoreGeometry(geometry)
            
        # Recent files
        self.recent_files = settings.value("recent_files", [])
        if not isinstance(self.recent_files, list):
            self.recent_files = []
            
    def save_settings(self):
        """Save application settings"""
        settings = QSettings("PyQt6ExcelClone", "Settings")
        settings.setValue("geometry", self.saveGeometry())
        settings.setValue("recent_files", self.recent_files)
        
    def closeEvent(self, event):
        """Handle application close"""
        # Save settings
        self.save_settings()
        
        # Clean up threads
        for thread in self.formula_threads:
            if thread.isRunning():
                thread.terminate()
                thread.wait()
                
        # Check for unsaved changes
        reply = QMessageBox.question(
            self, "Exit", "Save changes before closing?",
            QMessageBox.StandardButton.Save | 
            QMessageBox.StandardButton.Discard |
            QMessageBox.StandardButton.Cancel
        )
        
        if reply == QMessageBox.StandardButton.Save:
            self.save_file()
            event.accept()
        elif reply == QMessageBox.StandardButton.Discard:
            event.accept()
        else:
            event.ignore()

def main():
    """Main application entry point"""
    app = QApplication(sys.argv)
    app.setApplicationName("PyQt6 Excel Clone")
    app.setApplicationVersion("2.0")
    app.setOrganizationName("PyQt6 Development")
    
    # Set application style
    app.setStyle('Fusion')
    
    # Apply modern theme
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(240, 240, 240))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(0, 0, 0))
    palette.setColor(QPalette.ColorRole.Base, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(245, 245, 245))
    app.setPalette(palette)
    
    # Create and show main window
    window = ExcelClone()
    window.show()
    
    # Start event loop
    sys.exit(app.exec())

if __name__ == '__main__':
    main()
