;###########################################################################
;#                                                                         #
;#   Smart Reference Designator Placement on Silkscreen and Assembly      #
;#                                                                         #
;#  This routine places Silkscreen and Assembly Reference Designators     #
;#  beside components with intelligent space detection. It finds the      #
;#  side with maximum available space, maintains minimum clearances,      #
;#  and avoids overlapping components and vias.                           #
;#                                                                         #
;#  Features:                                                              #
;#  - Places text beside components, not on them                          #
;#  - Checks all sides for maximum available space                        #
;#  - Maintains 0.6 unit clearance from components                        #
;#  - Avoids overlapping vias when possible                               #
;#  - Places outside board boundary when no space available               #
;#  - User-configurable text size (default 0.81)                          #
;#                                                                         #
;#  Usage:  rotate_silkassy (from within Allegro)                          #
;###########################################################################
 
;##########################
;#  Register Program Name #
;##########################
axlCmdRegister("rotate_silkassy" 'RotateSilkAssyRD)
;#############################
;# MAIN Program Starts Here. #
;#############################
(defun RotateSilkAssyRD ()
  ; ==== Initialize Global Variables ====
  Layer_List         = nil
  Text_List          = nil
  justify            = ""
  LRBT               = t        ; Left to Right, Bottom to Top
  LRTB               = nil      ; Left to Right, Top to Bottom
  RLBT               = nil      ; Right to Left, Bottom to Top
  RLTB               = nil      ; Right to Left, Top to Bottom
  CenterAssy         = nil      ; Changed to nil since we're placing beside components
  ChangeTextSize     = t        ; Enable text size changing
  TextBlockLarge     = 6
  TextBlockMedium    = 3
  TextBlockSmall     = 1
  tblk_large         = "6"
  tblk_medium        = "3"
  tblk_small         = "1"
 
  ; New variables for intelligent placement
  MinClearance       = 0.6          ; Minimum clearance from components
  DefaultTextSize    = 0.81         ; Default text size
  UserTextSize       = 0.81         ; User-configurable text size
  AvoidVias          = t            ; Try to avoid placing on vias
  PlaceOutsideBoard  = t            ; Allow placement outside board if no space
 
  SilkTop            = nil
  SilkBot            = nil
  AssyTop            = nil
  AssyBot            = nil
  silktop_layer      = "REF DES/SILKSCREEN_TOP"
  silkbot_layer      = "REF DES/SILKSCREEN_BOTTOM"
  assytop_layer      = "REF DES/ASSEMBLY_TOP"
  assybot_layer      = "REF DES/ASSEMBLY_BOTTOM"
  BoardOutline       = nil          ; Initialize board outline variable
  FormDir            = "./"
 
 if( axlOKToProceed() then
     
      ; ==== Create and Display the User Interface ====
 
      createRotateRDForm()
      fFile = strcat( FormDir "rotateRDForm.form" )
      Form = axlFormCreate( (gensym)  fFile  nil 'rotateRDForm_Action t)
      axlFormSetField(Form "LRBT" LRBT)
      axlFormSetField(Form "LRTB" LRTB)
      axlFormSetField(Form "RLBT" RLBT)
      axlFormSetField(Form "RLTB" RLTB)
      axlFormSetField(Form "CenterAssy" CenterAssy)
      axlFormSetField(Form "TextBlockLarge" TextBlockLarge)
      axlFormSetField(Form "TextBlockMedium" TextBlockMedium)
      axlFormSetField(Form "TextBlockSmall" TextBlockSmall)
      axlFormSetField(Form "UserTextSize" UserTextSize )
      axlFormSetField(Form "MinClearance" MinClearance )
      axlFormSetField(Form "AvoidVias" AvoidVias)
      axlFormDisplay( Form )
  else
      printf("E- Please terminate your interactive command .\n")
  );endif OKToProceed
 
); end defun - MAIN Program
 
;############################################################################
;# doRotateSilkAssy - When OK is hit, perform Reference Designator Rotation #
;############################################################################
(defun doRotateSilkAssy ()
   axlClearSelSet ()
 
   axlSetFindFilter ('?enabled   (list "noall"  "text")
                     '?onButtons (list "text")
                     )
 
   axlMsgPut("Smart RD placement started.")
 
   ; Get board outline for boundary checking
   BoardOutline = getBoardOutline()
 
   foreach (layer Layer_List
       axlVisibleDesign (nil)
       axlVisibleLayer (layer t)
 
       Text_List = axlGetSelSet(axlAddSelectAll())
 
       (if (car (and (listp Text_List) Text_List))
      rotateSilkAssy()
       )
 
       axlClearSelSet()
       axlFlushDisplay()
       axlMsgPut (strcat( layer " Smart placement completed."))
   )
 
   ; ==== Turn On Top/Bottom Silk & Assembly Layers, if they were changed. ====
   Display_List = list("paramLayerGroup:BOARD GEOMETRY/paramLayer:OUTLINE")
 
   (if  AssyTop == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:ASSEMBLY_TOP" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:ASSEMBLY_TOP"          Display_List)
   )
 
   (if  AssyBot == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:ASSEMBLY_BOTTOM" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:ASSEMBLY_BOTTOM"          Display_List)
   )
 
   (if  SilkTop == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:SILKSCREEN_TOP" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:SILKSCREEN_TOP"          Display_List)
   )
 
   (if  SilkBot == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:SILKSCREEN_BOTTOM" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:SILKSCREEN_BOTTOM"          Display_List)
   )
 
  foreach ( Layer Display_List
            val = axlGetParam(Layer)
            val->visible = t
            axlSetParam(val)
          )
)
 
 
;######################################################################  
;# getBoardOutline - Get the board outline for boundary checking     #
;######################################################################  
(defun getBoardOutline ()
  (let ((outlineList nil) (boardBBox nil))
        axlClearSelSet()
 
    axlSetFindFilter('?enabled '("noall" "shape")
                      '?onButtons '("shape")
                      '?layerName '("BOARD GEOMETRY/OUTLINE"))
 
    outlineList = axlGetSelSet(axlAddSelectAll())
 
    (if outlineList
        boardBBox = (car outlineList)->bBox
        boardBBox = list(list(-10000 -10000) list(10000 10000))
    )
 
    axlClearSelSet()
    boardBBox
  )
)
 
 
;######################################################################  
;# findOptimalTextPosition - Find the best position for text placement#
;######################################################################  
(defun findOptimalTextPosition (componentBBox textWidth textHeight)
  (let ((positions (list)) (bestPos nil) (maxSpace 0) (currentSpace 0) (testX 0) (testY 0) (testPositions nil)
        (comp_llx 0) (comp_lly 0) (comp_urx 0) (comp_ury 0) (comp_centerX 0) (comp_centerY 0)))
 
    ; Calculate component center and dimensions
    comp_llx     = xCoord(car(componentBBox))
    comp_lly     = yCoord(car(componentBBox))
    comp_urx     = xCoord(cadr(componentBBox))
    comp_ury     = yCoord(cadr(componentBBox))
    comp_centerX = (comp_urx + comp_llx) / 2
    comp_centerY = (comp_ury + comp_lly) / 2  
    ; Define candidate positions: Right, Left, Top, Bottom
    testPositions = list(
        list(comp_urx + MinClearance + (textWidth / 2),  comp_centerY, "RIGHT")
        list(comp_llx - MinClearance - (textWidth / 2), comp_centerY, "LEFT")
        list(comp_centerX, comp_ury + MinClearance + (textHeight / 2), "TOP")
        list(comp_centerX, comp_lly - MinClearance - (textHeight / 2), "BOTTOM")
      )
 
    ; Evaluate each position
    (foreach testPos testPositions
      testX = car(testPos)
      testY = cadr(testPos)
      side  = caddr(testPos)
 
      currentSpace = calculateAvailableSpace(testX, testY, textWidth, textHeight, side)
 
     (if (currentSpace >= maxSpace
          maxSpace = currentSpace
          bestPos = list(testX, testY, side, maxSpace)
         )
      )
 
    ; If no good position found, try outside board
    (if ((bestPos == nil) || (maxSpace < (textWidth * textHeight))
    (if (PlaceOutsideBoard == t
    bestPos = findPositionOutsideBoard(componentBBox, textWidth, textHeight)
    )
   )
 
    bestPos
  )
)
    ))
 
;######################################################################  
;# calculateAvailableSpace - Calculate available space at position   #
;######################################################################  
(defun calculateAvailableSpace (testX testY textWidth textHeight side)
  (let ((space (times textWidth textHeight)) (conflictFound nil) (textBBox nil))
 
    ; Create test bounding box for text
   textBBox = list(
  list(testX - (textWidth / 2), testY - (textHeight / 2)),
  list(testX + (textWidth / 2), testY + (textHeight / 2))
  )
 
    ; Check for conflicts with other components
    conflictFound = checkComponentConflicts(textBBox)
 
    ; Check for conflicts with vias if avoiding them
   
        conflictFound = checkViaConflicts(textBBox)
    )
 
    ; If conflict found, reduce space significantly
    (if conflictFound == t then
        space = 0
    )
 
    space
  )
 
;######################################################################  
;# checkComponentConflicts - Check if text conflicts with components  #
;######################################################################  
(defun checkComponentConflicts (textBBox)
  (let ((conflictFound nil) (componentList nil))
 
    ; Get all components in the area
    axlClearSelSet()
    axlSetFindFilter('?enabled '("noall" "symbol")
                     '?onButtons '("symbol"))
 
    componentList = axlGetSelSet(axlAddSelectAll())
 
    (foreach comp componentList
      (if (boundingBoxOverlap(textBBox, comp->bBox, MinClearance) then
          conflictFound = t
      )
    )
 
    axlClearSelSet()
    conflictFound
  )
)
)
;######################################################################  
;# checkViaConflicts - Check if text conflicts with vias             #
;######################################################################  
(defun checkViaConflicts (textBBox)
  (let ((conflictFound nil) (viaList nil))
    ; Get all vias in the area
    axlClearSelSet()
    axlSetFindFilter '?enabled '("noall" "via")
                      '?onButtons '("via")
    viaList = axlGetSelSet (axlAddSelectAll())
    (foreach via viaList
      (if (boundingBoxOverlap textBBox (getq via 'bBox) (quotient MinClearance 2)) then
          conflictFound = t
      )
    )
    axlClearSelSet()
    conflictFound
  )
)
 
;######################################################################  
;# boundingBoxOverlap - Check if two bounding boxes overlap         #
;######################################################################  
(defun boundingBoxOverlap (bbox1 bbox2 clearance)
  (let ((box1_llx 0) (box1_lly 0) (box1_urx 0) (box1_ury 0)
        (box2_llx 0) (box2_lly 0) (box2_urx 0) (box2_ury 0))
 
    ; ==== Replace setq with = as in RotateSilkAssyRD ====
    box1_llx = ((xCoord (car bbox1)) - clearance)
    box1_lly = ((yCoord (car bbox1)) - clearance)
    box1_urx = ((xCoord (cadr bbox1)) + clearance)
    box1_ury = ((yCoord (cadr bbox1)) + clearance)
 
 
    box2_llx = (xCoord (car bbox2))
    box2_lly = (yCoord (car bbox2))
    box2_urx = (xCoord (cadr bbox2))
    box2_ury = (yCoord (cadr bbox2))
 
    ; ==== Overlap check ====
    (! (or (box1_urx < box2_llx)
       (box1_llx > box2_urx)
       (box1_ury < box2_lly)
       (box1_lly > box2_ury)))
 
  )
)
 
 
;######################################################################  
;# findPositionOutsideBoard - Find position outside board boundary   #
;######################################################################  
(defun findPositionOutsideBoard (componentBBox textWidth textHeight)
  (let ((comp_centerX 0) (comp_centerY 0) (boardCenterX 0) (boardCenterY 0) (bestPos nil))
      comp_centerX = ((xCoord (car componentBBox)) + (xCoord (cadr componentBBox))) / 2
      comp_centerY = ((yCoord (car componentBBox)) + (yCoord (cadr componentBBox))) / 2
      ; Get board center
      (if BoardOutline then
          boardCenterX = ((xCoord (car BoardOutline)) + (xCoord (cadr BoardOutline))) / 2
          boardCenterY = ((yCoord (car BoardOutline)) + (yCoord (cadr BoardOutline))) / 2
      ; Place text outside board in direction away from board center
      (if (lessp comp_centerX boardCenterX) then
        ; Place to the right of board
        bestPos = (list ((xCoord (cadr BoardOutline)) + (textWidth / 2) + MinClearance) comp_centerY "OUTSIDE_RIGHT" 1000)
      else
        ; Place to the left of board
        bestPos = (list ((xCoord (car BoardOutline)) - (textWidth / 2) - MinClearance) comp_centerY "OUTSIDE_LEFT" 1000)
      )
      else
        ; No board outline found, place to the right of component
        bestPos = (list ((xCoord (cadr componentBBox)) + (textWidth / 2) + (MinClearance * 2)) comp_centerY "OUTSIDE_DEFAULT" 1000)
 
    )
    bestPos
  )
)
 
;######################################################################  
;# rotateSilkAssy - Smart placement of reference designators         #
;######################################################################  
(defun rotateSilkAssy ()
   (foreach text_id Text_List
        ; ==== retrieve current information on text id ====
         changeit = 0
         text     =  text_id->text
         xy       =  text_id->xy
         txt_x    =  xCoord ( xy )
         txt_y    =  yCoord ( xy )
         txt_tblk =  text_id->textBlock
        ; ==== Change Text to "Center" Justification for ease of use ====
         txt_jus=  text_id->justify
        (if (not (equal txt_jus "CENTER"))
             changeit = 1
        )
        ; ==== Check current rotation against preferred orientation ====
         txt_rot = text_id->rotation
        (if  LRBT == t then
            (if  txt_rot == 180 then
                 txt_rot =  0
                 changeit = 1
            )
            (if  txt_rot == 270 then
                 txt_rot = 90
                 changeit = 1
            )
        )
        (if  LRTB == t then
            (if  txt_rot == 180 then
                 txt_rot = 0
                 changeit = 1
            )
            (if  txt_rot == 90 then
                 txt_rot = 270
                 changeit = 1
            )
        )
        (if  RLBT == t then
            (if  txt_rot == 180 then
                 txt_rot = 0
                 changeit = 1
            )
            (if  txt_rot == 270 then
                 txt_rot = 90
                 changeit = 1
            )
        )
        (if  RLTB == t then
            (if  txt_rot == 180 then
                 txt_rot  = 0
                 changeit = 1
            )
            (if  txt_rot == 90 then
                 txt_rot  = 270
                 changeit = 1
             )
          )
        )
        ; ==== Smart Positioning Logic ====
         txt_lyr = text_id->layer
        (if  txt_lyr == assytop_layer ||  txt_lyr == assybot_layer ||  txt_lyr == silktop_layer || txt_lyr == silkbot_layer then
            (if  CenterAssy == t then
                ; Legacy mode - center at component origin
                (foreach childid text_id->parent->children
                        (if   childid->layer == "PACKAGE GEOMETRY/PLACE_BOUND_TOP"||
                                 childid->layer == "PACKAGE GEOMETRY/PLACE_BOUND_BOTTOM" then                
                             sym_llx = (xCoord (car childid->bBox))
                             sym_lly = (yCoord (car childid->bBox))
                             sym_urx = (xCoord (cadr childid->bBox))
                             sym_ury = (yCoord (cadr childid->bBox)))
                             sym_x = (sym_urx + sym_llx) / 2
                             sym_y = (sym_ury + sym_lly) / 2
                        )
                )
                if( txt_rot ==   0 then sym_y = sym_y - 20 )
                if( txt_rot ==  90 then sym_x = sym_x + 20 )
                if( txt_rot == 180 then sym_y = sym_y + 20 )
                if( txt_rot == 270 then sym_x = sym_x - 20 )
                 xy    = list (sym_x sym_y)
                 changeit = 1
            else
                ; Smart placement mode
                ; Get component bounding box
                 componentBBox = text_id->parent->bBox
                ; Estimate text dimensions based on user text size
                textWidth  = ((length text) * UserTextSize * 0.7)
                textHeight = (UserTextSize * 1.2)
                ; Find optimal position
                 optimalPos = (findOptimalTextPosition componentBBox textWidth textHeight)
                 (if optimalPos t nil)
                     xy = (list (car optimalPos) (cadr optimalPos))
                     changeit = 1
                    ; Adjust rotation based on placement side
                     placementSide = (caddr optimalPos)
                    (case placementSide
                      ("LEFT"
                        (if  txt_rot == 0 then  txt_rot = 90)
                        (if  txt_rot == 180 then  txt_rot = 270)
                      )
                      ("RIGHT"  
                        (if  txt_rot == 0 then  txt_rot = 270)
                        (if  txt_rot == 180 then txt_rot = 90)
                      )
                    )
               
           
            ; Apply user text size
            (if ( ChangeTextSize == t)
                (progn
                   changeit = 1
      ; Convert user text size to appropriate text block
            (if   UserTextSize > 1.0 || UserTextSize == 1.0
                 txt_tblk = tblk_large
                (if   UserTextSize > 0.6 || UserTextSize == 0.6
                     txt_tblk = tblk_medium
                     txt_tblk = tblk_small
                ))
      )
    )
 
        ; ==== Do text movement, if anything has changed ====
        (if  changeit == 1 then createTextBlock_RD ()
      )
)
)
;####################################################################  
;# createTextBlock_RD - Create text record with smart positioning   #
;####################################################################  
(defun createTextBlock_RD ()
  textBlock = txt_tblk
  rotation  = txt_rot
  parent_id =  text_id->parent        ; symbol association
  mirrored  = text_id->isMirrored   ; t/nil
  justify   =  "CENTER"               ; "LEFT" "CENTER" "RIGHT"
  ; ==== setup defstruct for text insertion ====
  textOrientation = (make_axlTextOrientation ?textBlock textBlock
                                                 ?rotation  rotation
                                                 ?mirrored  mirrored
                                                 ?justify   justify)
  ; ==== Add new text and delete the existing text if successful ===
   update = axlDBCreateText (text xy textOrientation
                                text_id->layer parent_id)
    (if (not (equal update nil))
    axlDeleteObject ( list( text_id ))
    axlMsgPut((strcat " Update Failed on " text))
)
 
)
 
;###########################################################
;# Form CallBacks - Handle user interface interactions    #
;###########################################################
(defun rotateRDForm_Action (Form)
 
   (case Form->curField
     ("SilkTop"
         SilkTop=Form->curValue
     )
     ("SilkBot"
         SilkBot=Form->curValue
     )
     ("AssyTop"
         AssyTop=Form->curValue
     )
     ("AssyBot"
         AssyBot=Form->curValue
     )
     ("LRBT"
         LRBT=Form->curValue
         orient_0   =  t
         orient_90  =  t
         orient_180 = nil
         orient_270 = nil
     )
     ("LRTB"
         LRTB=Form->curValue
         orient_0   =  t
         orient_90  = nil
         orient_180 = nil
         orient_270 =  t
     )
     ("RLBT"
         RLBT=Form->curValue
         orient_0   = nil
         orient_90  = t
         orient_180 = t
         orient_270 = nil
     )
     ("RLTB"
         RLTB=Form->curValue
         orient_0   =  nil
         orient_90  =  nil
         orient_180 =  t
         orient_270 =  t
     )
     ("CenterAssy"
         CenterAssy=Form->curValue
     )
     ("ChangeTextSize"
         ChangeTextSize=Form->curValue
     )
     ("TextBlockLarge"
         TextBlockLarge=Form->curValue
        sprintf( tblk_large "%L" TextBlockLarge )
     )
     ("TextBlockMedium"
         TextBlockMedium=Form->curValue
        sprintf( tblk_medium "%L" TextBlockMedium )
     )
     ("TextBlockSmall"
         TextBlockSmall=Form->curValue
        sprintf( tblk_small "%L" TextBlockSmall )
     )
     ("UserTextSize"
         UserTextSize=Form->curValue
     )
     ("MinClearance"
         MinClearance=Form->curValue
     )
     ("AvoidVias"
         AvoidVias=Form->curValue
     )
     ("done"
        ; ==== cons puts the list together in reverse order
        (if  AssyBot == t then  Layer_List = (cons assybot_layer Layer_List))
        (if  AssyTop == t then  Layer_List = (cons assytop_layer Layer_List))
        (if  SilkBot == t then  Layer_List = (cons silkbot_layer Layer_List))
        (if  SilkTop == t then  Layer_List = (cons silktop_layer Layer_List))
         doRotateSilkAssy()
        (axlFormClose Form)
        (axlCancelEnterFun)
         deleteFile( fFile )
     )
     ("cancel"
        (axlFormClose Form)
        (axlCancelEnterFun)
        deleteFile( fFile )
     )
   )
 )
 
;###########################################################
;# createRotateRDForm - Enhanced User Interface Form      #
;###########################################################
(defun createRotateRDForm ()  
    fFile = (strcat FormDir "rotateRDForm.form")
    Form  = (outfile fFile "w")
   fprintf(Form "FILE_TYPE=FORM_DEFN VERSION=2\n")
   fprintf(Form "FORM\n")
   fprintf(Form "FIXED\n")
   fprintf(Form "PORT 85 25\n")
   fprintf(Form "HEADER \"Smart Reference Designator Placement V3.0\"\n")
   fprintf(Form "TILE\n")
   fprintf(Form "GROUP \"Select Layers to Process\"\n")
   fprintf(Form "GLOC 2 1\n")
   fprintf(Form "GSIZE 80 4\n")
   fprintf(Form "ENDGROUP\n")
   fprintf(Form "FIELD \"SilkTop\"\n")
   fprintf(Form "FLOC 3 3 \n")
   fprintf(Form "CHECKLIST \"Silkscreen-Top\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"SilkBot\"\n")
   fprintf(Form "FLOC 20 3 \n")
   fprintf(Form "CHECKLIST \"Silkscreen-Bottom\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"AssyTop\"\n")
   fprintf(Form "FLOC 37 3 \n")
   fprintf(Form "CHECKLIST \"Assembly-Top\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"AssyBot\"\n")
   fprintf(Form "FLOC 54 3 \n")
   fprintf(Form "CHECKLIST \"Assembly-Bottom\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "GROUP \"RD Orientation\"\n")
   fprintf(Form "GLOC 2 5\n")
   fprintf(Form "GSIZE 32 13\n")
   fprintf(Form "ENDGROUP\n")
   fprintf(Form "GROUP \"Smart Placement Settings\"\n")
   fprintf(Form "GLOC 36 5\n")
   fprintf(Form "GSIZE 46 13\n")
   fprintf(Form "ENDGROUP\n")
   fprintf(Form "TEXT \"Horizontal           Vertical \"\n")
   fprintf(Form "TLOC 6 7 \n")
   fprintf(Form "ENDTEXT\n")
   fprintf(Form "FIELD \"LRBT\"\n")
   fprintf(Form "FLOC 3 9 \n")
   fprintf(Form "CHECKLIST \"Left to Right     Bottom to Top\" \"rotate_group\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"LRTB\"\n")
   fprintf(Form "FLOC 3 11 \n")
   fprintf(Form "CHECKLIST \"Left to Right     Top to Bottom\" \"rotate_group\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"RLBT\"\n")
   fprintf(Form "FLOC 3 13 \n")
   fprintf(Form "CHECKLIST \"Right to Left     Bottom to Top\" \"rotate_group\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"RLTB\"\n")
   fprintf(Form "FLOC 3 15 \n")
   fprintf(Form "CHECKLIST \"Right to Left     Top to Bottom\" \"rotate_group\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "TEXT \"Text Size: \"\n")
   fprintf(Form "TLOC 38 7 \n")
   fprintf(Form "ENDTEXT\n")
   fprintf(Form "FIELD \"UserTextSize\"\n")
   fprintf(Form "FLOC 48 7 \n")
   fprintf(Form "FLOATSLIDEBAR 6 3\n MIN 0.3\n MAX 2.0\n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "TEXT \"Min Clearance: \"\n")
   fprintf(Form "TLOC 38 9 \n")
   fprintf(Form "ENDTEXT\n")
   fprintf(Form "FIELD \"MinClearance\"\n")
   fprintf(Form "FLOC 52 9 \n")
   fprintf(Form "FLOATSLIDEBAR 6 3\n MIN 0.1\n MAX 2.0\n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"AvoidVias\"\n")
   fprintf(Form "FLOC 38 11 \n")
   fprintf(Form "CHECKLIST \"Avoid Placing Over Vias\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"CenterAssy\"\n")
   fprintf(Form "FLOC 38 13 \n")
   fprintf(Form "CHECKLIST \"Legacy Center Mode (Override Smart)\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"ChangeTextSize\"\n")
   fprintf(Form "FLOC 38 15 \n")
   fprintf(Form "CHECKLIST \"Apply Custom Text Sizing\" \n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "TEXT \"Large  Text Block: \"\n")
   fprintf(Form "TLOC 5 19 \n")
   fprintf(Form "ENDTEXT\n")
   fprintf(Form "TEXT \"Medium Text Block: \"\n")
   fprintf(Form "TLOC 5 20 \n")
   fprintf(Form "ENDTEXT\n")
   fprintf(Form "TEXT \"Small Text Block: \"\n")
   fprintf(Form "TLOC 5 21 \n")
   fprintf(Form "ENDTEXT\n")
   fprintf(Form "FIELD \"TextBlockLarge\"\n")
   fprintf(Form "FLOC 23 19 \n")
   fprintf(Form "INTSLIDEBAR 3 3\n MIN 1\n MAX 60\n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"TextBlockMedium\"\n")
   fprintf(Form "FLOC 23 20 \n")
   fprintf(Form "INTSLIDEBAR 3 3\n MIN 1\n MAX 60\n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD \"TextBlockSmall\"\n")
   fprintf(Form "FLOC 23 21 \n")
   fprintf(Form "INTSLIDEBAR 3 3\n MIN 1\n MAX 60\n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD done\n")
   fprintf(Form "FLOC 35 23\n")
   fprintf(Form "MENUBUTTON \"Done\" 8 3\n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "FIELD cancel\n")
   fprintf(Form "FLOC 45 23\n")
   fprintf(Form "MENUBUTTON \"CANCEL\" 8 3\n")
   fprintf(Form "ENDFIELD\n")
   fprintf(Form "ENDTILE\n")
   fprintf(Form "ENDFORM\n")
   close(Form)
)
*Error* axlFormSetField: argument #1 should be any user-defined (other) type (type template = "otg") - nil
 

