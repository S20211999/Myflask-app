# bom_costing_app.py

import sys, re, json, time, urllib.parse, math, os, chardet
from datetime import datetime, timedelta
import requests
from bs4 import BeautifulSoup
import pandas as pd
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget, QToolBar,
    QFileDialog, QTableWidget, QTableWidgetItem, QComboBox, QLabel,
    QSpinBox, QDoubleSpinBox, QTextEdit, QMessageBox, QTabWidget, QProgressBar,
    QSplitter, QDialog, QListWidget, QPushButton
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal
from PyQt6.QtGui import QColor, QAction, QFont, QPalette, QPixmap,QIcon

USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
BASE_SEARCH = "https://www.findchips.com/search/"
BASE_DETAIL = "https://www.findchips.com/detail/{mpn}/{mfg}"

# Common MLCC/EIA size mapping for fallbacks and grouping
EIA_TO_MM = {
    "008004": (0.25, 0.13), "0075": (0.3, 0.15), "01005": (0.4, 0.2),
    "15015": (0.4, 0.4), "0201": (0.6, 0.3), "0202": (0.5, 0.5),
    "0302": (0.8, 0.5), "0303": (0.8, 0.8), "0504": (1.3, 1.0),
    "0402": (1.0, 0.5), "0603": (1.6, 0.8), "0805": (2.0, 1.25),
    "1008": (2.5, 2.0), "1111": (2.8, 2.8), "1206": (3.2, 1.6),
    "1210": (3.2, 2.5), "1410": (3.6, 2.5), "1515": (3.81, 3.81),
    "1806": (4.5, 1.6), "1808": (4.5, 2.0), "1812": (4.5, 3.2),
    "1825": (4.5, 6.4), "2010": (5.0, 2.5), "2020": (5.08, 5.08),
    "2220": (5.7, 5.0), "2225": (5.7, 6.4), "2512": (6.4, 3.2),
    "2520": (6.4, 5.0), "2920": (7.4, 5.0), "3333": (8.38, 8.38),
    "3640": (9.2, 10.16), "4040": (10.2, 10.2), "5550": (14.0, 12.7),
    "8060": (20.3, 15.3)
}

def apply_dark_green_theme(app):
    """Apply dark green theme to the entire application"""
    palette = QPalette()

    # Window background - Dark gray/black
    palette.setColor(QPalette.ColorRole.Window, QColor(25, 35, 25))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(0, 255, 100))  # Bright green text

    # Base background for input fields
    palette.setColor(QPalette.ColorRole.Base, QColor(35, 45, 35))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(45, 55, 45))

    # Text colors
    palette.setColor(QPalette.ColorRole.Text, QColor(0, 255, 100))

    # Button styling
    palette.setColor(QPalette.ColorRole.Button, QColor(35, 55, 35))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(0, 255, 100))

    # Highlight colors
    palette.setColor(QPalette.ColorRole.Highlight, QColor(0, 150, 50))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))

    # Links
    palette.setColor(QPalette.ColorRole.Link, QColor(100, 255, 150))

    # FIXED: Disabled elements - Use ColorGroup.Disabled, not ColorRole.Disabled
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.WindowText, QColor(100, 100, 100))
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.ButtonText, QColor(100, 100, 100))
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text, QColor(100, 100, 100))

    app.setPalette(palette)

    # Additional stylesheet for better appearance
    app.setStyleSheet("""
        QMainWindow {
            background-color: rgb(25, 35, 25);
            color: rgb(0, 255, 100);
        }
        
        QToolBar {
            background-color: rgb(35, 45, 35);
            border: 1px solid rgb(0, 150, 50);
            spacing: 3px;
        }
        
        QToolBar::separator {
            background-color: rgb(0, 150, 50);
            width: 2px;
            margin: 2px;
        }
        
        QPushButton, QToolButton {
            background-color: rgb(35, 55, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            padding: 5px 10px;
            font-weight: bold;
        }
        
        QPushButton:hover, QToolButton:hover {
            background-color: rgb(0, 150, 50);
            color: white;
        }
        
        QPushButton:pressed, QToolButton:pressed {
            background-color: rgb(0, 100, 30);
        }
        
        QComboBox {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 3px;
            padding: 2px 5px;
        }
        
        QComboBox::drop-down {
            border: none;
        }
        
        QComboBox::down-arrow {
            image: none;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid rgb(0, 255, 100);
        }
        
        QSpinBox, QDoubleSpinBox {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 3px;
            padding: 2px;
        }
        
        QLabel {
            color: rgb(0, 255, 100);
            font-weight: bold;
        }
        
        QTabBar::tab {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            padding: 8px 15px;
            margin: 2px;
        }
        
        QTabBar::tab:selected {
            background-color: rgb(0, 150, 50);
            color: white;
        }
        
        QTabBar::tab:hover {
            background-color: rgb(0, 120, 40);
        }
        
        QProgressBar {
            background-color: rgb(35, 45, 35);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            color: white;          
            text-align: center;
        }
        
        QProgressBar::chunk {
            background-color: rgb(0, 200, 50);
            border-radius: 3px;
        }
        
        QSplitter::handle {
            background-color: rgb(0, 150, 50);
        }
        
        QMessageBox {
            background-color: rgb(25, 35, 25);
            color: rgb(0, 255, 100);
        }
        
        QDialog {
            background-color: rgb(25, 35, 25);
            color: rgb(0, 255, 100);
        }
        
        QListWidget {
            background-color: white;
            color: black;
            border: 2px solid rgb(0, 150, 50);
        }
    """)

def norm_eia_code(text: str | None) -> str | None:
    if not text:
        return None
    cleaned = text.replace('-', '').replace('_', '')
    m = re.search(r'\b(008004|01005|0201|0302|0303|0402|0504|0603|0805|1008|1206|1210|1812|2010|2220|2225|2512|2920|3333|3640|4040|5550|8060)\b', cleaned)

    return m.group(1) if m else None

def max_dim_mm_from_package_or_size(package_code: str | None, L: float | None, W: float | None) -> float | None:
    if package_code and package_code in EIA_TO_MM:
        l, w = EIA_TO_MM[package_code]
        return max(l, w)
    if L is not None and W is not None:
        return max(L, W)
    if L is not None:
        return L
    if W is not None:
        return W
    return None

def filter_search_results(mpn: str, search_results: list[dict]) -> list[dict]:
    """
    Filter search results based on exact vs partial matches:
    - If exact matches exist, return only exact matches
    - If no exact matches exist, return only the first partial match
    """
    exact_matches = []
    partial_matches = []
    mpn_lower = mpn.strip().lower()
    
    for result in search_results:
        result_mpn = result["mpn"].strip().lower()
        if result_mpn == mpn_lower:
            exact_matches.append(result)
        else:
            partial_matches.append(result)
    
    # Return exact matches if they exist, otherwise return only first partial match
    if exact_matches:
        return exact_matches
    elif partial_matches:
        return partial_matches[:1] # Only take the first partial match
    else:
        return []

def detect_file_encoding(file_path: str) -> str:
    """Detect the encoding of a file"""
    try:
        with open(file_path, 'rb') as f:
            raw_data = f.read(10000)  # Read first 10KB
            result = chardet.detect(raw_data)
            return result['encoding'] or 'utf-8'
    except Exception:
        return 'utf-8'

def detect_csv_delimiter(file_path: str, encoding: str = 'utf-8') -> str:
    """Detect CSV delimiter by testing common delimiters"""
    delimiters = [',', ';', '\t', '|']
    try:
        with open(file_path, 'r', encoding=encoding) as f:
            sample = f.read(1024)
            
        delimiter_scores = {}
        for delim in delimiters:
            lines = sample.split('\n')[:3]  # Check first 3 lines
            scores = []
            for line in lines:
                if line.strip():
                    scores.append(line.count(delim))
            if scores and max(scores) > 0:
                delimiter_scores[delim] = max(scores)
        
        if delimiter_scores:
            return max(delimiter_scores.items(), key=lambda x: x[1])[0]
        return ','
    except Exception:
        return ','

class SheetSelectionDialog(QDialog):
    """Dialog for selecting Excel worksheet"""
    def __init__(self, sheet_names, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Worksheet")
        self.setModal(True)
        self.resize(300, 200)
        
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Multiple worksheets found. Select one:"))
        
        self.sheet_list = QListWidget()
        self.sheet_list.addItems(sheet_names)
        self.sheet_list.setCurrentRow(0)
        layout.addWidget(self.sheet_list)
        
        buttons = QHBoxLayout()
        ok_btn = QPushButton("OK")
        cancel_btn = QPushButton("Cancel")
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)
        buttons.addWidget(ok_btn)
        buttons.addWidget(cancel_btn)
        layout.addLayout(buttons)
        
        self.setLayout(layout)
        
    def get_selected_sheet(self, _):
        current_item = self.sheet_list.currentItem()
        return current_item.text() if current_item else None

class FindchipsClient:
    def __init__(self, timeout=15):
        self.s = requests.Session()
        self.s.headers.update({"User-Agent": USER_AGENT})
        self.timeout = timeout

    def get(self, url):
        return self.s.get(url, timeout=self.timeout)

    def search(self, mpn: str) -> list[dict]:
        """Extract only MPN and manufacturer from search page"""
        url = BASE_SEARCH + urllib.parse.quote(mpn)
        r = self.get(url)
        if r.status_code != 200:
            return []

        soup = BeautifulSoup(r.content, "html.parser")
        rows = soup.find_all("tr", class_="row")
        results = []

        for row in rows:
            try:
                mfg = (row.get("data-mfr") or row.get("data-manufacturer") or "").strip()
                result_mpn = (row.get("data-mfrpartnumber") or "").strip()
                if not mfg or not result_mpn:
                    continue

                # Only return MPN and manufacturer - no pricing/stock data
                results.append({
                    "mpn": result_mpn,
                    "manufacturer": mfg
                })
            except Exception:
                continue

        # Remove duplicates while preserving order
        seen = set()
        unique_results = []
        for item in results:
            key = (item["mpn"].lower(), item["manufacturer"].lower())
            if key not in seen:
                seen.add(key)
                unique_results.append(item)

        return unique_results

    def detail(self, mpn: str, manufacturer: str) -> dict:
        """Extract all data from detail page"""
        url = BASE_DETAIL.format(
            mpn=urllib.parse.quote(mpn),
            mfg=urllib.parse.quote(manufacturer.replace(' ', '-'))
        )
        r = self.get(url)
        if r.status_code != 200:
            return {}

        html = r.text
        meta = {
            "life_cycle_code": None,
            "package_code": None,
            "length_mm": None,
            "width_mm": None,
            "default_currency": None,
            "lead_time": None,
            "offers": []
        }

        # Extract metadata from JavaScript or meta tags
        dc = re.search(r'"defaultCurrency"\s*:\s*"([A-Z]{3})"', html)
        if dc:
            meta["default_currency"] = dc.group(1)

        # Parse HTML table for Part Data Attributes
        soup = BeautifulSoup(html, "html.parser")
        
        # Extract from Part Data Attributes table
        data_rows = soup.find_all("tr", class_="data-row")
        for row in data_rows:
            try:
                field_cell = row.find("td", class_="field-cell")
                main_cell = row.find("td", class_="main-part-cell")
                
                if field_cell and main_cell:
                    field_name = field_cell.get_text(strip=True)
                    field_value = main_cell.get_text(strip=True)
                    
                    # Extract specific fields
                    if field_name == "Part Life Cycle Code":
                        meta["life_cycle_code"] = field_value
                    elif field_name in ["Part Package Code", "Size Code", "Package Description"]:
                        # Try to normalize package code
                        normalized = norm_eia_code(field_value)
                        if normalized:
                            meta["package_code"] = normalized
                        else:
                            meta["package_code"] = field_value
                    elif field_name == "Factory Lead Time":
                        meta["lead_time"] = field_value
                    # NEW: Extract Length and Width
                    elif field_name in ["Length","Package Length"]:
                        # Extract numeric value from "14 mm"
                        length_match = re.search(r'(\d+(?:\.\d+)?)', field_value)
                        if length_match:
                            meta["length_mm"] = float(length_match.group(1))
                    elif field_name in ["Width","Package Width"]:
                        # Extract numeric value from "14 mm"
                        width_match = re.search(r'(\d+(?:\.\d+)?)', field_value)
                        if width_match:
                            meta["width_mm"] = float(width_match.group(1))
                            
            except Exception:
                continue

        # Try to extract dimensions from package description
        pkg_desc_rows = soup.find_all("tr", attrs={"data-field": "Package Description"})
        for row in pkg_desc_rows:
            try:
                desc_cell = row.find("td", class_="main-part-cell")
                if desc_cell:
                    desc_text = desc_cell.get_text(strip=True)
                    # Try to extract dimensions from package description
                    # Look for patterns like "1.6x0.8" or "1.6 x 0.8"
                    size_match = re.search(r'(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)', desc_text)
                    if size_match:
                        meta["length_mm"] = float(size_match.group(1))
                        meta["width_mm"] = float(size_match.group(2))
                    else:
                        # Try to extract standard package sizes (like 0805)
                        std_size = norm_eia_code(desc_text)
                        if std_size and std_size in EIA_TO_MM:
                            meta["package_code"] = std_size
                            l, w = EIA_TO_MM[std_size]
                            meta["length_mm"] = l
                            meta["width_mm"] = w
            except Exception:
                continue

        # Fallback: Try original JavaScript extraction methods
        if not meta["life_cycle_code"]:
            life = re.search(r'"lifeCycle(Code)?"\s*:\s*"([^"]+)"', html)
            if life:
                meta["life_cycle_code"] = life.group(2)

        if not meta["package_code"]:
            pkg = re.search(r'"sizeCode"\s*:\s*"([^"]+)"', html) or re.search(r'"package"\s*:\s*"([^"]+)"', html)
            if pkg:
                normalized = norm_eia_code(pkg.group(1))
                meta["package_code"] = normalized or pkg.group(1)

        # Continue with existing dimensions extraction if not found
        if not meta["length_mm"]:
            lmatch = re.search(r'"length"\s*:\s*([0-9.]+)\s*,\s*"unit"\s*:\s*"mm"', html)
            if lmatch:
                meta["length_mm"] = float(lmatch.group(1))
                
        if not meta["width_mm"]:
            wmatch = re.search(r'"width"\s*:\s*([0-9.]+)\s*,\s*"unit"\s*:\s*"mm"', html)
            if wmatch:
                meta["width_mm"] = float(wmatch.group(1))

        # Extract distributor offers from the FC.group JavaScript object
        group_match = re.search(r'FC\.group\s*=\s*\{[^}]*offers:\s*(\[.*?\])', html, re.DOTALL)
        if group_match:
            try:
                offers_json = group_match.group(1)
                # Clean up the JavaScript to make it valid JSON
                offers_json = re.sub(r'([{,]\s*)(\w+):', r'\1"\2":', offers_json) # Quote keys
                offers_json = re.sub(r"'([^']*)'", r'"\1"', offers_json) # Convert single quotes
                offers_data = json.loads(offers_json)

                for offer in offers_data:
                    distributor = offer.get("distributor", "").strip()
                    stock = int(offer.get("stock", 0) or 0)

                    # Extract price tiers
                    price_tiers = []
                    price_data = offer.get("price", [])
                    if isinstance(price_data, list):
                        for tier in price_data:
                            if isinstance(tier, list) and len(tier) >= 3:
                                try:
                                    qty = int(str(tier[0]).replace(",", ""))
                                    price = float(str(tier[2]).replace(",", ""))
                                    price_tiers.append({"quantity": qty, "price": price})
                                except (ValueError, IndexError):
                                    continue

                    if distributor and (price_tiers or stock > 0):
                        meta["offers"].append({
                            "distributor": distributor,
                            "stock": stock,
                            "currency": "USD",
                            "price_tiers": sorted(price_tiers, key=lambda x: x["quantity"]),
                            "lead_time": offer.get("leadTime") or meta.get("lead_time"),
                            "moq": min(tier["quantity"] for tier in price_tiers) if price_tiers else None
                        })
            except (json.JSONDecodeError, Exception):
                pass

        # Fallback: Parse HTML tables for distributor data
        if not meta["offers"]:
            price_stock_table = soup.find("table", class_="price-stock-table")
            if price_stock_table:
                for row in price_stock_table.find_all("tr", class_="price-stock-tr"):
                    try:
                        # Extract distributor name
                        dist_cell = row.find("td", class_="td-dis")
                        if not dist_cell:
                            continue
                        distributor = dist_cell.get_text(strip=True)

                        # Extract stock
                        stock_cell = row.find("td", class_="td-stock")
                        stock = 0
                        if stock_cell:
                            stock_text = stock_cell.get_text(strip=True)
                            stock_match = re.search(r'(\d[\d,]*)', stock_text)
                            if stock_match:
                                stock = int(stock_match.group(1).replace(",", ""))

                        # Extract lead time from description
                        desc_cell = row.find("td", class_="td-desc")
                        row_lead_time = None
                        if desc_cell:
                            desc_text = desc_cell.get_text()
                            lead_match = re.search(r'Lead time:\s*([^<\n]+)', desc_text)
                            if lead_match:
                                row_lead_time = lead_match.group(1).strip()

                        # Extract price tiers
                        price_tiers = []
                        price_cell = row.find("td", class_="td-price")
                        if price_cell:
                            price_items = price_cell.find_all("li", class_="price-item")
                            for item in price_items:
                                label = item.find("span", class_="label")
                                value = item.find("span", class_="value")
                                if label and value:
                                    try:
                                        qty_text = label.get_text(strip=True).replace(",", "")
                                        price_text = value.get_text(strip=True).replace("$", "").replace(",", "")
                                        qty = int(qty_text)
                                        price = float(price_text)
                                        price_tiers.append({"quantity": qty, "price": price})
                                    except (ValueError, AttributeError):
                                        continue

                        if distributor and (price_tiers or stock > 0):
                            meta["offers"].append({
                                "distributor": distributor,
                                "stock": stock,
                                "currency": "USD",
                                "price_tiers": sorted(price_tiers, key=lambda x: x["quantity"]),
                                "lead_time": row_lead_time or meta.get("lead_time"),
                                "moq": min(tier["quantity"] for tier in price_tiers) if price_tiers else None
                            })
                    except Exception:
                        continue

        return meta

class JSONStorage:
    """JSON-based storage system to replace SQLite database"""
    def __init__(self, path="bom_costing_data.json"):
        self.path = path
        self.data = self._load()

    def _load(self):
        """Load data from JSON file"""
        if os.path.exists(self.path):
            try:
                with open(self.path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                print(f"Error loading JSON data: {e}")
                return {}
        return {}

    def _save(self):
        """Save data to JSON file"""
        try:
            # Create backup of existing file
            if os.path.exists(self.path):
                backup_path = f"{self.path}.backup"
                if os.path.exists(backup_path):
                    os.remove(backup_path)
                os.rename(self.path, backup_path)
            
            with open(self.path, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Error saving JSON data: {e}")
            # Restore backup if save failed
            backup_path = f"{self.path}.backup"
            if os.path.exists(backup_path):
                os.rename(backup_path, self.path)

    def upsert_offer(
        self, mpn, distributor, manufacturer, price_tiers, stock, currency,
        lead_time=None, life_cycle_code=None, package_code=None,
        length_mm=None, width_mm=None, default_currency=None, part_type=None
    ):
        """Insert or update component offer data"""
        if mpn not in self.data:
            self.data[mpn] = {}
        
        if distributor not in self.data[mpn]:
            self.data[mpn][distributor] = {}
        
        # Sort price tiers
        tiers_sorted = sorted(price_tiers or [], key=lambda x: x["quantity"])
        
        # Update offer data
        offer_data = {
            "manufacturer": manufacturer,
            "price_tiers": tiers_sorted,
            "stock": max(self.data[mpn][distributor].get("stock", 0), int(stock or 0)),
            "currency": currency or "USD",
            "lead_time": lead_time or self.data[mpn][distributor].get("lead_time"),
            "life_cycle_code": life_cycle_code or self.data[mpn][distributor].get("life_cycle_code"),
            "package_code": package_code or self.data[mpn][distributor].get("package_code"),
            "length_mm": length_mm if length_mm is not None else self.data[mpn][distributor].get("length_mm"),
            "width_mm": width_mm if width_mm is not None else self.data[mpn][distributor].get("width_mm"),
            "default_currency": default_currency or self.data[mpn][distributor].get("default_currency", "USD"),
            "part_type": part_type or self.data[mpn][distributor].get("part_type"),
            "scraped_date": datetime.now().isoformat()
        }
        
        self.data[mpn][distributor].update(offer_data)
        self._save()

    def offers_by_mpn(self, mpn):
        """Get all offers for a specific MPN"""
        if mpn not in self.data:
            return []
        
        offers = []
        for distributor, offer_data in self.data[mpn].items():
            offers.append({
                "distributor": distributor,
                "manufacturer": offer_data.get("manufacturer", ""),
                "price_tiers": offer_data.get("price_tiers", []),
                "stock": offer_data.get("stock", 0),
                "currency": offer_data.get("currency", "USD"),
                "lead_time": offer_data.get("lead_time"),
                "life_cycle_code": offer_data.get("life_cycle_code"),
                "package_code": offer_data.get("package_code"),
                "length_mm": offer_data.get("length_mm"),
                "width_mm": offer_data.get("width_mm"),
                "default_currency": offer_data.get("default_currency", "USD"),
                "part_type": offer_data.get("part_type")
            })
        
        return sorted(offers, key=lambda x: x["distributor"])

    def part_meta(self, mpn):
        """Get metadata for a part"""
        offers = self.offers_by_mpn(mpn)
        
        life = next((o["life_cycle_code"] for o in offers if o.get("life_cycle_code")), "")
        pkg = next((o["package_code"] for o in offers if o.get("package_code")), "")
        L = next((o["length_mm"] for o in offers if o.get("length_mm") is not None), None)
        W = next((o["width_mm"] for o in offers if o.get("width_mm") is not None), None)
        defcur = next((o["default_currency"] for o in offers if o.get("default_currency")), "USD")
        ptype = next((o["part_type"] for o in offers if o.get("part_type")), "")
        lead = next((o["lead_time"] for o in offers if o.get("lead_time")), "")
        
        return {
            "life": life, "package": pkg, "L": L, "W": W, 
            "default_currency": defcur, "part_type": ptype, "lead_time": lead
        }

    def update_size_for_mpn(self, mpn, length_mm, width_mm):
        """Update length and width for all distributors of a specific MPN"""
        if mpn in self.data:
            for distributor in self.data[mpn]:
                self.data[mpn][distributor]["length_mm"] = length_mm
                self.data[mpn][distributor]["width_mm"] = width_mm
            self._save()
            return len(self.data[mpn])
        return 0

    def update_package_for_mpn(self, mpn, new_package):
        """Update package code for all distributors of a specific MPN"""
        if mpn in self.data:
            for distributor in self.data[mpn]:
                self.data[mpn][distributor]["package_code"] = new_package
            self._save()
            return len(self.data[mpn])
        return 0
    
    def is_data_fresh(self, mpn, hours=6):
        """Check if MPN data is fresh (within specified hours)"""
        if mpn not in self.data:
            return False
        
        # Check if any distributor has recent data
        for distributor_data in self.data[mpn].values():
            scraped_date_str = distributor_data.get("scraped_date")
            if scraped_date_str:
                try:
                    scraped_date = datetime.fromisoformat(scraped_date_str)
                    time_diff = datetime.now() - scraped_date
                    if time_diff < timedelta(hours=hours):
                        return True
                except Exception:
                    continue
        return False
    
    def get_data_age_hours(self, mpn):
        """Get the age of data in hours for an MPN"""
        if mpn not in self.data:
            return float('inf')
        
        oldest_hours = 0
        for distributor_data in self.data[mpn].values():
            scraped_date_str = distributor_data.get("scraped_date")
            if scraped_date_str:
                try:
                    scraped_date = datetime.fromisoformat(scraped_date_str)
                    hours_old = (datetime.now() - scraped_date).total_seconds() / 3600
                    oldest_hours = max(oldest_hours, hours_old)
                except Exception:
                    continue
        return oldest_hours if oldest_hours > 0 else float('inf')

class ScrapeThread(QThread):
    progress = pyqtSignal(int)
    log = pyqtSignal(str)
    done = pyqtSignal()

    def __init__(self, mpns, storage: JSONStorage):
        super().__init__()
        self.mpns = mpns
        self.storage = storage
        self.client = FindchipsClient()
        self.cancelled = False

    def cancel(self, _):
        """Cancel the scraping process"""
        self.cancelled = True
        self.log.emit("Scraping cancelled by user")

    def run(self):
        total = len(self.mpns)
        fresh_count = 0
        scraped_count = 0
        
        for i, mpn in enumerate(self.mpns):
            # Check for cancellation
            if self.cancelled:
                self.log.emit("Scraping process was cancelled")
                self.done.emit()
                return
                
            try:
                # Check if data is fresh (less than 6 hours old)
                if self.storage.is_data_fresh(mpn, hours=6):
                    data_age = self.storage.get_data_age_hours(mpn)
                    self.log.emit(f"Using cached data for {mpn} (age: {data_age:.1f} hours)")
                    fresh_count += 1
                    self.progress.emit(int((i + 1) * 100 / total))
                    continue
                
                # Data is stale or doesn't exist, scrape from Findchips
                data_age = self.storage.get_data_age_hours(mpn)
                age_text = f"{data_age:.1f} hours old" if data_age != float('inf') else "not found"
                self.log.emit(f"Scraping {mpn} (existing data: {age_text})")
                
                # Step 1: Get manufacturers from search page
                search_results = self.client.search(mpn)
                if not search_results:
                    self.log.emit(f"No manufacturers found for {mpn}")
                    self.progress.emit(int((i + 1) * 100 / total))
                    time.sleep(0.1)
                    continue

                # Step 1.5: Filter search results - exact matches first, then max 1 partial match
                filtered_results = filter_search_results(mpn, search_results)
                if not filtered_results:
                    self.log.emit(f"No suitable matches found for {mpn}")
                    self.progress.emit(int((i + 1) * 100 / total))
                    time.sleep(0.1)
                    continue

                self.log.emit(f"Found {len(filtered_results)} suitable matches for {mpn}")

                # Step 2: For each filtered manufacturer, get detailed data from detail page
                for result in filtered_results:
                    # Check for cancellation before each detail request
                    if self.cancelled:
                        self.log.emit("Scraping process was cancelled")
                        self.done.emit()
                        return
                        
                    result_mpn = result["mpn"]
                    manufacturer = result["manufacturer"]

                    # Determine if this is exact match or alternate
                    is_exact = result_mpn.strip().lower() == mpn.strip().lower()
                    part_type = "Precise Match" if is_exact else "Alternate Parts"

                    self.log.emit(f"Getting details: {result_mpn} / {manufacturer} ({'Exact' if is_exact else 'Partial'} match)")

                    # Get detailed data from detail page
                    detail_data = self.client.detail(result_mpn, manufacturer)

                    # Store offers from detail page
                    offers = detail_data.get("offers", [])
                    if not offers:
                        # If no offers, create a placeholder entry
                        offers = [{"distributor": "Unknown", "stock": 0, "price_tiers": [], "currency": "USD"}]

                    for offer in offers:
                        self.storage.upsert_offer(
                            mpn=mpn,  # Store under the searched MPN
                            distributor=offer.get("distributor", "Unknown"),
                            manufacturer=manufacturer,
                            price_tiers=offer.get("price_tiers", []),
                            stock=offer.get("stock", 0),
                            currency=offer.get("currency", "USD"),
                            lead_time=offer.get("lead_time"),
                            life_cycle_code=detail_data.get("life_cycle_code"),
                            package_code=detail_data.get("package_code"),
                            length_mm=detail_data.get("length_mm"),
                            width_mm=detail_data.get("width_mm"),
                            default_currency=detail_data.get("default_currency", "USD"),
                            part_type=part_type
                        )

                scraped_count += 1
                self.log.emit(f"Completed: {mpn} - processed {len(filtered_results)} manufacturers")

            except Exception as e:
                self.log.emit(f"Error processing {mpn}: {e}")

            self.progress.emit(int((i + 1) * 100 / total))
            time.sleep(0.1)

        # Final summary
        self.log.emit(f"Scraping completed - Used cached: {fresh_count}, Scraped fresh: {scraped_count}")
        self.done.emit()



def convert_price(price, src, dst, usd_to_inr):
    if src == dst:
        return price
    if src == "USD" and dst == "INR":
        return price * usd_to_inr
    if src == "INR" and dst == "USD" and usd_to_inr:
        return price / usd_to_inr
    return price

def select_tier_for_qty(tiers, required_qty):
    if not tiers:
        return None, None, None
    tiers = sorted(tiers, key=lambda x: x["quantity"])
    chosen = None
    next_t = None
    for t in tiers:
        if required_qty >= t["quantity"]:
            chosen = t
        elif required_qty < t["quantity"] and next_t is None:
            next_t = t
            break
    if chosen is None:
        chosen = tiers[0]
    moq = tiers[0]["quantity"]
    return chosen, next_t, moq

def choose_best_option(offers, total_required_qty, currency, usd_to_inr, package_code, L, W):
    """
    REVISED: Choose best option with distributor priority and corrected MOQ/Procure Qty logic
    Priority: 1st - Digikey, 2nd - Mouser, 3rd - Others
    MOQ = lowest available quantity tier
    Procure Qty = follows detailed buffer rules based on package and price
    """
    # Distributor priority list
    priority_list = ['Digikey', 'Mouser']

    # Group offers by distributor priority
    prioritized_offers = {d: [] for d in priority_list}
    others = []

    for off in offers:
        dist_lower = off.get('distributor', '').lower()
        matched = None
        for p in priority_list:
            if p.lower() in dist_lower:
                prioritized_offers[p].append(off)
                matched = p
                break
        if not matched:
            others.append(off)

    # Select offers to consider based on priority
    final_offers_to_consider = []
    for d in priority_list:
        if prioritized_offers[d]:
            final_offers_to_consider.extend(prioritized_offers[d])
            break
    else:
        final_offers_to_consider.extend(others)

    def pct_or_floor(trq, pct, floor_add):
        return max(int(math.ceil(trq * pct / 100)), floor_add)

    def calculate_procure_qty(trq, price_usd, pkg_code, max_dim):
        """Calculate procurement quantity based on detailed rules"""
        
        # Special case: price > $20 USD
        if price_usd > 20:
            return trq if trq < 250 else trq + 1
        
        is_low_price = price_usd < 1.0
        
        # Determine package group
        pkg_group = None
        if pkg_code in ['0201', '0402', '0603']:
            pkg_group = '0201-0603'
        elif pkg_code in ['0805', '1206', '1210']:
            pkg_group = '0805-1210'
        elif pkg_code in ['1812', '2010', '2512', '2920']:
            pkg_group = '1210-8060'
        
        if is_low_price:
            if pkg_group == '0201-0603':
                if trq < 100:
                    return trq + 50
                elif trq < 250:
                    return trq + 80
                elif trq < 500:
                    return trq + pct_or_floor(trq, 15, 80)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 8, 80)
                else:
                    return trq + pct_or_floor(trq, 5, 80)
                    
            elif pkg_group == '0805-1210':
                if trq < 100:
                    return trq + 25
                elif trq < 250:
                    return trq + 40
                elif trq < 500:
                    return trq + pct_or_floor(trq, 10, 40)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 7, 40)
                else:
                    return trq + pct_or_floor(trq, 3, 40)
                    
            elif pkg_group == '1210-8060':
                if trq < 100:
                    return trq + 12
                elif trq < 250:
                    return trq + 20
                elif trq < 500:
                    return trq + pct_or_floor(trq, 5, 20)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 3, 20)
                else:
                    return trq + pct_or_floor(trq, 2, 20)
            else:
                # Unknown package with size info
                if max_dim and max_dim < 5:
                    # Use 0805-1210 logic
                    if trq < 100:
                        return trq + 25
                    elif trq < 250:
                        return trq + 40
                    elif trq < 500:
                        return trq + pct_or_floor(trq, 10, 40)
                    elif trq < 1000:
                        return trq + pct_or_floor(trq, 7, 40)
                    else:
                        return trq + pct_or_floor(trq, 3, 40)
                else:
                    # Default fallback
                    return trq + (2 if trq < 250 else 3)
                    
        else: # High price (>= $1 USD)
            if pkg_group in ['0201-0603', '0805-1210']:
                if trq < 100:
                    return trq + 15
                elif trq < 250:
                    return trq + 20
                elif trq < 500:
                    return trq + pct_or_floor(trq, 4, 20)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 3, 20)
                else:
                    return trq + pct_or_floor(trq, 2, 20)
                    
            elif pkg_group == '1210-8060':
                if trq < 250:
                    return trq + 5
                elif trq < 500:
                    return trq + pct_or_floor(trq, 3, 5)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 2, 5)
                else:
                    return trq + pct_or_floor(trq, 1, 5)
            else:
                # Unknown package handling
                if max_dim and max_dim >= 5:
                    # Use 0201-1210 high price logic
                    if trq < 100:
                        return trq + 15
                    elif trq < 250:
                        return trq + 20
                    elif trq < 500:
                        return trq + pct_or_floor(trq, 4, 20)
                    elif trq < 1000:
                        return trq + pct_or_floor(trq, 3, 20)
                    else:
                        return trq + pct_or_floor(trq, 2, 20)
                elif max_dim and max_dim >= 5 and 10 <= price_usd <= 20:
                    # Special case
                    return trq + 1 if trq < 250 else trq + 1
                else:
                    return trq + (2 if trq < 250 else 3)
        
        return trq + 5  # Default fallback

    best = None
    for off in final_offers_to_consider:
        tiers = off.get("price_tiers") or []
        if not tiers:
            continue

        tiers_conv = []
        for t in tiers:
            price_converted = convert_price(t["price"], off.get("currency", "USD"), currency, usd_to_inr)
            tiers_conv.append({"quantity": int(t["quantity"]), "price": float(price_converted)})

        tiers_conv = sorted(tiers_conv, key=lambda x: x["quantity"])

        # MOQ = lowest available quantity tier
        moq = tiers_conv[0]["quantity"] if tiers_conv else 1

        # Find tier for total_required_qty
        chosen, next_t, _ = select_tier_for_qty(tiers_conv, total_required_qty)
        if not chosen:
            continue

        price_usd = convert_price(chosen["price"], currency, "USD", usd_to_inr)
        max_dim = max_dim_mm_from_package_or_size(package_code, L, W)
        
        # Calculate procurement quantity
        proc_qty = calculate_procure_qty(total_required_qty, price_usd, package_code, max_dim)
        
        # Find the tier for procurement quantity
        chosen_proc, next_proc, _ = select_tier_for_qty(tiers_conv, proc_qty)
        if not chosen_proc:
            chosen_proc = chosen

        # Calculate costs: current quantity vs next tier quantity
        cost_current = proc_qty * chosen_proc["price"]
        cost_next = float('inf')
        
        if next_proc:
            cost_next = next_proc["quantity"] * next_proc["price"]

        # Choose the lower cost option
        if cost_next < cost_current:
            final_procure_qty = next_proc["quantity"]
            final_unit_price = next_proc["price"]
            final_qty_tier = next_proc["quantity"]
            final_total_cost = cost_next
        else:
            final_procure_qty = proc_qty
            final_unit_price = chosen_proc["price"]
            final_qty_tier = chosen_proc["quantity"]
            final_total_cost = cost_current

        option = {
            "distributor": off["distributor"],
            "moq": moq,
            "qty_tier": final_qty_tier,
            "unit_price": final_unit_price,
            "procure_qty": final_procure_qty,
            "total_cost": final_total_cost,
            "stock": off.get("stock", 0)
        }

        if best is None or option["total_cost"] < best["total_cost"]:
            best = option

    return best

class RobustBOMLoader:
    """Enhanced BOM file loader with better error handling and format support"""
    
    @staticmethod
    def load_bom_file(file_path: str) -> pd.DataFrame:
        """Load BOM file with robust error handling and format detection"""
        
        # Detect file extension
        file_ext = os.path.splitext(file_path)[1].lower()
        
        try:
            if file_ext == '.csv':
                return RobustBOMLoader._load_csv(file_path)
            elif file_ext in ['.xlsx', '.xls']:
                return RobustBOMLoader._load_excel(file_path)
            else:
                raise ValueError(f"Unsupported file format: {file_ext}")
        except Exception as e:
            raise Exception(f"Failed to load BOM file: {str(e)}")
    
    @staticmethod
    def _load_csv(file_path: str) -> pd.DataFrame:
        """Load CSV file with encoding and delimiter detection"""
        
        # Detect encoding
        encoding = detect_file_encoding(file_path)
        
        # Detect delimiter
        delimiter = detect_csv_delimiter(file_path, encoding)
        
        # Try different encoding options if detection fails
        encodings_to_try = [encoding, 'utf-8', 'utf-8-sig', 'iso-8859-1', 'cp1252']
        
        for enc in encodings_to_try:
            try:
                # Read with pandas
                df = pd.read_csv(
                    file_path, 
                    delimiter=delimiter, 
                    encoding=enc,
                    engine='python',  # More flexible parser
                    on_bad_lines='skip',  # Skip bad lines instead of failing
                    dtype=str  # Read all as strings initially
                )
                
                # Basic validation
                if df.empty:
                    raise ValueError("CSV file is empty")
                
                if len(df.columns) < 2:
                    raise ValueError("CSV file must have at least 2 columns")
                
                # Clean up column names (remove extra whitespace)
                df.columns = df.columns.str.strip()
                
                return df
                
            except UnicodeDecodeError:
                continue  # Try next encoding
            except Exception as e:
                if enc == encodings_to_try[-1]:  # Last encoding failed
                    raise Exception(f"Failed to read CSV: {str(e)}")
                continue
        
        raise Exception("Could not read CSV file with any supported encoding")
    
    @staticmethod
    def _load_excel(file_path: str) -> pd.DataFrame:
        """Load Excel file with sheet selection and error handling"""
        
        try:
            # Try to read Excel file and get sheet names
            excel_file = pd.ExcelFile(file_path)
            sheet_names = excel_file.sheet_names
            
            if len(sheet_names) == 0:
                raise ValueError("Excel file contains no worksheets")
            
            # If multiple sheets, we need to let user choose
            # For now, just use the first sheet, but in the GUI we can add sheet selection
            selected_sheet = sheet_names[0]
            
            # Read the selected sheet
            df = pd.read_excel(
                file_path,
                sheet_name=selected_sheet,
                dtype=str,  # Read all as strings initially
                engine='openpyxl'
            )
            
            # Basic validation
            if df.empty:
                raise ValueError("Excel sheet is empty")
            
            if len(df.columns) < 2:
                raise ValueError("Excel sheet must have at least 2 columns")
            
            # Clean up column names
            df.columns = df.columns.str.strip()
            
            # Remove completely empty rows
            df = df.dropna(how='all')
            
            return df
            
        except Exception as e:
            raise Exception(f"Failed to read Excel file: {str(e)}")

class App(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("SIENNA BOM Cost Analysis tool V1.1                    \u00A9 2025 Sienna ECAD Technologies. All Rights Reserved.")
        self.resize(1250, 750)
        self.storage = JSONStorage()
        self.client = FindchipsClient()
        self.exchange = {"USD": 1.0, "INR": 87.0}
        self._manufacturer_overrides = {}
        self._package_overrides = {}
        self._build_ui()
        self._apply_white_backgrounds()  # Apply white backgrounds to specific widgets
        self.bom_df = None
        self.loader = RobustBOMLoader()
        self.setWindowIcon(QIcon("logo.ico"))

    def _build_ui(self):
        tb = QToolBar(); self.addToolBar(tb)
        act_open = QAction("Upload BOM", self); act_open.triggered.connect(self.on_open); tb.addAction(act_open)
        tb.addSeparator()
        act_fetch = QAction("Fetch Data", self); act_fetch.triggered.connect(self.on_fetch); tb.addAction(act_fetch)
        tb.addSeparator()
        act_export = QAction("Export to Excel", self); act_export.triggered.connect(self.on_export_smart); tb.addAction(act_export)

        top = QHBoxLayout()

        # MPN Column
        mpn_layout = QHBoxLayout()
        mpn_layout.addWidget(QLabel("MPN Column:"))
        self.cmb_mpn = QComboBox()
        self.cmb_mpn.setMinimumWidth(200)
        mpn_layout.addWidget(self.cmb_mpn)
        mpn_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(mpn_layout)
        

        # QTY Column
        qty_layout = QHBoxLayout()
        qty_layout.addWidget(QLabel("QTY Column:"))
        self.cmb_qty = QComboBox()
        self.cmb_qty.setMinimumWidth(200)
        qty_layout.addWidget(self.cmb_qty)
        qty_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(qty_layout)

        # PCB Qty
        pcb_layout = QHBoxLayout()
        pcb_layout.addWidget(QLabel("PCB Qty:"))
        self.sp_pcb = QSpinBox()
        self.sp_pcb.setRange(1, 1000000)
        self.sp_pcb.setEnabled(True)
        self.sp_pcb.setValue(1)
        self.sp_pcb.setMinimumWidth(150)
        pcb_layout.addWidget(self.sp_pcb)
        pcb_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(pcb_layout)

        # Currency
        cur_layout = QHBoxLayout()
        cur_layout.addWidget(QLabel("Currency:"))
        self.cmb_cur = QComboBox()
        self.cmb_cur.addItems(["USD", "INR"])
        self.cmb_cur.setMinimumWidth(120)
        cur_layout.addWidget(self.cmb_cur)
        cur_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(cur_layout)

        # Exchange Rate
        rate_layout = QHBoxLayout()
        rate_layout.addWidget(QLabel("USD→INR:"))
        self.sp_rate = QDoubleSpinBox()
        self.sp_rate.setRange(0.01, 1000.0)
        self.sp_rate.setDecimals(2)
        self.sp_rate.setValue(87.0)
        self.sp_rate.setMinimumWidth(120)
        rate_layout.addWidget(self.sp_rate)
        rate_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(rate_layout)

        img1_layout = QHBoxLayout()
        img_label = QLabel()
        pixmap = QPixmap("SiennaLogo.png")  # 🔁 Replace with actual image path
        img_label.setPixmap(pixmap.scaledToHeight(40, Qt.TransformationMode.SmoothTransformation))
        img_label.setMinimumWidth(80)  # Optional scaling
        img1_layout.addWidget(img_label)
        img1_layout.setAlignment(Qt.AlignmentFlag.AlignRight)
        top.addLayout(img1_layout)

        # Set the layout to a widget
        topw = QWidget()
        topw.setLayout(top)


        self.tabs = QTabWidget()
        self.tbl_results = QTableWidget()
        self.tbl_details = QTableWidget()
        self.tabs.addTab(self.tbl_results, "BOM Results")
        self.tabs.addTab(self.tbl_details, "Component Details")

        self.log = QTextEdit(); self.log.setReadOnly(True); self.log.setMaximumHeight(160)
        # Progress bar with cancel button
        progress_layout = QHBoxLayout()
        self.progress = QProgressBar()
        self.progress.setVisible(False)
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.setVisible(False)
        self.cancel_btn.clicked.connect(self.on_cancel_scraping)
        
        progress_layout.addWidget(self.progress)
        progress_layout.addWidget(self.cancel_btn)
        progress_widget = QWidget()
        progress_widget.setLayout(progress_layout)

        spl = QSplitter(Qt.Orientation.Vertical)
        spl.addWidget(self.tabs); spl.addWidget(self.log); spl.setStretchFactor(0, 3); spl.setStretchFactor(1, 1)

        root = QVBoxLayout(); root.addWidget(topw); root.addWidget(progress_widget); root.addWidget(spl)
        cw = QWidget(); cw.setLayout(root); self.setCentralWidget(cw)

        self._setup_debounced_recalc()
        self.tbl_results.itemChanged.connect(self._on_package_edit_changed)

    def on_cancel_scraping(self, _):
        """Cancel the current scraping operation"""
        if hasattr(self, 'worker') and self.worker.isRunning():
            self.worker.cancel()
            self.cancel_btn.setEnabled(False)
            self.cancel_btn.setText("Cancelling...")

    def on_fetch(self, _):
        if self.bom_df is None:
            QMessageBox.warning(self, "Warning", "Upload BOM first")
            return

        mpn_col = self.cmb_mpn.currentText()
        if not mpn_col:
            QMessageBox.warning(self, "Warning", "Select MPN column")
            return

        # Get unique MPNs, handling NaN values
        mpns = []
        for val in self.bom_df[mpn_col].dropna().astype(str).str.strip().unique():
            if val and val.lower() != 'nan':
                mpns.append(val)

        if not mpns:
            QMessageBox.warning(self, "Warning", "No valid MPNs found")
            return

        # Show cache status
        fresh_mpns = [mpn for mpn in mpns if self.storage.is_data_fresh(mpn, hours=6)]
        stale_mpns = [mpn for mpn in mpns if not self.storage.is_data_fresh(mpn, hours=6)]
        
        self.log_msg(f"Starting fetch for {len(mpns)} unique MPNs")
        self.log_msg(f"Fresh data (< 6 hours): {len(fresh_mpns)} MPNs")
        self.log_msg(f"Will scrape: {len(stale_mpns)} MPNs")

        self.progress.setVisible(True)
        self.progress.setValue(0)
        self.cancel_btn.setVisible(True)
        self.cancel_btn.setEnabled(True)
        self.cancel_btn.setText("Cancel")

        self.worker = ScrapeThread(mpns, self.storage)
        self.worker.progress.connect(self.progress.setValue)
        self.worker.log.connect(self.log_msg)
        self.worker.done.connect(self.on_scrape_done)
        self.worker.start()

        self._details_needs_refresh = True

    def on_scrape_done(self):
        self.progress.setVisible(False)
        self.cancel_btn.setVisible(False)
        self._details_needs_refresh = True
        self.log_msg("Processing completed")
        self.recalc_all()

    def _apply_white_backgrounds(self):
        """Apply white backgrounds to log and table widgets for better readability"""
        white_style = """
            background-color: white;
            color: black;
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        """
        
        table_style = """
            QTableWidget {
                background-color: white;
                color: black;
                border: 2px solid rgb(0, 150, 50);
                selection-background-color: rgb(0, 150, 50);
                selection-color: white;
            }
            QTableWidget::item {
                padding: 3px;
            }
            QTableWidget::item:selected {
                background-color: rgb(0, 150, 50);
                color: white;
            }
            /* Horizontal headers (column headers) - GREEN background, WHITE text */
            QHeaderView::section:horizontal {
                background-color: rgb(0, 150, 50);
                color: white;
                padding: 5px;
                border: 1px solid rgb(200, 200, 200);
                font-weight: bold;
                font-size: 11pt;
            }
            
            /* Vertical headers (row numbers) - WHITE background, BLACK text */
            QHeaderView::section:vertical {
                background-color: white;
                color: black;
                padding: 3px;
                border: 1px solid rgb(200, 200, 200);
                font-weight: bold;
            }
            
            /* Corner button (top-left corner) */
            QTableCornerButton::section {
                background-color: rgb(0, 150, 50);
                border: 1px solid rgb(200, 200, 200);
            }
        """
        
        self.log.setStyleSheet(white_style)
        self.tbl_results.setStyleSheet(table_style)
        self.tbl_details.setStyleSheet(table_style)

    def log_msg(self, m):
        self.log.append(f"[{datetime.now().strftime('%H:%M:%S')}] {m}")

    def on_open(self, _):
        path, _ = QFileDialog.getOpenFileName(
            self, 
            "Open BOM", 
            "", 
            "Excel (*.xlsx *.xls);;CSV (*.csv);;All Files (*.*)"
        )
        if not path: 
            return
        
        try:
            self.log_msg(f"Loading file: {os.path.basename(path)}")
            
            # Use robust BOM loader
            self.bom_df = self.loader.load_bom_file(path)
            
            # Update UI
            self.cmb_mpn.clear()
            self.cmb_qty.clear()
            cols = list(self.bom_df.columns)
            self.cmb_mpn.addItems(cols)
            self.cmb_qty.addItems(cols)
            
            # Try to auto-detect MPN and QTY columns
            self._auto_detect_columns(cols)
            
            self.show_bom(self.bom_df)
            self.populate_details_initial()
            self.log_msg(f"Successfully loaded BOM with {len(self.bom_df)} rows and {len(self.bom_df.columns)} columns")
            
        except Exception as e:
            QMessageBox.critical(self, "Error Loading BOM", str(e))
            self.log_msg(f"Error loading BOM: {str(e)}")

    def _setup_debounced_recalc(self):
        """Setup debounced recalculation to prevent rapid-fire updates"""
        from PyQt6.QtCore import QTimer
        
        # Create debounce timer
        self.debounce_timer = QTimer(self)
        self.debounce_timer.setSingleShot(True)  # Only fire once
        self.debounce_timer.setInterval(300)     # 300ms delay
        self.debounce_timer.timeout.connect(self.recalc_all)
        
        # Connect signals to start/restart the debounce timer
        self.cmb_cur.currentTextChanged.connect(self._trigger_debounced_recalc)
        self.sp_rate.valueChanged.connect(self._trigger_debounced_recalc)
        self.sp_pcb.valueChanged.connect(self._trigger_debounced_recalc)

    def _trigger_debounced_recalc(self, _):
        """Start/restart the debounce timer"""
        self.debounce_timer.start()  # Restarts timer if alrea

    def _auto_detect_columns(self, columns):
        """Auto-detect MPN and QTY columns based on common naming patterns"""
        mpn_patterns = ['mpn', 'part', 'partno', 'part_no', 'part number']
        qty_patterns = ['qty', 'quantity']
        
        # Find MPN column
        for i, col in enumerate(columns):
            col_lower = col.lower().strip()
            if any(pattern in col_lower for pattern in mpn_patterns):
                self.cmb_mpn.setCurrentIndex(i)
                break
        
        # Find QTY column
        for i, col in enumerate(columns):
            col_lower = col.lower().strip()
            if any(pattern in col_lower for pattern in qty_patterns):
                self.cmb_qty.setCurrentIndex(i)
                break

    def show_bom(self, df):
        self.tbl_results.setRowCount(len(df))
        self.tbl_results.setColumnCount(len(df.columns))
        self.tbl_results.setHorizontalHeaderLabels(list(df.columns))
        for r in range(len(df)):
            for c in range(len(df.columns)):
                val = df.iloc[r, c]
                # Handle NaN values
                display_val = str(val) if pd.notna(val) else ""
                self.tbl_results.setItem(r, c, QTableWidgetItem(display_val))

    def populate_details_initial(self):
        if self.bom_df is None: 
            return
        self.tbl_details.setRowCount(len(self.bom_df))
        self.tbl_details.setColumnCount(len(self.bom_df.columns))
        self.tbl_details.setHorizontalHeaderLabels(list(self.bom_df.columns))
        for r in range(len(self.bom_df)):
            for c in range(len(self.bom_df.columns)):
                val = self.bom_df.iloc[r, c]
                display_val = str(val) if pd.notna(val) else ""
                self.tbl_details.setItem(r, c, QTableWidgetItem(display_val))


    def recalc_all(self):
        if self.bom_df is None:
            return
        try:
            self.calc_bom_results()
            self.refresh_details_view()
        except Exception as e:
            self.log_msg(f"Recalc error: {e}")

    def refresh_details_view(self):
        if self.bom_df is None: 
            return
        
        if not hasattr(self, '_details_needs_refresh'):
            self._details_needs_refresh = True
        
        if not self._details_needs_refresh:
            return

        mpn_col = self.cmb_mpn.currentText() or self.bom_df.columns[0]
        df = self.bom_df.copy()

        add_cols = ["Manufacturer", "Part Type", "Life Cycle", "Package", "Size (L×W mm)", "Default Currency", "Lead Time"]
        for col in add_cols:
            df[col] = ""

        fixed_dists = ['Digikey', 'Mouser', 'Arrow', 'Avnet', 'Newark', 'RS Components', 'Element14']
        max_tiers = 5

        for d in fixed_dists:
            df[f"{d} Stock"] = ""
            for t in range(1, max_tiers + 1):
                df[f"{d} T{t} Qty"] = ""
                df[f"{d} T{t} Price"] = ""

        for idx, row in df.iterrows():
            mpn_val = row[mpn_col]
            if pd.isna(mpn_val):
                continue
            mpn = str(mpn_val).strip()
            if not mpn or mpn.lower() == 'nan':
                continue

            offers = self.storage.offers_by_mpn(mpn)
            manuf = sorted({o["manufacturer"] for o in offers if o.get("manufacturer")})
            meta = self.storage.part_meta(mpn)

            df.at[idx, "Manufacturer"] = " | ".join(manuf) if manuf else ""
            df.at[idx, "Part Type"] = meta.get("part_type", "")
            df.at[idx, "Life Cycle"] = meta.get("life", "")
            df.at[idx, "Lead Time"] = meta.get("lead_time", "")
            pkg = meta.get("package") or ""
            L = meta.get("L")
            W = meta.get("W")
            df.at[idx, "Package"] = pkg or ""
            if L is not None or W is not None:
                df.at[idx, "Size (L×W mm)"] = f"{(L or '')}×{(W or '')}"
            df.at[idx, "Default Currency"] = meta.get("default_currency", "USD")

            for o in offers:
                dname_raw = o["distributor"] or ""
                matched = next((d for d in fixed_dists if d.lower() in dname_raw.lower()), None)
                if not matched:
                    continue

                df.at[idx, f"{matched} Stock"] = str(o.get("stock", 0))
                tiers = sorted(o.get("price_tiers") or [], key=lambda x: x["quantity"])
                for ti, t in enumerate(tiers[:max_tiers], start=1):
                    df.at[idx, f"{matched} T{ti} Qty"] = str(t["quantity"])
                    df.at[idx, f"{matched} T{ti} Price"] = f"{t['price']:.6f}"

        self.tbl_details.setRowCount(len(df))
        self.tbl_details.setColumnCount(len(df.columns))
        self.tbl_details.setHorizontalHeaderLabels(list(df.columns))
        for r in range(len(df)):
            for c in range(len(df.columns)):
                val = df.iloc[r, c]
                display_val = str(val) if pd.notna(val) else ""
                self.tbl_details.setItem(r, c, QTableWidgetItem(display_val))

        self._details_needs_refresh = False

    def calc_bom_results(self):
        mpn_col = self.cmb_mpn.currentText()
        qty_col = self.cmb_qty.currentText()
        if not mpn_col or not qty_col:
            return

        df = self.bom_df.copy()

        result_cols = [
            "Part Type", "MPN", "Manufacturer", "Part Life Cycle Code", "Package",
            "Size (L×W mm)", "Lead Time", "In Stock", "MOQ", "Total Required Qty",
            "Procure Qty", "Distributor", "Qty Tier", "Unit Price", "PCB Per Unit Price", "Total Project Price"
        ]

        for col in result_cols:
            df[col] = ""

        pcb_qty = int(self.sp_pcb.value())
        currency = self.cmb_cur.currentText()
        usd_to_inr = float(self.sp_rate.value())

        for idx, row in df.iterrows():
            mpn_val = row[mpn_col]
            if pd.isna(mpn_val):
                continue
            mpn = str(mpn_val).strip()
            if not mpn or mpn.lower() == 'nan':
                continue

            qty_val = row[qty_col]
            if pd.isna(qty_val):
                bom_qty = 0.0
            else:
                try:
                    bom_qty = float(qty_val)
                except (ValueError, TypeError):
                    bom_qty = 0.0
            
            total_required = int(bom_qty * pcb_qty)

            # Get fresh data from storage (includes any user package updates)
            offers = self.storage.offers_by_mpn(mpn)
            meta = self.storage.part_meta(mpn)

            # Filter by manufacturer if user selected one
            selected_manufacturer = self._manufacturer_overrides.get(mpn)
            if selected_manufacturer:
                offers = [o for o in offers if o.get("manufacturer") == selected_manufacturer]
                if offers:
                    life = next((o["life_cycle_code"] for o in offers if o.get("life_cycle_code")), "")
                    pkg = next((o["package_code"] for o in offers if o.get("package_code")), "")
                    L = next((o["length_mm"] for o in offers if o.get("length_mm") is not None), None)
                    W = next((o["width_mm"] for o in offers if o.get("width_mm") is not None), None)
                    defcur = next((o["default_currency"] for o in offers if o.get("default_currency")), "USD")
                    ptype = next((o["part_type"] for o in offers if o.get("part_type")), "")
                    lead = next((o["lead_time"] for o in offers if o.get("lead_time")), "")
                    meta = {"life": life, "package": pkg, "L": L, "W": W, "default_currency": defcur, "part_type": ptype, "lead_time": lead}

            pkg_code = meta.get("package") or ""
            L = meta.get("L")
            W = meta.get("W")

            offers_conv = []
            for o in offers:
                tiers = []
                for t in o.get("price_tiers") or []:
                    price_conv = convert_price(t["price"], o.get("currency", "USD"), currency, usd_to_inr)
                    tiers.append({"quantity": int(t["quantity"]), "price": float(price_conv)})

                offers_conv.append({
                    "distributor": o["distributor"], "price_tiers": sorted(tiers, key=lambda x: x["quantity"]),
                    "stock": o.get("stock", 0), "currency": currency
                })

            best = choose_best_option(offers_conv, total_required, currency, usd_to_inr, norm_eia_code(pkg_code), L, W)

            if best:
                df.at[idx, "In Stock"] = str(best.get("stock", 0))
                df.at[idx, "MOQ"] = str(best.get("moq", ""))
                df.at[idx, "Total Required Qty"] = str(total_required)
                df.at[idx, "Procure Qty"] = str(best.get("procure_qty", total_required))
                df.at[idx, "Distributor"] = best.get("distributor", "")
                df.at[idx, "Qty Tier"] = str(best.get("qty_tier", ""))
                df.at[idx, "Unit Price"] = f"{best.get('unit_price', 0):.6f}"
                df.at[idx, "PCB Per Unit Price"] = f"{float(best.get('unit_price', 0)) * bom_qty:.6f}"
                df.at[idx, "Total Project Price"] = f"{float(best.get('unit_price', 0)) * bom_qty * pcb_qty:.4f}"

            df.at[idx, "Part Type"] = meta.get("part_type", "")
            df.at[idx, "MPN"] = mpn
            df.at[idx, "Part Life Cycle Code"] = meta.get("life", "")
            df.at[idx, "Package"] = meta.get("package", "")  # Use storage value directly
            df.at[idx, "Lead Time"] = meta.get("lead_time", "")
            
            if meta.get("L") is not None or meta.get("W") is not None:
                df.at[idx, "Size (L×W mm)"] = f"{(meta.get('L') or '')}×{(meta.get('W') or '')}"

            # Set manufacturer
            all_offers = self.storage.offers_by_mpn(mpn)
            manufacturers = sorted({o["manufacturer"] for o in all_offers if o.get("manufacturer")})
            if manufacturers:
                df.at[idx, "Manufacturer"] = selected_manufacturer or manufacturers[0]

        sums_cols = ["PCB Per Unit Price", "Total Project Price"]
        totals = {}
        for c in sums_cols:
            vals = pd.to_numeric(df[c].replace("", 0), errors="coerce").fillna(0) if c in df.columns else pd.Series()
            totals[c] = vals.sum()

        self.tbl_results.setRowCount(len(df) + 1)
        self.tbl_results.setColumnCount(len(df.columns))
        self.tbl_results.setHorizontalHeaderLabels(list(df.columns))

        for r in range(len(df)):
            for c in range(len(df.columns)):
                col_name = df.columns[c]
                val = df.iloc[r, c]
                display_val = str(val) if pd.notna(val) else ""
                it = QTableWidgetItem(display_val)
                
                if col_name == "In Stock":
                    try:
                        s = int(display_val) if display_val else 0
                    except Exception:
                        s = 0
                    if s == 0: 
                        it.setBackground(QColor(255, 200, 200))
                    elif s < 100: 
                        it.setBackground(QColor(255, 255, 200))
                    elif s < 1000: 
                        it.setBackground(QColor(255, 255, 150))
                    else: 
                        it.setBackground(QColor(200, 255, 200))
                    f = QFont(); f.setBold(True); it.setFont(f)
                
                # Make Package column editable
                elif col_name == "Package":
                    it.setFlags(it.flags() | Qt.ItemFlag.ItemIsEditable)
                    it.setBackground(QColor(240, 255, 240))  # Light green = editable

                # NEW: Make Size column editable
                elif col_name == "Size (L×W mm)":
                    it.setFlags(it.flags() | Qt.ItemFlag.ItemIsEditable)
                    it.setBackground(QColor(240, 240, 255))  # Light blue = editable

                self.tbl_results.setItem(r, c, it)

        # Add manufacturer dropdowns
        self._add_manufacturer_dropdowns(df)

        # Add totals row
        tr = len(df)
        for c in range(len(df.columns)):
            name = df.columns[c]
            if c == 0:
                tit = QTableWidgetItem("TOTAL")
            elif name in totals:
                tit = QTableWidgetItem(f"{totals[name]:.4f}")
            else:
                tit = QTableWidgetItem("")
            f = QFont(); f.setBold(True); tit.setFont(f); tit.setBackground(QColor(220, 220, 220))
            self.tbl_results.setItem(tr, c, tit)

    def _on_package_edit_changed(self, item):
        """Handle manual package and size edits and update storage"""
        if not item:
            return

        # Skip last TOTAL row
        if item.row() >= self.tbl_results.rowCount() - 1:
            return

        # Check which column was changed
        col = item.column()
        header = self.tbl_results.horizontalHeaderItem(col)
        if not header:
            return
        
        col_name = header.text()
        
        # Only handle Package and Size columns
        if col_name not in ["Package", "Size (L×W mm)"]:
            return

        # Get MPN of this row
        row = item.row()
        mpn_col_idx = None
        for c in range(self.tbl_results.columnCount()):
            h = self.tbl_results.horizontalHeaderItem(c)
            if h and h.text() == "MPN":
                mpn_col_idx = c
                break

        if mpn_col_idx is None:
            self.log_msg("Error: Cannot find MPN column")
            return

        mpn_item = self.tbl_results.item(row, mpn_col_idx)
        if not mpn_item:
            self.log_msg("Error: Cannot get MPN from row")
            return

        mpn = mpn_item.text().strip()
        new_value = item.text().strip()

        if not mpn:
            self.log_msg(f"Error: MPN is empty, cannot update {col_name}")
            return

        # Get original values for comparison
        orig_meta = self.storage.part_meta(mpn)
        
        try:
            if col_name == "Package":
                # Handle package update (existing functionality)
                original_package = orig_meta.get("package", "")
                if new_value != original_package:
                    rows_affected = self.storage.update_package_for_mpn(mpn, new_value)
                    self.log_msg(f"Package updated for {mpn}: '{new_value}' (was: '{original_package}') - {rows_affected} records affected")
            
            elif col_name == "Size (L×W mm)":
                # Handle size update (new functionality)
                original_l = orig_meta.get("L")
                original_w = orig_meta.get("W")
                original_size = f"{(original_l or '')}×{(original_w or '')}" if (original_l is not None or original_w is not None) else ""
                
                if new_value != original_size:
                    # Parse the new size value
                    length_mm, width_mm = self._parse_size_input(new_value)
                    
                    if length_mm is None and width_mm is None and new_value:
                        self.log_msg(f"Error: Invalid size format '{new_value}'. Use format like '1.6×0.8' or '1.6x0.8'")
                        item.setText(original_size)
                        return
                    
                    rows_affected = self.storage.update_size_for_mpn(mpn, length_mm, width_mm)
                    new_size_display = f"{(length_mm or '')}×{(width_mm or '')}" if (length_mm is not None or width_mm is not None) else ""
                    self.log_msg(f"Size updated for {mpn}: '{new_size_display}' (was: '{original_size}') - {rows_affected} records affected")
                    
                    # Update the display to show consistent format
                    item.setText(new_size_display)

        except Exception as e:
            self.log_msg(f"Error updating {col_name}: {e}")
            # Revert cell to original value on error
            if col_name == "Package":
                item.setText(orig_meta.get("package", ""))
            elif col_name == "Size (L×W mm)":
                original_l = orig_meta.get("L")
                original_w = orig_meta.get("W")
                original_size = f"{(original_l or '')}×{(original_w or '')}" if (original_l is not None or original_w is not None) else ""
                item.setText(original_size)
            return

        # Temporarily disconnect signal to avoid recursion
        self.tbl_results.itemChanged.disconnect(self._on_package_edit_changed)
        try:
            # Recalculate with updated storage
            self.recalc_all()
        except Exception as e:
            self.log_msg(f"Error during recalculation: {e}")
        finally:
            # Reconnect signal
            self.tbl_results.itemChanged.connect(self._on_package_edit_changed)

    def _parse_size_input(self, size_text):
        """Parse size input like '1.6×0.8' or '1.6x0.8' into length and width"""
        if not size_text or size_text.strip() == "×" or size_text.strip() == "x":
            return None, None
        
        # Handle various separators and formats
        import re
        
        # Look for patterns like "1.6×0.8", "1.6x0.8", "1.6 x 0.8", etc.
        pattern = r'([0-9]*\.?[0-9]+)\s*[×x]\s*([0-9]*\.?[0-9]+)'
        match = re.search(pattern, size_text.strip())
        
        if match:
            try:
                length = float(match.group(1))
                width = float(match.group(2))
                return length, width
            except ValueError:
                pass
        
        # Try to parse single number (assume it's length only)
        try:
            single_value = float(size_text.strip())
            return single_value, None
        except ValueError:
            pass
        
        return None, None



    def _add_manufacturer_dropdowns(self, df):
        """Add manufacturer dropdowns for MPNs with multiple manufacturers"""
        if "Manufacturer" not in df.columns or "MPN" not in df.columns:
            return
        
        manf_col_idx = list(df.columns).index("Manufacturer")
        mpn_col_idx = list(df.columns).index("MPN")
        
        for r in range(len(df)):
            mpn_val = df.iloc[r, mpn_col_idx]
            if pd.isna(mpn_val):
                continue
            mpn = str(mpn_val).strip()
            if not mpn or mpn.lower() == 'nan':
                continue
            
            # Get all manufacturers for this MPN
            offers = self.storage.offers_by_mpn(mpn)
            manufacturers = sorted({o["manufacturer"] for o in offers if o.get("manufacturer")})
            
            if len(manufacturers) <= 1:
                continue  # Single or no manufacturer, keep as text
            
            # Create dropdown for multiple manufacturers
            combo = QComboBox()
            combo.addItems(manufacturers)
            
            # Set current selection
            current_manf = self._manufacturer_overrides.get(mpn, manufacturers[0])
            combo.setCurrentText(current_manf)
            
            # Connect change event
            combo.currentTextChanged.connect(
                lambda selected_manf, mpn=mpn: self._on_manufacturer_changed(mpn, selected_manf)
            )
            
            # Set dropdown in table
            self.tbl_results.setCellWidget(r, manf_col_idx, combo)

    def _on_manufacturer_changed(self, mpn, selected_manufacturer):
        """Handle manufacturer dropdown change"""
        self._manufacturer_overrides[mpn] = selected_manufacturer
        self.log_msg(f"Manufacturer changed for {mpn}: {selected_manufacturer}")
        
        # Recalculate results with new manufacturer selection
        self.recalc_all()

    def on_export_smart(self, _):
        """Smart export - detects active tab and exports accordingly"""
        current_tab_index = self.tabs.currentIndex()
        current_tab_text = self.tabs.tabText(current_tab_index)
        
        if "Results" in current_tab_text:
            self.on_export_results()
        elif "Details" in current_tab_text:
            self.on_export_details()
        else:
            # Default to results if unclear
            self.on_export_results()


    def on_export_results(self):
        """Export BOM Results to Excel with summary table and green headers"""
        if self.tbl_results.rowCount() == 0:
            QMessageBox.warning(self, "Warning", "No data to export")
            return

        path, _ = QFileDialog.getSaveFileName(self, "Save Results Excel", "", "Excel (*.xlsx)")
        if not path:
            return

        try:
            # Get results data
            headers = [self.tbl_results.horizontalHeaderItem(i).text() for i in range(self.tbl_results.columnCount())]
            data = []
            
            for r in range(self.tbl_results.rowCount()):
                row = []
                for c in range(self.tbl_results.columnCount()):
                    it = self.tbl_results.item(r, c)
                    row.append(it.text() if it else "")
                data.append(row)

            df = pd.DataFrame(data, columns=headers)
            
            # Use openpyxl for advanced styling and summary
            from openpyxl import Workbook
            from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
            from openpyxl.utils.dataframe import dataframe_to_rows
            from openpyxl.drawing.image import Image
            import io
            
            wb = Workbook()
            ws = wb.active
            ws.title = "BOM Results"
            
            # Create summary table at top
            self._add_summary_table(ws, df)
            
            # Add spacing
            current_row = ws.max_row + 3
            
            # Add main data table
            for r_idx, row in enumerate(dataframe_to_rows(df, index=False, header=True), start=current_row):
                for c_idx, value in enumerate(row, start=1):
                    ws.cell(row=r_idx, column=c_idx, value=value)
            
            # Style the main table headers
            self._style_table_headers(ws, current_row, len(headers))
            
            # Auto-adjust column widths
            self._auto_adjust_columns(ws)
            
            wb.save(path)
            self.log_msg(f"Results exported: {path}")

        except Exception as e:
            QMessageBox.critical(self, "Export Error", str(e))
            self.log_msg(f"Results export failed: {e}")

    def _add_summary_table(self, ws, df):
        """Add summary table with image at the top of the worksheet"""
        from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
        
        # Calculate summary statistics
        total_rows = len(df) - 1  # Subtract TOTAL row
        if total_rows < 0:
            total_rows = 0
        
        # Try to get totals from the TOTAL row
        total_project_cost = 0
        total_pcb_cost = 0
        
        try:
            total_row = df.iloc[-1]  # Last row should be TOTAL
            if 'Total Project Price' in df.columns:
                total_project_str = str(total_row['Total Project Price']).replace(',', '')
                if total_project_str and total_project_str != 'TOTAL':
                    total_project_cost = float(total_project_str)
            
            if 'PCB Per Unit Price' in df.columns:
                total_pcb_str = str(total_row['PCB Per Unit Price']).replace(',', '')
                if total_pcb_str and total_pcb_str != 'TOTAL':
                    total_pcb_cost = float(total_pcb_str)
        except:
            pass
        
        currency = self.cmb_cur.currentText()
        pcb_qty = self.sp_pcb.value()
        
        # Title styling
        title_font = Font(size=16, bold=True, color="00962F")
        header_font = Font(size=12, bold=True, color="FFFFFF")
        value_font = Font(size=11)
        
        green_fill = PatternFill(start_color="00962F", end_color="00962F", fill_type="solid")
        light_green_fill = PatternFill(start_color="E8F5E8", end_color="E8F5E8", fill_type="solid")
        
        center_align = Alignment(horizontal="center", vertical="center")
        
        # Add title
        ws['A1'] = 'Sienna ECAD Technologies'
        ws['A1'].font = title_font
        ws['A1'].alignment = center_align
        ws.merge_cells('A1:F1')
        
        # Add summary table
        summary_start_row = 3
        
        # Summary headers
        summary_headers = [
            ('Metric', 'A'), ('Value', 'B'), ('', 'C'), 
            ('Metric', 'D'), ('Value', 'E'), ('Unit', 'F')
        ]
        
        for header, col in summary_headers:
            cell = ws[f'{col}{summary_start_row}']
            cell.value = header
            cell.font = header_font
            cell.fill = green_fill
            cell.alignment = center_align
        
        # Summary data
        summary_data = [
            ('Total Components', total_rows, '', 'PCB Quantity', pcb_qty, 'pcs'),
            ('Currency', currency, '', 'PCB Unit Cost', f'{total_pcb_cost:.2f}', currency),
            ('Project Total', f'{total_project_cost:.2f}', currency, 'Cost per PCB', f'{total_project_cost/pcb_qty if pcb_qty > 0 else 0:.2f}', f'{currency}/pcb'),
            ('Generated On', datetime.now().strftime('%Y-%m-%d %H:%M'), '', 'Exchange Rate', f'${1:.2f} = ₹{self.sp_rate.value():.2f}' if currency == 'INR' else 'N/A', ''),
        ]
        
        for row_idx, (metric1, value1, unit1, metric2, value2, unit2) in enumerate(summary_data, start=summary_start_row + 1):
            # Left side
            ws[f'A{row_idx}'].value = metric1
            ws[f'B{row_idx}'].value = value1
            ws[f'C{row_idx}'].value = unit1
            
            # Right side  
            ws[f'D{row_idx}'].value = metric2
            ws[f'E{row_idx}'].value = value2
            ws[f'F{row_idx}'].value = unit2
            
            # Style alternating rows
            fill = light_green_fill if row_idx % 2 == 0 else PatternFill()
            for col in ['A', 'B', 'C', 'D', 'E', 'F']:
                cell = ws[f'{col}{row_idx}']
                cell.fill = fill
                cell.alignment = center_align if col in ['B', 'E', 'F'] else Alignment(horizontal="left", vertical="center")

    def _style_table_headers(self, ws, header_row, num_cols):
        """Apply green background and white text to table headers"""
        from openpyxl.styles import Font, PatternFill, Alignment
        
        green_fill = PatternFill(start_color="00962F", end_color="00962F", fill_type="solid")
        white_font = Font(color="FFFFFF", bold=True, size=11)
        center_alignment = Alignment(horizontal="center", vertical="center")
        
        for col in range(1, num_cols + 1):
            cell = ws.cell(row=header_row, column=col)
            cell.fill = green_fill
            cell.font = white_font
            cell.alignment = center_alignment

    def _auto_adjust_columns(self, ws):
        """Auto-adjust column widths based on content - handles merged cells"""
        from openpyxl.cell import MergedCell
        
        # Get column letters and calculate max widths
        column_widths = {}
        
        for row in ws.iter_rows():
            for cell in row:
                # Skip merged cells
                if isinstance(cell, MergedCell):
                    continue
                    
                column_letter = cell.column_letter
                
                try:
                    # Calculate content length
                    content_length = len(str(cell.value)) if cell.value is not None else 0
                    
                    # Update max width for this column
                    if column_letter not in column_widths:
                        column_widths[column_letter] = content_length
                    else:
                        column_widths[column_letter] = max(column_widths[column_letter], content_length)
                        
                except Exception:
                    continue
        
        # Apply calculated widths
        for column_letter, max_length in column_widths.items():
            adjusted_width = min(max_length + 2, 50)  # Add padding, cap at 50
            ws.column_dimensions[column_letter].width = adjusted_width


    def on_export_details(self):
        """Export Component Details view to Excel with styling"""
        if self.tbl_details.rowCount() == 0:
            QMessageBox.warning(self, "Warning", "No details data to export")
            return

        path, _ = QFileDialog.getSaveFileName(self, "Save Details Excel", "", "Excel (*.xlsx)")
        if not path:
            return

        try:
            # Get data from details table
            headers = [self.tbl_details.horizontalHeaderItem(i).text() for i in range(self.tbl_details.columnCount())]
            data = []
            
            for r in range(self.tbl_details.rowCount()):
                row = []
                for c in range(self.tbl_details.columnCount()):
                    it = self.tbl_details.item(r, c)
                    row.append(it.text() if it else "")
                data.append(row)

            # Create DataFrame and export with custom styling
            df = pd.DataFrame(data, columns=headers)
            
            # Use openpyxl for custom styling
            from openpyxl import Workbook
            from openpyxl.styles import Font, PatternFill, Alignment
            from openpyxl.utils.dataframe import dataframe_to_rows
            
            wb = Workbook()
            ws = wb.active
            ws.title = "Component Details"
            
            # Add DataFrame to worksheet
            for r in dataframe_to_rows(df, index=False, header=True):
                ws.append(r)
            
            # Style headers - Green background, white text
            green_fill = PatternFill(start_color="00962F", end_color="00962F", fill_type="solid")
            white_font = Font(color="FFFFFF", bold=True, size=11)
            center_alignment = Alignment(horizontal="center", vertical="center")
            
            # Apply header styling to first row
            for col in range(1, len(headers) + 1):
                cell = ws.cell(row=1, column=col)
                cell.fill = green_fill
                cell.font = white_font
                cell.alignment = center_alignment
            
            # Auto-adjust column widths
            for column in ws.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 50)
                ws.column_dimensions[column_letter].width = adjusted_width
            
            wb.save(path)
            self.log_msg(f"Details exported: {path}")

        except Exception as e:
            QMessageBox.critical(self, "Export Error", str(e))
            self.log_msg(f"Details export failed: {e}")



def run_app():
    app = QApplication(sys.argv)
    
    # Apply dark green theme to the entire application
    apply_dark_green_theme(app)
    
    # Create and show the main window
    w = App()
    w.show()
    
    # Set window icon if desired
    w.setWindowIcon(w.style().standardIcon(w.style().StandardPixmap.SP_ComputerIcon))
    
    sys.exit(app.exec())

# Optional: still run if executing directly
if __name__ == "__main__":
    run_app()
