
import sys
import sqlite3
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import pandas as pd
import re
import time
from datetime import datetime
from PyQt6.QtWidgets import (QApplication, QMainWindow, QVBoxLayout, QHBoxLayout,
                             QWidget, QToolBar, QPushButton, QTableWidget, QTableWidgetItem,
                             QComboBox, QLineEdit, QLabel, QTextEdit, QFileDialog,
                             QMessageBox, QTabWidget, QSpinBox, QDoubleSpinBox,
                             QProgressBar, QSplitter, QHeaderView)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QAction, QIcon, QColor, QFont
import json
import urllib.parse

class FindChipScraper:
    def __init__(self):
        self.setup_driver()
        # Current exchange rates (you can update these or fetch from an API)
        self.exchange_rates = {
            'USD': 1.0,
            'INR': 0.012,  # 1 INR = 0.012 USD (approximate)
            'EUR': 1.08,   # 1 EUR = 1.08 USD (approximate)
            'GBP': 1.26,   # 1 GBP = 1.26 USD (approximate)
        }

    def setup_driver(self):
        """Setup Chrome WebDriver with options"""
        chrome_options = Options()
        chrome_options.add_argument('--headless')  # Run in background
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--disable-gpu')
        chrome_options.add_argument('--window-size=1920,1080')
        chrome_options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
        
        try:
            self.driver = webdriver.Chrome(options=chrome_options)
            self.wait = WebDriverWait(self.driver, 10)
        except Exception as e:
            print(f"Error setting up WebDriver: {str(e)}")
            self.driver = None

    def search_mpn(self, mpn):
        """Search for MPN on findchips.com and return pricing data"""
        if not self.driver:
            return None
            
        try:
            search_url = f"https://www.findchips.com/search/{urllib.parse.quote(mpn)}"
            self.driver.get(search_url)
            
            # Wait for results to load
            time.sleep(3)
            
            # Look for table rows with data attributes
            distributor_rows = self.driver.find_elements(By.CSS_SELECTOR, 'tr.row')
            
            distributors = []
            
            for row in distributor_rows:
                try:
                    distributor_data = self.parse_distributor_row(row)
                    if distributor_data:
                        distributors.append(distributor_data)
                except Exception as e:
                    continue
            
            return distributors
            
        except Exception as e:
            print(f"Error scraping {mpn}: {str(e)}")
            return None

    def parse_distributor_row(self, row):
        """Parse distributor data from a table row with data attributes"""
        try:
            # Extract data from attributes
            distributor_name = row.get_attribute('data-distributor_name') or 'Unknown'
            manufacturer = row.get_attribute('data-mfr') or 'Unknown'
            mpn = row.get_attribute('data-mfrpartnumber') or ''
            stock_raw = row.get_attribute('data-instock') or '0'
            price_data_raw = row.get_attribute('data-price') or '[]'
            
            # Parse stock information
            try:
                stock = int(stock_raw) if stock_raw.isdigit() else 0
            except (ValueError, AttributeError):
                stock = 0
            
            # Parse price tiers with currency conversion to USD
            price_tiers_usd = self.parse_price_data_to_usd(price_data_raw)
            
            if not price_tiers_usd:
                return None
                
            return {
                'distributor': distributor_name,
                'manufacturer': manufacturer,
                'mpn': mpn,
                'price_tiers': price_tiers_usd,
                'stock': stock,
                'currency': 'USD'  # All prices are now converted to USD
            }
            
        except Exception as e:
            return None

    def parse_price_data_to_usd(self, price_data_raw):
        """Parse price data from JSON string and convert all prices to USD"""
        price_tiers = []
        
        try:
            # The price data is in format: [[qty, "currency", "price"], ...]
            price_list = json.loads(price_data_raw)
            
            for tier in price_list:
                if len(tier) >= 3:
                    qty = int(tier[0])
                    currency = tier[1].upper()  # Ensure uppercase
                    price = float(tier[2])
                    
                    # Convert price to USD
                    usd_price = self.convert_to_usd(price, currency)
                    
                    price_tiers.append({
                        'quantity': qty,
                        'price': usd_price
                    })
                    
        except (json.JSONDecodeError, ValueError, IndexError) as e:
            return []
        
        # Sort by quantity (ascending)
        return sorted(price_tiers, key=lambda x: x['quantity'])

    def convert_to_usd(self, price, from_currency):
        """Convert price from any currency to USD"""
        from_currency = from_currency.upper()
        
        if from_currency == 'USD':
            return price
        elif from_currency in self.exchange_rates:
            return price * self.exchange_rates[from_currency]
        else:
            # If currency not recognized, assume it's already USD
            print(f"Warning: Unknown currency {from_currency}, assuming USD")
            return price

    def close(self):
        """Close the WebDriver"""
        if self.driver:
            self.driver.quit()

class ScrapingWorker(QThread):
    progress_updated = pyqtSignal(int)
    log_updated = pyqtSignal(str)
    data_scraped = pyqtSignal(str, list)  # mpn, distributors
    finished_scraping = pyqtSignal()

    def __init__(self, mpn_list):
        super().__init__()
        self.mpn_list = mpn_list
        self.scraper = None

    def run(self):
        self.scraper = FindChipScraper()
        
        if not self.scraper.driver:
            self.log_updated.emit("Failed to initialize WebDriver")
            self.finished_scraping.emit()
            return
            
        total = len(self.mpn_list)
        for i, mpn in enumerate(self.mpn_list):
            try:
                self.log_updated.emit(f"Scraping MPN: {mpn}")
                distributors = self.scraper.search_mpn(mpn)
                if distributors:
                    self.data_scraped.emit(mpn, distributors)
                    self.log_updated.emit(f"Found {len(distributors)} distributors for {mpn}")
                else:
                    self.log_updated.emit(f"No data found for {mpn}")
                    
                self.progress_updated.emit(int((i + 1) / total * 100))
                time.sleep(2)  # Rate limiting for Selenium
                
            except Exception as e:
                self.log_updated.emit(f"Error scraping {mpn}: {str(e)}")
        
        if self.scraper:
            self.scraper.close()
        self.finished_scraping.emit()

class DatabaseManager:
    def __init__(self, db_path="bom_data.db"):
        self.db_path = db_path
        self.init_database()
        self.migrate_database()

    def init_database(self):
        """Initialize the database tables"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS component_data (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            mpn TEXT NOT NULL,
            distributor TEXT,
            manufacturer TEXT,
            price_tiers TEXT,  -- Store as JSON string
            stock INTEGER DEFAULT 0,
            currency TEXT DEFAULT 'USD',
            scraped_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(mpn, distributor)
        )
        ''')
        conn.commit()
        conn.close()

    def migrate_database(self):
        """Migrate old database format to new format"""
        import json
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Check if we need to migrate
        cursor.execute("PRAGMA table_info(component_data)")
        columns = [column[1] for column in cursor.fetchall()]
        
        if 'price_tiers' not in columns and 'quantity' in columns:
            # Old format - need to migrate
            print("Migrating database to new format...")
            
            # Create new table
            cursor.execute('''
            CREATE TABLE component_data_new (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                mpn TEXT NOT NULL,
                distributor TEXT,
                manufacturer TEXT,
                price_tiers TEXT,
                stock INTEGER DEFAULT 0,
                currency TEXT DEFAULT 'USD',
                scraped_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(mpn, distributor)
            )
            ''')
            
            # Migrate data
            cursor.execute('''
            SELECT mpn, distributor, manufacturer, quantity, price, stock, currency
            FROM component_data
            ORDER BY mpn, distributor, quantity
            ''')
            
            old_data = cursor.fetchall()
            
            # Group by mpn+distributor
            grouped_data = {}
            for mpn, dist, mfg, qty, price, stock, currency in old_data:
                key = (mpn, dist)
                if key not in grouped_data:
                    grouped_data[key] = {
                        'mpn': mpn,
                        'distributor': dist,
                        'manufacturer': mfg,
                        'stock': stock or 0,
                        'currency': currency,
                        'price_tiers': []
                    }
                grouped_data[key]['price_tiers'].append({'quantity': qty, 'price': price})
            
            # Insert merged data
            for key, data in grouped_data.items():
                price_tiers_json = json.dumps(data['price_tiers'])
                cursor.execute('''
                INSERT INTO component_data_new
                (mpn, distributor, manufacturer, price_tiers, stock, currency)
                VALUES (?, ?, ?, ?, ?, ?)
                ''', (data['mpn'], data['distributor'], data['manufacturer'], 
                      price_tiers_json, data['stock'], data['currency']))
            
            # Replace old table
            cursor.execute('DROP TABLE component_data')
            cursor.execute('ALTER TABLE component_data_new RENAME TO component_data')
            
            print("Database migration completed")
        
        conn.commit()
        conn.close()

    def save_component_data(self, mpn, distributors):
        """Save component data to database"""
        import json
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        for dist_data in distributors:
            distributor = dist_data['distributor']
            manufacturer = dist_data['manufacturer']
            currency = dist_data['currency']  # Should be USD now
            stock = dist_data.get('stock', 0)
            price_tiers = dist_data['price_tiers']
            
            # Check if this distributor+MPN combination already exists
            cursor.execute('''
            SELECT price_tiers FROM component_data 
            WHERE mpn = ? AND distributor = ?
            ''', (mpn, distributor))
            
            existing = cursor.fetchone()
            
            if existing:
                # Merge with existing price tiers
                existing_tiers = json.loads(existing[0])
                
                # Create a dictionary for easy merging
                tier_dict = {tier['quantity']: tier for tier in existing_tiers}
                
                # Add new tiers or update existing ones
                for tier in price_tiers:
                    tier_dict[tier['quantity']] = tier
                
                # Convert back to list and sort
                merged_tiers = sorted(tier_dict.values(), key=lambda x: x['quantity'])
                price_tiers_json = json.dumps(merged_tiers)
            else:
                # No existing data, use new tiers
                price_tiers_json = json.dumps(price_tiers)
            
            cursor.execute('''
            INSERT OR REPLACE INTO component_data
            (mpn, distributor, manufacturer, price_tiers, stock, currency)
            VALUES (?, ?, ?, ?, ?, ?)
            ''', (mpn, distributor, manufacturer, price_tiers_json, stock, currency))
        
        conn.commit()
        conn.close()

    def get_component_data(self, mpn):
        """Get component data from database"""
        import json
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT distributor, manufacturer, price_tiers, stock, currency
        FROM component_data
        WHERE mpn = ?
        ORDER BY distributor
        ''', (mpn,))
        
        results = cursor.fetchall()
        conn.close()
        
        # Parse JSON price tiers and flatten the data
        flattened_results = []
        for dist, mfg, price_tiers_json, stock, currency in results:
            try:
                price_tiers = json.loads(price_tiers_json)
                for tier in price_tiers:
                    flattened_results.append((
                        dist, mfg, tier['quantity'], tier['price'], currency, stock
                    ))
            except json.JSONDecodeError:
                continue
        
        return flattened_results

    def get_component_details_by_mpn(self, mpn):
        """Get detailed component data by MPN for Component Details tab"""
        import json
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT distributor, manufacturer, price_tiers, stock, currency
        FROM component_data
        WHERE mpn = ?
        ORDER BY distributor
        ''', (mpn,))
        
        results = cursor.fetchall()
        conn.close()
        
        # Return structured data with all tiers per distributor
        component_details = []
        for dist, mfg, price_tiers_json, stock, currency in results:
            try:
                price_tiers = json.loads(price_tiers_json)
                component_details.append({
                    'distributor': dist,
                    'manufacturer': mfg,
                    'stock': stock,
                    'currency': currency,
                    'price_tiers': price_tiers
                })
            except json.JSONDecodeError:
                continue
        
        return component_details

class BOMAnalyzer(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BOM Web Scraper & Analyzer (Selenium - USD Converter)")
        self.setGeometry(100, 100, 1400, 800)
        
        # Initialize components
        self.db_manager = DatabaseManager()
        self.bom_data = None
        self.scraped_data = {}
        
        # Exchange rates (default values) - All prices are now in USD
        self.exchange_rates = {"USD": 1.0, "INR": 83.2}
        
        self.setup_ui()
        self.setup_connections()

    def setup_ui(self):
        """Setup the user interface"""
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Create toolbar
        self.create_toolbar()
        
        # Create main layout
        main_layout = QVBoxLayout(central_widget)
        
        # Create top controls
        controls_layout = self.create_controls()
        main_layout.addLayout(controls_layout)
        
        # Create progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        main_layout.addWidget(self.progress_bar)
        
        # Create splitter for main content
        splitter = QSplitter(Qt.Orientation.Vertical)
        
        # Create tab widget for data display
        self.tab_widget = QTabWidget()
        
        # BOM Result View
        self.result_table = QTableWidget()
        self.tab_widget.addTab(self.result_table, "BOM Results")
        
        # Detail View
        self.detail_table = QTableWidget()
        self.tab_widget.addTab(self.detail_table, "Component Details")
        
        splitter.addWidget(self.tab_widget)
        
        # Create log area
        self.log_text = QTextEdit()
        self.log_text.setMaximumHeight(150)
        self.log_text.setReadOnly(True)
        splitter.addWidget(self.log_text)
        
        splitter.setStretchFactor(0, 3)
        splitter.setStretchFactor(1, 1)
        
        main_layout.addWidget(splitter)

    def create_toolbar(self):
        """Create the application toolbar"""
        toolbar = QToolBar()
        self.addToolBar(toolbar)
        
        # Upload BOM action
        upload_action = QAction("Upload BOM", self)
        upload_action.triggered.connect(self.upload_bom)
        toolbar.addAction(upload_action)
        
        toolbar.addSeparator()
        
        # Fetch Data action
        fetch_action = QAction("Fetch Data", self)
        fetch_action.triggered.connect(self.fetch_data)
        toolbar.addAction(fetch_action)
        
        toolbar.addSeparator()
        
        # Export to Excel action
        export_action = QAction("Export to Excel", self)
        export_action.triggered.connect(self.export_to_excel)
        toolbar.addAction(export_action)

    def create_controls(self):
        """Create control widgets with package column selection"""
        layout = QHBoxLayout()
        
        # Column selection - Added Package column
        layout.addWidget(QLabel("MPN Column:"))
        self.mpn_column_combo = QComboBox()
        layout.addWidget(self.mpn_column_combo)
        
        layout.addWidget(QLabel("QTY Column:"))
        self.qty_column_combo = QComboBox()
        layout.addWidget(self.qty_column_combo)
        
        # NEW: Package column selection
        layout.addWidget(QLabel("Package Column:"))
        self.package_column_combo = QComboBox()
        layout.addWidget(self.package_column_combo)
        
        # PCB Quantity
        layout.addWidget(QLabel("PCB Qty:"))
        self.pcb_qty_input = QSpinBox()
        self.pcb_qty_input.setMinimum(1)
        self.pcb_qty_input.setMaximum(1000000)
        self.pcb_qty_input.setValue(1)
        layout.addWidget(self.pcb_qty_input)
        
        # Currency selection (for display purposes - internal is always USD)
        layout.addWidget(QLabel("Display Currency:"))
        self.currency_combo = QComboBox()
        self.currency_combo.addItems(["USD", "INR", "EUR", "GBP"])
        layout.addWidget(self.currency_combo)
        
        # Exchange rate
        layout.addWidget(QLabel("USD to INR Rate:"))
        self.exchange_rate_input = QDoubleSpinBox()
        self.exchange_rate_input.setMinimum(0.01)
        self.exchange_rate_input.setMaximum(1000.0)
        self.exchange_rate_input.setValue(83.2)
        self.exchange_rate_input.setDecimals(2)
        layout.addWidget(self.exchange_rate_input)
        
        layout.addStretch()
        
        return layout

    def setup_connections(self):
        """Setup signal connections"""
        self.currency_combo.currentTextChanged.connect(self.on_currency_changed)
        self.exchange_rate_input.valueChanged.connect(self.on_exchange_rate_changed)
        self.pcb_qty_input.valueChanged.connect(self.recalculate_results)

    def on_currency_changed(self, currency):
        """Handle currency change"""
        if self.bom_data is not None and len(self.scraped_data) > 0:
            self.log_message(f"Display currency changed to {currency}, recalculating results...")
            self.calculate_bom_results()

    def on_exchange_rate_changed(self, rate):
        """Handle exchange rate change"""
        self.exchange_rates["INR"] = rate
        if self.bom_data is not None and len(self.scraped_data) > 0:
            self.log_message(f"Exchange rate updated to {rate}, recalculating results...")
            self.calculate_bom_results()

    def log_message(self, message):
        """Add message to log"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.append(f"[{timestamp}] {message}")

    def upload_bom(self):
        """Upload and process BOM file with improved column handling"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open BOM file", "", "Excel files (*.xlsx *.xls)"
        )
        
        if file_path:
            try:
                # Read Excel file
                self.bom_data = pd.read_excel(file_path)
                self.log_message(f"BOM loaded: {len(self.bom_data)} rows")
                
                # Populate column dropdowns
                columns = list(self.bom_data.columns)
                
                # Clear and populate all column dropdowns
                self.mpn_column_combo.clear()
                self.qty_column_combo.clear()
                self.package_column_combo.clear()
                
                self.mpn_column_combo.addItems(columns)
                self.qty_column_combo.addItems(columns)
                
                # Package column with "None" option
                self.package_column_combo.addItem("(None)")
                self.package_column_combo.addItems(columns)
                
                # Smart column selection based on common names
                self.auto_select_columns(columns)
                
                # Display BOM in result table
                self.display_bom_data()
                
                # Load component details
                self.load_component_details()
                
                self.log_message("BOM uploaded successfully")
                
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to load BOM: {str(e)}")
                self.log_message(f"Error loading BOM: {str(e)}")

    def auto_select_columns(self, columns):
        """Automatically select columns based on common naming patterns"""
        # Auto-select MPN column
        mpn_patterns = ['MPN', 'PART NUMBER', 'PART_NUMBER', 'PARTNUMBER', 'P/N', 'PN']
        for i, col in enumerate(columns):
            if any(pattern in col.upper() for pattern in mpn_patterns):
                self.mpn_column_combo.setCurrentIndex(i)
                break
        
        # Auto-select QTY column
        qty_patterns = ['QTY', 'QUANTITY', 'COUNT', 'QT', 'AMOUNT']
        for i, col in enumerate(columns):
            if any(pattern in col.upper() for pattern in qty_patterns):
                self.qty_column_combo.setCurrentIndex(i)
                break
        
        # Auto-select Package column
        package_patterns = ['PACKAGE', 'PKG', 'FOOTPRINT', 'CASE', 'ENCLOSURE']
        for i, col in enumerate(columns):
            if any(pattern in col.upper() for pattern in package_patterns):
                self.package_column_combo.setCurrentIndex(i + 1)  # +1 because of "(None)" option
                break

    def display_bom_data(self):
        """Display BOM data in the result table"""
        if self.bom_data is None:
            return
        
        # Set up table
        self.result_table.setRowCount(len(self.bom_data))
        self.result_table.setColumnCount(len(self.bom_data.columns))
        self.result_table.setHorizontalHeaderLabels(list(self.bom_data.columns))
        
        # Set fixed column widths for BOM columns
        bom_column_widths = {
            'Designator': 120,
            'Comment': 150,
            'Footprint': 140,
            'LCSC Part #': 120,
            'MPN': 150,
            'Quantity': 100,
            'Qty': 100,
            'Value': 120,
            'Package': 100,
            'Description': 200,
            'Manufacturer': 140,
            'Part Number': 150
        }
        
        # Apply fixed widths to BOM columns
        for i, col_name in enumerate(self.bom_data.columns):
            if col_name in bom_column_widths:
                self.result_table.setColumnWidth(i, bom_column_widths[col_name])
            else:
                self.result_table.setColumnWidth(i, 120)  # Default width
        
        # Disable stretching to preserve fixed widths
        self.result_table.horizontalHeader().setStretchLastSection(False)
        
        # Set green header background color for BOM data
        for i in range(self.result_table.columnCount()):
            header_item = self.result_table.horizontalHeaderItem(i)
            if header_item:
                header_item.setBackground(QColor(0, 150, 0))  # Dark green
                header_item.setForeground(QColor(255, 255, 255))  # White text for contrast
        
        # Fill table with data
        for row in range(len(self.bom_data)):
            for col in range(len(self.bom_data.columns)):
                item = QTableWidgetItem(str(self.bom_data.iloc[row, col]))
                self.result_table.setItem(row, col, item)

    # Load component details method remains the same...
    def load_component_details(self):
        """Load component details tab with individual tier columns and stock columns for each distributor"""
        if self.bom_data is None:
            return
        
        # Find MPN column
        mpn_column = None
        for col in self.bom_data.columns:
            if 'MPN' in col.upper() or 'PART' in col.upper():
                mpn_column = col
                break
        
        if not mpn_column:
            mpn_column = self.bom_data.columns[0]  # Fallback to first column
        
        # Create detail dataframe starting with BOM data
        detail_df = self.bom_data.copy()
        
        # Fixed list of distributors
        distributors = ['Digikey', 'Mouser', 'Arrow', 'Avnet', 'Newark', 'RS Components', 
                    'Future Electronics', 'Element14', 'TME', 'Farnell']
        
        # Maximum number of tiers to create columns for
        max_tiers = 5
        
        # Add Manufacturer column first
        detail_df['Manufacturer'] = ''
        
        # Create individual tier columns and stock columns for each distributor
        tier_columns = []
        stock_columns = []
        
        for distributor in distributors:
            # Add tier columns for this distributor
            for tier_num in range(1, max_tiers + 1):
                qty_col = f'{distributor} T{tier_num} Qty'
                price_col = f'{distributor} T{tier_num} Price'
                tier_columns.extend([qty_col, price_col])
                detail_df[qty_col] = ''
                detail_df[price_col] = ''
            
            # Add stock column for this distributor
            stock_col = f'{distributor} Stock'
            stock_columns.append(stock_col)
            detail_df[stock_col] = ''
        
        # Collect component details for each row
        component_details_map = {}
        
        for idx, row in detail_df.iterrows():
            mpn = str(row[mpn_column]).strip()
            if mpn and mpn != 'nan':
                component_details = self.db_manager.get_component_details_by_mpn(mpn)
                component_details_map[idx] = component_details
        
        # Fill data for each row
        for idx in component_details_map:
            details = component_details_map[idx]
            manufacturers = set()
            
            # Process each distributor's data
            for detail in details:
                manufacturers.add(detail['manufacturer'])
                dist = detail['distributor']
                
                # Check if this distributor matches any of our fixed distributor names
                matched_dist = None
                for target_dist in distributors:
                    if target_dist.lower() in dist.lower():
                        matched_dist = target_dist
                        break
                
                if matched_dist:
                    # Sort price tiers by quantity
                    sorted_tiers = sorted(detail['price_tiers'], key=lambda x: x['quantity'])
                    
                    # Fill individual tier columns (up to max_tiers)
                    for tier_idx, tier in enumerate(sorted_tiers[:max_tiers]):
                        tier_num = tier_idx + 1  # T1, T2, T3, etc.
                        qty_col = f'{matched_dist} T{tier_num} Qty'
                        price_col = f'{matched_dist} T{tier_num} Price'
                        
                        detail_df.at[idx, qty_col] = str(tier['quantity'])
                        # Prices are already in USD, format them properly
                        detail_df.at[idx, price_col] = f"${tier['price']:.4f}"
                    
                    # Fill stock column for this distributor
                    stock_col = f'{matched_dist} Stock'
                    detail_df.at[idx, stock_col] = str(detail['stock'])
            
            # Set manufacturer (join multiple if different)
            if manufacturers:
                detail_df.at[idx, 'Manufacturer'] = ' | '.join(sorted(manufacturers))
        
        # Set up detail table (same as before, but with USD prices)
        self.detail_table.setRowCount(len(detail_df))
        self.detail_table.setColumnCount(len(detail_df.columns))
        self.detail_table.setHorizontalHeaderLabels(list(detail_df.columns))
        
        # Set column widths for better display
        column_widths = {
            # Original BOM columns
            'Designator': 100,
            'Comment': 120,
            'Footprint': 120,
            'LCSC Part #': 100,
            'MPN': 130,
            'Quantity': 80,
            'Qty': 80,
            'Value': 100,
            'Package': 100,
            'Description': 150,
            'Manufacturer': 140
        }
        
        # Set widths for tier columns and stock columns
        for i, col_name in enumerate(detail_df.columns):
            if col_name in column_widths:
                self.detail_table.setColumnWidth(i, column_widths[col_name])
            elif 'Qty' in col_name and 'T' in col_name:
                self.detail_table.setColumnWidth(i, 60)  # Narrower for quantity
            elif 'Price' in col_name and 'T' in col_name:
                self.detail_table.setColumnWidth(i, 90)  # Wider for USD price
            elif 'Stock' in col_name:
                self.detail_table.setColumnWidth(i, 70)  # Medium width for stock
            else:
                self.detail_table.setColumnWidth(i, 100)  # Default width
        
        # Rest of the formatting code remains the same...
        # (Color coding, headers, etc.)
        
        self.log_message(f"Component Details loaded: {len(detail_df)} components with USD prices")

    # Fetch data method remains similar...
    def fetch_data(self):
        """Start fetching data from findchips.com"""
        if self.bom_data is None:
            QMessageBox.warning(self, "Warning", "Please upload BOM first")
            return
        
        mpn_column = self.mpn_column_combo.currentText()
        if not mpn_column:
            QMessageBox.warning(self, "Warning", "Please select MPN column")
            return
        
        # Get unique MPNs
        mpn_list = self.bom_data[mpn_column].dropna().unique().tolist()
        if not mpn_list:
            QMessageBox.warning(self, "Warning", "No MPNs found in selected column")
            return
        
        self.log_message(f"Starting to scrape {len(mpn_list)} MPNs (converting all to USD)")
        
        # Show progress bar
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        
        # Start scraping thread
        self.scraping_worker = ScrapingWorker(mpn_list)
        self.scraping_worker.progress_updated.connect(self.progress_bar.setValue)
        self.scraping_worker.log_updated.connect(self.log_message)
        self.scraping_worker.data_scraped.connect(self.process_scraped_data)
        self.scraping_worker.finished_scraping.connect(self.scraping_finished)
        self.scraping_worker.start()

    def process_scraped_data(self, mpn, distributors):
        """Process scraped data for an MPN"""
        self.scraped_data[mpn] = distributors
        self.db_manager.save_component_data(mpn, distributors)

    def scraping_finished(self):
        """Handle scraping completion"""
        self.progress_bar.setVisible(False)
        self.log_message("Scraping completed - All prices converted to USD")
        self.calculate_bom_results()
        # Refresh component details with new data
        self.load_component_details()

    # Calculate BOM results with USD conversion for display
    def calculate_bom_results(self):
        """Calculate BOM results with pricing data"""
        if self.bom_data is None:
            return
        
        mpn_column = self.mpn_column_combo.currentText()
        qty_column = self.qty_column_combo.currentText()
        
        if not mpn_column or not qty_column:
            QMessageBox.warning(self, "Warning", "Please select both MPN and QTY columns")
            return
        
        # Create results dataframe
        results_df = self.bom_data.copy()
        
        # Add new columns - include Stock here
        new_columns = ['Stock','MOQ', 'Total Required Qty', 'Procure Qty', 'Distributor',
                       'Qty Tier', 'Unit Price (USD)', 'PCB Per Unit Price', 'Total Project Price']
        
        for col in new_columns:
            results_df[col] = ""
        
        pcb_qty = self.pcb_qty_input.value()
        display_currency = self.currency_combo.currentText()
        usd_to_inr_rate = self.exchange_rate_input.value()
        
        # Process each row
        for idx, row in results_df.iterrows():
            mpn = str(row[mpn_column])
            bom_qty = float(row[qty_column]) if pd.notna(row[qty_column]) else 0
            
            # Get component data (already in USD)
            component_data = self.db_manager.get_component_data(mpn)
            
            if component_data:
                # Process pricing data
                best_option = self.find_best_pricing_option(component_data, bom_qty * pcb_qty, display_currency, usd_to_inr_rate)
                
                if best_option:
                    results_df.at[idx, 'Stock'] = best_option.get('stock', 'N/A')
                    results_df.at[idx, 'MOQ'] = best_option['moq']
                    results_df.at[idx, 'Total Required Qty'] = int(bom_qty * pcb_qty)
                    results_df.at[idx, 'Procure Qty'] = int(bom_qty * pcb_qty)
                    results_df.at[idx, 'Distributor'] = best_option['distributor']
                    results_df.at[idx, 'Qty Tier'] = best_option['qty_tier']
                    results_df.at[idx, 'Unit Price (USD)'] = round(best_option['unit_price'], 4)
                    results_df.at[idx, 'PCB Per Unit Price'] = round(best_option['unit_price'] * bom_qty, 4)
                    results_df.at[idx, 'Total Project Price'] = round(best_option['unit_price'] * bom_qty * pcb_qty, 2)
        
        # Display results
        self.display_results(results_df)
        self.log_message("BOM analysis completed with USD pricing")

    def find_best_pricing_option(self, component_data, required_qty, display_currency, usd_to_inr_rate):
        """Find the best pricing option for a component with proper currency conversion"""
        distributors = {}
        
        # Group by distributor - prices are already in USD from scraping
        for dist, mfg, qty, price_usd, curr, stock in component_data:
            if dist not in distributors:
                distributors[dist] = {'tiers': [], 'stock': stock}
            
            # Convert USD price to display currency if needed
            if display_currency == 'INR':
                converted_price = price_usd * usd_to_inr_rate
            elif display_currency == 'EUR':
                converted_price = price_usd / 1.08  # Approximate
            elif display_currency == 'GBP':
                converted_price = price_usd / 1.26  # Approximate
            else:  # USD
                converted_price = price_usd
            
            distributors[dist]['tiers'].append({
                'quantity': qty,
                'price': converted_price,
                'manufacturer': mfg
            })
            
            # Use the highest stock value found for this distributor
            distributors[dist]['stock'] = max(distributors[dist]['stock'], stock)

        # Priority order for distributors
        priority_order = ['Digikey', 'Mouser', 'Arrow', 'Avnet', 'Newark', 'RS Components']
        
        best_option = None
        best_distributor = None
        
        # Check distributors in priority order
        for priority_dist in priority_order:
            for dist_name in distributors.keys():
                if priority_dist.lower() in dist_name.lower():
                    option = self.calculate_pricing_for_distributor(distributors[dist_name]['tiers'], required_qty)
                    if option and (best_option is None or option['unit_price'] < best_option['unit_price']):
                        best_option = option
                        best_distributor = dist_name
                    break
            if best_option:
                break

        # If no priority distributor found, check others
        if not best_option:
            for dist_name, dist_data in distributors.items():
                option = self.calculate_pricing_for_distributor(dist_data['tiers'], required_qty)
                if option and (best_option is None or option['unit_price'] < best_option['unit_price']):
                    best_option = option
                    best_distributor = dist_name

        if best_option:
            best_option['distributor'] = best_distributor
            best_option['stock'] = distributors[best_distributor]['stock']
            
        return best_option

    def calculate_pricing_for_distributor(self, price_tiers, required_qty):
        """Calculate pricing for a specific distributor"""
        if not price_tiers:
            return None
        
        # Sort by quantity
        sorted_tiers = sorted(price_tiers, key=lambda x: x['quantity'])
        
        # Find MOQ (lowest quantity tier)
        moq = sorted_tiers[0]['quantity']
        
        # Find appropriate qty tier for required quantity
        selected_tier = None
        for tier in sorted_tiers:
            if required_qty >= tier['quantity']:
                selected_tier = tier
            else:
                break
        
        if not selected_tier:
            selected_tier = sorted_tiers[0]  # Use MOQ tier
        
        return {
            'moq': moq,
            'qty_tier': selected_tier['quantity'],
            'unit_price': selected_tier['price']
        }

    # Display results and other methods remain largely the same...
    def display_results(self, results_df):
        """Display calculated results in the table"""
        # Calculate totals for specific columns
        sum_columns = ['PCB Per Unit Price', 'Total Project Price']
        totals = {}
        
        for col in sum_columns:
            if col in results_df.columns:
                try:
                    # Convert to numeric, replacing empty strings with 0
                    numeric_values = pd.to_numeric(results_df[col].replace('', 0), errors='coerce').fillna(0)
                    totals[col] = numeric_values.sum()
                except:
                    totals[col] = 0
        
        # Set up table with extra row for totals
        total_rows = len(results_df) + 1  # +1 for total row
        self.result_table.setRowCount(total_rows)
        self.result_table.setColumnCount(len(results_df.columns))
        self.result_table.setHorizontalHeaderLabels(list(results_df.columns))
        
        # Set fixed column widths for better display
        column_widths = {
            'Designator': 120,
            'Comment': 150,
            'Footprint': 140,
            'LCSC Part #': 120,
            'MPN': 150,
            'Stock': 100,
            'MOQ': 80,
            'Total Required Qty': 130,
            'Procure Qty': 110,
            'Distributor': 120,
            'Qty Tier': 80,
            'Unit Price (USD)': 110,
            'PCB Per Unit Price': 140,
            'Total Project Price': 140
        }
        
        # Apply fixed widths to columns
        for i, col_name in enumerate(results_df.columns):
            if col_name in column_widths:
                self.result_table.setColumnWidth(i, column_widths[col_name])
            else:
                self.result_table.setColumnWidth(i, 100)  # Default width
        
        # Disable stretching to preserve fixed widths
        self.result_table.horizontalHeader().setStretchLastSection(False)
        
        # Set green header background color
        for i in range(self.result_table.columnCount()):
            header_item = self.result_table.horizontalHeaderItem(i)
            if header_item:
                header_item.setBackground(QColor(0, 150, 0))  # Dark green
                header_item.setForeground(QColor(255, 255, 255))  # White text for contrast

        # Fill table with data (regular rows)
        for row in range(len(results_df)):
            for col in range(len(results_df.columns)):
                item = QTableWidgetItem(str(results_df.iloc[row, col]))

                # Color code stock levels
                if results_df.columns[col] == 'Stock':
                    try:
                        stock_val = int(results_df.iloc[row, col]) if str(results_df.iloc[row, col]).isdigit() else 0
                        if stock_val == 0:
                            item.setBackground(QColor(255, 200, 200))  # Light red - No stock
                        elif stock_val < 100:
                            item.setBackground(QColor(255, 255, 200))  # Light yellow - Low stock
                        elif stock_val < 1000:
                            item.setBackground(QColor(255, 255, 150))  # Light orange - Medium stock
                        else:
                            item.setBackground(QColor(200, 255, 200))  # Light green - Good stock
                    except (ValueError, TypeError):
                        item.setBackground(QColor(240, 240, 240))  # Gray for N/A

                # Make Procure Qty column editable
                if results_df.columns[col] == 'Procure Qty':
                    item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
                    
                self.result_table.setItem(row, col, item)

        # Add total row at the bottom
        total_row_index = len(results_df)
        
        for col in range(len(results_df.columns)):
            col_name = results_df.columns[col]
            
            if col == 0:  # First column - add "TOTAL" label
                total_item = QTableWidgetItem("TOTAL")
            elif col_name in totals:  # Sum columns
                total_value = round(totals[col_name], 2)
                total_item = QTableWidgetItem(str(total_value))
            else:  # Other columns - leave empty
                total_item = QTableWidgetItem("")
            
            # Style the total row
            font = QFont()
            font.setBold(True)
            total_item.setFont(font)
            total_item.setBackground(QColor(220, 220, 220))  # Light gray background
            
            # Make total row non-editable
            total_item.setFlags(total_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            
            self.result_table.setItem(total_row_index, col, total_item)

        # Connect cell change signal for recalculation
        self.result_table.cellChanged.connect(self.on_cell_changed)

    # Other methods remain the same as in your original code...
    def on_cell_changed(self, row, col):
        """Handle cell changes for recalculation"""
        if self.result_table.horizontalHeaderItem(col).text() == 'Procure Qty':
            self.recalculate_row(row)
            # Recalculate totals after individual row update
            self.update_totals()

    def update_totals(self):
        """Update total row calculations"""
        sum_columns = ['PCB Per Unit Price', 'Total Project Price']
        totals = {}
        
        # Calculate totals from current table data (excluding last row which is totals)
        total_row_count = self.result_table.rowCount() - 1  # Exclude total row
        
        for col_index in range(self.result_table.columnCount()):
            col_name = self.result_table.horizontalHeaderItem(col_index).text()
            
            if col_name in sum_columns:
                total = 0.0
                for row in range(total_row_count):  # Exclude the total row
                    item = self.result_table.item(row, col_index)
                    if item:
                        try:
                            value = float(item.text()) if item.text() else 0.0
                            total += value
                        except ValueError:
                            pass
                totals[col_name] = total
        
        # Update total row
        total_row_index = total_row_count
        
        for col_index in range(self.result_table.columnCount()):
            col_name = self.result_table.horizontalHeaderItem(col_index).text()
            
            if col_name in totals:
                total_value = round(totals[col_name], 2)
                total_item = QTableWidgetItem(str(total_value))
                
                # Style the total row
                font = QFont()
                font.setBold(True)
                total_item.setFont(font)
                total_item.setBackground(QColor(220, 220, 220))
                total_item.setFlags(total_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
                
                self.result_table.setItem(total_row_index, col_index, total_item)

    def recalculate_row(self, row):
        """Recalculate pricing for a specific row"""
        try:
            # Skip if this is the total row
            if row >= self.result_table.rowCount() - 1:
                return
                
            procure_qty = float(self.result_table.item(row, self.get_column_index('Procure Qty')).text())
            unit_price = float(self.result_table.item(row, self.get_column_index('Unit Price (USD)')).text())

            # Calculate new total project price
            total_price = procure_qty * unit_price
            self.result_table.setItem(row, self.get_column_index('Total Project Price'),
                                    QTableWidgetItem(str(round(total_price, 2))))
            
            # Update totals after row calculation
            self.update_totals()
            
        except (ValueError, AttributeError):
            pass

    def get_column_index(self, column_name):
        """Get column index by name"""
        for i in range(self.result_table.columnCount()):
            if self.result_table.horizontalHeaderItem(i).text() == column_name:
                return i
        return -1

    def recalculate_results(self):
        """Recalculate results when PCB quantity changes"""
        if self.bom_data is not None and self.scraped_data:
            self.calculate_bom_results()

    def export_to_excel(self):
        """Export results to Excel file"""
        if self.result_table.rowCount() == 0:
            QMessageBox.warning(self, "Warning", "No data to export")
            return

        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Excel File", "", "Excel files (*.xlsx)"
        )

        if file_path:
            try:
                # Convert table data to DataFrame
                data = []
                headers = []

                # Get headers
                for col in range(self.result_table.columnCount()):
                    headers.append(self.result_table.horizontalHeaderItem(col).text())

                # Get data
                for row in range(self.result_table.rowCount()):
                    row_data = []
                    for col in range(self.result_table.columnCount()):
                        item = self.result_table.item(row, col)
                        row_data.append(item.text() if item else "")
                    data.append(row_data)

                # Create DataFrame and save
                df = pd.DataFrame(data, columns=headers)
                df.to_excel(file_path, index=False)

                self.log_message(f"Data exported to {file_path}")
                QMessageBox.information(self, "Success", "Data exported successfully!")

            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to export: {str(e)}")
                self.log_message(f"Export error: {str(e)}")


def main():
    app = QApplication(sys.argv)
    window = BOMAnalyzer()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
