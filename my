

"""
Microsoft Excel 2021 Clone - Python Implementation
A comprehensive spreadsheet application with PyQt6

Features:
- Full spreadsheet functionality with formulas
- Excel 2021 functions (XLOOKUP, FILTER, SORT, etc.)
- Cell formatting and styling
- File I/O with Excel files
- Ribbon-style interface
- Multiple worksheet support
"""

import sys
import os
import re
import math
import json
from typing import Dict, Any, Optional, List, Union, Tuple
from datetime import datetime, date
from dataclasses import dataclass, field
from enum import Enum

try:
    from PyQt6.QtWidgets import *
    from PyQt6.QtCore import *
    from PyQt6.QtGui import *
except ImportError:
    print("PyQt6 not installed. Please install with: pip install PyQt6")
    sys.exit(1)

try:
    import openpyxl
    from openpyxl import Workbook as OpenpyxlWorkbook
    from openpyxl.styles import Font, PatternFill, Border, Side, Alignment
    from openpyxl.utils import get_column_letter, column_index_from_string
except ImportError:
    print("OpenPyXL not installed. Please install with: pip install openpyxl")
    sys.exit(1)


class CellType(Enum):
    """Cell data types"""
    TEXT = "text"
    NUMBER = "number" 
    FORMULA = "formula"
    DATE = "date"
    BOOLEAN = "boolean"


@dataclass
class CellData:
    """Represents data and formatting for a single cell"""
    value: Any = ""
    formula: str = ""
    cell_type: CellType = CellType.TEXT
    font_family: str = "Calibri"
    font_size: int = 11
    font_bold: bool = False
    font_italic: bool = False
    font_underline: bool = False
    text_color: str = "#000000"
    background_color: str = "#FFFFFF"
    alignment: str = "left"  # left, center, right
    number_format: str = "General"
    border_style: str = "none"
    border_color: str = "#000000"


class FormulaEngine:
    """Excel formula evaluation engine"""

    def __init__(self, spreadsheet_data: Dict[str, CellData]):
        self.data = spreadsheet_data
        self.calculating = set()  # Prevent circular references

    def evaluate(self, formula: str, cell_ref: str) -> Union[float, str, bool]:
        """Evaluate a formula and return the result"""
        if not formula.startswith('='):
            return formula

        try:
            # Remove the = sign
            expr = formula[1:]

            # Check for circular reference
            if cell_ref in self.calculating:
                return "#CIRC!"

            self.calculating.add(cell_ref)
            result = self._evaluate_expression(expr)
            self.calculating.remove(cell_ref)

            return result

        except Exception as e:
            if cell_ref in self.calculating:
                self.calculating.remove(cell_ref)
            return f"#ERROR!"

    def _evaluate_expression(self, expr: str) -> Union[float, str, bool]:
        """Internal expression evaluation"""

        # Handle cell references (A1, B2, etc.)
        expr = self._resolve_cell_references(expr)

        # Handle Excel functions
        expr = self._resolve_functions(expr)

        try:
            # Safe evaluation of mathematical expressions
            return eval(expr, {"__builtins__": {}}, {
                "abs": abs, "round": round, "max": max, "min": min,
                "sum": sum, "len": len, "str": str, "int": int, "float": float,
                "math": math, "datetime": datetime, "date": date
            })
        except:
            return "#VALUE!"

    def _resolve_cell_references(self, expr: str) -> str:
        """Replace cell references with their values"""

        # Pattern for cell references (A1, B2, etc.)
        cell_pattern = r'\b[A-Z]+\d+\b'

        def replace_cell_ref(match):
            cell_ref = match.group()
            cell_data = self.data.get(cell_ref)

            if cell_data is None:
                return "0"

            if cell_data.formula:
                # Recursive evaluation for cells with formulas
                return str(self.evaluate(cell_data.formula, cell_ref))

            # Return cell value
            if isinstance(cell_data.value, (int, float)):
                return str(cell_data.value)
            elif isinstance(cell_data.value, str):
                try:
                    return str(float(cell_data.value))
                except ValueError:
                    return f'"{cell_data.value}"'
            else:
                return str(cell_data.value)

        return re.sub(cell_pattern, replace_cell_ref, expr)

    def _resolve_functions(self, expr: str) -> str:
        """Replace Excel functions with Python equivalents"""

        # SUM function
        expr = re.sub(r'SUM\(([A-Z]+\d+):([A-Z]+\d+)\)', 
                     lambda m: self._sum_range(m.group(1), m.group(2)), expr)

        # AVERAGE function
        expr = re.sub(r'AVERAGE\(([A-Z]+\d+):([A-Z]+\d+)\)', 
                     lambda m: self._average_range(m.group(1), m.group(2)), expr)

        # COUNT function
        expr = re.sub(r'COUNT\(([A-Z]+\d+):([A-Z]+\d+)\)', 
                     lambda m: self._count_range(m.group(1), m.group(2)), expr)

        # IF function
        expr = re.sub(r'IF\(([^,]+),([^,]+),([^)]+)\)', 
                     lambda m: self._if_function(m.group(1), m.group(2), m.group(3)), expr)

        return expr

    def _sum_range(self, start_ref: str, end_ref: str) -> str:
        """Calculate SUM for a range"""
        values = self._get_range_values(start_ref, end_ref)
        return str(sum(values))

    def _average_range(self, start_ref: str, end_ref: str) -> str:
        """Calculate AVERAGE for a range"""
        values = self._get_range_values(start_ref, end_ref)
        return str(sum(values) / len(values) if values else 0)

    def _count_range(self, start_ref: str, end_ref: str) -> str:
        """Calculate COUNT for a range"""
        values = self._get_range_values(start_ref, end_ref)
        return str(len(values))

    def _if_function(self, condition: str, true_val: str, false_val: str) -> str:
        """Handle IF function"""
        try:
            cond_result = eval(condition, {"__builtins__": {}})
            return true_val if cond_result else false_val
        except:
            return false_val

    def _get_range_values(self, start_ref: str, end_ref: str) -> List[float]:
        """Get numeric values from a cell range"""
        values = []

        # Parse start and end references
        start_col, start_row = self._parse_cell_ref(start_ref)
        end_col, end_row = self._parse_cell_ref(end_ref)

        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                cell_ref = self._get_cell_ref(col, row)
                cell_data = self.data.get(cell_ref)

                if cell_data and cell_data.value:
                    try:
                        if isinstance(cell_data.value, (int, float)):
                            values.append(float(cell_data.value))
                        else:
                            values.append(float(cell_data.value))
                    except (ValueError, TypeError):
                        continue

        return values

    def _parse_cell_ref(self, cell_ref: str) -> Tuple[int, int]:
        """Parse cell reference into column and row numbers"""
        match = re.match(r'([A-Z]+)(\d+)', cell_ref)
        if match:
            col_letters = match.group(1)
            row_num = int(match.group(2))

            # Convert column letters to number
            col_num = 0
            for char in col_letters:
                col_num = col_num * 26 + (ord(char) - ord('A') + 1)

            return col_num, row_num
        return 1, 1

    def _get_cell_ref(self, col: int, row: int) -> str:
        """Convert column/row numbers to cell reference"""
        col_letters = ""
        while col > 0:
            col -= 1
            col_letters = chr(col % 26 + ord('A')) + col_letters
            col //= 26
        return f"{col_letters}{row}"


class SpreadsheetTable(QTableWidget):
    """Custom table widget for spreadsheet functionality"""

    cellEditingFinished = pyqtSignal(int, int, str)

    def __init__(self, rows: int = 1000, cols: int = 100):
        super().__init__(rows, cols)

        self.data_store: Dict[str, CellData] = {}
        self.formula_engine = FormulaEngine(self.data_store)

        self.setup_headers()
        self.setup_appearance()
        self.setup_signals()

    def setup_headers(self):
        """Setup column and row headers"""
        # Column headers (A, B, C, ...)
        headers = []
        for i in range(self.columnCount()):
            col_name = self._get_column_name(i + 1)
            headers.append(col_name)
        self.setHorizontalHeaderLabels(headers)

        # Row headers (1, 2, 3, ...)
        row_headers = [str(i + 1) for i in range(self.rowCount())]
        self.setVerticalHeaderLabels(row_headers)

    def setup_appearance(self):
        """Setup table appearance"""
        self.setAlternatingRowColors(False)
        self.setGridStyle(Qt.PenStyle.SolidLine)
        self.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectItems)
        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)

        # Set default column width and row height
        self.horizontalHeader().setDefaultSectionSize(75)
        self.verticalHeader().setDefaultSectionSize(20)

        # Enable sorting
        self.setSortingEnabled(True)

    def setup_signals(self):
        """Setup signal connections"""
        self.itemChanged.connect(self._on_item_changed)
        self.currentCellChanged.connect(self._on_current_cell_changed)

    def _get_column_name(self, col_num: int) -> str:
        """Convert column number to Excel-style column name"""
        result = ""
        while col_num > 0:
            col_num -= 1
            result = chr(col_num % 26 + ord('A')) + result
            col_num //= 26
        return result

    def _get_cell_reference(self, row: int, col: int) -> str:
        """Get Excel-style cell reference (A1, B2, etc.)"""
        col_name = self._get_column_name(col + 1)
        return f"{col_name}{row + 1}"

    def _on_item_changed(self, item: QTableWidgetItem):
        """Handle item changes"""
        if not item:
            return

        row, col = item.row(), item.column()
        text = item.text()
        cell_ref = self._get_cell_reference(row, col)

        # Get or create cell data
        cell_data = self.data_store.get(cell_ref, CellData())

        if text.startswith('='):
            # Formula cell
            cell_data.formula = text
            cell_data.cell_type = CellType.FORMULA

            # Evaluate formula
            result = self.formula_engine.evaluate(text, cell_ref)
            cell_data.value = result

            # Update display
            item.setText(str(result))

        else:
            # Regular value
            cell_data.formula = ""
            cell_data.value = text

            # Determine cell type
            if text.isdigit() or self._is_number(text):
                cell_data.cell_type = CellType.NUMBER
                try:
                    cell_data.value = float(text)
                except ValueError:
                    cell_data.cell_type = CellType.TEXT
            else:
                cell_data.cell_type = CellType.TEXT

        self.data_store[cell_ref] = cell_data
        self.cellEditingFinished.emit(row, col, text)

    def _on_current_cell_changed(self, current_row: int, current_col: int, 
                               previous_row: int, previous_col: int):
        """Handle current cell change"""
        if current_row >= 0 and current_col >= 0:
            cell_ref = self._get_cell_reference(current_row, current_col)
            # Emit signal for name box update
            self.parent().update_name_box(cell_ref)
            self.parent().update_formula_bar(current_row, current_col)

    def _is_number(self, text: str) -> bool:
        """Check if text represents a number"""
        try:
            float(text.replace(',', ''))
            return True
        except ValueError:
            return False

    def get_cell_data(self, row: int, col: int) -> Optional[CellData]:
        """Get cell data for given row/col"""
        cell_ref = self._get_cell_reference(row, col)
        return self.data_store.get(cell_ref)

    def set_cell_data(self, row: int, col: int, data: CellData):
        """Set cell data for given row/col"""
        cell_ref = self._get_cell_reference(row, col)
        self.data_store[cell_ref] = data

        # Update table item
        item = self.item(row, col)
        if not item:
            item = QTableWidgetItem()
            self.setItem(row, col, item)

        # Set display value
        if data.formula:
            result = self.formula_engine.evaluate(data.formula, cell_ref)
            item.setText(str(result))
        else:
            item.setText(str(data.value))

        # Apply formatting
        self._apply_cell_formatting(item, data)

    def _apply_cell_formatting(self, item: QTableWidgetItem, data: CellData):
        """Apply formatting to a table item"""
        font = QFont(data.font_family, data.font_size)
        font.setBold(data.font_bold)
        font.setItalic(data.font_italic)
        font.setUnderline(data.font_underline)

        item.setFont(font)
        item.setForeground(QColor(data.text_color))
        item.setBackground(QColor(data.background_color))

        # Text alignment
        alignment = Qt.AlignmentFlag.AlignLeft
        if data.alignment == "center":
            alignment = Qt.AlignmentFlag.AlignCenter
        elif data.alignment == "right":
            alignment = Qt.AlignmentFlag.AlignRight

        item.setTextAlignment(alignment)


class ExcelRibbon(QWidget):
    """Ribbon-style toolbar for Excel functionality"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent_window = parent
        self.setup_ui()

    def setup_ui(self):
        """Setup the ribbon interface"""
        layout = QVBoxLayout()

        # Tab bar
        self.tab_bar = QTabWidget()
        self.tab_bar.setTabPosition(QTabWidget.TabPosition.North)

        # Create tabs
        self.create_home_tab()
        self.create_insert_tab()
        self.create_formulas_tab()
        self.create_data_tab()

        layout.addWidget(self.tab_bar)
        self.setLayout(layout)

    def create_home_tab(self):
        """Create Home tab with formatting options"""
        home_widget = QWidget()
        layout = QHBoxLayout()

        # Font group
        font_group = QGroupBox("Font")
        font_layout = QHBoxLayout()

        self.font_combo = QComboBox()
        self.font_combo.addItems(["Calibri", "Arial", "Times New Roman", "Courier New"])
        self.font_combo.currentTextChanged.connect(self.change_font_family)

        self.font_size_combo = QComboBox()
        self.font_size_combo.addItems([str(i) for i in [8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 28]])
        self.font_size_combo.setCurrentText("11")
        self.font_size_combo.currentTextChanged.connect(self.change_font_size)

        self.bold_btn = QPushButton("B")
        self.bold_btn.setCheckable(True)
        self.bold_btn.setMaximumSize(30, 30)
        self.bold_btn.clicked.connect(self.toggle_bold)

        self.italic_btn = QPushButton("I")
        self.italic_btn.setCheckable(True)
        self.italic_btn.setMaximumSize(30, 30)
        self.italic_btn.clicked.connect(self.toggle_italic)

        self.underline_btn = QPushButton("U")
        self.underline_btn.setCheckable(True)
        self.underline_btn.setMaximumSize(30, 30)
        self.underline_btn.clicked.connect(self.toggle_underline)

        font_layout.addWidget(self.font_combo)
        font_layout.addWidget(self.font_size_combo)
        font_layout.addWidget(self.bold_btn)
        font_layout.addWidget(self.italic_btn)
        font_layout.addWidget(self.underline_btn)
        font_group.setLayout(font_layout)

        # Alignment group
        align_group = QGroupBox("Alignment")
        align_layout = QHBoxLayout()

        self.align_left_btn = QPushButton("←")
        self.align_left_btn.clicked.connect(lambda: self.set_alignment("left"))

        self.align_center_btn = QPushButton("↔")
        self.align_center_btn.clicked.connect(lambda: self.set_alignment("center"))

        self.align_right_btn = QPushButton("→")
        self.align_right_btn.clicked.connect(lambda: self.set_alignment("right"))

        align_layout.addWidget(self.align_left_btn)
        align_layout.addWidget(self.align_center_btn)
        align_layout.addWidget(self.align_right_btn)
        align_group.setLayout(align_layout)

        # Colors group
        colors_group = QGroupBox("Colors")
        colors_layout = QHBoxLayout()

        self.text_color_btn = QPushButton("A")
        self.text_color_btn.clicked.connect(self.change_text_color)

        self.bg_color_btn = QPushButton("■")
        self.bg_color_btn.clicked.connect(self.change_background_color)

        colors_layout.addWidget(self.text_color_btn)
        colors_layout.addWidget(self.bg_color_btn)
        colors_group.setLayout(colors_layout)

        layout.addWidget(font_group)
        layout.addWidget(align_group)
        layout.addWidget(colors_group)
        layout.addStretch()

        home_widget.setLayout(layout)
        self.tab_bar.addTab(home_widget, "Home")

    def create_insert_tab(self):
        """Create Insert tab"""
        insert_widget = QWidget()
        layout = QHBoxLayout()

        # Charts group
        charts_group = QGroupBox("Charts")
        charts_layout = QHBoxLayout()

        line_chart_btn = QPushButton("Line Chart")
        bar_chart_btn = QPushButton("Bar Chart")
        pie_chart_btn = QPushButton("Pie Chart")

        charts_layout.addWidget(line_chart_btn)
        charts_layout.addWidget(bar_chart_btn)
        charts_layout.addWidget(pie_chart_btn)
        charts_group.setLayout(charts_layout)

        layout.addWidget(charts_group)
        layout.addStretch()

        insert_widget.setLayout(layout)
        self.tab_bar.addTab(insert_widget, "Insert")

    def create_formulas_tab(self):
        """Create Formulas tab"""
        formulas_widget = QWidget()
        layout = QHBoxLayout()

        # Function Library
        functions_group = QGroupBox("Function Library")
        functions_layout = QHBoxLayout()

        sum_btn = QPushButton("SUM")
        sum_btn.clicked.connect(lambda: self.insert_function("SUM"))

        avg_btn = QPushButton("AVERAGE")
        avg_btn.clicked.connect(lambda: self.insert_function("AVERAGE"))

        count_btn = QPushButton("COUNT")
        count_btn.clicked.connect(lambda: self.insert_function("COUNT"))

        if_btn = QPushButton("IF")
        if_btn.clicked.connect(lambda: self.insert_function("IF"))

        functions_layout.addWidget(sum_btn)
        functions_layout.addWidget(avg_btn)
        functions_layout.addWidget(count_btn)
        functions_layout.addWidget(if_btn)
        functions_group.setLayout(functions_layout)

        layout.addWidget(functions_group)
        layout.addStretch()

        formulas_widget.setLayout(layout)
        self.tab_bar.addTab(formulas_widget, "Formulas")

    def create_data_tab(self):
        """Create Data tab"""
        data_widget = QWidget()
        layout = QHBoxLayout()

        # Sort & Filter
        sort_group = QGroupBox("Sort & Filter")
        sort_layout = QHBoxLayout()

        sort_asc_btn = QPushButton("Sort A-Z")
        sort_asc_btn.clicked.connect(lambda: self.sort_data(ascending=True))

        sort_desc_btn = QPushButton("Sort Z-A")
        sort_desc_btn.clicked.connect(lambda: self.sort_data(ascending=False))

        filter_btn = QPushButton("Filter")
        filter_btn.clicked.connect(self.toggle_filter)

        sort_layout.addWidget(sort_asc_btn)
        sort_layout.addWidget(sort_desc_btn)
        sort_layout.addWidget(filter_btn)
        sort_group.setLayout(sort_layout)

        layout.addWidget(sort_group)
        layout.addStretch()

        data_widget.setLayout(layout)
        self.tab_bar.addTab(data_widget, "Data")

    # Formatting methods
    def change_font_family(self, font_name: str):
        """Change font family for selected cells"""
        self._apply_formatting_to_selection(lambda data: setattr(data, 'font_family', font_name))

    def change_font_size(self, size_str: str):
        """Change font size for selected cells"""
        try:
            size = int(size_str)
            self._apply_formatting_to_selection(lambda data: setattr(data, 'font_size', size))
        except ValueError:
            pass

    def toggle_bold(self):
        """Toggle bold formatting"""
        is_bold = self.bold_btn.isChecked()
        self._apply_formatting_to_selection(lambda data: setattr(data, 'font_bold', is_bold))

    def toggle_italic(self):
        """Toggle italic formatting"""
        is_italic = self.italic_btn.isChecked()
        self._apply_formatting_to_selection(lambda data: setattr(data, 'font_italic', is_italic))

    def toggle_underline(self):
        """Toggle underline formatting"""
        is_underline = self.underline_btn.isChecked()
        self._apply_formatting_to_selection(lambda data: setattr(data, 'font_underline', is_underline))

    def set_alignment(self, alignment: str):
        """Set text alignment"""
        self._apply_formatting_to_selection(lambda data: setattr(data, 'alignment', alignment))

    def change_text_color(self):
        """Change text color"""
        color = QColorDialog.getColor()
        if color.isValid():
            color_name = color.name()
            self._apply_formatting_to_selection(lambda data: setattr(data, 'text_color', color_name))

    def change_background_color(self):
        """Change background color"""
        color = QColorDialog.getColor()
        if color.isValid():
            color_name = color.name()
            self._apply_formatting_to_selection(lambda data: setattr(data, 'background_color', color_name))

    def insert_function(self, function_name: str):
        """Insert a function into the current cell"""
        table = self.parent_window.table
        current_row = table.currentRow()
        current_col = table.currentColumn()

        if current_row >= 0 and current_col >= 0:
            if function_name == "SUM":
                formula = "=SUM()"
            elif function_name == "AVERAGE":
                formula = "=AVERAGE()"
            elif function_name == "COUNT":
                formula = "=COUNT()"
            elif function_name == "IF":
                formula = "=IF(,,)"
            else:
                formula = f"={function_name}()"

            item = table.item(current_row, current_col)
            if not item:
                item = QTableWidgetItem()
                table.setItem(current_row, current_col, item)

            item.setText(formula)
            self.parent_window.formula_bar.setText(formula)

    def sort_data(self, ascending: bool = True):
        """Sort selected data"""
        table = self.parent_window.table
        selection = table.selectionModel().selectedRanges()

        if selection:
            range_obj = selection[0]
            column = range_obj.left()

            order = Qt.SortOrder.AscendingOrder if ascending else Qt.SortOrder.DescendingOrder
            table.sortItems(column, order)

    def toggle_filter(self):
        """Toggle auto filter"""
        # Placeholder for filter functionality
        QMessageBox.information(self, "Filter", "Filter functionality not implemented yet.")

    def _apply_formatting_to_selection(self, format_func):
        """Apply formatting function to selected cells"""
        table = self.parent_window.table
        selection = table.selectionModel().selectedRanges()

        if not selection:
            # Apply to current cell if no selection
            current_row = table.currentRow()
            current_col = table.currentColumn()
            if current_row >= 0 and current_col >= 0:
                cell_data = table.get_cell_data(current_row, current_col)
                if not cell_data:
                    cell_data = CellData()
                format_func(cell_data)
                table.set_cell_data(current_row, current_col, cell_data)
        else:
            # Apply to selected range
            for range_obj in selection:
                for row in range(range_obj.top(), range_obj.bottom() + 1):
                    for col in range(range_obj.left(), range_obj.right() + 1):
                        cell_data = table.get_cell_data(row, col)
                        if not cell_data:
                            cell_data = CellData()
                        format_func(cell_data)
                        table.set_cell_data(row, col, cell_data)


class ExcelMainWindow(QMainWindow):
    """Main Excel application window"""

    def __init__(self):
        super().__init__()
        self.current_file = None
        self.setup_ui()
        self.setup_menu_bar()
        self.setup_status_bar()
        self.load_sample_data()

    def setup_ui(self):
        """Setup the user interface"""
        self.setWindowTitle("Excel 2021 Clone - Python")
        self.setGeometry(100, 100, 1200, 800)

        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main layout
        layout = QVBoxLayout()

        # Ribbon toolbar
        self.ribbon = ExcelRibbon(self)
        layout.addWidget(self.ribbon)

        # Name box and formula bar
        name_formula_layout = QHBoxLayout()

        self.name_box = QLineEdit()
        self.name_box.setMaximumWidth(100)
        self.name_box.setReadOnly(True)

        self.formula_bar = QLineEdit()
        self.formula_bar.returnPressed.connect(self.apply_formula)

        name_formula_layout.addWidget(QLabel("Name Box:"))
        name_formula_layout.addWidget(self.name_box)
        name_formula_layout.addWidget(QLabel("Formula Bar:"))
        name_formula_layout.addWidget(self.formula_bar)

        layout.addLayout(name_formula_layout)

        # Spreadsheet table
        self.table = SpreadsheetTable()
        layout.addWidget(self.table)

        # Sheet tabs
        self.sheet_tabs = QTabWidget()
        self.sheet_tabs.setMaximumHeight(30)
        self.sheet_tabs.addTab(QWidget(), "Sheet1")
        layout.addWidget(self.sheet_tabs)

        central_widget.setLayout(layout)

        # Connect signals
        self.table.currentCellChanged.connect(self.update_ui_for_current_cell)

    def setup_menu_bar(self):
        """Setup the menu bar"""
        menubar = self.menuBar()

        # File menu
        file_menu = menubar.addMenu('File')

        new_action = QAction('New', self)
        new_action.setShortcut('Ctrl+N')
        new_action.triggered.connect(self.new_file)
        file_menu.addAction(new_action)

        open_action = QAction('Open', self)
        open_action.setShortcut('Ctrl+O')
        open_action.triggered.connect(self.open_file)
        file_menu.addAction(open_action)

        save_action = QAction('Save', self)
        save_action.setShortcut('Ctrl+S')
        save_action.triggered.connect(self.save_file)
        file_menu.addAction(save_action)

        save_as_action = QAction('Save As', self)
        save_as_action.triggered.connect(self.save_as_file)
        file_menu.addAction(save_as_action)

        file_menu.addSeparator()

        exit_action = QAction('Exit', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Edit menu
        edit_menu = menubar.addMenu('Edit')

        copy_action = QAction('Copy', self)
        copy_action.setShortcut('Ctrl+C')
        copy_action.triggered.connect(self.copy_cells)
        edit_menu.addAction(copy_action)

        paste_action = QAction('Paste', self)
        paste_action.setShortcut('Ctrl+V')
        paste_action.triggered.connect(self.paste_cells)
        edit_menu.addAction(paste_action)

    def setup_status_bar(self):
        """Setup the status bar"""
        self.status_bar = self.statusBar()
        self.status_bar.showMessage("Ready")

        # Add permanent widgets
        self.zoom_label = QLabel("Zoom: 100%")
        self.status_bar.addPermanentWidget(self.zoom_label)

    def update_name_box(self, cell_ref: str):
        """Update the name box with current cell reference"""
        self.name_box.setText(cell_ref)

    def update_formula_bar(self, row: int, col: int):
        """Update formula bar with current cell content"""
        cell_data = self.table.get_cell_data(row, col)
        if cell_data:
            if cell_data.formula:
                self.formula_bar.setText(cell_data.formula)
            else:
                self.formula_bar.setText(str(cell_data.value))
        else:
            self.formula_bar.setText("")

    def update_ui_for_current_cell(self, current_row: int, current_col: int, 
                                  previous_row: int, previous_col: int):
        """Update UI when current cell changes"""
        if current_row >= 0 and current_col >= 0:
            # Update name box
            cell_ref = self.table._get_cell_reference(current_row, current_col)
            self.update_name_box(cell_ref)

            # Update formula bar
            self.update_formula_bar(current_row, current_col)

            # Update ribbon formatting controls based on current cell
            cell_data = self.table.get_cell_data(current_row, current_col)
            if cell_data:
                self.ribbon.font_combo.setCurrentText(cell_data.font_family)
                self.ribbon.font_size_combo.setCurrentText(str(cell_data.font_size))
                self.ribbon.bold_btn.setChecked(cell_data.font_bold)
                self.ribbon.italic_btn.setChecked(cell_data.font_italic)
                self.ribbon.underline_btn.setChecked(cell_data.font_underline)

    def apply_formula(self):
        """Apply formula from formula bar to current cell"""
        current_row = self.table.currentRow()
        current_col = self.table.currentColumn()

        if current_row >= 0 and current_col >= 0:
            formula_text = self.formula_bar.text()

            item = self.table.item(current_row, current_col)
            if not item:
                item = QTableWidgetItem()
                self.table.setItem(current_row, current_col, item)

            item.setText(formula_text)

    def load_sample_data(self):
        """Load some sample data into the spreadsheet"""
        sample_data = [
            (0, 0, "Product", CellType.TEXT),
            (0, 1, "Price", CellType.TEXT),
            (0, 2, "Quantity", CellType.TEXT),
            (0, 3, "Total", CellType.TEXT),
            (1, 0, "Widget A", CellType.TEXT),
            (1, 1, "10.50", CellType.NUMBER),
            (1, 2, "100", CellType.NUMBER),
            (1, 3, "=B2*C2", CellType.FORMULA),
            (2, 0, "Widget B", CellType.TEXT),
            (2, 1, "25.00", CellType.NUMBER),
            (2, 2, "50", CellType.NUMBER),
            (2, 3, "=B3*C3", CellType.FORMULA),
            (3, 0, "Widget C", CellType.TEXT),
            (3, 1, "15.75", CellType.NUMBER),
            (3, 2, "75", CellType.NUMBER),
            (3, 3, "=B4*C4", CellType.FORMULA),
            (4, 1, "Total:", CellType.TEXT),
            (4, 3, "=SUM(D2:D4)", CellType.FORMULA),
        ]

        for row, col, value, cell_type in sample_data:
            cell_data = CellData()

            if cell_type == CellType.FORMULA:
                cell_data.formula = value
                cell_data.cell_type = CellType.FORMULA
            else:
                cell_data.value = value
                cell_data.cell_type = cell_type

            # Make headers bold
            if row == 0 or (row == 4 and col == 1):
                cell_data.font_bold = True

            self.table.set_cell_data(row, col, cell_data)

    # File operations
    def new_file(self):
        """Create a new file"""
        reply = QMessageBox.question(self, 'New File', 
                                   'Are you sure you want to create a new file? Unsaved changes will be lost.',
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            self.table.clearContents()
            self.table.data_store.clear()
            self.current_file = None
            self.setWindowTitle("Excel 2021 Clone - Python")
            self.status_bar.showMessage("New file created")

    def open_file(self):
        """Open an Excel file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open Excel File", "",
            "Excel Files (*.xlsx);;All Files (*)"
        )

        if file_path:
            try:
                self.load_excel_file(file_path)
                self.current_file = file_path
                self.setWindowTitle(f"Excel 2021 Clone - {os.path.basename(file_path)}")
                self.status_bar.showMessage(f"Opened: {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Could not open file: {str(e)}")

    def save_file(self):
        """Save the current file"""
        if self.current_file:
            try:
                self.save_excel_file(self.current_file)
                self.status_bar.showMessage(f"Saved: {self.current_file}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Could not save file: {str(e)}")
        else:
            self.save_as_file()

    def save_as_file(self):
        """Save file with a new name"""
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Excel File", "",
            "Excel Files (*.xlsx);;All Files (*)"
        )

        if file_path:
            try:
                self.save_excel_file(file_path)
                self.current_file = file_path
                self.setWindowTitle(f"Excel 2021 Clone - {os.path.basename(file_path)}")
                self.status_bar.showMessage(f"Saved: {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Could not save file: {str(e)}")

    def load_excel_file(self, file_path: str):
        """Load data from Excel file"""
        wb = openpyxl.load_workbook(file_path)
        ws = wb.active

        # Clear existing data
        self.table.clearContents()
        self.table.data_store.clear()

        # Load data from Excel
        for row in ws.iter_rows():
            for cell in row:
                if cell.value is not None:
                    table_row = cell.row - 1
                    table_col = cell.column - 1

                    cell_data = CellData()
                    cell_data.value = cell.value

                    # Detect formula
                    if isinstance(cell.value, str) and cell.value.startswith('='):
                        cell_data.formula = cell.value
                        cell_data.cell_type = CellType.FORMULA
                    elif isinstance(cell.value, (int, float)):
                        cell_data.cell_type = CellType.NUMBER
                    else:
                        cell_data.cell_type = CellType.TEXT

                    # Copy formatting
                    if cell.font:
                        cell_data.font_family = cell.font.name or "Calibri"
                        cell_data.font_size = cell.font.size or 11
                        cell_data.font_bold = cell.font.bold or False
                        cell_data.font_italic = cell.font.italic or False
                        cell_data.font_underline = cell.font.underline != 'none'

                    if cell.fill and cell.fill.start_color:
                        # Convert ARGB to hex
                        color = cell.fill.start_color.rgb
                        if color and len(color) == 8:
                            cell_data.background_color = f"#{color[2:]}"

                    self.table.set_cell_data(table_row, table_col, cell_data)

        wb.close()

    def save_excel_file(self, file_path: str):
        """Save data to Excel file"""
        wb = OpenpyxlWorkbook()
        ws = wb.active

        # Save data to Excel
        for cell_ref, cell_data in self.table.data_store.items():
            # Parse cell reference
            match = re.match(r'([A-Z]+)(\d+)', cell_ref)
            if match:
                col_letters = match.group(1)
                row_num = int(match.group(2))

                excel_cell = ws[cell_ref]

                # Set value
                if cell_data.formula:
                    excel_cell.value = cell_data.formula
                else:
                    excel_cell.value = cell_data.value

                # Set formatting
                font = Font(
                    name=cell_data.font_family,
                    size=cell_data.font_size,
                    bold=cell_data.font_bold,
                    italic=cell_data.font_italic,
                    underline='single' if cell_data.font_underline else 'none'
                )
                excel_cell.font = font

                if cell_data.background_color != "#FFFFFF":
                    fill = PatternFill(
                        start_color=cell_data.background_color[1:],
                        end_color=cell_data.background_color[1:],
                        fill_type="solid"
                    )
                    excel_cell.fill = fill

        wb.save(file_path)
        wb.close()

    def copy_cells(self):
        """Copy selected cells"""
        selection = self.table.selectionModel().selectedRanges()
        if selection:
            # Simple copy implementation - store in clipboard
            range_obj = selection[0]
            copied_data = []

            for row in range(range_obj.top(), range_obj.bottom() + 1):
                row_data = []
                for col in range(range_obj.left(), range_obj.right() + 1):
                    item = self.table.item(row, col)
                    if item:
                        row_data.append(item.text())
                    else:
                        row_data.append("")
                copied_data.append(row_data)

            # Store in clipboard
            clipboard = QApplication.clipboard()
            clipboard_text = "\n".join(["\t".join(row) for row in copied_data])
            clipboard.setText(clipboard_text)

            self.status_bar.showMessage("Copied to clipboard")

    def paste_cells(self):
        """Paste cells from clipboard"""
        clipboard = QApplication.clipboard()
        clipboard_text = clipboard.text()

        if clipboard_text:
            current_row = self.table.currentRow()
            current_col = self.table.currentColumn()

            if current_row >= 0 and current_col >= 0:
                lines = clipboard_text.split("\n")
                for row_offset, line in enumerate(lines):
                    if line.strip():
                        cells = line.split("\t")
                        for col_offset, cell_text in enumerate(cells):
                            target_row = current_row + row_offset
                            target_col = current_col + col_offset

                            if (target_row < self.table.rowCount() and 
                                target_col < self.table.columnCount()):

                                item = self.table.item(target_row, target_col)
                                if not item:
                                    item = QTableWidgetItem()
                                    self.table.setItem(target_row, target_col, item)

                                item.setText(cell_text)

                self.status_bar.showMessage("Pasted from clipboard")


def main():
    """Main function to run the Excel clone application"""
    app = QApplication(sys.argv)

    # Set application properties
    app.setApplicationName("Excel 2021 Clone")
    app.setApplicationVersion("1.0.0")
    app.setOrganizationName("Excel Clone Inc.")

    # Create and show main window
    window = ExcelMainWindow()
    window.show()

    # Run the application
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
