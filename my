# bom_costing_app.py

import sys, re, json, time, urllib.parse, math, os, chardet
from datetime import datetime, timedelta
import requests
from bs4 import BeautifulSoup
import pandas as pd
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget, QToolBar,
    QFileDialog, QTableWidget, QTableWidgetItem, QComboBox, QLabel,
    QSpinBox, QDoubleSpinBox, QTextEdit, QMessageBox, QTabWidget, QProgressBar,
    QSplitter, QDialog, QListWidget, QPushButton
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal
from PyQt6.QtGui import QColor, QAction, QFont, QPalette, QPixmap,QIcon

USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
BASE_SEARCH = "https://www.findchips.com/search/"
BASE_DETAIL = "https://www.findchips.com/detail/{mpn}/{mfg}"

# Common MLCC/EIA size mapping for fallbacks and grouping
EIA_TO_MM = {
    "008004": (0.25, 0.13), "0075": (0.3, 0.15), "01005": (0.4, 0.2),
    "15015": (0.4, 0.4), "0201": (0.6, 0.3), "0202": (0.5, 0.5),
    "0302": (0.8, 0.5), "0303": (0.8, 0.8), "0504": (1.3, 1.0),
    "0402": (1.0, 0.5), "0603": (1.6, 0.8), "0805": (2.0, 1.25),
    "1008": (2.5, 2.0), "1111": (2.8, 2.8), "1206": (3.2, 1.6),
    "1210": (3.2, 2.5), "1410": (3.6, 2.5), "1515": (3.81, 3.81),
    "1806": (4.5, 1.6), "1808": (4.5, 2.0), "1812": (4.5, 3.2),
    "1825": (4.5, 6.4), "2010": (5.0, 2.5), "2020": (5.08, 5.08),
    "2220": (5.7, 5.0), "2225": (5.7, 6.4), "2512": (6.4, 3.2),
    "2520": (6.4, 5.0), "2920": (7.4, 5.0), "3333": (8.38, 8.38),
    "3640": (9.2, 10.16), "4040": (10.2, 10.2), "5550": (14.0, 12.7),
    "8060": (20.3, 15.3)
}

def apply_dark_green_theme(app):
    """Apply dark green theme to the entire application"""
    palette = QPalette()

    # Window background - Dark gray/black
    palette.setColor(QPalette.ColorRole.Window, QColor(25, 35, 25))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(0, 255, 100))  # Bright green text

    # Base background for input fields
    palette.setColor(QPalette.ColorRole.Base, QColor(35, 45, 35))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(45, 55, 45))

    # Text colors
    palette.setColor(QPalette.ColorRole.Text, QColor(0, 255, 100))

    # Button styling
    palette.setColor(QPalette.ColorRole.Button, QColor(35, 55, 35))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(0, 255, 100))

    # Highlight colors
    palette.setColor(QPalette.ColorRole.Highlight, QColor(0, 150, 50))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))

    # Links
    palette.setColor(QPalette.ColorRole.Link, QColor(100, 255, 150))

    # FIXED: Disabled elements - Use ColorGroup.Disabled, not ColorRole.Disabled
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.WindowText, QColor(100, 100, 100))
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.ButtonText, QColor(100, 100, 100))
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text, QColor(100, 100, 100))

    app.setPalette(palette)

    # Additional stylesheet for better appearance
    app.setStyleSheet("""
        QMainWindow {
            background-color: rgb(25, 35, 25);
            color: rgb(0, 255, 100);
        }
        
        QToolBar {
            background-color: rgb(35, 45, 35);
            border: 1px solid rgb(0, 150, 50);
            spacing: 3px;
        }
        
        QToolBar::separator {
            background-color: rgb(0, 150, 50);
            width: 2px;
            margin: 2px;
        }
        
        QPushButton, QToolButton {
            background-color: rgb(35, 55, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            padding: 5px 10px;
            font-weight: bold;
        }
        
        QPushButton:hover, QToolButton:hover {
            background-color: rgb(0, 150, 50);
            color: white;
        }
        
        QPushButton:pressed, QToolButton:pressed {
            background-color: rgb(0, 100, 30);
        }
        
        QComboBox {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 3px;
            padding: 2px 5px;
        }
        
        QComboBox::drop-down {
            border: none;
        }
        
        QComboBox::down-arrow {
            image: none;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid rgb(0, 255, 100);
        }
        
        QSpinBox, QDoubleSpinBox {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 3px;
            padding: 2px;
        }
        
        QLabel {
            color: rgb(0, 255, 100);
            font-weight: bold;
        }
        
        QTabBar::tab {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            padding: 8px 15px;
            margin: 2px;
        }
        
        QTabBar::tab:selected {
            background-color: rgb(0, 150, 50);
            color: white;
        }
        
        QTabBar::tab:hover {
            background-color: rgb(0, 120, 40);
        }
        
        QProgressBar {
            background-color: rgb(35, 45, 35);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            color: white;          
            text-align: center;
        }
        
        QProgressBar::chunk {
            background-color: rgb(0, 200, 50);
            border-radius: 3px;
        }
        
        QSplitter::handle {
            background-color: rgb(0, 150, 50);
        }
        
        QMessageBox {
            background-color: rgb(25, 35, 25);
            color: rgb(0, 255, 100);
        }
        
        QDialog {
            background-color: rgb(25, 35, 25);
            color: rgb(0, 255, 100);
        }
        
        QListWidget {
            background-color: white;
            color: black;
            border: 2px solid rgb(0, 150, 50);
        }
    """)

def norm_eia_code(text: str | None) -> str | None:
    if not text:
        return None
    cleaned = text.replace('-', '').replace('_', '')
    m = re.search(r'\b(008004|01005|0201|0302|0303|0402|0504|0603|0805|1008|1206|1210|1812|2010|2220|2225|2512|2920|3333|3640|4040|5550|8060)\b', cleaned)

    return m.group(1) if m else None

def max_dim_mm_from_package_or_size(package_code: str | None, L: float | None, W: float | None) -> float | None:
    if package_code and package_code in EIA_TO_MM:
        l, w = EIA_TO_MM[package_code]
        return max(l, w)
    if L is not None and W is not None:
        return max(L, W)
    if L is not None:
        return L
    if W is not None:
        return W
    return None

def filter_search_results(mpn: str, search_results: list[dict]) -> list[dict]:
    """
    Filter search results based on exact vs partial matches:
    - If exact matches exist, return only exact matches
    - If no exact matches exist, return only the first partial match
    """
    exact_matches = []
    partial_matches = []
    mpn_lower = mpn.strip().lower()
    
    for result in search_results:
        result_mpn = result["mpn"].strip().lower()
        if result_mpn == mpn_lower:
            exact_matches.append(result)
        else:
            partial_matches.append(result)
    
    # Return exact matches if they exist, otherwise return only first partial match
    if exact_matches:
        return exact_matches
    elif partial_matches:
        return partial_matches[:1] # Only take the first partial match
    else:
        return []

def detect_file_encoding(file_path: str) -> str:
    """Detect the encoding of a file"""
    try:
        with open(file_path, 'rb') as f:
            raw_data = f.read(10000)  # Read first 10KB
            result = chardet.detect(raw_data)
            return result['encoding'] or 'utf-8'
    except Exception:
        return 'utf-8'

def detect_csv_delimiter(file_path: str, encoding: str = 'utf-8') -> str:
    """Detect CSV delimiter by testing common delimiters"""
    delimiters = [',', ';', '\t', '|']
    try:
        with open(file_path, 'r', encoding=encoding) as f:
            sample = f.read(1024)
            
        delimiter_scores = {}
        for delim in delimiters:
            lines = sample.split('\n')[:3]  # Check first 3 lines
            scores = []
            for line in lines:
                if line.strip():
                    scores.append(line.count(delim))
            if scores and max(scores) > 0:
                delimiter_scores[delim] = max(scores)
        
        if delimiter_scores:
            return max(delimiter_scores.items(), key=lambda x: x[1])[0]
        return ','
    except Exception:
        return ','

class SheetSelectionDialog(QDialog):
    """Dialog for selecting Excel worksheet"""
    def __init__(self, sheet_names, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Worksheet")
        self.setModal(True)
        self.resize(300, 200)
        
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Multiple worksheets found. Select one:"))
        
        self.sheet_list = QListWidget()
        self.sheet_list.addItems(sheet_names)
        self.sheet_list.setCurrentRow(0)
        layout.addWidget(self.sheet_list)
        
        buttons = QHBoxLayout()
        ok_btn = QPushButton("OK")
        cancel_btn = QPushButton("Cancel")
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)
        buttons.addWidget(ok_btn)
        buttons.addWidget(cancel_btn)
        layout.addLayout(buttons)
        
        self.setLayout(layout)
        
    def get_selected_sheet(self, _):
        current_item = self.sheet_list.currentItem()
        return current_item.text() if current_item else None

class FindchipsClient:
    def __init__(self, timeout=15):
        self.s = requests.Session()
        self.s.headers.update({"User-Agent": USER_AGENT})
        self.timeout = timeout

    def get(self, url):
        return self.s.get(url, timeout=self.timeout)

    def search(self, mpn: str) -> list[dict]:
        """Extract only MPN and manufacturer from search page"""
        url = BASE_SEARCH + urllib.parse.quote(mpn)
        r = self.get(url)
        if r.status_code != 200:
            return []

        soup = BeautifulSoup(r.content, "html.parser")
        rows = soup.find_all("tr", class_="row")
        results = []

        for row in rows:
            try:
                mfg = (row.get("data-mfr") or row.get("data-manufacturer") or "").strip()
                result_mpn = (row.get("data-mfrpartnumber") or "").strip()
                if not mfg or not result_mpn:
                    continue

                # Only return MPN and manufacturer - no pricing/stock data
                results.append({
                    "mpn": result_mpn,
                    "manufacturer": mfg
                })
            except Exception:
                continue

        # Remove duplicates while preserving order
        seen = set()
        unique_results = []
        for item in results:
            key = (item["mpn"].lower(), item["manufacturer"].lower())
            if key not in seen:
                seen.add(key)
                unique_results.append(item)

        return unique_results

    def detail(self, mpn: str, manufacturer: str) -> dict:
        """Extract all data from detail page"""
        url = BASE_DETAIL.format(
            mpn=urllib.parse.quote(mpn),
            mfg=urllib.parse.quote(manufacturer.replace(' ', '-'))
        )
        r = self.get(url)
        if r.status_code != 200:
            return {}

        html = r.text
        meta = {
            "life_cycle_code": None,
            "package_code": None,
            "length_mm": None,
            "width_mm": None,
            "default_currency": None,
            "lead_time": None,
            "offers": []
        }

        # Extract metadata from JavaScript or meta tags
        dc = re.search(r'"defaultCurrency"\s*:\s*"([A-Z]{3})"', html)
        if dc:
            meta["default_currency"] = dc.group(1)

        # Parse HTML table for Part Data Attributes
        soup = BeautifulSoup(html, "html.parser")
        
        # Extract from Part Data Attributes table
        data_rows = soup.find_all("tr", class_="data-row")
        for row in data_rows:
            try:
                field_cell = row.find("td", class_="field-cell")
                main_cell = row.find("td", class_="main-part-cell")
                
                if field_cell and main_cell:
                    field_name = field_cell.get_text(strip=True)
                    field_value = main_cell.get_text(strip=True)
                    
                    # Extract specific fields
                    if field_name == "Part Life Cycle Code":
                        meta["life_cycle_code"] = field_value
                    elif field_name in ["Part Package Code", "Size Code", "Package Description"]:
                        # Try to normalize package code
                        normalized = norm_eia_code(field_value)
                        if normalized:
                            meta["package_code"] = normalized
                        else:
                            meta["package_code"] = field_value
                    elif field_name == "Factory Lead Time":
                        meta["lead_time"] = field_value
                    # NEW: Extract Length and Width
                    elif field_name in ["Length","Package Length"]:
                        # Extract numeric value from "14 mm"
                        length_match = re.search(r'(\d+(?:\.\d+)?)', field_value)
                        if length_match:
                            meta["length_mm"] = float(length_match.group(1))
                    elif field_name in ["Width","Package Width"]:
                        # Extract numeric value from "14 mm"
                        width_match = re.search(r'(\d+(?:\.\d+)?)', field_value)
                        if width_match:
                            meta["width_mm"] = float(width_match.group(1))
                            
            except Exception:
                continue

        # Try to extract dimensions from package description
        pkg_desc_rows = soup.find_all("tr", attrs={"data-field": "Package Description"})
        for row in pkg_desc_rows:
            try:
                desc_cell = row.find("td", class_="main-part-cell")
                if desc_cell:
                    desc_text = desc_cell.get_text(strip=True)
                    # Try to extract dimensions from package description
                    # Look for patterns like "1.6x0.8" or "1.6 x 0.8"
                    size_match = re.search(r'(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)', desc_text)
                    if size_match:
                        meta["length_mm"] = float(size_match.group(1))
                        meta["width_mm"] = float(size_match.group(2))
                    else:
                        # Try to extract standard package sizes (like 0805)
                        std_size = norm_eia_code(desc_text)
                        if std_size and std_size in EIA_TO_MM:
                            meta["package_code"] = std_size
                            l, w = EIA_TO_MM[std_size]
                            meta["length_mm"] = l
                            meta["width_mm"] = w
            except Exception:
                continue

        # Fallback: Try original JavaScript extraction methods
        if not meta["life_cycle_code"]:
            life = re.search(r'"lifeCycle(Code)?"\s*:\s*"([^"]+)"', html)
            if life:
                meta["life_cycle_code"] = life.group(2)

        if not meta["package_code"]:
            pkg = re.search(r'"sizeCode"\s*:\s*"([^"]+)"', html) or re.search(r'"package"\s*:\s*"([^"]+)"', html)
            if pkg:
                normalized = norm_eia_code(pkg.group(1))
                meta["package_code"] = normalized or pkg.group(1)

        # Continue with existing dimensions extraction if not found
        if not meta["length_mm"]:
            lmatch = re.search(r'"length"\s*:\s*([0-9.]+)\s*,\s*"unit"\s*:\s*"mm"', html)
            if lmatch:
                meta["length_mm"] = float(lmatch.group(1))
                
        if not meta["width_mm"]:
            wmatch = re.search(r'"width"\s*:\s*([0-9.]+)\s*,\s*"unit"\s*:\s*"mm"', html)
            if wmatch:
                meta["width_mm"] = float(wmatch.group(1))

        # Extract distributor offers from the FC.group JavaScript object
        group_match = re.search(r'FC\.group\s*=\s*\{[^}]*offers:\s*(\[.*?\])', html, re.DOTALL)
        if group_match:
            try:
                offers_json = group_match.group(1)
                # Clean up the JavaScript to make it valid JSON
                offers_json = re.sub(r'([{,]\s*)(\w+):', r'\1"\2":', offers_json) # Quote keys
                offers_json = re.sub(r"'([^']*)'", r'"\1"', offers_json) # Convert single quotes
                offers_data = json.loads(offers_json)

                for offer in offers_data:
                    distributor = offer.get("distributor", "").strip()
                    stock = int(offer.get("stock", 0) or 0)

                    # Extract price tiers
                    price_tiers = []
                    price_data = offer.get("price", [])
                    if isinstance(price_data, list):
                        for tier in price_data:
                            if isinstance(tier, list) and len(tier) >= 3:
                                try:
                                    qty = int(str(tier[0]).replace(",", ""))
                                    price = float(str(tier[2]).replace(",", ""))
                                    price_tiers.append({"quantity": qty, "price": price})
                                except (ValueError, IndexError):
                                    continue

                    if distributor and (price_tiers or stock > 0):
                        meta["offers"].append({
                            "distributor": distributor,
                            "stock": stock,
                            "currency": "USD",
                            "price_tiers": sorted(price_tiers, key=lambda x: x["quantity"]),
                            "lead_time": offer.get("leadTime") or meta.get("lead_time"),
                            "moq": min(tier["quantity"] for tier in price_tiers) if price_tiers else None
                        })
            except (json.JSONDecodeError, Exception):
                pass

        # Fallback: Parse HTML tables for distributor data
        if not meta["offers"]:
            price_stock_table = soup.find("table", class_="price-stock-table")
            if price_stock_table:
                for row in price_stock_table.find_all("tr", class_="price-stock-tr"):
                    try:
                        # Extract distributor name
                        dist_cell = row.find("td", class_="td-dis")
                        if not dist_cell:
                            continue
                        distributor = dist_cell.get_text(strip=True)

                        # Extract stock
                        stock_cell = row.find("td", class_="td-stock")
                        stock = 0
                        if stock_cell:
                            stock_text = stock_cell.get_text(strip=True)
                            stock_match = re.search(r'(\d[\d,]*)', stock_text)
                            if stock_match:
                                stock = int(stock_match.group(1).replace(",", ""))

                        # Extract lead time from description
                        desc_cell = row.find("td", class_="td-desc")
                        row_lead_time = None
                        if desc_cell:
                            desc_text = desc_cell.get_text()
                            lead_match = re.search(r'Lead time:\s*([^<\n]+)', desc_text)
                            if lead_match:
                                row_lead_time = lead_match.group(1).strip()

                        # Extract price tiers
                        price_tiers = []
                        price_cell = row.find("td", class_="td-price")
                        if price_cell:
                            price_items = price_cell.find_all("li", class_="price-item")
                            for item in price_items:
                                label = item.find("span", class_="label")
                                value = item.find("span", class_="value")
                                if label and value:
                                    try:
                                        qty_text = label.get_text(strip=True).replace(",", "")
                                        price_text = value.get_text(strip=True).replace("$", "").replace(",", "")
                                        qty = int(qty_text)
                                        price = float(price_text)
                                        price_tiers.append({"quantity": qty, "price": price})
                                    except (ValueError, AttributeError):
                                        continue

                        if distributor and (price_tiers or stock > 0):
                            meta["offers"].append({
                                "distributor": distributor,
                                "stock": stock,
                                "currency": "USD",
                                "price_tiers": sorted(price_tiers, key=lambda x: x["quantity"]),
                                "lead_time": row_lead_time or meta.get("lead_time"),
                                "moq": min(tier["quantity"] for tier in price_tiers) if price_tiers else None
                            })
                    except Exception:
                        continue

        return meta

class JSONStorage:
    """JSON-based storage system to replace SQLite database"""
    def __init__(self, path="bom_costing_data.json"):
        self.path = path
        self.data = self._load()

    def _load(self):
        """Load data from JSON file"""
        if os.path.exists(self.path):
            try:
                with open(self.path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                print(f"Error loading JSON data: {e}")
                return {}
        return {}

    def _save(self):
        """Save data to JSON file"""
        try:
            # Create backup of existing file
            if os.path.exists(self.path):
                backup_path = f"{self.path}.backup"
                if os.path.exists(backup_path):
                    os.remove(backup_path)
                os.rename(self.path, backup_path)
            
            with open(self.path, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Error saving JSON data: {e}")
            # Restore backup if save failed
            backup_path = f"{self.path}.backup"
            if os.path.exists(backup_path):
                os.rename(backup_path, self.path)

    def upsert_offer(
        self, mpn, distributor, manufacturer, price_tiers, stock, currency,
        lead_time=None, life_cycle_code=None, package_code=None,
        length_mm=None, width_mm=None, default_currency=None, part_type=None
    ):
        """Insert or update component offer data"""
        if mpn not in self.data:
            self.data[mpn] = {}
        
        if distributor not in self.data[mpn]:
            self.data[mpn][distributor] = {}
        
        # Sort price tiers
        tiers_sorted = sorted(price_tiers or [], key=lambda x: x["quantity"])
        
        # Update offer data
        offer_data = {
            "manufacturer": manufacturer,
            "price_tiers": tiers_sorted,
            "stock": max(self.data[mpn][distributor].get("stock", 0), int(stock or 0)),
            "currency": currency or "USD",
            "lead_time": lead_time or self.data[mpn][distributor].get("lead_time"),
            "life_cycle_code": life_cycle_code or self.data[mpn][distributor].get("life_cycle_code"),
            "package_code": package_code or self.data[mpn][distributor].get("package_code"),
            "length_mm": length_mm if length_mm is not None else self.data[mpn][distributor].get("length_mm"),
            "width_mm": width_mm if width_mm is not None else self.data[mpn][distributor].get("width_mm"),
            "default_currency": default_currency or self.data[mpn][distributor].get("default_currency", "USD"),
            "part_type": part_type or self.data[mpn][distributor].get("part_type"),
            "scraped_date": datetime.now().isoformat()
        }
        
        self.data[mpn][distributor].update(offer_data)
        self._save()

    def offers_by_mpn(self, mpn):
        """Get all offers for a specific MPN"""
        if mpn not in self.data:
            return []
        
        offers = []
        for distributor, offer_data in self.data[mpn].items():
            offers.append({
                "distributor": distributor,
                "manufacturer": offer_data.get("manufacturer", ""),
                "price_tiers": offer_data.get("price_tiers", []),
                "stock": offer_data.get("stock", 0),
                "currency": offer_data.get("currency", "USD"),
                "lead_time": offer_data.get("lead_time"),
                "life_cycle_code": offer_data.get("life_cycle_code"),
                "package_code": offer_data.get("package_code"),
                "length_mm": offer_data.get("length_mm"),
                "width_mm": offer_data.get("width_mm"),
                "default_currency": offer_data.get("default_currency", "USD"),
                "part_type": offer_data.get("part_type")
            })
        
        return sorted(offers, key=lambda x: x["distributor"])

    def part_meta(self, mpn):
        """Get metadata for a part"""
        offers = self.offers_by_mpn(mpn)
        
        life = next((o["life_cycle_code"] for o in offers if o.get("life_cycle_code")), "")
        pkg = next((o["package_code"] for o in offers if o.get("package_code")), "")
        L = next((o["length_mm"] for o in offers if o.get("length_mm") is not None), None)
        W = next((o["width_mm"] for o in offers if o.get("width_mm") is not None), None)
        defcur = next((o["default_currency"] for o in offers if o.get("default_currency")), "USD")
        ptype = next((o["part_type"] for o in offers if o.get("part_type")), "")
        lead = next((o["lead_time"] for o in offers if o.get("lead_time")), "")
        
        return {
            "life": life, "package": pkg, "L": L, "W": W, 
            "default_currency": defcur, "part_type": ptype, "lead_time": lead
        }

    def update_size_for_mpn(self, mpn, length_mm, width_mm):
        """Update length and width for all distributors of a specific MPN"""
        if mpn in self.data:
            for distributor in self.data[mpn]:
                self.data[mpn][distributor]["length_mm"] = length_mm
                self.data[mpn][distributor]["width_mm"] = width_mm
            self._save()
            return len(self.data[mpn])
        return 0

    def update_package_for_mpn(self, mpn, new_package):
        """Update package code for all distributors of a specific MPN"""
        if mpn in self.data:
            for distributor in self.data[mpn]:
                self.data[mpn][distributor]["package_code"] = new_package
            self._save()
            return len(self.data[mpn])
        return 0
    
    def is_data_fresh(self, mpn, hours=6):
        """Check if MPN data is fresh (within specified hours)"""
        if mpn not in self.data:
            return False
        
        # Check if any distributor has recent data
        for distributor_data in self.data[mpn].values():
            scraped_date_str = distributor_data.get("scraped_date")
            if scraped_date_str:
                try:
                    scraped_date = datetime.fromisoformat(scraped_date_str)
                    time_diff = datetime.now() - scraped_date
                    if time_diff < timedelta(hours=hours):
                        return True
                except Exception:
                    continue
        return False
    
    def get_data_age_hours(self, mpn):
        """Get the age of data in hours for an MPN"""
        if mpn not in self.data:
            return float('inf')
        
        oldest_hours = 0
        for distributor_data in self.data[mpn].values():
            scraped_date_str = distributor_data.get("scraped_date")
            if scraped_date_str:
                try:
                    scraped_date = datetime.fromisoformat(scraped_date_str)
                    hours_old = (datetime.now() - scraped_date).total_seconds() / 3600
                    oldest_hours = max(oldest_hours, hours_old)
                except Exception:
                    continue
        return oldest_hours if oldest_hours > 0 else float('inf')

class ScrapeThread(QThread):
    progress = pyqtSignal(int)
    log = pyqtSignal(str)
    done = pyqtSignal()

    def __init__(self, mpns, storage: JSONStorage):
        super().__init__()
        self.mpns = mpns
        self.storage = storage
        self.client = FindchipsClient()
        self.cancelled = False

    def cancel(self, _):
        """Cancel the scraping process"""
        self.cancelled = True
        self.log.emit("Scraping cancelled by user")

    def run(self):
        total = len(self.mpns)
        fresh_count = 0
        scraped_count = 0
        
        for i, mpn in enumerate(self.mpns):
            # Check for cancellation
            if self.cancelled:
                self.log.emit("Scraping process was cancelled")
                self.done.emit()
                return
                
            try:
                # Check if data is fresh (less than 6 hours old)
                if self.storage.is_data_fresh(mpn, hours=6):
                    data_age = self.storage.get_data_age_hours(mpn)
                    self.log.emit(f"Using cached data for {mpn} (age: {data_age:.1f} hours)")
                    fresh_count += 1
                    self.progress.emit(int((i + 1) * 100 / total))
                    continue
                
                # Data is stale or doesn't exist, scrape from Findchips
                data_age = self.storage.get_data_age_hours(mpn)
                age_text = f"{data_age:.1f} hours old" if data_age != float('inf') else "not found"
                self.log.emit(f"Scraping {mpn} (existing data: {age_text})")
                
                # Step 1: Get manufacturers from search page
                search_results = self.client.search(mpn)
                if not search_results:
                    self.log.emit(f"No manufacturers found for {mpn}")
                    self.progress.emit(int((i + 1) * 100 / total))
                    time.sleep(0.1)
                    continue

                # Step 1.5: Filter search results - exact matches first, then max 1 partial match
                filtered_results = filter_search_results(mpn, search_results)
                if not filtered_results:
                    self.log.emit(f"No suitable matches found for {mpn}")
                    self.progress.emit(int((i + 1) * 100 / total))
                    time.sleep(0.1)
                    continue

                self.log.emit(f"Found {len(filtered_results)} suitable matches for {mpn}")

                # Step 2: For each filtered manufacturer, get detailed data from detail page
                for result in filtered_results:
                    # Check for cancellation before each detail request
                    if self.cancelled:
                        self.log.emit("Scraping process was cancelled")
                        self.done.emit()
                        return
                        
                    result_mpn = result["mpn"]
                    manufacturer = result["manufacturer"]

                    # Determine if this is exact match or alternate
                    is_exact = result_mpn.strip().lower() == mpn.strip().lower()
                    part_type = "Precise Match" if is_exact else "Alternate Parts"

                    self.log.emit(f"Getting details: {result_mpn} / {manufacturer} ({'Exact' if is_exact else 'Partial'} match)")

                    # Get detailed data from detail page
                    detail_data = self.client.detail(result_mpn, manufacturer)

                    # Store offers from detail page
                    offers = detail_data.get("offers", [])
                    if not offers:
                        # If no offers, create a placeholder entry
                        offers = [{"distributor": "Unknown", "stock": 0, "price_tiers": [], "currency": "USD"}]

                    for offer in offers:
                        self.storage.upsert_offer(
                            mpn=mpn,  # Store under the searched MPN
                            distributor=offer.get("distributor", "Unknown"),
                            manufacturer=manufacturer,
                            price_tiers=offer.get("price_tiers", []),
                            stock=offer.get("stock", 0),
                            currency=offer.get("currency", "USD"),
                            lead_time=offer.get("lead_time"),
                            life_cycle_code=detail_data.get("life_cycle_code"),
                            package_code=detail_data.get("package_code"),
                            length_mm=detail_data.get("length_mm"),
                            width_mm=detail_data.get("width_mm"),
                            default_currency=detail_data.get("default_currency", "USD"),
                            part_type=part_type
                        )

                scraped_count += 1
                self.log.emit(f"Completed: {mpn} - processed {len(filtered_results)} manufacturers")

            except Exception as e:
                self.log.emit(f"Error processing {mpn}: {e}")

            self.progress.emit(int((i + 1) * 100 / total))
            time.sleep(0.1)

        # Final summary
        self.log.emit(f"Scraping completed - Used cached: {fresh_count}, Scraped fresh: {scraped_count}")
        self.done.emit()



def convert_price(price, src, dst, usd_to_inr):
    if src == dst:
        return price
    if src == "USD" and dst == "INR":
        return price * usd_to_inr
    if src == "INR" and dst == "USD" and usd_to_inr:
        return price / usd_to_inr
    return price

def select_tier_for_qty(tiers, required_qty):
    if not tiers:
        return None, None, None
    tiers = sorted(tiers, key=lambda x: x["quantity"])
    chosen = None
    next_t = None
    for t in tiers:
        if required_qty >= t["quantity"]:
            chosen = t
        elif required_qty < t["quantity"] and next_t is None:
            next_t = t
            break
    if chosen is None:
        chosen = tiers[0]
    moq = tiers[0]["quantity"]
    return chosen, next_t, moq

def choose_best_option(offers, total_required_qty, currency, usd_to_inr, package_code, L, W):
    """
    REVISED: Choose best option with distributor priority and corrected MOQ/Procure Qty logic
    Priority: 1st - Digikey, 2nd - Mouser, 3rd - Others
    MOQ = lowest available quantity tier
    Procure Qty = follows detailed buffer rules based on package and price
    """
    # Distributor priority list
    priority_list = ['Digikey', 'Mouser']

    # Group offers by distributor priority
    prioritized_offers = {d: [] for d in priority_list}
    others = []

    for off in offers:
        dist_lower = off.get('distributor', '').lower()
        matched = None
        for p in priority_list:
            if p.lower() in dist_lower:
                prioritized_offers[p].append(off)
                matched = p
                break
        if not matched:
            others.append(off)

    # Select offers to consider based on priority
    final_offers_to_consider = []
    for d in priority_list:
        if prioritized_offers[d]:
            final_offers_to_consider.extend(prioritized_offers[d])
            break
    else:
        final_offers_to_consider.extend(others)

    def pct_or_floor(trq, pct, floor_add):
        return max(int(math.ceil(trq * pct / 100)), floor_add)

    def calculate_procure_qty(trq, price_usd, pkg_code, max_dim):
        """Calculate procurement quantity based on detailed rules"""
        
        # Special case: price > $20 USD
        if price_usd > 20:
            return trq if trq < 250 else trq + 1
        
        is_low_price = price_usd < 1.0
        
        # Determine package group
        pkg_group = None
        if pkg_code in ['0201', '0402', '0603']:
            pkg_group = '0201-0603'
        elif pkg_code in ['0805', '1206', '1210']:
            pkg_group = '0805-1210'
        elif pkg_code in ['1812', '2010', '2512', '2920']:
            pkg_group = '1210-8060'
        
        if is_low_price:
            if pkg_group == '0201-0603':
                if trq < 100:
                    return trq + 50
                elif trq < 250:
                    return trq + 80
                elif trq < 500:
                    return trq + pct_or_floor(trq, 15, 80)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 8, 80)
                else:
                    return trq + pct_or_floor(trq, 5, 80)
                    
            elif pkg_group == '0805-1210':
                if trq < 100:
                    return trq + 25
                elif trq < 250:
                    return trq + 40
                elif trq < 500:
                    return trq + pct_or_floor(trq, 10, 40)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 7, 40)
                else:
                    return trq + pct_or_floor(trq, 3, 40)
                    
            elif pkg_group == '1210-8060':
                if trq < 100:
                    return trq + 12
                elif trq < 250:
                    return trq + 20
                elif trq < 500:
                    return trq + pct_or_floor(trq, 5, 20)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 3, 20)
                else:
                    return trq + pct_or_floor(trq, 2, 20)
            else:
                # Unknown package with size info
                if max_dim and max_dim < 5:
                    # Use 0805-1210 logic
                    if trq < 100:
                        return trq + 25
                    elif trq < 250:
                        return trq + 40
                    elif trq < 500:
                        return trq + pct_or_floor(trq, 10, 40)
                    elif trq < 1000:
                        return trq + pct_or_floor(trq, 7, 40)
                    else:
                        return trq + pct_or_floor(trq, 3, 40)
                else:
                    # Default fallback
                    return trq + (2 if trq < 250 else 3)
                    
        else: # High price (>= $1 USD)
            if pkg_group in ['0201-0603', '0805-1210']:
                if trq < 100:
                    return trq + 15
                elif trq < 250:
                    return trq + 20
                elif trq < 500:
                    return trq + pct_or_floor(trq, 4, 20)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 3, 20)
                else:
                    return trq + pct_or_floor(trq, 2, 20)
                    
            elif pkg_group == '1210-8060':
                if trq < 250:
                    return trq + 5
                elif trq < 500:
                    return trq + pct_or_floor(trq, 3, 5)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 2, 5)
                else:
                    return trq + pct_or_floor(trq, 1, 5)
            else:
                # Unknown package handling
                if max_dim and max_dim >= 5:
                    # Use 0201-1210 high price logic
                    if trq < 100:
                        return trq + 15
                    elif trq < 250:
                        return trq + 20
                    elif trq < 500:
                        return trq + pct_or_floor(trq, 4, 20)
                    elif trq < 1000:
                        return trq + pct_or_floor(trq, 3, 20)
                    else:
                        return trq + pct_or_floor(trq, 2, 20)
                elif max_dim and max_dim >= 5 and 10 <= price_usd <= 20:
                    # Special case
                    return trq + 1 if trq < 250 else trq + 1
                else:
                    return trq + (2 if trq < 250 else 3)
        
        return trq + 5  # Default fallback

    best = None
    for off in final_offers_to_consider:
        tiers = off.get("price_tiers") or []
        if not tiers:
            continue

        tiers_conv = []
        for t in tiers:
            price_converted = convert_price(t["price"], off.get("currency", "USD"), currency, usd_to_inr)
            tiers_conv.append({"quantity": int(t["quantity"]), "price": float(price_converted)})

        tiers_conv = sorted(tiers_conv, key=lambda x: x["quantity"])

        # MOQ = lowest available quantity tier
        moq = tiers_conv[0]["quantity"] if tiers_conv else 1

        # Find tier for total_required_qty
        chosen, next_t, _ = select_tier_for_qty(tiers_conv, total_required_qty)
        if not chosen:
            continue

        price_usd = convert_price(chosen["price"], currency, "USD", usd_to_inr)
        max_dim = max_dim_mm_from_package_or_size(package_code, L, W)
        
        # Calculate procurement quantity
        proc_qty = calculate_procure_qty(total_required_qty, price_usd, package_code, max_dim)
        
        # Find the tier for procurement quantity
        chosen_proc, next_proc, _ = select_tier_for_qty(tiers_conv, proc_qty)
        if not chosen_proc:
            chosen_proc = chosen

        # Calculate costs: current quantity vs next tier quantity
        cost_current = proc_qty * chosen_proc["price"]
        cost_next = float('inf')
        
        if next_proc:
            cost_next = next_proc["quantity"] * next_proc["price"]

        # Choose the lower cost option
        if cost_next < cost_current:
            final_procure_qty = next_proc["quantity"]
            final_unit_price = next_proc["price"]
            final_qty_tier = next_proc["quantity"]
            final_total_cost = cost_next
        else:
            final_procure_qty = proc_qty
            final_unit_price = chosen_proc["price"]
            final_qty_tier = chosen_proc["quantity"]
            final_total_cost = cost_current

        option = {
            "distributor": off["distributor"],
            "moq": moq,
            "qty_tier": final_qty_tier,
            "unit_price": final_unit_price,
            "procure_qty": final_procure_qty,
            "total_cost": final_total_cost,
            "stock": off.get("stock", 0)
        }

        if best is None or option["total_cost"] < best["total_cost"]:
            best = option

    return best

class RobustBOMLoader:
    """Enhanced BOM file loader with better error handling and format support"""
    
    @staticmethod
    def load_bom_file(file_path: str) -> pd.DataFrame:
        """Load BOM file with robust error handling and format detection"""
        
        # Detect file extension
        file_ext = os.path.splitext(file_path)[1].lower()
        
        try:
            if file_ext == '.csv':
                return RobustBOMLoader._load_csv(file_path)
            elif file_ext in ['.xlsx', '.xls']:
                return RobustBOMLoader._load_excel(file_path)
            else:
                raise ValueError(f"Unsupported file format: {file_ext}")
        except Exception as e:
            raise Exception(f"Failed to load BOM file: {str(e)}")
    
    @staticmethod
    def _load_csv(file_path: str) -> pd.DataFrame:
        """Load CSV file with encoding and delimiter detection"""
        
        # Detect encoding
        encoding = detect_file_encoding(file_path)
        
        # Detect delimiter
        delimiter = detect_csv_delimiter(file_path, encoding)
        
        # Try different encoding options if detection fails
        encodings_to_try = [encoding, 'utf-8', 'utf-8-sig', 'iso-8859-1', 'cp1252']
        
        for enc in encodings_to_try:
            try:
                # Read with pandas
                df = pd.read_csv(
                    file_path, 
                    delimiter=delimiter, 
                    encoding=enc,
                    engine='python',  # More flexible parser
                    on_bad_lines='skip',  # Skip bad lines instead of failing
                    dtype=str  # Read all as strings initially
                )
                
                # Basic validation
                if df.empty:
                    raise ValueError("CSV file is empty")
                
                if len(df.columns) < 2:
                    raise ValueError("CSV file must have at least 2 columns")
                
                # Clean up column names (remove extra whitespace)
                df.columns = df.columns.str.strip()
                
                return df
                
            except UnicodeDecodeError:
                continue  # Try next encoding
            except Exception as e:
                if enc == encodings_to_try[-1]:  # Last encoding failed
                    raise Exception(f"Failed to read CSV: {str(e)}")
                continue
        
        raise Exception("Could not read CSV file with any supported encoding")
    
    @staticmethod
    def _load_excel(file_path: str) -> pd.DataFrame:
        """Load Excel file with sheet selection and error handling"""
        
        try:
            # Try to read Excel file and get sheet names
            excel_file = pd.ExcelFile(file_path)
            sheet_names = excel_file.sheet_names
            
            if len(sheet_names) == 0:
                raise ValueError("Excel file contains no worksheets")
            
            # If multiple sheets, we need to let user choose
            # For now, just use the first sheet, but in the GUI we can add sheet selection
            selected_sheet = sheet_names[0]
            
            # Read the selected sheet
            df = pd.read_excel(
                file_path,
                sheet_name=selected_sheet,
                dtype=str,  # Read all as strings initially
                engine='openpyxl'
            )
            
            # Basic validation
            if df.empty:
                raise ValueError("Excel sheet is empty")
            
            if len(df.columns) < 2:
                raise ValueError("Excel sheet must have at least 2 columns")
            
            # Clean up column names
            df.columns = df.columns.str.strip()
            
            # Remove completely empty rows
            df = df.dropna(how='all')
            
            return df
            
        except Exception as e:
            raise Exception(f"Failed to read Excel file: {str(e)}")

class App(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("SIENNA BOM Cost Analysis tool V1.1                    \u00A9 2025 Sienna ECAD Technologies. All Rights Reserved.")
        self.resize(1250, 750)
        self.storage = JSONStorage()
        self.client = FindchipsClient()
        self.exchange = {"USD": 1.0, "INR": 87.0}
        self._manufacturer_overrides = {}
        self._package_overrides = {}
        self._build_ui()
        self._apply_white_backgrounds()  # Apply white backgrounds to specific widgets
        self.bom_df = None
        self.loader = RobustBOMLoader()
        self.setWindowIcon(QIcon("logo.ico"))

    def _build_ui(self):
        tb = QToolBar(); self.addToolBar(tb)
        act_open = QAction("Upload BOM", self); act_open.triggered.connect(self.on_open); tb.addAction(act_open)
        tb.addSeparator()
        act_fetch = QAction("Fetch Data", self); act_fetch.triggered.connect(self.on_fetch); tb.addAction(act_fetch)
        tb.addSeparator()
        act_export = QAction("Export to Excel", self); act_export.triggered.connect(self.on_export_smart); tb.addAction(act_export)

        top = QHBoxLayout()

        # MPN Column
        mpn_layout = QHBoxLayout()
        mpn_layout.addWidget(QLabel("MPN Column:"))
        self.cmb_mpn = QComboBox()
        self.cmb_mpn.setMinimumWidth(200)
        mpn_layout.addWidget(self.cmb_mpn)
        mpn_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(mpn_layout)
        

        # QTY Column
        qty_layout = QHBoxLayout()
        qty_layout.addWidget(QLabel("QTY Column:"))
        self.cmb_qty = QComboBox()
        self.cmb_qty.setMinimumWidth(200)
        qty_layout.addWidget(self.cmb_qty)
        qty_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(qty_layout)

        # PCB Qty
        pcb_layout = QHBoxLayout()
        pcb_layout.addWidget(QLabel("PCB Qty:"))
        self.sp_pcb = QSpinBox()
        self.sp_pcb.setRange(1, 1000000)
        self.sp_pcb.setEnabled(True)
        self.sp_pcb.setValue(1)
        self.sp_pcb.setMinimumWidth(150)
        pcb_layout.addWidget(self.sp_pcb)
        pcb_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(pcb_layout)

        # Currency
        cur_layout = QHBoxLayout()
        cur_layout.addWidget(QLabel("Currency:"))
        self.cmb_cur = QComboBox()
        self.cmb_cur.addItems(["USD", "INR"])
        self.cmb_cur.setMinimumWidth(120)
        cur_layout.addWidget(self.cmb_cur)
        cur_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(cur_layout)

        # Exchange Rate
        rate_layout = QHBoxLayout()
        rate_layout.addWidget(QLabel("USDâ†’INR:"))
        self.sp_rate = QDoubleSpinBox()
        self.sp_rate.setRange(0.01, 1000.0)
        self.sp_rate.setDecimals(2)
        self.sp_rate.setValue(87.0)
        self.sp_rate.setMinimumWidth(120)
        rate_layout.addWidget(self.sp_rate)
        rate_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        top.addLayout(rate_layout)

        img1_layout = QHBoxLayout()
        img_label = QLabel()
        pixmap = QPixmap("SiennaLogo.png")  # ðŸ” Replace with actual image path
        img_label.setPixmap(pixmap.scaledToHeight(40, Qt.TransformationMode.SmoothTransformation))
        img_label.setMinimumWidth(80)  # Optional scaling
        img1_layout.addWidget(img_label)
        img1_layout.setAlignment(Qt.AlignmentFlag.AlignRight)
        top.addLayout(img1_layout)

        # Set the layout to a widget
        topw = QWidget()
        topw.setLayout(top)


        self.tabs = QTabWidget()
        self.tbl_results = QTableWidget()
        self.tbl_details = QTableWidget()
        self.tabs.addTab(self.tbl_results, "BOM Results")
        self.tabs.addTab(self.tbl_details, "Component Details")

        self.log = QTextEdit(); self.log.setReadOnly(True); self.log.setMaximumHeight(160)
        # Progress bar with cancel button
        progress_layout = QHBoxLayout()
        self.progress = QProgressBar()
        self.progress.setVisible(False)
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.setVisible(False)
        self.cancel_btn.clicked.connect(self.on_cancel_scraping)
        
        progress_layout.addWidget(self.progress)
        progress_layout.addWidget(self.cancel_btn)
        progress_widget = QWidget()
        progress_widget.setLayout(progress_layout)

        spl = QSplitter(Qt.Orientation.Vertical)
        spl.addWidget(self.tabs); spl.addWidget(self.log); spl.setStretchFactor(0, 3); spl.setStretchFactor(1, 1)

        root = QVBoxLayout(); root.addWidget(topw); root.addWidget(progress_widget); root.addWidget(spl)
        cw = QWidget(); cw.setLayout(root); self.setCentralWidget(cw)

        self._setup_debounced_recalc()
        self.tbl_results.itemChanged.connect(self._on_package_edit_changed)

    def on_cancel_scraping(self, _):
        """Cancel the current scraping operation"""
        if hasattr(self, 'worker') and self.worker.isRunning():
            self.worker.cancel()
            self.cancel_btn.setEnabled(False)
            self.cancel_btn.setText("Cancelling...")

    def on_fetch(self, _):
        if self.bom_df is None:
            QMessageBox.warning(self, "Warning", "Upload BOM first")
            return

        mpn_col = self.cmb_mpn.currentText()
        if not mpn_col:
            QMessageBox.warning(self, "Warning", "Select MPN column")
            return

        # Get unique MPNs, handling NaN values
        mpns = []
        for val in self.bom_df[mpn_col].dropna().astype(str).str.strip().unique():
            if val and val.lower() != 'nan':
                mpns.append(val)

        if not mpns:
            QMessageBox.warning(self, "Warning", "No valid MPNs found")
            return

        # Show cache status
        fresh_mpns = [mpn for mpn in mpns if self.storage.is_data_fresh(mpn, hours=6)]
        stale_mpns = [mpn for mpn in mpns if not self.storage.is_data_fresh(mpn, hours=6)]
        
        self.log_msg(f"Starting fetch for {len(mpns)} unique MPNs")
        self.log_msg(f"Fresh data (< 6 hours): {len(fresh_mpns)} MPNs")
        self.log_msg(f"Will scrape: {len(stale_mpns)} MPNs")

        self.progress.setVisible(True)
        self.progress.setValue(0)
        self.cancel_btn.setVisible(True)
        self.cancel_btn.setEnabled(True)
        self.cancel_btn.setText("Cancel")

        self.worker = ScrapeThread(mpns, self.storage)
        self.worker.progress.connect(self.progress.setValue)
        self.worker.log.connect(self.log_msg)
        self.worker.done.connect(self.on_scrape_done)
        self.worker.start()

        self._details_needs_refresh = True

    def on_scrape_done(self):
        self.progress.setVisible(False)
        self.cancel_btn.setVisible(False)
        self._details_needs_refresh = True
        self.log_msg("Processing completed")
        self.recalc_all()

    def _apply_white_backgrounds(self):
        """Apply white backgrounds to log and table widgets for better readability"""
        white_style = """
            background-color: white;
            color: black;
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        """
        
        table_style = """
            QTableWidget {
                background-color: white;
                color: black;
                border: 2px solid rgb(0, 150, 50);
                selection-background-color: rgb(0, 150, 50);
                selection-color: white;
            }
            QTableWidget::item {
                padding: 3px;
            }
            QTableWidget::item:selected {
                background-color: rgb(0, 150, 50);
                color: white;
            }
            /* Horizontal headers (column headers) - GREEN background, WHITE text */
            QHeaderView::section:horizontal {
                background-color: rgb(0, 150, 50);
                color: white;
                padding: 5px;
                border: 1px solid rgb(200, 200, 200);
                font-weight: bold;
                font-size: 11pt;
            }
            
            /* Vertical headers (row numbers) - WHITE background, BLACK text */
            QHeaderView::section:vertical {
                background-color: white;
                color: black;
                padding: 3px;
                border: 1px solid rgb(200, 200, 200);
                font-weight: bold;
            }
            
            /* Corner button (top-left corner) */
            QTableCornerButton::section {
                background-color: rgb(0, 150, 50);
                border: 1px solid rgb(200, 200, 200);
            }
        """
        
        self.log.setStyleSheet(white_style)
        self.tbl_results.setStyleSheet(table_style)
        self.tbl_details.setStyleSheet(table_style)

    def log_msg(self, m):
        self.log.append(f"[{datetime.now().strftime('%H:%M:%S')}] {m}")

    def on_open(self, _):
        path, _ = QFileDialog.getOpenFileName(
            self, 
            "Open BOM", 
            "", 
            "Excel (*.xlsx *.xls);;CSV (*.csv);;All Files (*.*)"
        )
        if not path: 
            return
        
        try:
            self.log_msg(f"Loading file: {os.path.basename(path)}")
            
            # Use robust BOM loader
            self.bom_df = self.loader.load_bom_file(path)
            
            # Update UI
            self.cmb_mpn.clear()
            self.cmb_qty.clear()
            cols = list(self.bom_df.columns)
            self.cmb_mpn.addItems(cols)
            self.cmb_qty.addItems(cols)
            
            # Try to auto-detect MPN and QTY columns
            self._auto_detect_columns(cols)
            
            self.show_bom(self.bom_df)
            self.populate_details_initial()
            self.log_msg(f"Successfully loaded BOM with {len(self.bom_df)} rows and {len(self.bom_df.columns)} columns")
            
        except Exception as e:
            QMessageBox.critical(self, "Error Loading BOM", str(e))
            self.log_msg(f"Error loading BOM: {str(e)}")

    def _setup_debounced_recalc(self):
        """Setup debounced recalculation to prevent rapid-fire updates"""
        from PyQt6.QtCore import QTimer
        
        # Create debounce timer
        self.debounce_timer = QTimer(self)
        self.debounce_timer.setSingleShot(True)  # Only fire once
        self.debounce_timer.setInterval(300)     # 300ms delay
        self.debounce_timer.timeout.connect(self.recalc_all)
        
        # Connect signals to start/restart the debounce timer
        self.cmb_cur.currentTextChanged.connect(self._trigger_debounced_recalc)
        self.sp_rate.valueChanged.connect(self._trigger_debounced_recalc)
        self.sp_pcb.valueChanged.connect(self._trigger_debounced_recalc)

    def _trigger_debounced_recalc(self, _):
        """Start/restart the debounce timer"""
        self.debounce_timer.start()  # Restarts timer if alrea

    def _auto_detect_columns(self, columns):
        """Auto-detect MPN and QTY columns based on common naming patterns"""
        mpn_patterns = ['mpn', 'part', 'partno', 'part_no', 'part number']
        qty_patterns = ['qty', 'quantity']
        
        # Find MPN column
        for i, col in enumerate(columns):
            col_lower = col.lower().strip()
            if any(pattern in col_lower for pattern in mpn_patterns):
                self.cmb_mpn.setCurrentIndex(i)
                break
        
        # Find QTY column
        for i, col in enumerate(columns):
            col_lower = col.lower().strip()
            if any(pattern in col_lower for pattern in qty_patterns):
                self.cmb_qty.setCurrentIndex(i)
                break

    def show_bom(self, df):
        self.tbl_results.setRowCount(len(df))
        self.tbl_results.setColumnCount(len(df.columns))
        self.tbl_results.setHorizontalHeaderLabels(list(df.columns))
        for r in range(len(df)):
            for c in range(len(df.columns)):
                val = df.iloc[r, c]
                # Handle NaN values
                display_val = str(val) if pd.notna(val) else ""
                self.tbl_results.setItem(r, c, QTableWidgetItem(display_val))

    def populate_details_initial(self):
        if self.bom_df is None: 
            return
        self.tbl_details.setRowCount(len(self.bom_df))
        self.tbl_details.setColumnCount(len(self.bom_df.columns))
        self.tbl_details.setHorizontalHeaderLabels(list(self.bom_df.columns))
        for r in range(len(self.bom_df)):
            for c in range(len(self.bom_df.columns)):
                val = self.bom_df.iloc[r, c]
                display_val = str(val) if pd.notna(val) else ""
                self.tbl_details.setItem(r, c, QTableWidgetItem(display_val))


    def recalc_all(self):
        if self.bom_df is None:
            return
        try:
            self.calc_bom_results()
            self.refresh_details_view()
        except Exception as e:
            self.log_msg(f"Recalc error: {e}")

    def refresh_details_view(self):
        if self.bom_df is None: 
            return
        
        if not hasattr(self, '_details_needs_refresh'):
            self._details_needs_refresh = True
        
        if not self._details_needs_refresh:
            return

        mpn_col = self.cmb_mpn.currentText() or self.bom_df.columns[0]
        df = self.bom_df.copy()

        add_cols = ["Manufacturer", "Part Type", "Life Cycle", "Package", "Size (LÃ—W mm)", "Default Currency", "Lead Time"]
        for col in add_cols:
            df[col] = ""

        fixed_dists = ['Digikey', 'Mouser', 'Arrow', 'Avnet', 'Newark', 'RS Components', 'Element14']
        max_tiers = 5

        for d in fixed_dists:
            df[f"{d} Stock"] = ""
            for t in range(1, max_tiers + 1):
                df[f"{d} T{t} Qty"] = ""
                df[f"{d} T{t} Price"] = ""

        for idx, row in df.iterrows():
            mpn_val = row[mpn_col]
            if pd.isna(mpn_val):
                continue
            mpn = str(mpn_val).strip()
            if not mpn or mpn.lower() == 'nan':
                continue

            offers = self.storage.offers_by_mpn(mpn)
            manuf = sorted({o["manufacturer"] for o in offers if o.get("manufacturer")})
            meta = self.storage.part_meta(mpn)

            df.at[idx, "Manufacturer"] = " | ".join(manuf) if manuf else ""
            df.at[idx, "Part Type"] = meta.get("part_type", "")
            df.at[idx, "Life Cycle"] = meta.get("life", "")
            df.at[idx, "Lead Time"] = meta.get("lead_time", "")
            pkg = meta.get("package") or ""
            L = meta.get("L")
            W = meta.get("W")
            df.at[idx, "Package"] = pkg or ""
            if L is not None or W is not None:
                df.at[idx, "Size (LÃ—W mm)"] = f"{(L or '')}Ã—{(W or '')}"
            df.at[idx, "Default Currency"] = meta.get("default_currency", "USD")

            for o in offers:
                dname_raw = o["distributor"] or ""
                matched = next((d for d in fixed_dists if d.lower() in dname_raw.lower()), None)
                if not matched:
                    continue

                df.at[idx, f"{matched} Stock"] = str(o.get("stock", 0))
                tiers = sorted(o.get("price_tiers") or [], key=lambda x: x["quantity"])
                for ti, t in enumerate(tiers[:max_tiers], start=1):
                    df.at[idx, f"{matched} T{ti} Qty"] = str(t["quantity"])
                    df.at[idx, f"{matched} T{ti} Price"] = f"{t['price']:.6f}"

        self.tbl_details.setRowCount(len(df))
        self.tbl_details.setColumnCount(len(df.columns))
        self.tbl_details.setHorizontalHeaderLabels(list(df.columns))
        for r in range(len(df)):
            for c in range(len(df.columns)):
                val = df.iloc[r, c]
                display_val = str(val) if pd.notna(val) else ""
                self.tbl_details.setItem(r, c, QTableWidgetItem(display_val))

        self._details_needs_refresh = False

    def calc_bom_results(self):
        mpn_col = self.cmb_mpn.currentText()
        qty_col = self.cmb_qty.currentText()
        if not mpn_col or not qty_col:
            return

        df = self.bom_df.copy()

        result_cols = [
            "Part Type", "MPN", "Manufacturer", "Part Life Cycle Code", "Package",
            "Size (LÃ—W mm)", "Lead Time", "In Stock", "MOQ", "Total Required Qty",
            "Procure Qty", "Distributor", "Qty Tier", "Unit Price", "PCB Per Unit Price", "Total Project Price"
        ]

        for col in result_cols:
            df[col] = ""

        pcb_qty = int(self.sp_pcb.value())
        currency = self.cmb_cur.currentText()
        usd_to_inr = float(self.sp_rate.value())

        for idx, row in df.iterrows():
            mpn_val = row[mpn_col]
            if pd.isna(mpn_val):
                continue
            mpn = str(mpn_val).strip()
            if not mpn or mpn.lower() == 'nan':
                continue

            qty_val = row[qty_col]
            if pd.isna(qty_val):
                bom_qty = 0.0
            else:
                try:
                    bom_qty = float(qty_val)
                except (ValueError, TypeError):
                    bom_qty = 0.0
            
            total_required = int(bom_qty * pcb_qty)

            # Get fresh data from storage (includes any user package updates)
            offers = self.storage.offers_by_mpn(mpn)
            meta = self.storage.part_meta(mpn)

            # Filter by manufacturer if user selected one
            selected_manufacturer = self._manufacturer_overrides.get(mpn)
            if selected_manufacturer:
                offers = [o for o in offers if o.get("manufacturer") == selected_manufacturer]
                if offers:
                    life = next((o["life_cycle_code"] for o in offers if o.get("life_cycle_code")), "")
                    pkg = next((o["package_code"] for o in offers if o.get("package_code")), "")
                    L = next((o["length_mm"] for o in offers if o.get("length_mm") is not None), None)
                    W = next((o["width_mm"] for o in offers if o.get("width_mm") is not None), None)
                    defcur = next((o["default_currency"] for o in offers if o.get("default_currency")), "USD")
                    ptype = next((o["part_type"] for o in offers if o.get("part_type")), "")
                    lead = next((o["lead_time"] for o in offers if o.get("lead_time")), "")
                    meta = {"life": life, "package": pkg, "L": L, "W": W, "default_currency": defcur, "part_type": ptype, "lead_time": lead}

            pkg_code = meta.get("package") or ""
            L = meta.get("L")
            W = meta.get("W")

            offers_conv = []
            for o in offers:
                tiers = []
                for t in o.get("price_tiers") or []:
                    price_conv = convert_price(t["price"], o.get("currency", "USD"), currency, usd_to_inr)
                    tiers.append({"quantity": int(t["quantity"]), "price": float(price_conv)})

                offers_conv.append({
                    "distributor": o["distributor"], "price_tiers": sorted(tiers, key=lambda x: x["quantity"]),
                    "stock": o.get("stock", 0), "currency": currency
                })

            best = choose_best_option(offers_conv, total_required, currency, usd_to_inr, norm_eia_code(pkg_code), L, W)

            if best:
                df.at[idx, "In Stock"] = str(best.get("stock", 0))
                df.at[idx, "MOQ"] = str(best.get("moq", ""))
                df.at[idx, "Total Required Qty"] = str(total_required)
                df.at[idx, "Procure Qty"] = str(best.get("procure_qty", total_required))
                df.at[idx, "Distributor"] = best.get("distributor", "")
                df.at[idx, "Qty Tier"] = str(best.get("qty_tier", ""))
                df.at[idx, "Unit Price"] = f"{best.get('unit_price', 0):.6f}"
                df.at[idx, "PCB Per Unit Price"] = f"{float(best.get('unit_price', 0)) * bom_qty:.6f}"
                df.at[idx, "Total Project Price"] = f"{float(best.get('unit_price', 0)) * bom_qty * pcb_qty:.4f}"

            df.at[idx, "Part Type"] = meta.get("part_type", "")
            df.at[idx, "MPN"] = mpn
            df.at[idx, "Part Life Cycle Code"] = meta.get("life", "")
            df.at[idx, "Package"] = meta.get("package", "")  # Use storage value directly
            df.at[idx, "Lead Time"] = meta.get("lead_time", "")
            
            if meta.get("L") is not None or meta.get("W") is not None:
                df.at[idx, "Size (LÃ—W mm)"] = f"{(meta.get('L') or '')}Ã—{(meta.get('W') or '')}"

            # Set manufacturer
            all_offers = self.storage.offers_by_mpn(mpn)
            manufacturers = sorted({o["manufacturer"] for o in all_offers if o.get("manufacturer")})
            if manufacturers:
                df.at[idx, "Manufacturer"] = selected_manufacturer or manufacturers[0]

        sums_cols = ["PCB Per Unit Price", "Total Project Price"]
        totals = {}
        for c in sums_cols:
            vals = pd.to_numeric(df[c].replace("", 0), errors="coerce").fillna(0) if c in df.columns else pd.Series()
            totals[c] = vals.sum()

        self.tbl_results.setRowCount(len(df) + 1)
        self.tbl_results.setColumnCount(len(df.columns))
        self.tbl_results.setHorizontalHeaderLabels(list(df.columns))

        for r in range(len(df)):
            for c in range(len(df.columns)):
                col_name = df.columns[c]
                val = df.iloc[r, c]
                display_val = str(val) if pd.notna(val) else ""
                it = QTableWidgetItem(display_val)
                
                if col_name == "In Stock":
                    try:
                        s = int(display_val) if display_val else 0
                    except Exception:
                        s = 0
                    if s == 0: 
                        it.setBackground(QColor(255, 200, 200))
                    elif s < 100: 
                        it.setBackground(QColor(255, 255, 200))
                    elif s < 1000: 
                        it.setBackground(QColor(255, 255, 150))
                    else: 
                        it.setBackground(QColor(200, 255, 200))
                    f = QFont(); f.setBold(True); it.setFont(f)
                
                # Make Package column editable
                elif col_name == "Package":
                    it.setFlags(it.flags() | Qt.ItemFlag.ItemIsEditable)
                    it.setBackground(QColor(240, 255, 240))  # Light green = editable

                # NEW: Make Size column editable
                elif col_name == "Size (LÃ—W mm)":
                    it.setFlags(it.flags() | Qt.ItemFlag.ItemIsEditable)
                    it.setBackground(QColor(240, 240, 255))  # Light blue = editable

                self.tbl_results.setItem(r, c, it)

        # Add manufacturer dropdowns
        self._add_manufacturer_dropdowns(df)

        # Add totals row
        tr = len(df)
        for c in range(len(df.columns)):
            name = df.columns[c]
            if c == 0:
                tit = QTableWidgetItem("TOTAL")
            elif name in totals:
                tit = QTableWidgetItem(f"{totals[name]:.4f}")
            else:
                tit = QTableWidgetItem("")
            f = QFont(); f.setBold(True); tit.setFont(f); tit.setBackground(QColor(220, 220, 220))
            self.tbl_results.setItem(tr, c, tit)

    def _on_package_edit_changed(self, item):
        """Handle manual package and size edits and update storage"""
        if not item:
            return

        # Skip last TOTAL row
        if item.row() >= self.tbl_results.rowCount() - 1:
            return

        # Check which column was changed
        col = item.column()
        header = self.tbl_results.horizontalHeaderItem(col)
        if not header:
            return
        
        col_name = header.text()
        
        # Only handle Package and Size columns
        if col_name not in ["Package", "Size (LÃ—W mm)"]:
            return

        # Get MPN of this row
        row = item.row()
        mpn_col_idx = None
        for c in range(self.tbl_results.columnCount()):
            h = self.tbl_results.horizontalHeaderItem(c)
            if h and h.text() == "MPN":
                mpn_col_idx = c
                break

        if mpn_col_idx is None:
            self.log_msg("Error: Cannot find MPN column")
            return

        mpn_item = self.tbl_results.item(row, mpn_col_idx)
        if not mpn_item:
            self.log_msg("Error: Cannot get MPN from row")
            return

        mpn = mpn_item.text().strip()
        new_value = item.text().strip()

        if not mpn:
            self.log_msg(f"Error: MPN is empty, cannot update {col_name}")
            return

        # Get original values for comparison
        orig_meta = self.storage.part_meta(mpn)
        
        try:
            if col_name == "Package":
                # Handle package update (existing functionality)
                original_package = orig_meta.get("package", "")
                if new_value != original_package:
                    rows_affected = self.storage.update_package_for_mpn(mpn, new_value)
                    self.log_msg(f"Package updated for {mpn}: '{new_value}' (was: '{original_package}') - {rows_affected} records affected")
            
            elif col_name == "Size (LÃ—W mm)":
                # Handle size update (new functionality)
                original_l = orig_meta.get("L")
                original_w = orig_meta.get("W")
                original_size = f"{(original_l or '')}Ã—{(original_w or '')}" if (original_l is not None or original_w is not None) else ""
                
                if new_value != original_size:
                    # Parse the new size value
                    length_mm, width_mm = self._parse_size_input(new_value)
                    
                    if length_mm is None and width_mm is None and new_value:
                        self.log_msg(f"Error: Invalid size format '{new_value}'. Use format like '1.6Ã—0.8' or '1.6x0.8'")
                        item.setText(original_size)
                        return
                    
                    rows_affected = self.storage.update_size_for_mpn(mpn, length_mm, width_mm)
                    new_size_display = f"{(length_mm or '')}Ã—{(width_mm or '')}" if (length_mm is not None or width_mm is not None) else ""
                    self.log_msg(f"Size updated for {mpn}: '{new_size_display}' (was: '{original_size}') - {rows_affected} records affected")
                    
                    # Update the display to show consistent format
                    item.setText(new_size_display)

        except Exception as e:
            self.log_msg(f"Error updating {col_name}: {e}")
            # Revert cell to original value on error
            if col_name == "Package":
                item.setText(orig_meta.get("package", ""))
            elif col_name == "Size (LÃ—W mm)":
                original_l = orig_meta.get("L")
                original_w = orig_meta.get("W")
                original_size = f"{(original_l or '')}Ã—{(original_w or '')}" if (original_l is not None or original_w is not None) else ""
                item.setText(original_size)
            return

        # Temporarily disconnect signal to avoid recursion
        self.tbl_results.itemChanged.disconnect(self._on_package_edit_changed)
        try:
            # Recalculate with updated storage
            self.recalc_all()
        except Exception as e:
            self.log_msg(f"Error during recalculation: {e}")
        finally:
            # Reconnect signal
            self.tbl_results.itemChanged.connect(self._on_package_edit_changed)

    def _parse_size_input(self, size_text):
        """Parse size input like '1.6Ã—0.8' or '1.6x0.8' into length and width"""
        if not size_text or size_text.strip() == "Ã—" or size_text.strip() == "x":
            return None, None
        
        # Handle various separators and formats
        import re
        
        # Look for patterns like "1.6Ã—0.8", "1.6x0.8", "1.6 x 0.8", etc.
        pattern = r'([0-9]*\.?[0-9]+)\s*[Ã—x]\s*([0-9]*\.?[0-9]+)'
        match = re.search(pattern, size_text.strip())
        
        if match:
            try:
                length = float(match.group(1))
                width = float(match.group(2))
                return length, width
            except ValueError:
                pass
        
        # Try to parse single number (assume it's length only)
        try:
            single_value = float(size_text.strip())
            return single_value, None
        except ValueError:
            pass
        
        return None, None



    def _add_manufacturer_dropdowns(self, df):
        """Add manufacturer dropdowns for MPNs with multiple manufacturers"""
        if "Manufacturer" not in df.columns or "MPN" not in df.columns:
            return
        
        manf_col_idx = list(df.columns).index("Manufacturer")
        mpn_col_idx = list(df.columns).index("MPN")
        
        for r in range(len(df)):
            mpn_val = df.iloc[r, mpn_col_idx]
            if pd.isna(mpn_val):
                continue
            mpn = str(mpn_val).strip()
            if not mpn or mpn.lower() == 'nan':
                continue
            
            # Get all manufacturers for this MPN
            offers = self.storage.offers_by_mpn(mpn)
            manufacturers = sorted({o["manufacturer"] for o in offers if o.get("manufacturer")})
            
            if len(manufacturers) <= 1:
                continue  # Single or no manufacturer, keep as text
            
            # Create dropdown for multiple manufacturers
            combo = QComboBox()
            combo.addItems(manufacturers)
            
            # Set current selection
            current_manf = self._manufacturer_overrides.get(mpn, manufacturers[0])
            combo.setCurrentText(current_manf)
            
            # Connect change event
            combo.currentTextChanged.connect(
                lambda selected_manf, mpn=mpn: self._on_manufacturer_changed(mpn, selected_manf)
            )
            
            # Set dropdown in table
            self.tbl_results.setCellWidget(r, manf_col_idx, combo)

    def _on_manufacturer_changed(self, mpn, selected_manufacturer):
        """Handle manufacturer dropdown change"""
        self._manufacturer_overrides[mpn] = selected_manufacturer
        self.log_msg(f"Manufacturer changed for {mpn}: {selected_manufacturer}")
        
        # Recalculate results with new manufacturer selection
        self.recalc_all()

    def on_export_smart(self, _):
        """Smart export - detects active tab and exports accordingly"""
        current_tab_index = self.tabs.currentIndex()
        current_tab_text = self.tabs.tabText(current_tab_index)
        
        if "Results" in current_tab_text:
            self.on_export_results()
        elif "Details" in current_tab_text:
            self.on_export_details()
        else:
            # Default to results if unclear
            self.on_export_results()


    def on_export_results(self):
        """Export BOM Results to Excel with summary table and green headers"""
        if self.tbl_results.rowCount() == 0:
            QMessageBox.warning(self, "Warning", "No data to export")
            return

        path, _ = QFileDialog.getSaveFileName(self, "Save Results Excel", "", "Excel (*.xlsx)")
        if not path:
            return

        try:
            # Get results data
            headers = [self.tbl_results.horizontalHeaderItem(i).text() for i in range(self.tbl_results.columnCount())]
            data = []
            
            for r in range(self.tbl_results.rowCount()):
                row = []
                for c in range(self.tbl_results.columnCount()):
                    it = self.tbl_results.item(r, c)
                    row.append(it.text() if it else "")
                data.append(row)

            df = pd.DataFrame(data, columns=headers)
            
            # Use openpyxl for advanced styling and summary
            from openpyxl import Workbook
            from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
            from openpyxl.utils.dataframe import dataframe_to_rows
            from openpyxl.drawing.image import Image
            import io
            
            wb = Workbook()
            ws = wb.active
            ws.title = "BOM Results"
            
            # Create summary table at top
            self._add_summary_table(ws, df)
            
            # Add spacing
            current_row = ws.max_row + 3
            
            # Add main data table
            for r_idx, row in enumerate(dataframe_to_rows(df, index=False, header=True), start=current_row):
                for c_idx, value in enumerate(row, start=1):
                    ws.cell(row=r_idx, column=c_idx, value=value)
            
            # Style the main table headers
            self._style_table_headers(ws, current_row, len(headers))
            
            # Auto-adjust column widths
            self._auto_adjust_columns(ws)
            
            wb.save(path)
            self.log_msg(f"Results exported: {path}")

        except Exception as e:
            QMessageBox.critical(self, "Export Error", str(e))
            self.log_msg(f"Results export failed: {e}")

    def _add_summary_table(self, ws, df):
        """Add summary table with image at the top of the worksheet"""
        from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
        
        # Calculate summary statistics
        total_rows = len(df) - 1  # Subtract TOTAL row
        if total_rows < 0:
            total_rows = 0
        
        # Try to get totals from the TOTAL row
        total_project_cost = 0
        total_pcb_cost = 0
        
        try:
            total_row = df.iloc[-1]  # Last row should be TOTAL
            if 'Total Project Price' in df.columns:
                total_project_str = str(total_row['Total Project Price']).replace(',', '')
                if total_project_str and total_project_str != 'TOTAL':
                    total_project_cost = float(total_project_str)
            
            if 'PCB Per Unit Price' in df.columns:
                total_pcb_str = str(total_row['PCB Per Unit Price']).replace(',', '')
                if total_pcb_str and total_pcb_str != 'TOTAL':
                    total_pcb_cost = float(total_pcb_str)
        except:
            pass
        
        currency = self.cmb_cur.currentText()
        pcb_qty = self.sp_pcb.value()
        
        # Title styling
        title_font = Font(size=16, bold=True, color="00962F")
        header_font = Font(size=12, bold=True, color="FFFFFF")
        value_font = Font(size=11)
        
        green_fill = PatternFill(start_color="00962F", end_color="00962F", fill_type="solid")
        light_green_fill = PatternFill(start_color="E8F5E8", end_color="E8F5E8", fill_type="solid")
        
        center_align = Alignment(horizontal="center", vertical="center")
        
        # Add title
        ws['A1'] = 'Sienna ECAD Technologies'
        ws['A1'].font = title_font
        ws['A1'].alignment = center_align
        ws.merge_cells('A1:F1')
        
        # Add summary table
        summary_start_row = 3
        
        # Summary headers
        summary_headers = [
            ('Metric', 'A'), ('Value', 'B'), ('', 'C'), 
            ('Metric', 'D'), ('Value', 'E'), ('Unit', 'F')
        ]
        
        for header, col in summary_headers:
            cell = ws[f'{col}{summary_start_row}']
            cell.value = header
            cell.font = header_font
            cell.fill = green_fill
            cell.alignment = center_align
        
        # Summary data
        summary_data = [
            ('Total Components', total_rows, '', 'PCB Quantity', pcb_qty, 'pcs'),
            ('Currency', currency, '', 'PCB Unit Cost', f'{total_pcb_cost:.2f}', currency),
            ('Project Total', f'{total_project_cost:.2f}', currency, 'Cost per PCB', f'{total_project_cost/pcb_qty if pcb_qty > 0 else 0:.2f}', f'{currency}/pcb'),
            ('Generated On', datetime.now().strftime('%Y-%m-%d %H:%M'), '', 'Exchange Rate', f'${1:.2f} = â‚¹{self.sp_rate.value():.2f}' if currency == 'INR' else 'N/A', ''),
        ]
        
        for row_idx, (metric1, value1, unit1, metric2, value2, unit2) in enumerate(summary_data, start=summary_start_row + 1):
            # Left side
            ws[f'A{row_idx}'].value = metric1
            ws[f'B{row_idx}'].value = value1
            ws[f'C{row_idx}'].value = unit1
            
            # Right side  
            ws[f'D{row_idx}'].value = metric2
            ws[f'E{row_idx}'].value = value2
            ws[f'F{row_idx}'].value = unit2
            
            # Style alternating rows
            fill = light_green_fill if row_idx % 2 == 0 else PatternFill()
            for col in ['A', 'B', 'C', 'D', 'E', 'F']:
                cell = ws[f'{col}{row_idx}']
                cell.fill = fill
                cell.alignment = center_align if col in ['B', 'E', 'F'] else Alignment(horizontal="left", vertical="center")

    def _style_table_headers(self, ws, header_row, num_cols):
        """Apply green background and white text to table headers"""
        from openpyxl.styles import Font, PatternFill, Alignment
        
        green_fill = PatternFill(start_color="00962F", end_color="00962F", fill_type="solid")
        white_font = Font(color="FFFFFF", bold=True, size=11)
        center_alignment = Alignment(horizontal="center", vertical="center")
        
        for col in range(1, num_cols + 1):
            cell = ws.cell(row=header_row, column=col)
            cell.fill = green_fill
            cell.font = white_font
            cell.alignment = center_alignment

    def _auto_adjust_columns(self, ws):
        """Auto-adjust column widths based on content - handles merged cells"""
        from openpyxl.cell import MergedCell
        
        # Get column letters and calculate max widths
        column_widths = {}
        
        for row in ws.iter_rows():
            for cell in row:
                # Skip merged cells
                if isinstance(cell, MergedCell):
                    continue
                    
                column_letter = cell.column_letter
                
                try:
                    # Calculate content length
                    content_length = len(str(cell.value)) if cell.value is not None else 0
                    
                    # Update max width for this column
                    if column_letter not in column_widths:
                        column_widths[column_letter] = content_length
                    else:
                        column_widths[column_letter] = max(column_widths[column_letter], content_length)
                        
                except Exception:
                    continue
        
        # Apply calculated widths
        for column_letter, max_length in column_widths.items():
            adjusted_width = min(max_length + 2, 50)  # Add padding, cap at 50
            ws.column_dimensions[column_letter].width = adjusted_width


    def on_export_details(self):
        """Export Component Details view to Excel with styling"""
        if self.tbl_details.rowCount() == 0:
            QMessageBox.warning(self, "Warning", "No details data to export")
            return

        path, _ = QFileDialog.getSaveFileName(self, "Save Details Excel", "", "Excel (*.xlsx)")
        if not path:
            return

        try:
            # Get data from details table
            headers = [self.tbl_details.horizontalHeaderItem(i).text() for i in range(self.tbl_details.columnCount())]
            data = []
            
            for r in range(self.tbl_details.rowCount()):
                row = []
                for c in range(self.tbl_details.columnCount()):
                    it = self.tbl_details.item(r, c)
                    row.append(it.text() if it else "")
                data.append(row)

            # Create DataFrame and export with custom styling
            df = pd.DataFrame(data, columns=headers)
            
            # Use openpyxl for custom styling
            from openpyxl import Workbook
            from openpyxl.styles import Font, PatternFill, Alignment
            from openpyxl.utils.dataframe import dataframe_to_rows
            
            wb = Workbook()
            ws = wb.active
            ws.title = "Component Details"
            
            # Add DataFrame to worksheet
            for r in dataframe_to_rows(df, index=False, header=True):
                ws.append(r)
            
            # Style headers - Green background, white text
            green_fill = PatternFill(start_color="00962F", end_color="00962F", fill_type="solid")
            white_font = Font(color="FFFFFF", bold=True, size=11)
            center_alignment = Alignment(horizontal="center", vertical="center")
            
            # Apply header styling to first row
            for col in range(1, len(headers) + 1):
                cell = ws.cell(row=1, column=col)
                cell.fill = green_fill
                cell.font = white_font
                cell.alignment = center_alignment
            
            # Auto-adjust column widths
            for column in ws.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 50)
                ws.column_dimensions[column_letter].width = adjusted_width
            
            wb.save(path)
            self.log_msg(f"Details exported: {path}")

        except Exception as e:
            QMessageBox.critical(self, "Export Error", str(e))
            self.log_msg(f"Details export failed: {e}")



def run_app():
    app = QApplication(sys.argv)
    
    # Apply dark green theme to the entire application
    apply_dark_green_theme(app)
    
    # Create and show the main window
    w = App()
    w.show()
    
    # Set window icon if desired
    w.setWindowIcon(w.style().standardIcon(w.style().StandardPixmap.SP_ComputerIcon))
    
    sys.exit(app.exec())

# Optional: still run if executing directly
if __name__ == "__main__":
    run_app()
