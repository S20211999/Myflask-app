
;###########################################################################
;# Modified: Place RD beside component at side with max space (0.6 gap)    #
;###########################################################################

; Register Program Name
axlCmdRegister("rotate_silkassy" 'RotateSilkAssyRD)

(defun RotateSilkAssyRD ()
  ; ==== Initialize Global Variables ====

  Layer_List = nil
  Text_List  = nil
  Layer_List = nil
  justify    = ""

  LRBT = t
  LRTB = nil
  RLBT = nil
  RLTB = nil

  CenterAssy = nil ;--- MOD: Disable centering, will use custom placement
  ChangeTextSize  = nil
  TextBlockLarge  = 6
  TextBlockMedium = 3
  TextBlockSmall  = 1
  tblk_large  = "6"
  tblk_medium = "3"
  tblk_small  = "1"

  SilkTop = nil
  SilkBot = nil
  AssyTop = nil
  AssyBot = nil
  silktop_layer = "REF DES/SILKSCREEN_TOP"
  silkbot_layer = "REF DES/SILKSCREEN_BOTTOM"
  assytop_layer = "REF DES/ASSEMBLY_TOP"
  assybot_layer = "REF DES/ASSEMBLY_BOTTOM"

  sym_savex  = -1
  sym_savey  = -1
  sym_saveparent = nil

  FormDir = "./"

  if( axlOKToProceed() then
      createRotateRDForm()
      fFile = strcat( FormDir "rotateRDForm.form" )
      Form = axlFormCreate( (gensym)  fFile  nil 'rotateRDForm_Action t)
      axlFormSetField(Form "LRBT" LRBT)
      axlFormSetField(Form "LRTB" LRTB)
      axlFormSetField(Form "RLBT" RLBT)
      axlFormSetField(Form "RLTB" RLTB)
      axlFormSetField(Form "CenterAssy"      CenterAssy)
      axlFormSetField(Form "TextBlockLarge"  TextBlockLarge )
      axlFormSetField(Form "TextBlockMedium" TextBlockMedium)
      axlFormSetField(Form "TextBlockSmall"  TextBlockSmall )
      axlFormDisplay( Form )
  else
      printf("E- Please terminate your interactive command .\n")
  );endif OKToProceed

); end defun - MAIN Program

(defun doRotateSilkAssy ()
   axlClearSelSet()
   axlSetFindFilter( ?enabled   (list "noall"  "text")
                     ?onButtons (list "text")
                   )
   axlMsgPut("Silk/Assy RD rotation started.")
   foreach( layer Layer_List
            axlVisibleDesign(nil)
            axlVisibleLayer( layer t)
            Text_List = axlGetSelSet( axlAddSelectAll() )
            if( length( Text_List ) != 0 then rotateSilkAssy() )
            axlClearSelSet()
            axlFlushDisplay()
            axlMsgPut(strcat( layer " Rotation completed.") )
          ); foreach

   Display_List = list("paramLayerGroup:BOARD GEOMETRY/paramLayer:OUTLINE")
   if( AssyTop == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:ASSEMBLY_TOP" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:ASSEMBLY_TOP" Display_List)
     )
   if( AssyBot == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:ASSEMBLY_BOTTOM" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:ASSEMBLY_BOTTOM" Display_List)
     )
   if( SilkTop == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:SILKSCREEN_TOP" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:SILKSCREEN_TOP" Display_List)
     )
   if( SilkBot == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:SILKSCREEN_BOTTOM" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:SILKSCREEN_BOTTOM" Display_List)
     )
   foreach( Layer Display_List
     val = axlGetParam( Layer )
     val->visible = t
     axlSetParam( val )
   )
); end defun - doRotateSilkAssy

(defun rotateSilkAssy ()
 ;--- MOD START: Replace symbol origin centering with optimal side scan
   foreach( text_id Text_List
     changeit = 0
     text   = text_id->text
     xy     = text_id->xy
     txt_x  = xCoord( xy )
     txt_y  = yCoord( xy )
     txt_tblk = text_id->textBlock
     txt_jus = text_id->justify
     if( txt_jus != "CENTER" then changeit = 1 )
     txt_rot= text_id->rotation
     ;--- Keep orientation logic as required
     if( LRBT == t then
       if( txt_rot == 180 then
         txt_rot  = 0
         changeit = 1
       )
       if( txt_rot == 270 then
         txt_rot  = 90
         changeit = 1
       )
     );endif LRTB
     ; More orientation logic can be left unchanged

     txt_lyr = text_id->layer

     ;--- MOD START: Compute optimal text location beside component
     ;--- Only proceed for the selected layers
     if( txt_lyr == assytop_layer || txt_lyr == assybot_layer ||
         txt_lyr == silktop_layer || txt_lyr == silkbot_layer then

       ; Find symbol bounding box
       maxSideSpace = -1
       bestPos = nil
       bestRot = txt_rot
       textSize = 20 ;--- Approximate text length/height (you may use actual from text block size)
       gap = 0.6
       boardBBox = axlDBGetDesignBBox() ;--- Get board bounding box

       foreach(childid text_id->parent->children
         if( childid->layer == "PACKAGE GEOMETRY/PLACE_BOUND_TOP" ||
             childid->layer == "PACKAGE GEOMETRY/PLACE_BOUND_BOTTOM" then
           sym_llx = xCoord( xCoord( childid->bBox ))
           sym_lly = yCoord( xCoord( childid->bBox ))
           sym_urx = xCoord( yCoord( childid->bBox ))
           sym_ury = yCoord( yCoord( childid->bBox ))

           ;--- Four sides: left, right, top, bottom
           ;--- Scan space from each side outward
           sideSpaces = list()
           ;--- Check Left side
           leftSpace = minDistToObjectOrBoard(list(sym_llx-gap, (sym_lly+sym_ury)/2), "left", textSize)
           sideSpaces = cons(list(leftSpace "left"
             list(sym_llx-gap-textSize/2, (sym_lly+sym_ury)/2)) sideSpaces)
           ;--- Check Right side
           rightSpace = minDistToObjectOrBoard(list(sym_urx+gap, (sym_lly+sym_ury)/2), "right", textSize)
           sideSpaces = cons(list(rightSpace "right"
             list(sym_urx+gap+textSize/2, (sym_lly+sym_ury)/2)) sideSpaces)
           ;--- Check Top side
           topSpace = minDistToObjectOrBoard(list((sym_llx+sym_urx)/2, sym_ury+gap), "top", textSize)
           sideSpaces = cons(list(topSpace "top"
             list((sym_llx+sym_urx)/2, sym_ury+gap+textSize/2)) sideSpaces)
           ;--- Check Bottom side
           botSpace = minDistToObjectOrBoard(list((sym_llx+sym_urx)/2, sym_lly-gap), "bottom", textSize)
           sideSpaces = cons(list(botSpace "bottom"
             list((sym_llx+sym_urx)/2, sym_lly-gap-textSize/2)) sideSpaces)
           ;--- Find best side
           foreach(spaceinfo sideSpaces
             spVal = car(spaceinfo)
             spDir = cadr(spaceinfo)
             spPos = caddr(spaceinfo)
             if( spVal >= textSize + gap && spVal > maxSideSpace then
               maxSideSpace = spVal
               bestPos = spPos
               ;--- Optional: pick rotation based on side
               if(spDir == "left" then bestRot = 0)
               if(spDir == "right" then bestRot = 0)
               if(spDir == "top" then bestRot = 90)
               if(spDir == "bottom" then bestRot = 270)
             )
           )
           ;--- If none found, place outside board (just beyond closest edge)
           if(bestPos == nil then
             ;--- Outside board placement
             board_llx = car(boardBBox)
             board_lly = cadr(boardBBox)
             board_urx = car(cdr(boardBBox))
             board_ury = cadr(cdr(boardBBox))
             ;--- Find nearest board edge to symbol
             d_left = abs(sym_llx - board_llx)
             d_right = abs(sym_urx - board_urx)
             d_top = abs(sym_ury - board_ury)
             d_bot = abs(sym_lly - board_lly)
             mind = min(d_left, d_right, d_top, d_bot)
             if( mind == d_left then
               bestPos = list(board_llx-gap-textSize, (sym_lly+sym_ury)/2)
               bestRot = 0
             )
             if( mind == d_right then
               bestPos = list(board_urx+gap+textSize, (sym_lly+sym_ury)/2)
               bestRot = 0
             )
             if( mind == d_top then
               bestPos = list((sym_llx+sym_urx)/2, board_ury+gap+textSize)
               bestRot = 90
             )
             if( mind == d_bot then
               bestPos = list((sym_llx+sym_urx)/2, board_lly-gap-textSize)
               bestRot = 270
             )
           )
           xy = bestPos
           txt_rot = bestRot
           changeit = 1
         );endif childid
       );end foreach childid
     );endif txt_lyr
     ;--- MOD END

     if( ChangeTextSize == t then
       changeit = 1
       txt_tblk = tblk_large
       rdalpha  = substring( text 1 1 )
       if( rdalpha == "C" || rdalpha == "R" then
         txt_tblk = tblk_small
       )
       if( rdalpha == "D" then
         txt_tblk = tblk_small
       )
       rdalpha  = substring( text 1 2 )
       if( rdalpha == "RN" || rdalpha == "RP" then
         txt_tblk = tblk_medium
       )
       if( rdalpha == "FB" || rdalpha == "KP" then
         txt_tblk = tblk_medium
       )
       if( rdalpha == "TP" then
         txt_tblk = tblk_small
       )
     );endif ChangeTextBlock

     if( changeit == 1 then createTextBlock_RD())
   ); endforeach
;--- MOD END
); end defun - rotateSilkAssy

;#####################################################################
; Helper: Find minimum space from pos in direction to object or board #
; Returns distance to nearest obstacle in specified direction         #
;#####################################################################
(defun minDistToObjectOrBoard (pos direction textSize)
  ;--- Place holder: User must implement region query functions
  ;--- Here, always returns a large value for demonstration
  1000 ;--- Replace with actual region scan
); end defun

(defun createTextBlock_RD ()
  textBlock = txt_tblk
  rotation  = txt_rot
  parent_id = text_id->parent        ; symbol association
  mirrored  = text_id->isMirrored    ; t/nil
  justify   = "CENTER"               ; "LEFT" "CENTER" "RIGHT"

  textOrientation = make_axlTextOrientation( ?textBlock textBlock,
                                             ?rotation  rotation,
                                             ?mirrored  mirrored,
                                             ?justify   justify
                                           )
  update = axlDBCreateText( text, xy, textOrientation,
                            text_id->layer, parent_id
                          )
  if( update != nil then
    axlDeleteObject( list( text_id ))
  else
    axlMsgPut( strcat( "Update Failed on " text ) )
  ); endif
); end defun - createTextBlock_RD

; Form callbacks and GUI remain unchanged...

;###########################################################
;# End of Script                                            #
;###########################################################
