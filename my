
import sys
import re
import csv
import json
import math
import threading
from typing import Dict, Any, Optional, Tuple, List
from datetime import datetime
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QTableWidget, QTableWidgetItem, 
    QVBoxLayout, QHBoxLayout, QPushButton, QFileDialog, QLineEdit, QLabel, 
    QMessageBox, QTabWidget, QComboBox, QSpinBox, QColorDialog, QFontDialog,
    QMenuBar, QMenu, QToolBar, QStatusBar, QSplitter, QTextEdit, QCheckBox,
    QProgressBar, QDialog, QDialogButtonBox, QFormLayout, QListWidget,
    QGroupBox, QRadioButton, QSlider, QFrame
)
from PyQt6.QtCore import (
    Qt, QThread, pyqtSignal, QTimer, QMutex, QMutexLocker, QRect,
    QPropertyAnimation, QEasingCurve, QParallelAnimationGroup
)
from PyQt6.QtGui import (
    QFont, QColor, QPalette, QIcon, QPixmap, QPainter, QBrush, QPen,
    QAction, QKeySequence, QClipboard
)

class FormulaThread(QThread):
    """Multi-threaded formula evaluation engine"""
    resultReady = pyqtSignal(int, int, object)
    errorOccurred = pyqtSignal(int, int, str)
    
    def __init__(self, row: int, col: int, formula: str, table_data: Dict, parent=None):
        super().__init__(parent)
        self.row = row
        self.col = col
        self.formula = formula
        self.table_data = table_data
        self.mutex = QMutex()
        
    def run(self):
        """Execute formula calculation in separate thread"""
        try:
            with QMutexLocker(self.mutex):
                result = self.evaluate_formula(self.formula)
                self.resultReady.emit(self.row, self.col, result)
        except Exception as e:
            self.errorOccurred.emit(self.row, self.col, str(e))
    
    def evaluate_formula(self, formula: str):
        """Advanced formula evaluation with Excel-like functions"""
        if not formula.startswith('='):
            return formula
            
        expr = formula[1:].upper()
        
        # Handle cell references (A1, B2, etc.)
        expr = re.sub(r'([A-Z]+)([0-9]+)', self._replace_cell_ref, expr)
        
        # Handle range references (A1:B5)
        expr = re.sub(r'([A-Z]+[0-9]+):([A-Z]+[0-9]+)', self._handle_range, expr)
        
        # Handle Excel functions
        expr = self._handle_excel_functions(expr)
        
        # Safe evaluation
        allowed_names = {
            "__builtins__": {},
            "abs": abs, "round": round, "min": min, "max": max,
            "sum": sum, "len": len, "int": int, "float": float,
            "pow": pow, "sqrt": math.sqrt, "sin": math.sin, "cos": math.cos,
            "tan": math.tan, "log": math.log, "exp": math.exp
        }
        
        try:
            return eval(expr, allowed_names, {})
        except:
            raise ValueError(f"Invalid formula: {formula}")
    
    def _replace_cell_ref(self, match):
        """Convert cell reference to actual value"""
        col_str = match.group(1)
        row_str = match.group(2)
        
        col = self._col_str_to_num(col_str)
        row = int(row_str) - 1
        
        key = (row, col)
        if key in self.table_data:
            value = self.table_data[key]
            try:
                return str(float(value)) if value else '0'
            except ValueError:
                return f'"{value}"'
        return '0'
    
    def _col_str_to_num(self, col_str: str) -> int:
        """Convert column string (A, B, AA) to number"""
        col = 0
        for i, char in enumerate(reversed(col_str)):
            col += (ord(char) - ord('A') + 1) * (26 ** i)
        return col - 1
    
    def _handle_range(self, match):
        """Handle range operations like A1:B5"""
        start_ref = match.group(1)
        end_ref = match.group(2)
        # For now, return a simple range - could be expanded
        return f"range_func('{start_ref}', '{end_ref}')"
    
    def _handle_excel_functions(self, expr: str) -> str:
        """Handle Excel-like functions"""
        # SUM function
        expr = re.sub(r'SUM\(([^)]+)\)', r'sum([\1])', expr)
        # AVERAGE function  
        expr = re.sub(r'AVERAGE\(([^)]+)\)', r'(sum([\1])/len([\1]))', expr)
        # COUNT function
        expr = re.sub(r'COUNT\(([^)]+)\)', r'len([\1])', expr)
        
        return expr

class ExcelWorksheet(QTableWidget):
    """Individual worksheet with Excel-like functionality"""
    
    cellChanged = pyqtSignal(int, int, str)
    selectionChanged = pyqtSignal()
    
    def __init__(self, rows=1000, cols=50, parent=None):
        super().__init__(rows, cols, parent)
        self.setup_worksheet()
        self.formulas = {}
        self.formatting = {}
        self.undo_stack = []
        self.redo_stack = []
        
    def setup_worksheet(self):
        """Initialize worksheet appearance and behavior"""
        # Set headers
        col_headers = []
        for i in range(self.columnCount()):
            col_headers.append(self._num_to_col_str(i))
        self.setHorizontalHeaderLabels(col_headers)
        
        row_headers = [str(i + 1) for i in range(self.rowCount())]
        self.setVerticalHeaderLabels(row_headers)
        
        # Set default cell size
        self.setDefaultSectionSize(80)
        self.verticalHeader().setDefaultSectionSize(20)
        
        # Enable drag and drop, selection
        self.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectItems)
        self.setSelectionMode(QTableWidget.SelectionMode.ExtendedSelection)
        
        # Connect signals
        self.itemChanged.connect(self._on_item_changed)
        self.itemSelectionChanged.connect(self.selectionChanged.emit)
    
    def _num_to_col_str(self, num: int) -> str:
        """Convert column number to Excel-style letter"""
        result = ""
        while num >= 0:
            result = chr(num % 26 + ord('A')) + result
            num = num // 26 - 1
            if num < 0:
                break
        return result
    
    def _on_item_changed(self, item):
        """Handle cell content changes"""
        row, col = item.row(), item.column()
        self.cellChanged.emit(row, col, item.text())
    
    def set_cell_formula(self, row: int, col: int, formula: str):
        """Set formula for a cell"""
        self.formulas[(row, col)] = formula
        
    def get_cell_formula(self, row: int, col: int) -> Optional[str]:
        """Get formula for a cell"""
        return self.formulas.get((row, col))
    
    def set_cell_formatting(self, row: int, col: int, formatting: Dict):
        """Apply formatting to a cell"""
        self.formatting[(row, col)] = formatting
        item = self.item(row, col)
        if item:
            self._apply_formatting_to_item(item, formatting)
    
    def _apply_formatting_to_item(self, item: QTableWidgetItem, formatting: Dict):
        """Apply formatting dictionary to table item"""
        if 'font' in formatting:
            item.setFont(formatting['font'])
        if 'color' in formatting:
            item.setForeground(QBrush(formatting['color']))
        if 'background' in formatting:
            item.setBackground(QBrush(formatting['background']))
        if 'alignment' in formatting:
            item.setTextAlignment(formatting['alignment'])

class ChartDialog(QDialog):
    """Chart creation dialog"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Create Chart")
        self.setModal(True)
        self.resize(400, 300)
        
        layout = QVBoxLayout(self)
        
        # Chart type selection
        type_group = QGroupBox("Chart Type")
        type_layout = QVBoxLayout(type_group)
        
        self.chart_types = QComboBox()
        self.chart_types.addItems(["Line Chart", "Bar Chart", "Pie Chart", "Scatter Plot"])
        type_layout.addWidget(self.chart_types)
        
        layout.addWidget(type_group)
        
        # Data range
        range_group = QGroupBox("Data Range")
        range_layout = QFormLayout(range_group)
        
        self.range_input = QLineEdit()
        self.range_input.setPlaceholderText("e.g., A1:B10")
        range_layout.addRow("Range:", self.range_input)
        
        layout.addWidget(range_group)
        
        # Buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

class ExcelClone(QMainWindow):
    """Main Excel Clone Application"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("PyQt6 Multi-threaded Excel Clone")
        self.setGeometry(100, 100, 1200, 800)
        
        # Data structures
        self.worksheets = []
        self.current_worksheet_index = 0
        self.clipboard_data = []
        self.formula_threads = []
        
        # Setup UI
        self.setup_ui()
        self.setup_menus()
        self.setup_toolbars()
        self.setup_status_bar()
        
        # Create initial worksheet
        self.add_worksheet("Sheet1")
        
        # Setup auto-save timer
        self.auto_save_timer = QTimer()
        self.auto_save_timer.timeout.connect(self.auto_save)
        self.auto_save_timer.start(300000)  # Auto-save every 5 minutes
        
    def setup_ui(self):
        """Setup main user interface"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QVBoxLayout(central_widget)
        
        # Formula bar
        formula_layout = QHBoxLayout()
        formula_layout.addWidget(QLabel("Formula:"))
        
        self.cell_reference = QLabel("A1")
        self.cell_reference.setMinimumWidth(50)
        self.cell_reference.setStyleSheet("border: 1px solid gray; padding: 2px;")
        formula_layout.addWidget(self.cell_reference)
        
        self.formula_bar = QLineEdit()
        self.formula_bar.returnPressed.connect(self.apply_formula)
        formula_layout.addWidget(self.formula_bar)
        
        main_layout.addLayout(formula_layout)
        
        # Worksheet tabs
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.setMovable(True)
        self.tab_widget.currentChanged.connect(self.on_worksheet_changed)
        self.tab_widget.tabCloseRequested.connect(self.close_worksheet)
        
        main_layout.addWidget(self.tab_widget)
        
        # Add worksheet button
        add_sheet_btn = QPushButton("+ Add Sheet")
        add_sheet_btn.clicked.connect(lambda: self.add_worksheet(f"Sheet{len(self.worksheets) + 1}"))
        main_layout.addWidget(add_sheet_btn)
        
    def setup_menus(self):
        """Setup application menus"""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("File")
        
        new_action = QAction("New", self)
        new_action.setShortcut(QKeySequence.StandardKey.New)
        new_action.triggered.connect(self.new_workbook)
        file_menu.addAction(new_action)
        
        open_action = QAction("Open", self)
        open_action.setShortcut(QKeySequence.StandardKey.Open)
        open_action.triggered.connect(self.open_file)
        file_menu.addAction(open_action)
        
        save_action = QAction("Save", self)
        save_action.setShortcut(QKeySequence.StandardKey.Save)
        save_action.triggered.connect(self.save_file)
        file_menu.addAction(save_action)
        
        save_as_action = QAction("Save As", self)
        save_as_action.setShortcut(QKeySequence.StandardKey.SaveAs)
        save_as_action.triggered.connect(self.save_file_as)
        file_menu.addAction(save_as_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("Exit", self)
        exit_action.setShortcut(QKeySequence.StandardKey.Quit)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Edit menu
        edit_menu = menubar.addMenu("Edit")
        
        undo_action = QAction("Undo", self)
        undo_action.setShortcut(QKeySequence.StandardKey.Undo)
        undo_action.triggered.connect(self.undo)
        edit_menu.addAction(undo_action)
        
        redo_action = QAction("Redo", self)
        redo_action.setShortcut(QKeySequence.StandardKey.Redo)
        redo_action.triggered.connect(self.redo)
        edit_menu.addAction(redo_action)
        
        edit_menu.addSeparator()
        
        copy_action = QAction("Copy", self)
        copy_action.setShortcut(QKeySequence.StandardKey.Copy)
        copy_action.triggered.connect(self.copy_selection)
        edit_menu.addAction(copy_action)
        
        paste_action = QAction("Paste", self)
        paste_action.setShortcut(QKeySequence.StandardKey.Paste)
        paste_action.triggered.connect(self.paste_selection)
        edit_menu.addAction(paste_action)
        
        # Insert menu
        insert_menu = menubar.addMenu("Insert")
        
        chart_action = QAction("Chart", self)
        chart_action.triggered.connect(self.insert_chart)
        insert_menu.addAction(chart_action)
        
        # Format menu
        format_menu = menubar.addMenu("Format")
        
        font_action = QAction("Font", self)
        font_action.triggered.connect(self.format_font)
        format_menu.addAction(font_action)
        
        color_action = QAction("Cell Color", self)
        color_action.triggered.connect(self.format_cell_color)
        format_menu.addAction(color_action)
        
    def setup_toolbars(self):
        """Setup application toolbars"""
        # Main toolbar
        toolbar = self.addToolBar("Main")
        
        # File operations
        toolbar.addAction("New", self.new_workbook)
        toolbar.addAction("Open", self.open_file)
        toolbar.addAction("Save", self.save_file)
        toolbar.addSeparator()
        
        # Edit operations
        toolbar.addAction("Copy", self.copy_selection)
        toolbar.addAction("Paste", self.paste_selection)
        toolbar.addSeparator()
        
        # Formatting
        self.font_combo = QComboBox()
        self.font_combo.addItems(["Arial", "Times New Roman", "Calibri", "Helvetica"])
        self.font_combo.currentTextChanged.connect(self.change_font_family)
        toolbar.addWidget(self.font_combo)
        
        self.font_size = QSpinBox()
        self.font_size.setRange(6, 72)
        self.font_size.setValue(11)
        self.font_size.valueChanged.connect(self.change_font_size)
        toolbar.addWidget(self.font_size)
        
        toolbar.addAction("Bold", self.toggle_bold)
        toolbar.addAction("Italic", self.toggle_italic)
        
    def setup_status_bar(self):
        """Setup status bar"""
        self.status_bar = self.statusBar()
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.status_bar.addPermanentWidget(self.progress_bar)
        
        self.status_bar.showMessage("Ready")
        
    def add_worksheet(self, name: str):
        """Add a new worksheet"""
        worksheet = ExcelWorksheet()
        worksheet.cellChanged.connect(self.on_cell_changed)
        worksheet.selectionChanged.connect(self.on_selection_changed)
        
        self.worksheets.append(worksheet)
        self.tab_widget.addTab(worksheet, name)
        self.tab_widget.setCurrentWidget(worksheet)
        
    def close_worksheet(self, index: int):
        """Close a worksheet"""
        if len(self.worksheets) > 1:
            self.tab_widget.removeTab(index)
            del self.worksheets[index]
            
    def on_worksheet_changed(self, index: int):
        """Handle worksheet tab changes"""
        self.current_worksheet_index = index
        self.on_selection_changed()
        
    def on_cell_changed(self, row: int, col: int, value: str):
        """Handle cell content changes"""
        worksheet = self.get_current_worksheet()
        if value.startswith('='):
            # Formula - evaluate in separate thread
            self.evaluate_formula_threaded(row, col, value)
        
    def on_selection_changed(self):
        """Handle selection changes"""
        worksheet = self.get_current_worksheet()
        if worksheet:
            current = worksheet.currentItem()
            if current:
                row, col = current.row(), current.column()
                cell_ref = f"{worksheet._num_to_col_str(col)}{row + 1}"
                self.cell_reference.setText(cell_ref)
                
                # Update formula bar
                formula = worksheet.get_cell_formula(row, col)
                if formula:
                    self.formula_bar.setText(formula)
                else:
                    self.formula_bar.setText(current.text() if current.text() else "")
    
    def get_current_worksheet(self) -> Optional[ExcelWorksheet]:
        """Get currently active worksheet"""
        if 0 <= self.current_worksheet_index < len(self.worksheets):
            return self.worksheets[self.current_worksheet_index]
        return None
        
    def evaluate_formula_threaded(self, row: int, col: int, formula: str):
        """Evaluate formula in separate thread"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        # Collect current table data
        table_data = {}
        for r in range(worksheet.rowCount()):
            for c in range(worksheet.columnCount()):
                item = worksheet.item(r, c)
                if item and item.text():
                    table_data[(r, c)] = item.text()
        
        # Create and start formula thread
        thread = FormulaThread(row, col, formula, table_data, self)
        thread.resultReady.connect(self.on_formula_result)
        thread.errorOccurred.connect(self.on_formula_error)
        thread.start()
        
        self.formula_threads.append(thread)
        
    def on_formula_result(self, row: int, col: int, result):
        """Handle formula calculation result"""
        worksheet = self.get_current_worksheet()
        if worksheet:
            item = QTableWidgetItem(str(result))
            worksheet.setItem(row, col, item)
            
    def on_formula_error(self, row: int, col: int, error: str):
        """Handle formula calculation error"""
        worksheet = self.get_current_worksheet()
        if worksheet:
            item = QTableWidgetItem(f"#ERROR: {error}")
            worksheet.setItem(row, col, item)
            
    def apply_formula(self):
        """Apply formula from formula bar"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if not current:
            return
            
        formula = self.formula_bar.text()
        row, col = current.row(), current.column()
        
        if formula.startswith('='):
            worksheet.set_cell_formula(row, col, formula)
            self.evaluate_formula_threaded(row, col, formula)
        else:
            worksheet.set_cell_formula(row, col, None)
            current.setText(formula)
    
    # File operations
    def new_workbook(self):
        """Create new workbook"""
        reply = QMessageBox.question(self, "New Workbook", 
                                   "Create new workbook? Unsaved changes will be lost.",
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            self.tab_widget.clear()
            self.worksheets.clear()
            self.add_worksheet("Sheet1")
            
    def open_file(self):
        """Open file dialog and load file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", 
            "Excel Files (*.xlsx *.xls);;CSV Files (*.csv);;All Files (*)"
        )
        if file_path:
            self.load_file(file_path)
            
    def save_file(self):
        """Save current workbook"""
        # For demo, save as CSV
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save File", "", "CSV Files (*.csv);;All Files (*)"
        )
        if file_path:
            self.save_to_csv(file_path)
            
    def save_file_as(self):
        """Save as dialog"""
        self.save_file()
        
    def load_file(self, file_path: str):
        """Load file from path"""
        try:
            if file_path.endswith('.csv'):
                self.load_from_csv(file_path)
            else:
                QMessageBox.information(self, "Info", "Only CSV files supported in this demo")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load file: {str(e)}")
            
    def load_from_csv(self, file_path: str):
        """Load CSV file"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        with open(file_path, 'r', newline='', encoding='utf-8') as file:
            csv_reader = csv.reader(file)
            for row_idx, row_data in enumerate(csv_reader):
                for col_idx, cell_data in enumerate(row_data):
                    item = QTableWidgetItem(str(cell_data))
                    worksheet.setItem(row_idx, col_idx, item)
                    
        self.status_bar.showMessage(f"Loaded {file_path}")
        
    def save_to_csv(self, file_path: str):
        """Save to CSV file"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        with open(file_path, 'w', newline='', encoding='utf-8') as file:
            csv_writer = csv.writer(file)
            for row in range(worksheet.rowCount()):
                row_data = []
                empty_row = True
                for col in range(worksheet.columnCount()):
                    item = worksheet.item(row, col)
                    cell_value = item.text() if item else ""
                    row_data.append(cell_value)
                    if cell_value:
                        empty_row = False
                if not empty_row:
                    csv_writer.writerow(row_data)
                else:
                    break
                    
        self.status_bar.showMessage(f"Saved {file_path}")
        
    def auto_save(self):
        """Auto-save functionality"""
        # Implementation for auto-save
        pass
        
    # Edit operations
    def undo(self):
        """Undo last operation"""
        worksheet = self.get_current_worksheet()
        if worksheet and worksheet.undo_stack:
            # Implementation for undo
            pass
            
    def redo(self):
        """Redo last undone operation"""
        worksheet = self.get_current_worksheet()
        if worksheet and worksheet.redo_stack:
            # Implementation for redo
            pass
            
    def copy_selection(self):
        """Copy selected cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        selected_ranges = worksheet.selectedRanges()
        if not selected_ranges:
            return
            
        # For simplicity, copy first range
        range_item = selected_ranges[0]
        self.clipboard_data = []
        
        for row in range(range_item.topRow(), range_item.bottomRow() + 1):
            row_data = []
            for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                item = worksheet.item(row, col)
                row_data.append(item.text() if item else "")
            self.clipboard_data.append(row_data)
            
        # Also copy to system clipboard
        clipboard_text = '\n'.join(['\t'.join(row) for row in self.clipboard_data])
        QApplication.clipboard().setText(clipboard_text)
        
    def paste_selection(self):
        """Paste copied cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet or not self.clipboard_data:
            return
            
        current = worksheet.currentItem()
        if not current:
            return
            
        start_row, start_col = current.row(), current.column()
        
        for row_offset, row_data in enumerate(self.clipboard_data):
            for col_offset, cell_data in enumerate(row_data):
                target_row = start_row + row_offset
                target_col = start_col + col_offset
                
                if (target_row < worksheet.rowCount() and 
                    target_col < worksheet.columnCount()):
                    item = QTableWidgetItem(str(cell_data))
                    worksheet.setItem(target_row, target_col, item)
    
    # Formatting operations
    def format_font(self):
        """Open font dialog"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if not current:
            return
            
        font, ok = QFontDialog.getFont(current.font(), self)
        if ok:
            current.setFont(font)
            
    def format_cell_color(self):
        """Open color dialog for cell background"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        current = worksheet.currentItem()
        if not current:
            return
            
        color = QColorDialog.getColor(Qt.GlobalColor.white, self)
        if color.isValid():
            current.setBackground(QBrush(color))
            
    def change_font_family(self, font_family: str):
        """Change font family of selected cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        for item in worksheet.selectedItems():
            font = item.font()
            font.setFamily(font_family)
            item.setFont(font)
            
    def change_font_size(self, size: int):
        """Change font size of selected cells"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        for item in worksheet.selectedItems():
            font = item.font()
            font.setPointSize(size)
            item.setFont(font)
            
    def toggle_bold(self):
        """Toggle bold formatting"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        for item in worksheet.selectedItems():
            font = item.font()
            font.setBold(not font.bold())
            item.setFont(font)
            
    def toggle_italic(self):
        """Toggle italic formatting"""
        worksheet = self.get_current_worksheet()
        if not worksheet:
            return
            
        for item in worksheet.selectedItems():
            font = item.font()
            font.setItalic(not font.italic())
            item.setFont(font)
    
    # Chart operations
    def insert_chart(self):
        """Insert chart dialog"""
        dialog = ChartDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Chart creation would be implemented here
            QMessageBox.information(self, "Chart", "Chart creation feature would be implemented here")
    
    def closeEvent(self, event):
        """Handle application close"""
        # Clean up threads
        for thread in self.formula_threads:
            if thread.isRunning():
                thread.terminate()
                thread.wait()
        
        reply = QMessageBox.question(self, "Exit", "Save changes before closing?",
                                   QMessageBox.StandardButton.Save | 
                                   QMessageBox.StandardButton.Discard |
                                   QMessageBox.StandardButton.Cancel)
        
        if reply == QMessageBox.StandardButton.Save:
            self.save_file()
            event.accept()
        elif reply == QMessageBox.StandardButton.Discard:
            event.accept()
        else:
            event.ignore()

def main():
    """Main application entry point"""
    app = QApplication(sys.argv)
    app.setApplicationName("PyQt6 Excel Clone")
    app.setApplicationVersion("1.0")
    
    # Set application style
    app.setStyle('Fusion')
    
    # Create and show main window
    window = ExcelClone()
    window.show()
    
    # Start event loop
    sys.exit(app.exec())

if __name__ == '__main__':
    main()
