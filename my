;###########################################################################
;#                                                                         #
;#   Smart Reference Designator Placement on Silkscreen and Assembly      #
;#                                                                         #
;#  This routine places Silkscreen and Assembly Reference Designators     #
;#  beside components with intelligent space detection. It finds the      #
;#  side with maximum available space, maintains minimum clearances,      #
;#  and avoids overlapping components and vias.                           #
;#                                                                         #
;#  Features:                                                              #
;#  - Places text beside components, not on them                          #
;#  - Checks all sides for maximum available space                        #
;#  - Maintains 0.6 unit clearance from components                        #
;#  - Avoids overlapping vias when possible                               #
;#  - Places outside board boundary when no space available               #
;#  - User-configurable text size (default 0.81)                          #
;#                                                                         #
;#  Usage:  rotate_silkassy (from within Allegro)                          #
;###########################################################################

;##########################
;#  Register Program Name #
;##########################

axlCmdRegister("rotate_silkassy" 'RotateSilkAssyRD)

;#############################
;# MAIN Program Starts Here. #
;#############################

(defun RotateSilkAssyRD ()

  ; ==== Initialize Global Variables ====

  Layer_List = nil
  Text_List  = nil
  Layer_List = nil
  justify    = ""

  LRBT = t   ; Left to Right, Bottom to Top
  LRTB = nil ; Left to Right, Top to Bottom
  RLBT = nil ; Right to Left, Bottom to Top
  RLTB = nil ; Right to Left, Top to Bottom

  CenterAssy = nil  ; Changed to nil since we're placing beside components
  ChangeTextSize  = t  ; Enable text size changing
  TextBlockLarge  = 6
  TextBlockMedium = 3
  TextBlockSmall  = 1
  tblk_large  = "6"
  tblk_medium = "3"
  tblk_small  = "1"
  
  ; New variables for intelligent placement
  MinClearance = 0.6        ; Minimum clearance from components
  DefaultTextSize = 0.81    ; Default text size
  UserTextSize = 0.81       ; User-configurable text size
  AvoidVias = t             ; Try to avoid placing on vias
  PlaceOutsideBoard = t     ; Allow placement outside board if no space

  SilkTop = nil
  SilkBot = nil
  AssyTop = nil
  AssyBot = nil
  silktop_layer = "REF DES/SILKSCREEN_TOP"
  silkbot_layer = "REF DES/SILKSCREEN_BOTTOM"
  assytop_layer = "REF DES/ASSEMBLY_TOP"
  assybot_layer = "REF DES/ASSEMBLY_BOTTOM"
  
  sym_savex  = -1
  sym_savey  = -1
  sym_saveparent = nil

  FormDir = "./"

  if( axlOKToProceed() then
      
      ; ==== Create and Display the User Interface ====

      createRotateRDForm()
      fFile = strcat( FormDir "rotateRDForm.form" )
      Form = axlFormCreate( (gensym)  fFile  nil 'rotateRDForm_Action t)
      axlFormSetField(Form "LRBT" LRBT)
      axlFormSetField(Form "LRTB" LRTB)
      axlFormSetField(Form "RLBT" RLBT)
      axlFormSetField(Form "RLTB" RLTB)
      axlFormSetField(Form "CenterAssy"      CenterAssy)
      axlFormSetField(Form "TextBlockLarge"  TextBlockLarge )
      axlFormSetField(Form "TextBlockMedium" TextBlockMedium)
      axlFormSetField(Form "TextBlockSmall"  TextBlockSmall )
      axlFormSetField(Form "UserTextSize"    UserTextSize)
      axlFormSetField(Form "MinClearance"    MinClearance)
      axlFormSetField(Form "AvoidVias"       AvoidVias)
      axlFormDisplay( Form )
  else
      printf("E- Please terminate your interactive command .\n")
  );endif OKToProceed

); end defun - MAIN Program

;############################################################################
;# doRotateSilkAssy - When OK is hit, perform Reference Designator Rotation #
;#                   Do each layer separately to improve performance.       #
;############################################################################

(defun doRotateSilkAssy ()

   axlClearSelSet()
   axlSetFindFilter( ?enabled   (list "noall"  "text")
                     ?onButtons (list "text")
                   )
   axlMsgPut("Smart RD placement started.")
   
   ; Get board outline for boundary checking
   BoardOutline = getBoardOutline()
   
   foreach( layer Layer_List 
            axlVisibleDesign(nil)
            axlVisibleLayer( layer t)
            Text_List = axlGetSelSet( axlAddSelectAll() )
            if( length( Text_List ) != 0 then rotateSilkAssy() )
            axlClearSelSet()
            axlFlushDisplay()
            axlMsgPut(strcat( layer " Smart placement completed.") )
          ); foreach

; ==== Turn On Top/Bottom Silk & Assembly Layers, if they were changed. ====

   Display_List = list("paramLayerGroup:BOARD GEOMETRY/paramLayer:OUTLINE")
   if( AssyTop == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:ASSEMBLY_TOP" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:ASSEMBLY_TOP"          Display_List)
     )
   if( AssyBot == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:ASSEMBLY_BOTTOM" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:ASSEMBLY_BOTTOM"          Display_List)
     ) 
   if( SilkTop == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:SILKSCREEN_TOP"  Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:SILKSCREEN_TOP"           Display_List)
     )
   if( SilkBot == t then
       Display_List = cons("paramLayerGroup:PACKAGE GEOMETRY/paramLayer:SILKSCREEN_BOTTOM" Display_List)
       Display_List = cons("paramLayerGroup:REF DES/paramLayer:SILKSCREEN_BOTTOM"          Display_List)
     )
   foreach( Layer Display_List
            val = axlGetParam( Layer )
            val->visible = t
            axlSetParam( val )
          )

); end defun - doRotateSilkAssy

;######################################################################  
;# getBoardOutline - Get the board outline for boundary checking     #
;######################################################################  

(defun getBoardOutline ()
  let( (outlineList boardBBox)
    axlClearSelSet()
    axlSetFindFilter( ?enabled (list "noall" "shape")
                      ?onButtons (list "shape")
                      ?layerName (list "BOARD GEOMETRY/OUTLINE")
                    )
    outlineList = axlGetSelSet( axlAddSelectAll() )
    if( outlineList then
        boardBBox = car(outlineList)->bBox
      else
        ; If no outline found, return a large bounding box
        boardBBox = list(list(-10000 -10000) list(10000 10000))
      )
    axlClearSelSet()
    boardBBox
  )
)

;######################################################################  
;# findOptimalTextPosition - Find the best position for text placement#
;######################################################################  

(defun findOptimalTextPosition (componentBBox textWidth textHeight)
  let( (positions bestPos maxSpace currentSpace testX testY)
    positions = list()
    maxSpace = 0
    bestPos = nil
    
    ; Calculate component center and dimensions
    comp_llx = xCoord(car(componentBBox))
    comp_lly = yCoord(car(componentBBox))
    comp_urx = xCoord(cadr(componentBBox))
    comp_ury = yCoord(cadr(componentBBox))
    comp_width = comp_urx - comp_llx
    comp_height = comp_ury - comp_lly
    comp_centerX = (comp_urx + comp_llx) / 2
    comp_centerY = (comp_ury + comp_lly) / 2
    
    ; Test positions: Right, Left, Top, Bottom
    testPositions = list(
      ; Right side
      list((comp_urx + MinClearance + textWidth/2) comp_centerY "RIGHT")
      ; Left side  
      list((comp_llx - MinClearance - textWidth/2) comp_centerY "LEFT")
      ; Top side
      list(comp_centerX (comp_ury + MinClearance + textHeight/2) "TOP")
      ; Bottom side
      list(comp_centerX (comp_lly - MinClearance - textHeight/2) "BOTTOM")
    )
    
    foreach( testPos testPositions
      testX = car(testPos)
      testY = cadr(testPos)
      side = caddr(testPos)
      
      ; Calculate available space in this position
      currentSpace = calculateAvailableSpace(testX testY textWidth textHeight side)
      
      ; Check if this position is better
      if( currentSpace > maxSpace then
          maxSpace = currentSpace
          bestPos = list(testX testY side maxSpace)
        )
    )
    
    ; If no good position found, try outside board
    if( bestPos == nil || maxSpace < (textWidth * textHeight) then
        if( PlaceOutsideBoard == t then
            bestPos = findPositionOutsideBoard(componentBBox textWidth textHeight)
          )
      )
    
    bestPos
  )
)

;######################################################################  
;# calculateAvailableSpace - Calculate available space at position   #
;######################################################################  

(defun calculateAvailableSpace (testX testY textWidth textHeight side)
  let( (space conflictFound)
    space = textWidth * textHeight  ; Start with text area
    conflictFound = nil
    
    ; Create test bounding box for text
    textBBox = list(
      list((testX - textWidth/2) (testY - textHeight/2))
      list((testX + textWidth/2) (testY + textHeight/2))
    )
    
    ; Check for conflicts with other components
    conflictFound = checkComponentConflicts(textBBox)
    
    ; Check for conflicts with vias if avoiding them
    if( AvoidVias == t && conflictFound == nil then
        conflictFound = checkViaConflicts(textBBox)
      )
    
    ; If conflict found, reduce space significantly
    if( conflictFound == t then
        space = 0
      )
    
    space
  )
)

;######################################################################  
;# checkComponentConflicts - Check if text conflicts with components  #
;######################################################################  

(defun checkComponentConflicts (textBBox)
  let( (conflictFound componentList)
    conflictFound = nil
    
    ; Get all components in the area
    axlClearSelSet()
    axlSetFindFilter( ?enabled (list "noall" "symbol")
                      ?onButtons (list "symbol")
                    )
    componentList = axlGetSelSet( axlAddSelectAll() )
    
    foreach( comp componentList
      if( boundingBoxOverlap(textBBox comp->bBox MinClearance) then
          conflictFound = t
        )
    )
    
    axlClearSelSet()
    conflictFound
  )
)

;######################################################################  
;# checkViaConflicts - Check if text conflicts with vias             #
;######################################################################  

(defun checkViaConflicts (textBBox)
  let( (conflictFound viaList)
    conflictFound = nil
    
    ; Get all vias in the area
    axlClearSelSet()
    axlSetFindFilter( ?enabled (list "noall" "via")
                      ?onButtons (list "via")
                    )
    viaList = axlGetSelSet( axlAddSelectAll() )
    
    foreach( via viaList
      if( boundingBoxOverlap(textBBox via->bBox (MinClearance/2)) then
          conflictFound = t
        )
    )
    
    axlClearSelSet()
    conflictFound
  )
)

;######################################################################  
;# boundingBoxOverlap - Check if two bounding boxes overlap         #
;######################################################################  

(defun boundingBoxOverlap (bbox1 bbox2 clearance)
  let( (box1_llx box1_lly box1_urx box1_ury box2_llx box2_lly box2_urx box2_ury)
    box1_llx = xCoord(car(bbox1)) - clearance
    box1_lly = yCoord(car(bbox1)) - clearance
    box1_urx = xCoord(cadr(bbox1)) + clearance
    box1_ury = yCoord(cadr(bbox1)) + clearance
    
    box2_llx = xCoord(car(bbox2))
    box2_lly = yCoord(car(bbox2))
    box2_urx = xCoord(cadr(bbox2))
    box2_ury = yCoord(cadr(bbox2))
    
    ; Check if boxes don't overlap (return nil), otherwise they overlap (return t)
    !(box1_urx < box2_llx || box1_llx > box2_urx || box1_ury < box2_lly || box1_lly > box2_ury)
  )
)

;######################################################################  
;# findPositionOutsideBoard - Find position outside board boundary   #
;######################################################################  

(defun findPositionOutsideBoard (componentBBox textWidth textHeight)
  let( (comp_centerX comp_centerY boardCenter bestPos)
    comp_centerX = (xCoord(car(componentBBox)) + xCoord(cadr(componentBBox))) / 2
    comp_centerY = (yCoord(car(componentBBox)) + yCoord(cadr(componentBBox))) / 2
    
    ; Get board center
    if( BoardOutline then
        boardCenterX = (xCoord(car(BoardOutline)) + xCoord(cadr(BoardOutline))) / 2
        boardCenterY = (yCoord(car(BoardOutline)) + yCoord(cadr(BoardOutline))) / 2
        
        ; Place text outside board in direction away from board center
        if( comp_centerX > boardCenterX then
            ; Place to the right of board
            bestPos = list((xCoord(cadr(BoardOutline)) + textWidth/2 + MinClearance) comp_centerY "OUTSIDE_RIGHT" 1000)
          else
            ; Place to the left of board
            bestPos = list((xCoord(car(BoardOutline)) - textWidth/2 - MinClearance) comp_centerY "OUTSIDE_LEFT" 1000)
          )
      else
        ; No board outline found, place to the right of component
        bestPos = list((xCoord(cadr(componentBBox)) + textWidth/2 + MinClearance*2) comp_centerY "OUTSIDE_DEFAULT" 1000)
      )
    
    bestPos
  )
)

;######################################################################  
;# rotateSilkAssy - Smart placement of reference designators         #
;######################################################################  

(defun rotateSilkAssy ()
 
   foreach( text_id Text_List
            ; ==== retrieve current information on text id ====
          
        changeit = 0
        text   = text_id->text
        xy     = text_id->xy
        txt_x  = xCoord( xy )
        txt_y  = yCoord( xy )
        txt_tblk = text_id->textBlock

        ; ==== Change Text to "Center" Justification for ease of use ====
        txt_jus= text_id->justify
        if( txt_jus != "CENTER" then changeit = 1 )

        ; ==== Check current rotation against preferred orientation ====
        txt_rot= text_id->rotation
        if( LRBT == t then
            if( txt_rot == 180 then
                txt_rot  = 0
                changeit = 1
              )
            if( txt_rot == 270 then 
                txt_rot  = 90
                changeit = 1
              )
          );endif LRTB

        if( LRTB == t then
            if( txt_rot == 180 then 
                txt_rot  = 0
                changeit = 1
              )
            if( txt_rot == 90 then 
                txt_rot  = 270
                changeit = 1   
              )
          );endif LRBT

        if( RLBT == t then
            if( txt_rot == 180 then 
                txt_rot  = 0
                changeit = 1
              )
            if( txt_rot == 270 then 
                txt_rot  =  90
                changeit = 1
              )
          );endif RLBT

        if( RLTB == t then
            if( txt_rot == 180 then 
                txt_rot  = 0
                changeit = 1
              )
            if( txt_rot == 90 then 
                txt_rot  = 270
                changeit = 1
              )
          );endif RLTB

        ; ==== Smart Positioning Logic ====
        txt_lyr = text_id->layer
        if( txt_lyr == assytop_layer || txt_lyr == assybot_layer || txt_lyr == silktop_layer || txt_lyr == silkbot_layer then
            
            ; Get component bounding box
            componentBBox = text_id->parent->bBox
            
            ; Estimate text dimensions based on user text size
            textWidth = length(text) * UserTextSize * 0.7
            textHeight = UserTextSize * 1.2
            
            ; Find optimal position
            optimalPos = findOptimalTextPosition(componentBBox textWidth textHeight)
            
            if( optimalPos != nil then
                xy = list(car(optimalPos) cadr(optimalPos))
                changeit = 1
                
                ; Adjust rotation based on placement side
                placementSide = caddr(optimalPos)
                case( placementSide
                  ("LEFT"
                    if( txt_rot == 0 then txt_rot = 90 )
                    if( txt_rot == 180 then txt_rot = 270 )
                  )
                  ("RIGHT" 
                    if( txt_rot == 0 then txt_rot = 270 )
                    if( txt_rot == 180 then txt_rot = 90 )
                  )
                  ; TOP and BOTTOM keep horizontal orientation
                )
              )
            
            ; Apply user text size
            if( ChangeTextSize == t then 
                changeit = 1
                ; Convert user text size to appropriate text block
                if( UserTextSize >= 1.0 then
                    txt_tblk = tblk_large
                  else if( UserTextSize >= 0.6 then
                    txt_tblk = tblk_medium
                  else
                    txt_tblk = tblk_small
                  )
              )
          );endif txt_lyr

          ; ==== Do text movement, if anything has changed ==== 
          if( changeit == 1 then createTextBlock_RD())
      ); endforeach

); end defun - rotateSilkAssy

;####################################################################  
;# createTextBlock_RD - Create text record with smart positioning   #
;####################################################################  

(defun createTextBlock_RD ()

  textBlock = txt_tblk
  rotation  = txt_rot
  parent_id = text_id->parent        ; symbol association
  mirrored  = text_id->isMirrored    ; t/nil
  justify   = "CENTER"               ; "LEFT" "CENTER" "RIGHT"

  ; ==== setup defstruct for text insertion ====

  textOrientation = make_axlTextOrientation( ?textBlock textBlock,
                                             ?rotation  rotation,
                                             ?mirrored  mirrored,
                                             ?justify   justify
                                           )
  ; ==== Add new text and delete the existing text if successful ===
 
  update = axlDBCreateText( text, xy, textOrientation,
                            text_id->layer, parent_id
                          )
  if( update != nil then
      axlDeleteObject( list( text_id ))
  else
      axlMsgPut( strcat( "Update Failed on " text ) )
    ); endif

); end defun - createTextBlock_RD

 ;###########################################################
 ;# Form CallBacks - Handle user interface interactions    #
 ;###########################################################
 
(defun rotateRDForm_Action (Form)
 
   (case Form->curField
     ("SilkTop"
        SilkTop=Form->curValue
     ); end "SilkTop"

     ("SilkBot"
        SilkBot=Form->curValue
     ); end "SilkBot"

     ("AssyTop"
        AssyTop=Form->curValue
     ); end "AssyTop"

     ("AssyBot"
        AssyBot=Form->curValue
     ); end "AssyBot"

     ("LRBT"
        LRBT=Form->curValue
        orient_0   = t
        orient_90  = t
        orient_180 = nil
        orient_270 = nil
     ); end "LRTB"
 
     ("LRTB"
        LRTB=Form->curValue
        orient_0   = t
        orient_90  = nil
        orient_180 = nil
        orient_270 = t
     ); end "LRTB"

     ("RLBT"
        RLBT=Form->curValue
        orient_0   = nil
        orient_90  = t
        orient_180 = t
        orient_270 = nil
     ); end "LRTB"
 
     ("RLTB"
        RLTB=Form->curValue
        orient_0   = nil
        orient_90  = nil
        orient_180 = t
        orient_270 = t
     ); end "LRTB"

     ("CenterAssy"
        CenterAssy=Form->curValue
     ); end "CenterAssy"

     ("ChangeTextSize"
        ChangeTextSize=Form->curValue
     ); end "ChangeTextSize"

     ("TextBlockLarge"
        TextBlockLarge=Form->curValue
        sprintf( tblk_large "%L" TextBlockLarge )
     ); end "TextBlockLarge"

     ("TextBlockMedium"
        TextBlockMedium=Form->curValue
        sprintf( tblk_medium "%L" TextBlockMedium )
     ); end "TextBlockMedium"

     ("TextBlockSmall"
        TextBlockSmall=Form->curValue
        sprintf( tblk_small "%L" TextBlockSmall )
     ); end "TextBlockSmall"
     
     ("UserTextSize"
        UserTextSize=Form->curValue
     ); end "UserTextSize"

     ("MinClearance"
        MinClearance=Form->curValue
     ); end "MinClearance"

     ("AvoidVias"
        AvoidVias=Form->curValue
     ); end "AvoidVias"

     ("done"
        ; ==== cons puts the list together in reverse order
        if( AssyBot == t then Layer_List = cons( assybot_layer Layer_List ) )
        if( AssyTop == t then Layer_List = cons( assytop_layer Layer_List ) )
        if( SilkBot == t then Layer_List = cons( silkbot_layer Layer_List ) )
        if( SilkTop == t then Layer_List = cons( silktop_layer Layer_List ) )
        doRotateSilkAssy()
        (axlFormClose Form)
        (axlCancelEnterFun)
        deleteFile( fFile )
     ); end "done"

     ("cancel"
        (axlFormClose Form)
        (axlCancelEnterFun)
        deleteFile( fFile )
     ); end "cancel"

   ); end case
 
 ); end defun - rotateRDForm_Action

  ;###########################################################
  ;# createRotateRDForm - Enhanced User Interface Form      #
  ;###########################################################

(defun createRotateRDForm ()  

   fFile = strcat( FormDir "rotateRDForm.form" )
   Form  = outfile( fFile "w")
   fprintf(Form "FILE_TYPE=FORM_DEFN VERSION=2\n")
   fprintf(Form "FORM\n")
   fprintf(Form "FIXED\n")
   fprintf(Form "PORT 85 25\n")
   fprintf(Form "HEADER \"Smart Reference Designator Placement V3.0\"\n")
   fprintf(Form "TILE\n")
 
   fprintf(Form "GROUP \"Select Layers to Process\"\n")
   fprintf(Form "GLOC 2 1\n")
   fprintf(Form "GSIZE 80 4\n")
   fprintf(Form "ENDGROUP\n")

   fprintf(Form "FIELD \"SilkTop\"\n")
   fprintf(Form "FLOC 3 3 \n")
   fprintf(Form "CHECKLIST \"Silkscreen-Top\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"SilkBot\"\n")
   fprintf(Form "FLOC 20 3 \n")
   fprintf(Form "CHECKLIST \"Silkscreen-Bottom\" \n")
   fprintf(Form "ENDFIELD\n")
   
   fprintf(Form "FIELD \"AssyTop\"\n")
   fprintf(Form "FLOC 37 3 \n")
   fprintf(Form "CHECKLIST \"Assembly-Top\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"AssyBot\"\n")
   fprintf(Form "FLOC 54 3 \n")
   fprintf(Form "CHECKLIST \"Assembly-Bottom\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "GROUP \"RD Orientation\"\n")
   fprintf(Form "GLOC 2 5\n")
   fprintf(Form "GSIZE 32 13\n")
   fprintf(Form "ENDGROUP\n")

   fprintf(Form "GROUP \"Smart Placement Settings\"\n")
   fprintf(Form "GLOC 36 5\n")
   fprintf(Form "GSIZE 46 13\n")
   fprintf(Form "ENDGROUP\n")

   fprintf(Form "TEXT \"Horizontal           Vertical \"\n")
   fprintf(Form "TLOC 6 7 \n")
   fprintf(Form "ENDTEXT\n")

   fprintf(Form "FIELD \"LRBT\"\n")
   fprintf(Form "FLOC 3 9 \n")
   fprintf(Form "CHECKLIST \"Left to Right     Bottom to Top\" \"rotate_group\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"LRTB\"\n")
   fprintf(Form "FLOC 3 11 \n")
   fprintf(Form "CHECKLIST \"Left to Right     Top to Bottom\" \"rotate_group\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"RLBT\"\n")
   fprintf(Form "FLOC 3 13 \n")
   fprintf(Form "CHECKLIST \"Right to Left     Bottom to Top\" \"rotate_group\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"RLTB\"\n")
   fprintf(Form "FLOC 3 15 \n")
   fprintf(Form "CHECKLIST \"Right to Left     Top to Bottom\" \"rotate_group\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "TEXT \"Text Size: \"\n")
   fprintf(Form "TLOC 38 7 \n")
   fprintf(Form "ENDTEXT\n")

   fprintf(Form "FIELD \"UserTextSize\"\n")
   fprintf(Form "FLOC 48 7 \n")
   fprintf(Form "FLOATSLIDEBAR 6 3\n MIN 0.3\n MAX 2.0\n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "TEXT \"Min Clearance: \"\n")
   fprintf(Form "TLOC 38 9 \n")
   fprintf(Form "ENDTEXT\n")

   fprintf(Form "FIELD \"MinClearance\"\n")
   fprintf(Form "FLOC 52 9 \n")
   fprintf(Form "FLOATSLIDEBAR 6 3\n MIN 0.1\n MAX 2.0\n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"AvoidVias\"\n")
   fprintf(Form "FLOC 38 11 \n")
   fprintf(Form "CHECKLIST \"Avoid Placing Over Vias\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"CenterAssy\"\n")
   fprintf(Form "FLOC 38 13 \n")
   fprintf(Form "CHECKLIST \"Legacy Center Mode (Override Smart)\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"ChangeTextSize\"\n")
   fprintf(Form "FLOC 38 15 \n")
   fprintf(Form "CHECKLIST \"Apply Custom Text Sizing\" \n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "TEXT \"Large  Text Block: \"\n")
   fprintf(Form "TLOC 5 19 \n")
   fprintf(Form "ENDTEXT\n")

   fprintf(Form "TEXT \"Medium Text Block: \"\n")
   fprintf(Form "TLOC 5 20 \n")
   fprintf(Form "ENDTEXT\n")

   fprintf(Form "TEXT \"Small Text Block: \"\n")
   fprintf(Form "TLOC 5 21 \n")
   fprintf(Form "ENDTEXT\n")

   fprintf(Form "FIELD \"TextBlockLarge\"\n")
   fprintf(Form "FLOC 23 19 \n")
   fprintf(Form "INTSLIDEBAR 3 3\n MIN 1\n MAX 60\n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD \"TextBlockMedium\"\n")
   fprintf(Form "FLOC 23 20 \n")
   fprintf(Form "INTSLIDEBAR 3 3\n MIN 1\n MAX 60\n")
   fprintf(Form "ENDFIELD\n")
  
   fprintf(Form "FIELD \"TextBlockSmall\"\n")
   fprintf(Form "FLOC 23 21 \n")
   fprintf(Form "INTSLIDEBAR 3 3\n MIN 1\n MAX 60\n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD done\n")
   fprintf(Form "FLOC 35 23\n")
   fprintf(Form "MENUBUTTON \"Done\" 8 3\n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "FIELD cancel\n")
   fprintf(Form "FLOC 45 23\n")
   fprintf(Form "MENUBUTTON \"CANCEL\" 8 3\n")
   fprintf(Form "ENDFIELD\n")

   fprintf(Form "ENDTILE\n")
   fprintf(Form "ENDFORM\n")
   close(Form)
); end defun  - createRotateRDForm

