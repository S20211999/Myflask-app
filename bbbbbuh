# bom_costing_app.py

import sys, re, json, time, sqlite3, urllib.parse, math
from datetime import datetime
import requests
from bs4 import BeautifulSoup
import pandas as pd
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget, QToolBar,
    QFileDialog, QTableWidget, QTableWidgetItem, QComboBox, QLabel,
    QSpinBox, QDoubleSpinBox, QTextEdit, QMessageBox, QTabWidget, QProgressBar,
    QSplitter
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal
from PyQt6.QtGui import QColor, QAction, QFont, QPalette

USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
BASE_SEARCH = "https://www.findchips.com/search/"
BASE_DETAIL = "https://www.findchips.com/detail/{mpn}/{mfg}"

# Common MLCC/EIA size mapping for fallbacks and grouping
EIA_TO_MM = {
    "0201": (0.6, 0.3), "0402": (1.0, 0.5), "0603": (1.6, 0.8),
    "0805": (2.0, 1.25), "1206": (3.2, 1.6), "1210": (3.2, 2.5),
    "1812": (4.5, 3.2), "2010": (5.0, 2.5), "2512": (6.3, 3.2),
    "2920": (7.4, 5.0)
}

def apply_dark_green_theme(app):
    """Apply dark green theme to the entire application"""
    palette = QPalette()

    # Window background - Dark gray/black
    palette.setColor(QPalette.ColorRole.Window, QColor(25, 35, 25))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(0, 255, 100))  # Bright green text

    # Base background for input fields
    palette.setColor(QPalette.ColorRole.Base, QColor(35, 45, 35))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(45, 55, 45))

    # Text colors
    palette.setColor(QPalette.ColorRole.Text, QColor(0, 255, 100))

    # Button styling
    palette.setColor(QPalette.ColorRole.Button, QColor(35, 55, 35))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(0, 255, 100))

    # Highlight colors
    palette.setColor(QPalette.ColorRole.Highlight, QColor(0, 150, 50))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))

    # Links
    palette.setColor(QPalette.ColorRole.Link, QColor(100, 255, 150))

    # FIXED: Disabled elements - Use ColorGroup.Disabled, not ColorRole.Disabled
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.WindowText, QColor(100, 100, 100))
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.ButtonText, QColor(100, 100, 100))
    palette.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text, QColor(100, 100, 100))

    app.setPalette(palette)

    # Additional stylesheet for better appearance
    app.setStyleSheet("""
        QMainWindow {
            background-color: rgb(25, 35, 25);
            color: rgb(0, 255, 100);
        }
        
        QToolBar {
            background-color: rgb(35, 45, 35);
            border: 1px solid rgb(0, 150, 50);
            spacing: 3px;
        }
        
        QToolBar::separator {
            background-color: rgb(0, 150, 50);
            width: 2px;
            margin: 2px;
        }
        
        QPushButton, QToolButton {
            background-color: rgb(35, 55, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            padding: 5px 10px;
            font-weight: bold;
        }
        
        QPushButton:hover, QToolButton:hover {
            background-color: rgb(0, 150, 50);
            color: white;
        }
        
        QPushButton:pressed, QToolButton:pressed {
            background-color: rgb(0, 100, 30);
        }
        
        QComboBox {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 3px;
            padding: 2px 5px;
        }
        
        QComboBox::drop-down {
            border: none;
        }
        
        QComboBox::down-arrow {
            image: none;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid rgb(0, 255, 100);
        }
        
        QSpinBox, QDoubleSpinBox {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 3px;
            padding: 2px;
        }
        
        QLabel {
            color: rgb(0, 255, 100);
            font-weight: bold;
        }
        

        
        QTabBar::tab {
            background-color: rgb(35, 45, 35);
            color: rgb(0, 255, 100);
            border: 2px solid rgb(0, 150, 50);
            padding: 8px 15px;
            margin: 2px;
        }
        
        QTabBar::tab:selected {
            background-color: rgb(0, 150, 50);
            color: white;
        }
        
        QTabBar::tab:hover {
            background-color: rgb(0, 120, 40);
        }
        
        QProgressBar {
            background-color: rgb(35, 45, 35);
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            color: white;          
            text-align: center;
        }
        
        QProgressBar::chunk {
            background-color: rgb(0, 200, 50);
            border-radius: 3px;
        }
        
        QSplitter::handle {
            background-color: rgb(0, 150, 50);
        }
        
        QMessageBox {
            background-color: rgb(25, 35, 25);
            color: rgb(0, 255, 100);
        }
    """)

def norm_eia_code(text: str | None) -> str | None:
    if not text:
        return None
    cleaned = text.replace('-', '').replace('_', '')
    m = re.search(r'\b(0201|0402|0603|0805|1206|1210|1812|2010|2512|2920)\b', cleaned)
    return m.group(1) if m else None

def max_dim_mm_from_package_or_size(package_code: str | None, L: float | None, W: float | None) -> float | None:
    if package_code and package_code in EIA_TO_MM:
        l, w = EIA_TO_MM[package_code]
        return max(l, w)
    if L is not None and W is not None:
        return max(L, W)
    if L is not None:
        return L
    if W is not None:
        return W
    return None

def filter_search_results(mpn: str, search_results: list[dict]) -> list[dict]:
    """
    Filter search results based on exact vs partial matches:
    - If exact matches exist, return only exact matches
    - If no exact matches exist, return only the first partial match
    """
    exact_matches = []
    partial_matches = []
    mpn_lower = mpn.strip().lower()
    
    for result in search_results:
        result_mpn = result["mpn"].strip().lower()
        if result_mpn == mpn_lower:
            exact_matches.append(result)
        else:
            partial_matches.append(result)
    
    # Return exact matches if they exist, otherwise return only first partial match
    if exact_matches:
        return exact_matches
    elif partial_matches:
        return partial_matches[:1] # Only take the first partial match
    else:
        return []

class FindchipsClient:
    def __init__(self, timeout=15):
        self.s = requests.Session()
        self.s.headers.update({"User-Agent": USER_AGENT})
        self.timeout = timeout

    def get(self, url):
        return self.s.get(url, timeout=self.timeout)

    def search(self, mpn: str) -> list[dict]:
        """Extract only MPN and manufacturer from search page"""
        url = BASE_SEARCH + urllib.parse.quote(mpn)
        r = self.get(url)
        if r.status_code != 200:
            return []

        soup = BeautifulSoup(r.content, "html.parser")
        rows = soup.find_all("tr", class_="row")
        results = []

        for row in rows:
            try:
                mfg = (row.get("data-mfr") or row.get("data-manufacturer") or "").strip()
                result_mpn = (row.get("data-mfrpartnumber") or "").strip()
                if not mfg or not result_mpn:
                    continue

                # Only return MPN and manufacturer - no pricing/stock data
                results.append({
                    "mpn": result_mpn,
                    "manufacturer": mfg
                })
            except Exception:
                continue

        # Remove duplicates while preserving order
        seen = set()
        unique_results = []
        for item in results:
            key = (item["mpn"].lower(), item["manufacturer"].lower())
            if key not in seen:
                seen.add(key)
                unique_results.append(item)

        return unique_results

    def detail(self, mpn: str, manufacturer: str) -> dict:
        """Extract all data from detail page"""
        url = BASE_DETAIL.format(
            mpn=urllib.parse.quote(mpn),
            mfg=urllib.parse.quote(manufacturer.replace(' ', '-'))
        )
        r = self.get(url)
        if r.status_code != 200:
            return {}

        html = r.text
        meta = {
            "life_cycle_code": None,
            "package_code": None,
            "length_mm": None,
            "width_mm": None,
            "default_currency": None,
            "lead_time": None,
            "offers": []
        }

        # Extract metadata from JavaScript or meta tags
        dc = re.search(r'"defaultCurrency"\s*:\s*"([A-Z]{3})"', html)
        if dc:
            meta["default_currency"] = dc.group(1)

        # NEW: Parse HTML table for Part Data Attributes
        soup = BeautifulSoup(html, "html.parser")
        
        # Extract from Part Data Attributes table
        # Extract from Part Data Attributes table
        data_rows = soup.find_all("tr", class_="data-row")
        for row in data_rows:
            try:
                field_cell = row.find("td", class_="field-cell")
                main_cell = row.find("td", class_="main-part-cell")
                
                if field_cell and main_cell:
                    field_name = field_cell.get_text(strip=True)
                    field_value = main_cell.get_text(strip=True)
                    
                    # Extract specific fields
                    if field_name == "Part Life Cycle Code":
                        meta["life_cycle_code"] = field_value
                    elif field_name in ["Part Package Code", "Size Code", "Package Description"]:
                        # Try to normalize package code
                        normalized = norm_eia_code(field_value)
                        if normalized:
                            meta["package_code"] = normalized
                        else:
                            meta["package_code"] = field_value
                    elif field_name == "Factory Lead Time":
                        meta["lead_time"] = field_value
                    # NEW: Extract Length and Width
                    elif field_name in ["Length","Package Length"]:
                        # Extract numeric value from "14 mm"
                        length_match = re.search(r'(\d+(?:\.\d+)?)', field_value)
                        if length_match:
                            meta["length_mm"] = float(length_match.group(1))
                    elif field_name in ["Width","Package Width"]:
                        # Extract numeric value from "14 mm"
                        width_match = re.search(r'(\d+(?:\.\d+)?)', field_value)
                        if width_match:
                            meta["width_mm"] = float(width_match.group(1))
                            
            except Exception:
                continue


        # Try to extract dimensions from package description
        pkg_desc_rows = soup.find_all("tr", attrs={"data-field": "Package Description"})
        for row in pkg_desc_rows:
            try:
                desc_cell = row.find("td", class_="main-part-cell")
                if desc_cell:
                    desc_text = desc_cell.get_text(strip=True)
                    # Try to extract dimensions from package description
                    # Look for patterns like "1.6x0.8" or "1.6 x 0.8"
                    size_match = re.search(r'(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)', desc_text)
                    if size_match:
                        meta["length_mm"] = float(size_match.group(1))
                        meta["width_mm"] = float(size_match.group(2))
                    else:
                        # Try to extract standard package sizes (like 0805)
                        std_size = norm_eia_code(desc_text)
                        if std_size and std_size in EIA_TO_MM:
                            meta["package_code"] = std_size
                            l, w = EIA_TO_MM[std_size]
                            meta["length_mm"] = l
                            meta["width_mm"] = w
            except Exception:
                continue

        # Fallback: Try original JavaScript extraction methods
        if not meta["life_cycle_code"]:
            life = re.search(r'"lifeCycle(Code)?"\s*:\s*"([^"]+)"', html)
            if life:
                meta["life_cycle_code"] = life.group(2)

        if not meta["package_code"]:
            pkg = re.search(r'"sizeCode"\s*:\s*"([^"]+)"', html) or re.search(r'"package"\s*:\s*"([^"]+)"', html)
            if pkg:
                normalized = norm_eia_code(pkg.group(1))
                meta["package_code"] = normalized or pkg.group(1)

        # Continue with existing dimensions extraction if not found
        if not meta["length_mm"]:
            lmatch = re.search(r'"length"\s*:\s*([0-9.]+)\s*,\s*"unit"\s*:\s*"mm"', html)
            if lmatch:
                meta["length_mm"] = float(lmatch.group(1))
                
        if not meta["width_mm"]:
            wmatch = re.search(r'"width"\s*:\s*([0-9.]+)\s*,\s*"unit"\s*:\s*"mm"', html)
            if wmatch:
                meta["width_mm"] = float(wmatch.group(1))

        # Extract distributor offers from the FC.group JavaScript object
        group_match = re.search(r'FC\.group\s*=\s*\{[^}]*offers:\s*(\[.*?\])', html, re.DOTALL)
        if group_match:
            try:
                offers_json = group_match.group(1)
                # Clean up the JavaScript to make it valid JSON
                offers_json = re.sub(r'([{,]\s*)(\w+):', r'\1"\2":', offers_json) # Quote keys
                offers_json = re.sub(r"'([^']*)'", r'"\1"', offers_json) # Convert single quotes
                offers_data = json.loads(offers_json)

                for offer in offers_data:
                    distributor = offer.get("distributor", "").strip()
                    stock = int(offer.get("stock", 0) or 0)

                    # Extract price tiers
                    price_tiers = []
                    price_data = offer.get("price", [])
                    if isinstance(price_data, list):
                        for tier in price_data:
                            if isinstance(tier, list) and len(tier) >= 3:
                                try:
                                    qty = int(str(tier[0]).replace(",", ""))
                                    price = float(str(tier[2]).replace(",", ""))
                                    price_tiers.append({"quantity": qty, "price": price})
                                except (ValueError, IndexError):
                                    continue

                    if distributor and (price_tiers or stock > 0):
                        meta["offers"].append({
                            "distributor": distributor,
                            "stock": stock,
                            "currency": "USD",
                            "price_tiers": sorted(price_tiers, key=lambda x: x["quantity"]),
                            "lead_time": offer.get("leadTime") or meta.get("lead_time"),
                            "moq": min(tier["quantity"] for tier in price_tiers) if price_tiers else None
                        })
            except (json.JSONDecodeError, Exception):
                pass

        # Fallback: Parse HTML tables for distributor data
        if not meta["offers"]:
            price_stock_table = soup.find("table", class_="price-stock-table")
            if price_stock_table:
                for row in price_stock_table.find_all("tr", class_="price-stock-tr"):
                    try:
                        # Extract distributor name
                        dist_cell = row.find("td", class_="td-dis")
                        if not dist_cell:
                            continue
                        distributor = dist_cell.get_text(strip=True)

                        # Extract stock
                        stock_cell = row.find("td", class_="td-stock")
                        stock = 0
                        if stock_cell:
                            stock_text = stock_cell.get_text(strip=True)
                            stock_match = re.search(r'(\d[\d,]*)', stock_text)
                            if stock_match:
                                stock = int(stock_match.group(1).replace(",", ""))

                        # Extract lead time from description
                        desc_cell = row.find("td", class_="td-desc")
                        row_lead_time = None
                        if desc_cell:
                            desc_text = desc_cell.get_text()
                            lead_match = re.search(r'Lead time:\s*([^<\n]+)', desc_text)
                            if lead_match:
                                row_lead_time = lead_match.group(1).strip()

                        # Extract price tiers
                        price_tiers = []
                        price_cell = row.find("td", class_="td-price")
                        if price_cell:
                            price_items = price_cell.find_all("li", class_="price-item")
                            for item in price_items:
                                label = item.find("span", class_="label")
                                value = item.find("span", class_="value")
                                if label and value:
                                    try:
                                        qty_text = label.get_text(strip=True).replace(",", "")
                                        price_text = value.get_text(strip=True).replace("$", "").replace(",", "")
                                        qty = int(qty_text)
                                        price = float(price_text)
                                        price_tiers.append({"quantity": qty, "price": price})
                                    except (ValueError, AttributeError):
                                        continue

                        if distributor and (price_tiers or stock > 0):
                            meta["offers"].append({
                                "distributor": distributor,
                                "stock": stock,
                                "currency": "USD",
                                "price_tiers": sorted(price_tiers, key=lambda x: x["quantity"]),
                                "lead_time": row_lead_time or meta.get("lead_time"),
                                "moq": min(tier["quantity"] for tier in price_tiers) if price_tiers else None
                            })
                    except Exception:
                        continue

        return meta

class Database:
    def __init__(self, path="bom_costing.db"):
        self.path = path
        self._init()

    def _init(self):
        con = sqlite3.connect(self.path)
        cur = con.cursor()
        cur.execute("""
            CREATE TABLE IF NOT EXISTS component_data(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                mpn TEXT NOT NULL,
                distributor TEXT,
                manufacturer TEXT,
                price_tiers TEXT, -- JSON list of {quantity, price}
                stock INTEGER DEFAULT 0,
                currency TEXT DEFAULT 'USD',
                lead_time TEXT,
                life_cycle_code TEXT,
                package_code TEXT,
                length_mm REAL,
                width_mm REAL,
                default_currency TEXT,
                part_type TEXT, -- 'Precise Match' or 'Alternate Parts'
                scraped_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(mpn, distributor)
            )
        """)
        cur.execute("CREATE INDEX IF NOT EXISTS idx_component_mpn ON component_data(mpn)")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_component_dist ON component_data(distributor)")
        con.commit()
        con.close()

    def upsert_offer(
        self, mpn, distributor, manufacturer, price_tiers, stock, currency,
        lead_time=None, life_cycle_code=None, package_code=None,
        length_mm=None, width_mm=None, default_currency=None, part_type=None
    ):
        con = sqlite3.connect(self.path)
        cur = con.cursor()
        tiers_sorted = sorted(price_tiers or [], key=lambda x: x["quantity"])
        tiers_json = json.dumps(tiers_sorted)

        cur.execute("""
            INSERT INTO component_data(mpn, distributor, manufacturer, price_tiers, stock, currency,
                                     lead_time, life_cycle_code, package_code, length_mm, width_mm,
                                     default_currency, part_type, scraped_date)
            VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,CURRENT_TIMESTAMP)
            ON CONFLICT(mpn, distributor) DO UPDATE SET
                manufacturer=excluded.manufacturer,
                price_tiers=excluded.price_tiers,
                stock=MAX(component_data.stock, excluded.stock),
                currency=excluded.currency,
                lead_time=COALESCE(excluded.lead_time, component_data.lead_time),
                life_cycle_code=COALESCE(excluded.life_cycle_code, component_data.life_cycle_code),
                package_code=COALESCE(excluded.package_code, component_data.package_code),
                length_mm=COALESCE(excluded.length_mm, component_data.length_mm),
                width_mm=COALESCE(excluded.width_mm, component_data.width_mm),
                default_currency=COALESCE(excluded.default_currency, component_data.default_currency),
                part_type=COALESCE(excluded.part_type, component_data.part_type),
                scraped_date=CURRENT_TIMESTAMP
        """, (
            mpn, distributor, manufacturer, tiers_json, int(stock or 0), currency or "USD",
            lead_time, life_cycle_code, package_code, length_mm, width_mm, default_currency, part_type
        ))
        con.commit()
        con.close()

    def offers_by_mpn(self, mpn):
        con = sqlite3.connect(self.path)
        cur = con.cursor()
        cur.execute("""
            SELECT distributor, manufacturer, price_tiers, stock, currency,
                   lead_time, life_cycle_code, package_code, length_mm, width_mm,
                   default_currency, part_type
            FROM component_data WHERE mpn=?
            ORDER BY distributor
        """, (mpn,))
        rows = cur.fetchall()
        con.close()

        out = []
        for r in rows:
            dist, mfg, tiers_json, stock, curr, lead, life, pkg, L, W, defcur, ptype = r
            try:
                tiers = json.loads(tiers_json) if tiers_json else []
            except Exception:
                tiers = []

            out.append({
                "distributor": dist, "manufacturer": mfg, "price_tiers": tiers,
                "stock": stock or 0, "currency": curr or "USD", "lead_time": lead,
                "life_cycle_code": life, "package_code": pkg, "length_mm": L, "width_mm": W,
                "default_currency": defcur, "part_type": ptype
            })
        return out

    def part_meta(self, mpn):
        offers = self.offers_by_mpn(mpn)
        life = next((o["life_cycle_code"] for o in offers if o.get("life_cycle_code")), "")
        pkg = next((o["package_code"] for o in offers if o.get("package_code")), "")
        L = next((o["length_mm"] for o in offers if o.get("length_mm") is not None), None)
        W = next((o["width_mm"] for o in offers if o.get("width_mm") is not None), None)
        defcur = next((o["default_currency"] for o in offers if o.get("default_currency")), "USD")
        ptype = next((o["part_type"] for o in offers if o.get("part_type")), "")
        lead = next((o["lead_time"] for o in offers if o.get("lead_time")), "")
        return {
            "life": life, "package": pkg, "L": L, "W": W, 
            "default_currency": defcur, "part_type": ptype, "lead_time": lead
        }

class ScrapeThread(QThread):
    progress = pyqtSignal(int)
    log = pyqtSignal(str)
    done = pyqtSignal()

    def __init__(self, mpns, db: Database):
        super().__init__()
        self.mpns = mpns
        self.db = db
        self.client = FindchipsClient()

    def run(self):
        total = len(self.mpns)
        for i, mpn in enumerate(self.mpns):
            try:
                self.log.emit(f"Searching: {mpn}")
                # Step 1: Get manufacturers from search page
                search_results = self.client.search(mpn)
                if not search_results:
                    self.log.emit(f"No manufacturers found for {mpn}")
                    self.progress.emit(int((i + 1) * 100 / total))
                    time.sleep(0.3)
                    continue

                # Step 1.5: Filter search results - exact matches first, then max 1 partial match
                filtered_results = filter_search_results(mpn, search_results)
                if not filtered_results:
                    self.log.emit(f"No suitable matches found for {mpn}")
                    self.progress.emit(int((i + 1) * 100 / total))
                    time.sleep(0.3)
                    continue

                self.log.emit(f"Found {len(filtered_results)} suitable matches for {mpn}")

                # Step 2: For each filtered manufacturer, get detailed data from detail page
                for result in filtered_results:
                    result_mpn = result["mpn"]
                    manufacturer = result["manufacturer"]

                    # Determine if this is exact match or alternate
                    is_exact = result_mpn.strip().lower() == mpn.strip().lower()
                    part_type = "Precise Match" if is_exact else "Alternate Parts"

                    self.log.emit(f"Getting details: {result_mpn} / {manufacturer} ({'Exact' if is_exact else 'Partial'} match)")

                    # Get detailed data from detail page
                    detail_data = self.client.detail(result_mpn, manufacturer)

                    # Store offers from detail page
                    offers = detail_data.get("offers", [])
                    if not offers:
                        # If no offers, create a placeholder entry
                        offers = [{"distributor": "Unknown", "stock": 0, "price_tiers": [], "currency": "USD"}]

                    for offer in offers:
                        self.db.upsert_offer(
                            mpn=mpn, # Store under the searched MPN
                            distributor=offer.get("distributor", "Unknown"),
                            manufacturer=manufacturer,
                            price_tiers=offer.get("price_tiers", []),
                            stock=offer.get("stock", 0),
                            currency=offer.get("currency", "USD"),
                            lead_time=offer.get("lead_time"),
                            life_cycle_code=detail_data.get("life_cycle_code"),
                            package_code=detail_data.get("package_code"),
                            length_mm=detail_data.get("length_mm"),
                            width_mm=detail_data.get("width_mm"),
                            default_currency=detail_data.get("default_currency", "USD"),
                            part_type=part_type
                        )

                self.log.emit(f"Completed: {mpn} - processed {len(filtered_results)} manufacturers")

            except Exception as e:
                self.log.emit(f"Error processing {mpn}: {e}")

            self.progress.emit(int((i + 1) * 100 / total))
            time.sleep(0.3)

        self.done.emit()

def convert_price(price, src, dst, usd_to_inr):
    if src == dst:
        return price
    if src == "USD" and dst == "INR":
        return price * usd_to_inr
    if src == "INR" and dst == "USD" and usd_to_inr:
        return price / usd_to_inr
    return price

def select_tier_for_qty(tiers, required_qty):
    if not tiers:
        return None, None, None
    tiers = sorted(tiers, key=lambda x: x["quantity"])
    chosen = None
    next_t = None
    for t in tiers:
        if required_qty >= t["quantity"]:
            chosen = t
        elif required_qty < t["quantity"] and next_t is None:
            next_t = t
            break
    if chosen is None:
        chosen = tiers[0]
    moq = tiers[0]["quantity"]
    return chosen, next_t, moq

def choose_best_option(offers, total_required_qty, currency, usd_to_inr, package_code, L, W):
    """
    REVISED: Choose best option with distributor priority and corrected MOQ/Procure Qty logic
    Priority: 1st - Digikey, 2nd - Mouser, 3rd - Others
    MOQ = lowest available quantity tier
    Procure Qty = follows detailed buffer rules based on package and price
    """
    # Distributor priority list
    priority_list = ['Digikey', 'Mouser']

    # Group offers by distributor priority
    prioritized_offers = {d: [] for d in priority_list}
    others = []

    for off in offers:
        dist_lower = off.get('distributor', '').lower()
        matched = None
        for p in priority_list:
            if p.lower() in dist_lower:
                prioritized_offers[p].append(off)
                matched = p
                break
        if not matched:
            others.append(off)

    # Select offers to consider based on priority
    final_offers_to_consider = []
    for d in priority_list:
        if prioritized_offers[d]:
            final_offers_to_consider.extend(prioritized_offers[d])
            break
    else:
        final_offers_to_consider.extend(others)

    def pct_or_floor(trq, pct, floor_add):
        return max(int(math.ceil(trq * pct / 100)), floor_add)

    def calculate_procure_qty(trq, price_usd, pkg_code, max_dim):
        """Calculate procurement quantity based on detailed rules"""
        
        # Special case: price > $20 USD
        if price_usd > 20:
            return trq if trq < 250 else trq + 1
        
        is_low_price = price_usd < 1.0
        
        # Determine package group
        pkg_group = None
        if pkg_code in ['0201', '0402', '0603']:
            pkg_group = '0201-0603'
        elif pkg_code in ['0805', '1206', '1210']:
            pkg_group = '0805-1210'
        elif pkg_code in ['1812', '2010', '2512', '2920']:
            pkg_group = '1210-8060'
        
        if is_low_price:
            if pkg_group == '0201-0603':
                if trq < 100:
                    return trq + 50
                elif trq < 250:
                    return trq + 80
                elif trq < 500:
                    return trq + pct_or_floor(trq, 15, 80)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 8, 80)
                else:
                    return trq + pct_or_floor(trq, 5, 80)
                    
            elif pkg_group == '0805-1210':
                if trq < 100:
                    return trq + 25
                elif trq < 250:
                    return trq + 40
                elif trq < 500:
                    return trq + pct_or_floor(trq, 10, 40)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 7, 40)
                else:
                    return trq + pct_or_floor(trq, 3, 40)
                    
            elif pkg_group == '1210-8060':
                if trq < 100:
                    return trq + 12
                elif trq < 250:
                    return trq + 20
                elif trq < 500:
                    return trq + pct_or_floor(trq, 5, 20)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 3, 20)
                else:
                    return trq + pct_or_floor(trq, 2, 20)
            else:
                # Unknown package with size info
                if max_dim and max_dim < 5:
                    # Use 0805-1210 logic
                    if trq < 100:
                        return trq + 25
                    elif trq < 250:
                        return trq + 40
                    elif trq < 500:
                        return trq + pct_or_floor(trq, 10, 40)
                    elif trq < 1000:
                        return trq + pct_or_floor(trq, 7, 40)
                    else:
                        return trq + pct_or_floor(trq, 3, 40)
                else:
                    # Default fallback
                    return trq + (2 if trq < 250 else 3)
                    
        else: # High price (>= $1 USD)
            if pkg_group in ['0201-0603', '0805-1210']:
                if trq < 100:
                    return trq + 15
                elif trq < 250:
                    return trq + 20
                elif trq < 500:
                    return trq + pct_or_floor(trq, 4, 20)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 3, 20)
                else:
                    return trq + pct_or_floor(trq, 2, 20)
                    
            elif pkg_group == '1210-8060':
                if trq < 250:
                    return trq + 5
                elif trq < 500:
                    return trq + pct_or_floor(trq, 3, 5)
                elif trq < 1000:
                    return trq + pct_or_floor(trq, 2, 5)
                else:
                    return trq + pct_or_floor(trq, 1, 5)
            else:
                # Unknown package handling
                if max_dim and max_dim >= 5:
                    # Use 0201-1210 high price logic
                    if trq < 100:
                        return trq + 15
                    elif trq < 250:
                        return trq + 20
                    elif trq < 500:
                        return trq + pct_or_floor(trq, 4, 20)
                    elif trq < 1000:
                        return trq + pct_or_floor(trq, 3, 20)
                    else:
                        return trq + pct_or_floor(trq, 2, 20)
                elif max_dim and max_dim >= 5 and 10 <= price_usd <= 20:
                    # Special case
                    return trq + 1 if trq < 250 else trq + 1
                else:
                    return trq + (2 if trq < 250 else 3)
        
        return trq + 5  # Default fallback

    best = None
    for off in final_offers_to_consider:
        tiers = off.get("price_tiers") or []
        if not tiers:
            continue

        tiers_conv = []
        for t in tiers:
            price_converted = convert_price(t["price"], off.get("currency", "USD"), currency, usd_to_inr)
            tiers_conv.append({"quantity": int(t["quantity"]), "price": float(price_converted)})

        tiers_conv = sorted(tiers_conv, key=lambda x: x["quantity"])

        # MOQ = lowest available quantity tier
        moq = tiers_conv[0]["quantity"] if tiers_conv else 1

        # Find tier for total_required_qty
        chosen, next_t, _ = select_tier_for_qty(tiers_conv, total_required_qty)
        if not chosen:
            continue

        price_usd = convert_price(chosen["price"], currency, "USD", usd_to_inr)
        max_dim = max_dim_mm_from_package_or_size(package_code, L, W)
        
        # Calculate procurement quantity
        proc_qty = calculate_procure_qty(total_required_qty, price_usd, package_code, max_dim)
        
        # Find the tier for procurement quantity
        chosen_proc, next_proc, _ = select_tier_for_qty(tiers_conv, proc_qty)
        if not chosen_proc:
            chosen_proc = chosen

        # Calculate costs: current quantity vs next tier quantity
        cost_current = proc_qty * chosen_proc["price"]
        cost_next = float('inf')
        
        if next_proc:
            cost_next = next_proc["quantity"] * next_proc["price"]

        # Choose the lower cost option
        if cost_next < cost_current:
            final_procure_qty = next_proc["quantity"]
            final_unit_price = next_proc["price"]
            final_qty_tier = next_proc["quantity"]
            final_total_cost = cost_next
        else:
            final_procure_qty = proc_qty
            final_unit_price = chosen_proc["price"]
            final_qty_tier = chosen_proc["quantity"]
            final_total_cost = cost_current

        option = {
            "distributor": off["distributor"],
            "moq": moq,
            "qty_tier": final_qty_tier,
            "unit_price": final_unit_price,
            "procure_qty": final_procure_qty,
            "total_cost": final_total_cost,
            "stock": off.get("stock", 0)
        }

        if best is None or option["total_cost"] < best["total_cost"]:
            best = option

    return best

class App(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BOM Costing (Findchips) - Dark Green Theme")
        self.resize(1400, 850)
        self.db = Database()
        self.client = FindchipsClient()
        self.exchange = {"USD": 1.0, "INR": 87.0}
        self._manufacturer_overrides = {}
        self._package_overrides = {}
        self._build_ui()
        self._apply_white_backgrounds()  # Apply white backgrounds to specific widgets
        self.bom_df = None

    def _build_ui(self):
        tb = QToolBar(); self.addToolBar(tb)
        act_open = QAction("Upload BOM", self); act_open.triggered.connect(self.on_open); tb.addAction(act_open)
        tb.addSeparator()
        act_fetch = QAction("Fetch Data", self); act_fetch.triggered.connect(self.on_fetch); tb.addAction(act_fetch)
        tb.addSeparator()
        act_export = QAction("Export to Excel", self); act_export.triggered.connect(self.on_export); tb.addAction(act_export)

        top = QHBoxLayout()
        top.addWidget(QLabel("MPN Column:")); self.cmb_mpn = QComboBox(); top.addWidget(self.cmb_mpn)
        top.addWidget(QLabel("QTY Column:")); self.cmb_qty = QComboBox(); top.addWidget(self.cmb_qty)
        top.addWidget(QLabel("PCB Qty:")); self.sp_pcb = QSpinBox(); self.sp_pcb.setRange(1, 1000000); self.sp_pcb.setValue(1); top.addWidget(self.sp_pcb)
        top.addWidget(QLabel("Currency:")); self.cmb_cur = QComboBox(); self.cmb_cur.addItems(["USD", "INR"]); top.addWidget(self.cmb_cur)
        top.addWidget(QLabel("USD→INR:")); self.sp_rate = QDoubleSpinBox(); self.sp_rate.setRange(0.01, 1000.0); self.sp_rate.setDecimals(2); self.sp_rate.setValue(87.0); top.addWidget(self.sp_rate)

        topw = QWidget(); topw.setLayout(top)

        self.tabs = QTabWidget()
        self.tbl_results = QTableWidget()
        self.tbl_details = QTableWidget()
        self.tabs.addTab(self.tbl_results, "BOM Results")
        self.tabs.addTab(self.tbl_details, "Component Details")

        self.log = QTextEdit(); self.log.setReadOnly(True); self.log.setMaximumHeight(160)
        self.progress = QProgressBar(); self.progress.setVisible(False)

        spl = QSplitter(Qt.Orientation.Vertical)
        spl.addWidget(self.tabs); spl.addWidget(self.log); spl.setStretchFactor(0, 3); spl.setStretchFactor(1, 1)

        root = QVBoxLayout(); root.addWidget(topw); root.addWidget(self.progress); root.addWidget(spl)
        cw = QWidget(); cw.setLayout(root); self.setCentralWidget(cw)

        self.cmb_cur.currentTextChanged.connect(self.recalc_all)
        self.sp_rate.valueChanged.connect(self.recalc_all)
        self.sp_pcb.valueChanged.connect(self.recalc_all)
        self.tbl_results.itemChanged.connect(self._on_package_override_changed)

    def _apply_white_backgrounds(self):
        """Apply white backgrounds to log and table widgets for better readability"""
        white_style = """
            background-color: white;
            color: black;
            border: 2px solid rgb(0, 150, 50);
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        """
        
        table_style = """
            QTableWidget {
                background-color: white;
                color: black;
                border: 2px solid rgb(0, 150, 50);
                selection-background-color: rgb(0, 150, 50);
                selection-color: white;
            }
            QTableWidget::item {
                padding: 3px;
            }
            QTableWidget::item:selected {
                background-color: rgb(0, 150, 50);
                color: white;
            }
            /* Horizontal headers (column headers) - GREEN background, WHITE text */
            QHeaderView::section:horizontal {
                background-color: rgb(0, 150, 50);
                color: white;
                padding: 5px;
                border: 1px solid rgb(200, 200, 200);
                font-weight: bold;
                font-size: 11pt;
            }
            
            /* Vertical headers (row numbers) - WHITE background, BLACK text */
            QHeaderView::section:vertical {
                background-color: white;
                color: black;
                padding: 3px;
                border: 1px solid rgb(200, 200, 200);
                font-weight: bold;
            }
            
            /* Corner button (top-left corner) */
            QTableCornerButton::section {
                background-color: rgb(0, 150, 50);
                border: 1px solid rgb(200, 200, 200);
            }
        """
        
        self.log.setStyleSheet(white_style)
        self.tbl_results.setStyleSheet(table_style)
        self.tbl_details.setStyleSheet(table_style)

    def log_msg(self, m):
        self.log.append(f"[{datetime.now().strftime('%H:%M:%S')}] {m}")

    def on_open(self):
        path, _ = QFileDialog.getOpenFileName(self, "Open BOM", "", "Excel (*.xlsx *.xls);;CSV (*.csv)")
        if not path: return
        try:
            if path.lower().endswith(".csv"):
                self.bom_df = pd.read_csv(path)
            else:
                self.bom_df = pd.read_excel(path)
            self.cmb_mpn.clear(); self.cmb_qty.clear()
            cols = list(self.bom_df.columns)
            self.cmb_mpn.addItems(cols); self.cmb_qty.addItems(cols)
            self.show_bom(self.bom_df)
            self.populate_details_initial()
            self.log_msg(f"Loaded BOM with {len(self.bom_df)} rows")
        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))

    def show_bom(self, df):
        self.tbl_results.setRowCount(len(df))
        self.tbl_results.setColumnCount(len(df.columns))
        self.tbl_results.setHorizontalHeaderLabels(list(df.columns))
        for r in range(len(df)):
            for c in range(len(df.columns)):
                self.tbl_results.setItem(r, c, QTableWidgetItem(str(df.iloc[r, c])))

    def populate_details_initial(self):
        if self.bom_df is None: return
        self.tbl_details.setRowCount(len(self.bom_df))
        self.tbl_details.setColumnCount(len(self.bom_df.columns))
        self.tbl_details.setHorizontalHeaderLabels(list(self.bom_df.columns))
        for r in range(len(self.bom_df)):
            for c in range(len(self.bom_df.columns)):
                self.tbl_details.setItem(r, c, QTableWidgetItem(str(self.bom_df.iloc[r, c])))

    def on_fetch(self):
        if self.bom_df is None:
            QMessageBox.warning(self, "Warning", "Upload BOM first")
            return
        mpn_col = self.cmb_mpn.currentText()
        if not mpn_col:
            QMessageBox.warning(self, "Warning", "Select MPN column")
            return
        mpns = pd.Series(self.bom_df[mpn_col].dropna().astype(str).str.strip().unique()).tolist()
        if not mpns:
            QMessageBox.warning(self, "Warning", "No MPNs found")
            return

        self.progress.setVisible(True); self.progress.setValue(0)
        self.worker = ScrapeThread(mpns, self.db)
        self.worker.progress.connect(self.progress.setValue)
        self.worker.log.connect(self.log_msg)
        self.worker.done.connect(self.on_scrape_done)
        self.worker.start()

    def on_scrape_done(self):
        self.progress.setVisible(False)
        self.log_msg("Scraping completed")
        self.recalc_all()

    def recalc_all(self):
        if self.bom_df is None:
            return
        try:
            self.calc_bom_results()
            self.refresh_details_view()
        except Exception as e:
            self.log_msg(f"Recalc error: {e}")

    def refresh_details_view(self):
        if self.bom_df is None: return
        mpn_col = self.cmb_mpn.currentText() or self.bom_df.columns[0]
        df = self.bom_df.copy()

        add_cols = ["Manufacturer", "Part Type", "Life Cycle", "Package", "Size (L×W mm)", "Default Currency", "Lead Time"]
        for col in add_cols:
            df[col] = ""

        fixed_dists = ['Digikey', 'Mouser', 'Arrow', 'Avnet', 'Newark', 'RS Components', 'Element14']
        max_tiers = 5

        for d in fixed_dists:
            df[f"{d} Stock"] = ""
            for t in range(1, max_tiers + 1):
                df[f"{d} T{t} Qty"] = ""
                df[f"{d} T{t} Price"] = ""

        for idx, row in df.iterrows():
            mpn = str(row[mpn_col]).strip()
            if not mpn:
                continue

            offers = self.db.offers_by_mpn(mpn)
            manuf = sorted({o["manufacturer"] for o in offers if o.get("manufacturer")})
            meta = self.db.part_meta(mpn)

            df.at[idx, "Manufacturer"] = " | ".join(manuf) if manuf else ""
            df.at[idx, "Part Type"] = meta.get("part_type", "")
            df.at[idx, "Life Cycle"] = meta.get("life", "")
            df.at[idx, "Lead Time"] = meta.get("lead_time", "")
            pkg = meta.get("package") or ""
            L = meta.get("L"); W = meta.get("W")
            df.at[idx, "Package"] = pkg or ""
            if L is not None or W is not None:
                df.at[idx, "Size (L×W mm)"] = f"{(L or '')}×{(W or '')}"
            df.at[idx, "Default Currency"] = meta.get("default_currency", "USD")

            for o in offers:
                dname_raw = o["distributor"] or ""
                matched = next((d for d in fixed_dists if d.lower() in dname_raw.lower()), None)
                if not matched:
                    continue

                df.at[idx, f"{matched} Stock"] = str(o.get("stock", 0))
                tiers = sorted(o.get("price_tiers") or [], key=lambda x: x["quantity"])
                for ti, t in enumerate(tiers[:max_tiers], start=1):
                    df.at[idx, f"{matched} T{ti} Qty"] = str(t["quantity"])
                    df.at[idx, f"{matched} T{ti} Price"] = f"{t['price']:.6f}"

        self.tbl_details.setRowCount(len(df))
        self.tbl_details.setColumnCount(len(df.columns))
        self.tbl_details.setHorizontalHeaderLabels(list(df.columns))
        for r in range(len(df)):
            for c in range(len(df.columns)):
                self.tbl_details.setItem(r, c, QTableWidgetItem(str(df.iloc[r, c])))

    def calc_bom_results(self):
        mpn_col = self.cmb_mpn.currentText()
        qty_col = self.cmb_qty.currentText()
        if not mpn_col or not qty_col:
            return

        df = self.bom_df.copy()

        # Remove Package Override column - using Package column directly
        result_cols = [
            "Part Type", "MPN", "Manufacturer", "Part Life Cycle Code", "Package", 
            "Size (L×W mm)", "Lead Time", "In Stock", "MOQ", "Total Required Qty", 
            "Procure Qty", "Distributor", "Qty Tier", "Unit Price", "PCB Per Unit Price", "Total Project Price"
        ]

        for col in result_cols:
            df[col] = ""

        pcb_qty = int(self.sp_pcb.value())
        currency = self.cmb_cur.currentText()
        usd_to_inr = float(self.sp_rate.value())

        for idx, row in df.iterrows():
            mpn = str(row[mpn_col]).strip()
            if not mpn:
                continue

            bom_qty = float(row[qty_col]) if pd.notna(row[qty_col]) else 0.0
            total_required = int(bom_qty * pcb_qty)

            offers = self.db.offers_by_mpn(mpn)
            meta = self.db.part_meta(mpn)

            # NEW: Use package override if present, otherwise use original
            pkg_override = self._package_overrides.get(mpn)
            package_to_use = pkg_override if pkg_override else meta.get("package") or ""

            selected_manufacturer = self._manufacturer_overrides.get(mpn)
            if selected_manufacturer:
                offers = [o for o in offers if o.get("manufacturer") == selected_manufacturer]
                if offers:
                    life = next((o["life_cycle_code"] for o in offers if o.get("life_cycle_code")), "")
                    pkg = package_to_use  # Use override or original
                    L = next((o["length_mm"] for o in offers if o.get("length_mm") is not None), None)
                    W = next((o["width_mm"] for o in offers if o.get("width_mm") is not None), None)
                    defcur = next((o["default_currency"] for o in offers if o.get("default_currency")), "USD")
                    ptype = next((o["part_type"] for o in offers if o.get("part_type")), "")
                    lead = next((o["lead_time"] for o in offers if o.get("lead_time")), "")
                    meta = {"life": life, "package": pkg, "L": L, "W": W, "default_currency": defcur, "part_type": ptype, "lead_time": lead}
            else:
                # Update meta with override package
                meta_copy = dict(meta)
                meta_copy["package"] = package_to_use
                meta = meta_copy

            pkg_code = meta.get("package") or ""
            L = meta.get("L"); W = meta.get("W")

            offers_conv = []
            for o in offers:
                tiers = []
                for t in o.get("price_tiers") or []:
                    price_conv = convert_price(t["price"], o.get("currency", "USD"), currency, usd_to_inr)
                    tiers.append({"quantity": int(t["quantity"]), "price": float(price_conv)})

                offers_conv.append({
                    "distributor": o["distributor"], "price_tiers": sorted(tiers, key=lambda x: x["quantity"]),
                    "stock": o.get("stock", 0), "currency": currency
                })

            best = choose_best_option(offers_conv, total_required, currency, usd_to_inr, norm_eia_code(pkg_code), L, W)

            if best:
                df.at[idx, "In Stock"] = str(best.get("stock", 0))
                df.at[idx, "MOQ"] = str(best.get("moq", ""))
                df.at[idx, "Total Required Qty"] = str(total_required)
                df.at[idx, "Procure Qty"] = str(best.get("procure_qty", total_required))
                df.at[idx, "Distributor"] = best.get("distributor", "")
                df.at[idx, "Qty Tier"] = str(best.get("qty_tier", ""))
                df.at[idx, "Unit Price"] = f"{best.get('unit_price', 0):.6f}"
                df.at[idx, "PCB Per Unit Price"] = f"{float(best.get('unit_price', 0)) * bom_qty:.6f}"
                df.at[idx, "Total Project Price"] = f"{float(best.get('unit_price', 0)) * bom_qty * pcb_qty:.4f}"

            # Get original meta for other fields
            orig_meta = self.db.part_meta(mpn)
            df.at[idx, "Part Type"] = orig_meta.get("part_type", "")
            df.at[idx, "MPN"] = mpn
            df.at[idx, "Part Life Cycle Code"] = orig_meta.get("life", "")
            df.at[idx, "Package"] = package_to_use  # NEW: Show override or original package
            df.at[idx, "Lead Time"] = orig_meta.get("lead_time", "")
            
            if orig_meta.get("L") is not None or orig_meta.get("W") is not None:
                df.at[idx, "Size (L×W mm)"] = f"{(orig_meta.get('L') or '')}×{(orig_meta.get('W') or '')}"

            # Set manufacturer
            all_offers = self.db.offers_by_mpn(mpn)
            manufacturers = sorted({o["manufacturer"] for o in all_offers if o.get("manufacturer")})
            if manufacturers:
                df.at[idx, "Manufacturer"] = selected_manufacturer or manufacturers[0]

        sums_cols = ["PCB Per Unit Price", "Total Project Price"]
        totals = {}
        for c in sums_cols:
            vals = pd.to_numeric(df[c].replace("", 0), errors="coerce").fillna(0) if c in df.columns else pd.Series()
            totals[c] = vals.sum()

        self.tbl_results.setRowCount(len(df) + 1)
        self.tbl_results.setColumnCount(len(df.columns))
        self.tbl_results.setHorizontalHeaderLabels(list(df.columns))

        for r in range(len(df)):
            for c in range(len(df.columns)):
                col_name = df.columns[c]
                it = QTableWidgetItem(str(df.iloc[r, c]))
                
                if col_name == "In Stock":
                    try:
                        s = int(str(df.iloc[r, c]))
                    except Exception:
                        s = 0
                    if s == 0: it.setBackground(QColor(255, 200, 200))
                    elif s < 100: it.setBackground(QColor(255, 255, 200))
                    elif s < 1000: it.setBackground(QColor(255, 255, 150))
                    else: it.setBackground(QColor(200, 255, 200))
                    f = QFont(); f.setBold(True); it.setFont(f)
                
                # NEW: Make Package column editable
                elif col_name == "Package":
                    it.setFlags(it.flags() | Qt.ItemFlag.ItemIsEditable)
                    # Light green background to indicate it's editable
                    it.setBackground(QColor(240, 255, 240))

                self.tbl_results.setItem(r, c, it)

        # Add manufacturer dropdowns
        self._add_manufacturer_dropdowns(df)

        # Add totals row
        tr = len(df)
        for c in range(len(df.columns)):
            name = df.columns[c]
            if c == 0:
                tit = QTableWidgetItem("TOTAL")
            elif name in totals:
                tit = QTableWidgetItem(f"{totals[name]:.4f}")
            else:
                tit = QTableWidgetItem("")
            f = QFont(); f.setBold(True); tit.setFont(f); tit.setBackground(QColor(220, 220, 220))
            self.tbl_results.setItem(tr, c, tit)

    def _on_package_edit_changed(self, item):
        """Handle manual package edits in the Package column"""
        if not item:
            return
        
        # Check if changed column is Package
        col = item.column()
        header = self.tbl_results.horizontalHeaderItem(col).text() if self.tbl_results.horizontalHeaderItem(col) else ""
        if header != "Package":
            return

        # Get MPN of this row
        row = item.row()
        mpn_col_idx = None
        for c in range(self.tbl_results.columnCount()):
            h = self.tbl_results.horizontalHeaderItem(c)
            if h and h.text() == "MPN":
                mpn_col_idx = c
                break
        
        if mpn_col_idx is None:
            return

        mpn_item = self.tbl_results.item(row, mpn_col_idx)
        if not mpn_item:
            return

        mpn = mpn_item.text().strip()
        new_package = item.text().strip()
        
        # Get original package for comparison
        orig_meta = self.db.part_meta(mpn)
        original_package = orig_meta.get("package", "")

        # Store or remove override
        if new_package == "" or new_package == original_package:
            # User cleared or reverted to original - remove override
            if mpn in self._package_overrides:
                del self._package_overrides[mpn]
                self.log_msg(f"Package override removed for {mpn} (reverted to: '{original_package}')")
        else:
            # User entered new package - store override
            self._package_overrides[mpn] = new_package
            self.log_msg(f"Package override set for {mpn}: '{new_package}' (was: '{original_package}')")

        # Temporarily disconnect signal to avoid recursion during recalc
        self.tbl_results.itemChanged.disconnect(self._on_package_edit_changed)
        
        # Recalculate results with new package
        self.recalc_all()
        
        # Reconnect signal
        self.tbl_results.itemChanged.connect(self._on_package_edit_changed)


    def _add_manufacturer_dropdowns(self, df):
        """Add manufacturer dropdowns for MPNs with multiple manufacturers"""
        if "Manufacturer" not in df.columns or "MPN" not in df.columns:
            return
        
        manf_col_idx = list(df.columns).index("Manufacturer")
        mpn_col_idx = list(df.columns).index("MPN")
        
        for r in range(len(df)):
            mpn = str(df.iloc[r, mpn_col_idx]).strip()
            if not mpn:
                continue
            
            # Get all manufacturers for this MPN
            offers = self.db.offers_by_mpn(mpn)
            manufacturers = sorted({o["manufacturer"] for o in offers if o.get("manufacturer")})
            
            if len(manufacturers) <= 1:
                continue  # Single or no manufacturer, keep as text
            
            # Create dropdown for multiple manufacturers
            combo = QComboBox()
            combo.addItems(manufacturers)
            
            # Set current selection
            current_manf = self._manufacturer_overrides.get(mpn, manufacturers[0])
            combo.setCurrentText(current_manf)
            
            # Connect change event
            combo.currentTextChanged.connect(
                lambda selected_manf, mpn=mpn: self._on_manufacturer_changed(mpn, selected_manf)
            )
            
            # Set dropdown in table
            self.tbl_results.setCellWidget(r, manf_col_idx, combo)

    def _on_manufacturer_changed(self, mpn, selected_manufacturer):
        """Handle manufacturer dropdown change"""
        self._manufacturer_overrides[mpn] = selected_manufacturer
        self.log_msg(f"Manufacturer changed for {mpn}: {selected_manufacturer}")
        
        # Recalculate results with new manufacturer selection
        self.recalc_all()

    def _on_package_override_changed(self, item):
        """Handle manual package override changes"""
        if not item:
            return
        
        # Check if changed column is Package Override
        col = item.column()
        header = self.tbl_results.horizontalHeaderItem(col).text() if self.tbl_results.horizontalHeaderItem(col) else ""
        if header != "Package Override":
            return

        # Get MPN of this row
        row = item.row()
        mpn_col_idx = None
        for c in range(self.tbl_results.columnCount()):
            h = self.tbl_results.horizontalHeaderItem(c)
            if h and h.text() == "MPN":
                mpn_col_idx = c
                break
        
        if mpn_col_idx is None:
            return

        mpn_item = self.tbl_results.item(row, mpn_col_idx)
        if not mpn_item:
            return

        mpn = mpn_item.text().strip()
        new_override = item.text().strip()

        # Store or remove override
        if new_override == "":
            if mpn in self._package_overrides:
                del self._package_overrides[mpn]
                self.log_msg(f"Package override removed for {mpn}")
        else:
            self._package_overrides[mpn] = new_override
            self.log_msg(f"Package override set for {mpn}: '{new_override}'")

        # Temporarily disconnect signal to avoid recursion
        self.tbl_results.itemChanged.disconnect(self._on_package_override_changed)
        
        # Recalculate results with new override
        self.recalc_all()
        
        # Reconnect signal
        self.tbl_results.itemChanged.connect(self._on_package_override_changed)


    def on_export(self):
        if self.tbl_results.rowCount() == 0:
            QMessageBox.warning(self, "Warning", "No data to export")
            return

        path, _ = QFileDialog.getSaveFileName(self, "Save Excel", "", "Excel (*.xlsx)")
        if not path: return

        headers = [self.tbl_results.horizontalHeaderItem(i).text() for i in range(self.tbl_results.columnCount())]
        data = []
        for r in range(self.tbl_results.rowCount()):
            row = []
            for c in range(self.tbl_results.columnCount()):
                it = self.tbl_results.item(r, c)
                row.append(it.text() if it else "")
            data.append(row)

        pd.DataFrame(data, columns=headers).to_excel(path, index=False)
        self.log_msg(f"Exported: {path}")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    # Apply dark green theme to the entire application
    apply_dark_green_theme(app)
    
    # Create and show the main window
    w = App()
    w.show()
    
    # Set window icon if desired
    w.setWindowIcon(w.style().standardIcon(w.style().StandardPixmap.SP_ComputerIcon))
    
    sys.exit(app.exec())
