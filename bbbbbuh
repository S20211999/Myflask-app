
def _update_package_in_database(self, mpn, new_package):
    """Update package_code for all records of given MPN in database"""
    con = sqlite3.connect(self.db.path)
    cur = con.cursor()
    
    try:
        # Update package_code for all distributors of this MPN
        cur.execute("""
            UPDATE component_data 
            SET package_code = ? 
            WHERE mpn = ?
        """, (new_package, mpn))
        
        rows_affected = cur.rowcount
        con.commit()
        
        self.log_msg(f"Updated package for {mpn} in {rows_affected} database records")
        
    except Exception as e:
        self.log_msg(f"Error updating package in database: {e}")
        con.rollback()
    finally:
        con.close()




def _on_package_edit_changed(self, item):
    """Handle manual package edits and update database"""
    if not item:
        return
    
    # Check if changed column is Package
    col = item.column()
    header = self.tbl_results.horizontalHeaderItem(col).text() if self.tbl_results.horizontalHeaderItem(col) else ""
    if header != "Package":
        return

    # Get MPN of this row
    row = item.row()
    mpn_col_idx = None
    for c in range(self.tbl_results.columnCount()):
        h = self.tbl_results.horizontalHeaderItem(c)
        if h and h.text() == "MPN":
            mpn_col_idx = c
            break
    
    if mpn_col_idx is None:
        return

    mpn_item = self.tbl_results.item(row, mpn_col_idx)
    if not mpn_item:
        return

    mpn = mpn_item.text().strip()
    new_package = item.text().strip()
    
    # Get original package for comparison
    orig_meta = self.db.part_meta(mpn)
    original_package = orig_meta.get("package", "")

    if new_package != original_package:
        # Update database with new package value
        self._update_package_in_database(mpn, new_package)
        self.log_msg(f"Package updated in database for {mpn}: '{new_package}' (was: '{original_package}')")
    
    # Temporarily disconnect signal to avoid recursion during recalc
    self.tbl_results.itemChanged.disconnect(self._on_package_edit_changed)
    
    # Refresh calculations with updated database
    self.recalc_all()
    
    # Reconnect signal
    self.tbl_results.itemChanged.connect(self._on_package_edit_changed)



def calc_bom_results(self):
    mpn_col = self.cmb_mpn.currentText()
    qty_col = self.cmb_qty.currentText()
    if not mpn_col or not qty_col:
        return

    df = self.bom_df.copy()

    result_cols = [
        "Part Type", "MPN", "Manufacturer", "Part Life Cycle Code", "Package", 
        "Size (L×W mm)", "Lead Time", "In Stock", "MOQ", "Total Required Qty", 
        "Procure Qty", "Distributor", "Qty Tier", "Unit Price", "PCB Per Unit Price", "Total Project Price"
    ]

    for col in result_cols:
        df[col] = ""

    pcb_qty = int(self.sp_pcb.value())
    currency = self.cmb_cur.currentText()
    usd_to_inr = float(self.sp_rate.value())

    for idx, row in df.iterrows():
        mpn = str(row[mpn_col]).strip()
        if not mpn:
            continue

        bom_qty = float(row[qty_col]) if pd.notna(row[qty_col]) else 0.0
        total_required = int(bom_qty * pcb_qty)

        # Get fresh data from database (will include any user package updates)
        offers = self.db.offers_by_mpn(mpn)
        meta = self.db.part_meta(mpn)

        # Filter by manufacturer if user selected one
        selected_manufacturer = self._manufacturer_overrides.get(mpn)
        if selected_manufacturer:
            offers = [o for o in offers if o.get("manufacturer") == selected_manufacturer]
            if offers:
                life = next((o["life_cycle_code"] for o in offers if o.get("life_cycle_code")), "")
                pkg = next((o["package_code"] for o in offers if o.get("package_code")), "")
                L = next((o["length_mm"] for o in offers if o.get("length_mm") is not None), None)
                W = next((o["width_mm"] for o in offers if o.get("width_mm") is not None), None)
                defcur = next((o["default_currency"] for o in offers if o.get("default_currency")), "USD")
                ptype = next((o["part_type"] for o in offers if o.get("part_type")), "")
                lead = next((o["lead_time"] for o in offers if o.get("lead_time")), "")
                meta = {"life": life, "package": pkg, "L": L, "W": W, "default_currency": defcur, "part_type": ptype, "lead_time": lead}

        pkg_code = meta.get("package") or ""
        L = meta.get("L"); W = meta.get("W")

        offers_conv = []
        for o in offers:
            tiers = []
            for t in o.get("price_tiers") or []:
                price_conv = convert_price(t["price"], o.get("currency", "USD"), currency, usd_to_inr)
                tiers.append({"quantity": int(t["quantity"]), "price": float(price_conv)})

            offers_conv.append({
                "distributor": o["distributor"], "price_tiers": sorted(tiers, key=lambda x: x["quantity"]),
                "stock": o.get("stock", 0), "currency": currency
            })

        best = choose_best_option(offers_conv, total_required, currency, usd_to_inr, norm_eia_code(pkg_code), L, W)

        if best:
            df.at[idx, "In Stock"] = str(best.get("stock", 0))
            df.at[idx, "MOQ"] = str(best.get("moq", ""))
            df.at[idx, "Total Required Qty"] = str(total_required)
            df.at[idx, "Procure Qty"] = str(best.get("procure_qty", total_required))
            df.at[idx, "Distributor"] = best.get("distributor", "")
            df.at[idx, "Qty Tier"] = str(best.get("qty_tier", ""))
            df.at[idx, "Unit Price"] = f"{best.get('unit_price', 0):.6f}"
            df.at[idx, "PCB Per Unit Price"] = f"{float(best.get('unit_price', 0)) * bom_qty:.6f}"
            df.at[idx, "Total Project Price"] = f"{float(best.get('unit_price', 0)) * bom_qty * pcb_qty:.4f}"

        df.at[idx, "Part Type"] = meta.get("part_type", "")
        df.at[idx, "MPN"] = mpn
        df.at[idx, "Part Life Cycle Code"] = meta.get("life", "")
        df.at[idx, "Package"] = meta.get("package", "")  # Use updated database value
        df.at[idx, "Lead Time"] = meta.get("lead_time", "")
        
        if meta.get("L") is not None or meta.get("W") is not None:
            df.at[idx, "Size (L×W mm)"] = f"{(meta.get('L') or '')}×{(meta.get('W') or '')}"

        # Set manufacturer
        all_offers = self.db.offers_by_mpn(mpn)
        manufacturers = sorted({o["manufacturer"] for o in all_offers if o.get("manufacturer")})
        if manufacturers:
            df.at[idx, "Manufacturer"] = selected_manufacturer or manufacturers[0]

    sums_cols = ["PCB Per Unit Price", "Total Project Price"]
    totals = {}
    for c in sums_cols:
        vals = pd.to_numeric(df[c].replace("", 0), errors="coerce").fillna(0) if c in df.columns else pd.Series()
        totals[c] = vals.sum()

    self.tbl_results.setRowCount(len(df) + 1)
    self.tbl_results.setColumnCount(len(df.columns))
    self.tbl_results.setHorizontalHeaderLabels(list(df.columns))

    for r in range(len(df)):
        for c in range(len(df.columns)):
            col_name = df.columns[c]
            it = QTableWidgetItem(str(df.iloc[r, c]))
            
            if col_name == "In Stock":
                try:
                    s = int(str(df.iloc[r, c]))
                except Exception:
                    s = 0
                if s == 0: it.setBackground(QColor(255, 200, 200))
                elif s < 100: it.setBackground(QColor(255, 255, 200))
                elif s < 1000: it.setBackground(QColor(255, 255, 150))
                else: it.setBackground(QColor(200, 255, 200))
                f = QFont(); f.setBold(True); it.setFont(f)
            
            # Make Package column editable
            elif col_name == "Package":
                it.setFlags(it.flags() | Qt.ItemFlag.ItemIsEditable)
                it.setBackground(QColor(240, 255, 240))  # Light green = editable

            self.tbl_results.setItem(r, c, it)

    # Add manufacturer dropdowns
    self._add_manufacturer_dropdowns(df)

    # Add totals row
    tr = len(df)
    for c in range(len(df.columns)):
        name = df.columns[c]
        if c == 0:
            tit = QTableWidgetItem("TOTAL")
        elif name in totals:
            tit = QTableWidgetItem(f"{totals[name]:.4f}")
        else:
            tit = QTableWidgetItem("")
        f = QFont(); f.setBold(True); tit.setFont(f); tit.setBackground(QColor(220, 220, 220))
        self.tbl_results.setItem(tr, c, tit)




